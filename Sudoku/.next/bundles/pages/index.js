module.exports =

        __NEXT_REGISTER_PAGE('/', function() {
          var comp = 
      webpackJsonp([4],{

/***/ "./colors.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {/* unused harmony export backGroundOrange */
/* unused harmony export backGroundGrey */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return backGroundBlue; });
/* unused harmony export backGroundGreen */
(function () {
  var enterModule = __webpack_require__("./node_modules/react-hot-loader/patch.js").enterModule;

  enterModule && enterModule(module);
})();

var backGroundOrange = '#F4511E';
var backGroundGrey = '#546E7A';
var backGroundBlue = '#1B6B9B';
var backGroundGreen = '#7CDC1B';
;

(function () {
  var reactHotLoader = __webpack_require__("./node_modules/react-hot-loader/patch.js").default;

  var leaveModule = __webpack_require__("./node_modules/react-hot-loader/patch.js").leaveModule;

  if (!reactHotLoader) {
    return;
  }

  reactHotLoader.register(backGroundOrange, 'backGroundOrange', '/Users/lichenma/Projects/SuDuoku/SuDuoku/colors.js');
  reactHotLoader.register(backGroundGrey, 'backGroundGrey', '/Users/lichenma/Projects/SuDuoku/SuDuoku/colors.js');
  reactHotLoader.register(backGroundBlue, 'backGroundBlue', '/Users/lichenma/Projects/SuDuoku/SuDuoku/colors.js');
  reactHotLoader.register(backGroundGreen, 'backGroundGreen', '/Users/lichenma/Projects/SuDuoku/SuDuoku/colors.js');
  leaveModule(module);
})();

;
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__("./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./components/tool-tip.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_styled_jsx_style__ = __webpack_require__("./node_modules/styled-jsx/style.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_styled_jsx_style___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_styled_jsx_style__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react__ = __webpack_require__("./node_modules/react/cjs/react.development.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_react_popover__ = __webpack_require__("./node_modules/react-popover/index.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_react_popover___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_react_popover__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__svg_help_svg__ = __webpack_require__("./svg/help.svg");
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _jsxFileName = '/Users/lichenma/Projects/SuDuoku/SuDuoku/components/tool-tip.js';


(function () {
  var enterModule = __webpack_require__("./node_modules/react-hot-loader/patch.js").enterModule;

  enterModule && enterModule(module);
})();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }





var TipCopy = __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
  'div',
  {
    className: 'jsx-289995913' + ' ' + 'tip-copy',
    __source: {
      fileName: _jsxFileName,
      lineNumber: 6
    }
  },
  __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
    'div',
    {
      className: 'jsx-289995913' + ' ' + 'tip-line',
      __source: {
        fileName: _jsxFileName,
        lineNumber: 7
      }
    },
    __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
      'b',
      {
        className: 'jsx-289995913',
        __source: {
          fileName: _jsxFileName,
          lineNumber: 7
        }
      },
      'Select:'
    ),
    ' Click a cell'
  ),
  __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
    'div',
    {
      className: 'jsx-289995913' + ' ' + 'tip-line',
      __source: {
        fileName: _jsxFileName,
        lineNumber: 8
      }
    },
    __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
      'b',
      {
        className: 'jsx-289995913',
        __source: {
          fileName: _jsxFileName,
          lineNumber: 8
        }
      },
      'Assign Number:'
    ),
    ' Single click on desired number control'
  ),
  __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
    'div',
    {
      className: 'jsx-289995913',
      __source: {
        fileName: _jsxFileName,
        lineNumber: 9
      }
    },
    __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
      'b',
      {
        className: 'jsx-289995913',
        __source: {
          fileName: _jsxFileName,
          lineNumber: 9
        }
      },
      'Tag Number as Note:'
    ),
    ' Double click on the desired number control'
  ),
  __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_0_styled_jsx_style___default.a, {
    styleId: '289995913',
    css: '.tip-copy.jsx-289995913{font-size:1.2em;}.tip-line.jsx-289995913{margin-bottom:.4em;}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImNvbXBvbmVudHMvdG9vbC10aXAuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBVWdCLEFBRzZCLEFBR0csZ0JBRnZCLEdBR0EiLCJmaWxlIjoiY29tcG9uZW50cy90b29sLXRpcC5qcyIsInNvdXJjZVJvb3QiOiIvVXNlcnMvbGljaGVubWEvUHJvamVjdHMvU3VEdW9rdS9TdUR1b2t1Iiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQb3BvdmVyIGZyb20gJ3JlYWN0LXBvcG92ZXInO1xuaW1wb3J0IEhlbHBJY29uIGZyb20gJy4uL3N2Zy9oZWxwLnN2Zyc7XG5cbmNvbnN0IFRpcENvcHkgPSAoXG4gIDxkaXYgY2xhc3NOYW1lPVwidGlwLWNvcHlcIj5cbiAgICA8ZGl2IGNsYXNzTmFtZT1cInRpcC1saW5lXCI+PGI+U2VsZWN0OjwvYj4gQ2xpY2sgYSBjZWxsPC9kaXY+XG4gICAgPGRpdiBjbGFzc05hbWU9XCJ0aXAtbGluZVwiPjxiPkFzc2lnbiBOdW1iZXI6PC9iPiBTaW5nbGUgY2xpY2sgb24gZGVzaXJlZCBudW1iZXIgY29udHJvbDwvZGl2PlxuICAgIDxkaXY+PGI+VGFnIE51bWJlciBhcyBOb3RlOjwvYj4gRG91YmxlIGNsaWNrIG9uIHRoZSBkZXNpcmVkIG51bWJlciBjb250cm9sPC9kaXY+XG4gICAgeyAvKiBsYW5ndWFnZT1DU1MgKi8gfVxuICAgIDxzdHlsZSBqc3g+e2BcbiAgICAgICAgLnRpcC1jb3B5IHtcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMS4yZW07XG4gICAgICAgIH1cbiAgICAgICAgLnRpcC1saW5lIHtcbiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IC40ZW07XG4gICAgICAgIH1cbiAgICBgfVxuICAgIDwvc3R5bGU+XG4gIDwvZGl2PlxuKVxuXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRpcCBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgc3RhdGUgPSB7fVxuICAgIHRvZ2dsZU9wZW4gPSAoZXZlbnQpID0+IHtcbiAgICAgIC8vIFRoaXMgcHJldmVudHMgZ2hvc3QgY2xpY2suXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IG9wZW46ICF0aGlzLnN0YXRlLm9wZW4gfSk7XG4gICAgfVxuXG4gICAgY2xvc2UgPSAoKSA9PiB7XG4gICAgICB0aGlzLnNldFN0YXRlKHsgb3BlbjogZmFsc2UgfSk7XG4gICAgfVxuXG4gICAgb3BlbiA9ICgpID0+IHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBvcGVuOiB0cnVlIH0pO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICA8UG9wb3ZlclxuICAgICAgICAgIGlzT3Blbj17dGhpcy5zdGF0ZS5vcGVufVxuICAgICAgICAgIHByZWZlclBsYWNlPVwiYmVsb3dcIlxuICAgICAgICAgIGJvZHk9e1RpcENvcHl9XG4gICAgICAgICAgc3R5bGU9e3sgd2lkdGg6ICc5MHZ3JywgbWF4V2lkdGg6ICc0MGVtJyB9fVxuICAgICAgICA+XG4gICAgICAgICAgPGRpdlxuICAgICAgICAgICAgb25DbGljaz17dGhpcy50b2dnbGVPcGVufVxuICAgICAgICAgICAgb25Nb3VzZUVudGVyPXt0aGlzLm9wZW59XG4gICAgICAgICAgICBvbk1vdXNlTGVhdmU9e3RoaXMuY2xvc2V9XG4gICAgICAgICAgPlxuICAgICAgICAgICAgPEhlbHBJY29uIGNsYXNzTmFtZT1cImljb25cIiAvPlxuICAgICAgICAgICAgeyAvKiBsYW5ndWFnZT1DU1MgKi8gfVxuICAgICAgICAgICAgPHN0eWxlIGpzeD57YFxuICAgICAgICAgICAgICAgIDpnbG9iYWwoLmljb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAxLjI1ZW07XG4gICAgICAgICAgICAgICAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBgfVxuICAgICAgICAgICAgPC9zdHlsZT5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9Qb3BvdmVyPlxuICAgICAgKTtcbiAgICB9XG59XG4iXX0= */\n/*@ sourceURL=components/tool-tip.js */'
  })
);

var Tip = function (_Component) {
  _inherits(Tip, _Component);

  function Tip() {
    var _ref;

    var _temp, _this, _ret;

    _classCallCheck(this, Tip);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Tip.__proto__ || Object.getPrototypeOf(Tip)).call.apply(_ref, [this].concat(args))), _this), _this.state = {}, _this.toggleOpen = function (event) {
      // This prevents ghost click.
      event.preventDefault();
      _this.setState({ open: !_this.state.open });
    }, _this.close = function () {
      _this.setState({ open: false });
    }, _this.open = function () {
      _this.setState({ open: true });
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  _createClass(Tip, [{
    key: 'render',
    value: function render() {
      return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
        __WEBPACK_IMPORTED_MODULE_2_react_popover___default.a,
        {
          isOpen: this.state.open,
          preferPlace: 'below',
          body: TipCopy,
          style: { width: '90vw', maxWidth: '40em' },
          __source: {
            fileName: _jsxFileName,
            lineNumber: 41
          }
        },
        __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
          'div',
          {
            onClick: this.toggleOpen,
            onMouseEnter: this.open,
            onMouseLeave: this.close,
            className: 'jsx-2314980512',
            __source: {
              fileName: _jsxFileName,
              lineNumber: 47
            }
          },
          __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_3__svg_help_svg__["a" /* default */], { className: 'icon', __source: {
              fileName: _jsxFileName,
              lineNumber: 52
            }
          }),
          __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_0_styled_jsx_style___default.a, {
            styleId: '2314980512',
            css: '.icon{height:1.25em;cursor:pointer;}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImNvbXBvbmVudHMvdG9vbC10aXAuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBcUR3QixBQUdtQyxjQUNDLGVBQ25CIiwiZmlsZSI6ImNvbXBvbmVudHMvdG9vbC10aXAuanMiLCJzb3VyY2VSb290IjoiL1VzZXJzL2xpY2hlbm1hL1Byb2plY3RzL1N1RHVva3UvU3VEdW9rdSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUG9wb3ZlciBmcm9tICdyZWFjdC1wb3BvdmVyJztcbmltcG9ydCBIZWxwSWNvbiBmcm9tICcuLi9zdmcvaGVscC5zdmcnO1xuXG5jb25zdCBUaXBDb3B5ID0gKFxuICA8ZGl2IGNsYXNzTmFtZT1cInRpcC1jb3B5XCI+XG4gICAgPGRpdiBjbGFzc05hbWU9XCJ0aXAtbGluZVwiPjxiPlNlbGVjdDo8L2I+IENsaWNrIGEgY2VsbDwvZGl2PlxuICAgIDxkaXYgY2xhc3NOYW1lPVwidGlwLWxpbmVcIj48Yj5Bc3NpZ24gTnVtYmVyOjwvYj4gU2luZ2xlIGNsaWNrIG9uIGRlc2lyZWQgbnVtYmVyIGNvbnRyb2w8L2Rpdj5cbiAgICA8ZGl2PjxiPlRhZyBOdW1iZXIgYXMgTm90ZTo8L2I+IERvdWJsZSBjbGljayBvbiB0aGUgZGVzaXJlZCBudW1iZXIgY29udHJvbDwvZGl2PlxuICAgIHsgLyogbGFuZ3VhZ2U9Q1NTICovIH1cbiAgICA8c3R5bGUganN4PntgXG4gICAgICAgIC50aXAtY29weSB7XG4gICAgICAgICAgICBmb250LXNpemU6IDEuMmVtO1xuICAgICAgICB9XG4gICAgICAgIC50aXAtbGluZSB7XG4gICAgICAgICAgICBtYXJnaW4tYm90dG9tOiAuNGVtO1xuICAgICAgICB9XG4gICAgYH1cbiAgICA8L3N0eWxlPlxuICA8L2Rpdj5cbilcblxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUaXAgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRlID0ge31cbiAgICB0b2dnbGVPcGVuID0gKGV2ZW50KSA9PiB7XG4gICAgICAvLyBUaGlzIHByZXZlbnRzIGdob3N0IGNsaWNrLlxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBvcGVuOiAhdGhpcy5zdGF0ZS5vcGVuIH0pO1xuICAgIH1cblxuICAgIGNsb3NlID0gKCkgPT4ge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IG9wZW46IGZhbHNlIH0pO1xuICAgIH1cblxuICAgIG9wZW4gPSAoKSA9PiB7XG4gICAgICB0aGlzLnNldFN0YXRlKHsgb3BlbjogdHJ1ZSB9KTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgPFBvcG92ZXJcbiAgICAgICAgICBpc09wZW49e3RoaXMuc3RhdGUub3Blbn1cbiAgICAgICAgICBwcmVmZXJQbGFjZT1cImJlbG93XCJcbiAgICAgICAgICBib2R5PXtUaXBDb3B5fVxuICAgICAgICAgIHN0eWxlPXt7IHdpZHRoOiAnOTB2dycsIG1heFdpZHRoOiAnNDBlbScgfX1cbiAgICAgICAgPlxuICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgIG9uQ2xpY2s9e3RoaXMudG9nZ2xlT3Blbn1cbiAgICAgICAgICAgIG9uTW91c2VFbnRlcj17dGhpcy5vcGVufVxuICAgICAgICAgICAgb25Nb3VzZUxlYXZlPXt0aGlzLmNsb3NlfVxuICAgICAgICAgID5cbiAgICAgICAgICAgIDxIZWxwSWNvbiBjbGFzc05hbWU9XCJpY29uXCIgLz5cbiAgICAgICAgICAgIHsgLyogbGFuZ3VhZ2U9Q1NTICovIH1cbiAgICAgICAgICAgIDxzdHlsZSBqc3g+e2BcbiAgICAgICAgICAgICAgICA6Z2xvYmFsKC5pY29uKSB7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogMS4yNWVtO1xuICAgICAgICAgICAgICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgYH1cbiAgICAgICAgICAgIDwvc3R5bGU+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvUG9wb3Zlcj5cbiAgICAgICk7XG4gICAgfVxufVxuIl19 */\n/*@ sourceURL=components/tool-tip.js */'
          })
        )
      );
    }
  }, {
    key: '__reactstandin__regenerateByEval',
    value: function __reactstandin__regenerateByEval(key, code) {
      this[key] = eval(code);
    }
  }]);

  return Tip;
}(__WEBPACK_IMPORTED_MODULE_1_react__["Component"]);

var _default = Tip;
/* harmony default export */ __webpack_exports__["a"] = (_default);
;

(function () {
  var reactHotLoader = __webpack_require__("./node_modules/react-hot-loader/patch.js").default;

  var leaveModule = __webpack_require__("./node_modules/react-hot-loader/patch.js").leaveModule;

  if (!reactHotLoader) {
    return;
  }

  reactHotLoader.register(TipCopy, 'TipCopy', '/Users/lichenma/Projects/SuDuoku/SuDuoku/components/tool-tip.js');
  reactHotLoader.register(Tip, 'Tip', '/Users/lichenma/Projects/SuDuoku/SuDuoku/components/tool-tip.js');
  reactHotLoader.register(_default, 'default', '/Users/lichenma/Projects/SuDuoku/SuDuoku/components/tool-tip.js');
  leaveModule(module);
})();

;
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__("./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./input-range-style.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__colors__ = __webpack_require__("./colors.js");
(function () {
  var enterModule = __webpack_require__("./node_modules/react-hot-loader/patch.js").enterModule;

  enterModule && enterModule(module);
})();



// eslint-disable-next-line no-lone-blocks
// eslint-disable-next-line import/no-extraneous-dependencies
{/* language=CSS */}
var Style = new String(".input-range__slider{-webkit-appearance:none;-moz-appearance:none;appearance:none;background:#3f51b5;border:1px solid #3f51b5;border-radius:100%;cursor:pointer;display:block;height:1rem;margin-left:-0.5rem;margin-top:-0.65rem;outline:none;position:absolute;top:50%;-webkit-transition:-webkit-transform 0.3s ease-out,box-shadow 0.3s ease-out;-webkit-transition:transform 0.3s ease-out,box-shadow 0.3s ease-out;transition:transform 0.3s ease-out,box-shadow 0.3s ease-out;width:1rem;}.input-range__slider:active{-webkit-transform:scale(1.3);-ms-transform:scale(1.3);transform:scale(1.3);}.input-range__slider:focus{box-shadow:0 0 0 5px rgba(63,81,181,0.2);}.input-range--disabled .input-range__slider{background:#cccccc;border:1px solid #cccccc;box-shadow:none;-webkit-transform:none;-ms-transform:none;transform:none;}.input-range__slider-container{-webkit-transition:left 0.3s ease-out;transition:left 0.3s ease-out;}.input-range__label{color:#aaaaaa;font-size:0.8rem;-webkit-transform:translateZ(0);-ms-transform:translateZ(0);transform:translateZ(0);white-space:nowrap;}.input-range__label--min,.input-range__label--max{bottom:-1.4rem;position:absolute;}.input-range__label--min{left:0;}.input-range__label--max{right:0;}.input-range__label--value{position:absolute;top:-1.8rem;}.input-range__label-container{left:-50%;position:relative;}.input-range__label--max .input-range__label-container{left:50%;}.input-range__track{background:#eeeeee;border-radius:0.3rem;cursor:pointer;display:block;height:0.3rem;position:relative;-webkit-transition:left 0.3s ease-out,width 0.3s ease-out;transition:left 0.3s ease-out,width 0.3s ease-out;}.input-range--disabled .input-range__track{background:#eeeeee;}.input-range__track--background{left:0;margin-top:-0.15rem;position:absolute;right:0;top:50%;}.input-range__track--active{background:#3f51b5;}.input-range{height:1rem;position:relative;margin-top:1.2em;margin-bottom:1.4em;}.Popover{z-index:2000;}.Popover-body{display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;padding:.5rem 1rem;background:white;border-radius:0.3rem;opacity:.95;box-shadow:rgba(0,0,0,0.12) 0 1px 6px,rgba(0,0,0,0.12) 0 1px 4px;font-size:14px;}.Popover-tipShape{fill:" + __WEBPACK_IMPORTED_MODULE_0__colors__["a" /* backGroundBlue */] + ";}.Popover-white .Popover-tipShape{fill:#00bcd4;}.Popover-white .Popover-body{background:white;}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImlucHV0LXJhbmdlLXN0eWxlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQU1pQixBQUdtQixBQWVPLEFBRXVCLEFBRXpCLEFBTVMsQUFHaEIsQUFPQyxBQUlSLEFBR0MsQUFHVSxBQUlSLEFBR0MsQUFHUSxBQVFFLEFBR2QsQUFPWSxBQUdQLEFBT0csQUFHTyxBQVdjLEFBSXJCLEFBSUksT0FsRVgsQUE0QlksQ0F6QlgsQ0FVRyxDQUZNLEVBMkJBLENBT3BCLEFBa0JBLENBekVtQixDQU9DLEVBc0VwQixDQTVEYyxDQTFCZSxBQW9DTixBQU9DLEFBVUYsUUFMRixDQWxCQyxFQUpOLEFBZ0NJLENBaERPLEVBTUwsQ0E4RHJCLE1BekNpQixDQXhDZ0MsR0FJN0IsQ0FnRFYsRUFVWSxNQVRaLEVBWk0sS0FwQ0csQ0FyQkUsQUFxRVYsTUFVWCxDQXZEaUMsQ0FrQ2pCLE1BNUNVLEtBYkMsR0EwRFAsa0JBQ2lDLENBMEIzQixHQXBGTCxVQTRCQSxFQVRELE9BbEJILFVBMkJLLEtBMUJOLGNBQ0YsWUFDUSxlQWlGQyxLQWhGRCxjQWlGRCxNQWhGTixJQW9EdUMsT0E2QjdCLEVBaEZMLGtCQUNWLENBZ0ZNLE9BL0UrQyxLQWdGYSxpRUFDekQsZUFDbkIsdUhBakZhLFdBQUMiLCJmaWxlIjoiaW5wdXQtcmFuZ2Utc3R5bGUuanMiLCJzb3VyY2VSb290IjoiL1VzZXJzL2xpY2hlbm1hL1Byb2plY3RzL1N1RHVva3UvU3VEdW9rdSIsInNvdXJjZXNDb250ZW50IjpbIi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tZXh0cmFuZW91cy1kZXBlbmRlbmNpZXNcbmltcG9ydCBjc3MgZnJvbSAnc3R5bGVkLWpzeC9jc3MnO1xuaW1wb3J0IHtiYWNrR3JvdW5kQmx1ZX0gZnJvbSBcIi4vY29sb3JzXCI7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sb25lLWJsb2Nrc1xueyAvKiBsYW5ndWFnZT1DU1MgKi8gfVxuY29uc3QgU3R5bGUgPSBjc3NgXG4uaW5wdXQtcmFuZ2VfX3NsaWRlciB7XG4gIGFwcGVhcmFuY2U6IG5vbmU7XG4gIGJhY2tncm91bmQ6ICMzZjUxYjU7XG4gIGJvcmRlcjogMXB4IHNvbGlkICMzZjUxYjU7XG4gIGJvcmRlci1yYWRpdXM6IDEwMCU7XG4gIGN1cnNvcjogcG9pbnRlcjtcbiAgZGlzcGxheTogYmxvY2s7XG4gIGhlaWdodDogMXJlbTtcbiAgbWFyZ2luLWxlZnQ6IC0wLjVyZW07XG4gIG1hcmdpbi10b3A6IC0wLjY1cmVtO1xuICBvdXRsaW5lOiBub25lO1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIHRvcDogNTAlO1xuICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMC4zcyBlYXNlLW91dCwgYm94LXNoYWRvdyAwLjNzIGVhc2Utb3V0O1xuICB3aWR0aDogMXJlbTsgfVxuICAuaW5wdXQtcmFuZ2VfX3NsaWRlcjphY3RpdmUge1xuICAgIHRyYW5zZm9ybTogc2NhbGUoMS4zKTsgfVxuICAuaW5wdXQtcmFuZ2VfX3NsaWRlcjpmb2N1cyB7XG4gICAgYm94LXNoYWRvdzogMCAwIDAgNXB4IHJnYmEoNjMsIDgxLCAxODEsIDAuMik7IH1cbiAgLmlucHV0LXJhbmdlLS1kaXNhYmxlZCAuaW5wdXQtcmFuZ2VfX3NsaWRlciB7XG4gICAgYmFja2dyb3VuZDogI2NjY2NjYztcbiAgICBib3JkZXI6IDFweCBzb2xpZCAjY2NjY2NjO1xuICAgIGJveC1zaGFkb3c6IG5vbmU7XG4gICAgdHJhbnNmb3JtOiBub25lOyB9XG5cbi5pbnB1dC1yYW5nZV9fc2xpZGVyLWNvbnRhaW5lciB7XG4gIHRyYW5zaXRpb246IGxlZnQgMC4zcyBlYXNlLW91dDsgfVxuXG4uaW5wdXQtcmFuZ2VfX2xhYmVsIHtcbiAgY29sb3I6ICNhYWFhYWE7XG4gIGZvbnQtc2l6ZTogMC44cmVtO1xuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVooMCk7XG4gIHdoaXRlLXNwYWNlOiBub3dyYXA7IH1cblxuLmlucHV0LXJhbmdlX19sYWJlbC0tbWluLFxuLmlucHV0LXJhbmdlX19sYWJlbC0tbWF4IHtcbiAgYm90dG9tOiAtMS40cmVtO1xuICBwb3NpdGlvbjogYWJzb2x1dGU7IH1cblxuLmlucHV0LXJhbmdlX19sYWJlbC0tbWluIHtcbiAgbGVmdDogMDsgfVxuXG4uaW5wdXQtcmFuZ2VfX2xhYmVsLS1tYXgge1xuICByaWdodDogMDsgfVxuXG4uaW5wdXQtcmFuZ2VfX2xhYmVsLS12YWx1ZSB7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgdG9wOiAtMS44cmVtOyB9XG5cbi5pbnB1dC1yYW5nZV9fbGFiZWwtY29udGFpbmVyIHtcbiAgbGVmdDogLTUwJTtcbiAgcG9zaXRpb246IHJlbGF0aXZlOyB9XG4gIC5pbnB1dC1yYW5nZV9fbGFiZWwtLW1heCAuaW5wdXQtcmFuZ2VfX2xhYmVsLWNvbnRhaW5lciB7XG4gICAgbGVmdDogNTAlOyB9XG5cbi5pbnB1dC1yYW5nZV9fdHJhY2sge1xuICBiYWNrZ3JvdW5kOiAjZWVlZWVlO1xuICBib3JkZXItcmFkaXVzOiAwLjNyZW07XG4gIGN1cnNvcjogcG9pbnRlcjtcbiAgZGlzcGxheTogYmxvY2s7XG4gIGhlaWdodDogMC4zcmVtO1xuICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gIHRyYW5zaXRpb246IGxlZnQgMC4zcyBlYXNlLW91dCwgd2lkdGggMC4zcyBlYXNlLW91dDsgfVxuICAuaW5wdXQtcmFuZ2UtLWRpc2FibGVkIC5pbnB1dC1yYW5nZV9fdHJhY2sge1xuICAgIGJhY2tncm91bmQ6ICNlZWVlZWU7IH1cblxuLmlucHV0LXJhbmdlX190cmFjay0tYmFja2dyb3VuZCB7XG4gIGxlZnQ6IDA7XG4gIG1hcmdpbi10b3A6IC0wLjE1cmVtO1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIHJpZ2h0OiAwO1xuICB0b3A6IDUwJTsgfVxuXG4uaW5wdXQtcmFuZ2VfX3RyYWNrLS1hY3RpdmUge1xuICBiYWNrZ3JvdW5kOiAjM2Y1MWI1OyB9XG5cbi5pbnB1dC1yYW5nZSB7XG4gIGhlaWdodDogMXJlbTtcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xuICBtYXJnaW4tdG9wOiAxLjJlbTtcbiAgbWFyZ2luLWJvdHRvbTogMS40ZW07XG59XG4gIFxuLlBvcG92ZXIge1xuICAgIHotaW5kZXg6IDIwMDA7XG59XG4uUG9wb3Zlci1ib2R5IHtcbiAgICBkaXNwbGF5OiBpbmxpbmUtZmxleDtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgIHBhZGRpbmc6IC41cmVtIDFyZW07XG4gICAgYmFja2dyb3VuZDogd2hpdGU7XG4gICAgYm9yZGVyLXJhZGl1czogMC4zcmVtO1xuICAgIG9wYWNpdHk6IC45NTtcbiAgICBib3gtc2hhZG93OiByZ2JhKDAsIDAsIDAsIDAuMTIpIDAgMXB4IDZweCwgcmdiYSgwLCAwLCAwLCAwLjEyKSAwIDFweCA0cHg7XG4gICAgZm9udC1zaXplOiAxNHB4O1xufVxuXG4uUG9wb3Zlci10aXBTaGFwZSB7XG4gICAgZmlsbDogJHtiYWNrR3JvdW5kQmx1ZX07XG59XG5cbi5Qb3BvdmVyLXdoaXRlIC5Qb3BvdmVyLXRpcFNoYXBlIHtcbiAgICBmaWxsOiAjMDBiY2Q0O1xufVxuXG4uUG9wb3Zlci13aGl0ZSAuUG9wb3Zlci1ib2R5IHtcbiAgICBiYWNrZ3JvdW5kOiB3aGl0ZTtcbn1cbiAgYDtcblxuZXhwb3J0IGRlZmF1bHQgU3R5bGU7XG4iXX0= */\n/*@ sourceURL=input-range-style.js */");

Style.__hash = "2208778758";
Style.__scoped = ".input-range__slider.jsx-821553959{-webkit-appearance:none;-moz-appearance:none;appearance:none;background:#3f51b5;border:1px solid #3f51b5;border-radius:100%;cursor:pointer;display:block;height:1rem;margin-left:-0.5rem;margin-top:-0.65rem;outline:none;position:absolute;top:50%;-webkit-transition:-webkit-transform 0.3s ease-out,box-shadow 0.3s ease-out;-webkit-transition:transform 0.3s ease-out,box-shadow 0.3s ease-out;transition:transform 0.3s ease-out,box-shadow 0.3s ease-out;width:1rem;}.input-range__slider.jsx-821553959:active{-webkit-transform:scale(1.3);-ms-transform:scale(1.3);transform:scale(1.3);}.input-range__slider.jsx-821553959:focus{box-shadow:0 0 0 5px rgba(63,81,181,0.2);}.input-range--disabled.jsx-821553959 .input-range__slider.jsx-821553959{background:#cccccc;border:1px solid #cccccc;box-shadow:none;-webkit-transform:none;-ms-transform:none;transform:none;}.input-range__slider-container.jsx-821553959{-webkit-transition:left 0.3s ease-out;transition:left 0.3s ease-out;}.input-range__label.jsx-821553959{color:#aaaaaa;font-size:0.8rem;-webkit-transform:translateZ(0);-ms-transform:translateZ(0);transform:translateZ(0);white-space:nowrap;}.input-range__label--min.jsx-821553959,.input-range__label--max.jsx-821553959{bottom:-1.4rem;position:absolute;}.input-range__label--min.jsx-821553959{left:0;}.input-range__label--max.jsx-821553959{right:0;}.input-range__label--value.jsx-821553959{position:absolute;top:-1.8rem;}.input-range__label-container.jsx-821553959{left:-50%;position:relative;}.input-range__label--max.jsx-821553959 .input-range__label-container.jsx-821553959{left:50%;}.input-range__track.jsx-821553959{background:#eeeeee;border-radius:0.3rem;cursor:pointer;display:block;height:0.3rem;position:relative;-webkit-transition:left 0.3s ease-out,width 0.3s ease-out;transition:left 0.3s ease-out,width 0.3s ease-out;}.input-range--disabled.jsx-821553959 .input-range__track.jsx-821553959{background:#eeeeee;}.input-range__track--background.jsx-821553959{left:0;margin-top:-0.15rem;position:absolute;right:0;top:50%;}.input-range__track--active.jsx-821553959{background:#3f51b5;}.input-range.jsx-821553959{height:1rem;position:relative;margin-top:1.2em;margin-bottom:1.4em;}.Popover.jsx-821553959{z-index:2000;}.Popover-body.jsx-821553959{display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;padding:.5rem 1rem;background:white;border-radius:0.3rem;opacity:.95;box-shadow:rgba(0,0,0,0.12) 0 1px 6px,rgba(0,0,0,0.12) 0 1px 4px;font-size:14px;}.Popover-tipShape.jsx-821553959{fill:" + __WEBPACK_IMPORTED_MODULE_0__colors__["a" /* backGroundBlue */] + ";}.Popover-white.jsx-821553959 .Popover-tipShape.jsx-821553959{fill:#00bcd4;}.Popover-white.jsx-821553959 .Popover-body.jsx-821553959{background:white;}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImlucHV0LXJhbmdlLXN0eWxlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQU1pQixBQUdtQixBQWVPLEFBRXVCLEFBRXpCLEFBTVMsQUFHaEIsQUFPQyxBQUlSLEFBR0MsQUFHVSxBQUlSLEFBR0MsQUFHUSxBQVFFLEFBR2QsQUFPWSxBQUdQLEFBT0csQUFHTyxBQVdjLEFBSXJCLEFBSUksT0FsRVgsQUE0QlksQ0F6QlgsQ0FVRyxDQUZNLEVBMkJBLENBT3BCLEFBa0JBLENBekVtQixDQU9DLEVBc0VwQixDQTVEYyxDQTFCZSxBQW9DTixBQU9DLEFBVUYsUUFMRixDQWxCQyxFQUpOLEFBZ0NJLENBaERPLEVBTUwsQ0E4RHJCLE1BekNpQixDQXhDZ0MsR0FJN0IsQ0FnRFYsRUFVWSxNQVRaLEVBWk0sS0FwQ0csQ0FyQkUsQUFxRVYsTUFVWCxDQXZEaUMsQ0FrQ2pCLE1BNUNVLEtBYkMsR0EwRFAsa0JBQ2lDLENBMEIzQixHQXBGTCxVQTRCQSxFQVRELE9BbEJILFVBMkJLLEtBMUJOLGNBQ0YsWUFDUSxlQWlGQyxLQWhGRCxjQWlGRCxNQWhGTixJQW9EdUMsT0E2QjdCLEVBaEZMLGtCQUNWLENBZ0ZNLE9BL0UrQyxLQWdGYSxpRUFDekQsZUFDbkIsdUhBakZhLFdBQUMiLCJmaWxlIjoiaW5wdXQtcmFuZ2Utc3R5bGUuanMiLCJzb3VyY2VSb290IjoiL1VzZXJzL2xpY2hlbm1hL1Byb2plY3RzL1N1RHVva3UvU3VEdW9rdSIsInNvdXJjZXNDb250ZW50IjpbIi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tZXh0cmFuZW91cy1kZXBlbmRlbmNpZXNcbmltcG9ydCBjc3MgZnJvbSAnc3R5bGVkLWpzeC9jc3MnO1xuaW1wb3J0IHtiYWNrR3JvdW5kQmx1ZX0gZnJvbSBcIi4vY29sb3JzXCI7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sb25lLWJsb2Nrc1xueyAvKiBsYW5ndWFnZT1DU1MgKi8gfVxuY29uc3QgU3R5bGUgPSBjc3NgXG4uaW5wdXQtcmFuZ2VfX3NsaWRlciB7XG4gIGFwcGVhcmFuY2U6IG5vbmU7XG4gIGJhY2tncm91bmQ6ICMzZjUxYjU7XG4gIGJvcmRlcjogMXB4IHNvbGlkICMzZjUxYjU7XG4gIGJvcmRlci1yYWRpdXM6IDEwMCU7XG4gIGN1cnNvcjogcG9pbnRlcjtcbiAgZGlzcGxheTogYmxvY2s7XG4gIGhlaWdodDogMXJlbTtcbiAgbWFyZ2luLWxlZnQ6IC0wLjVyZW07XG4gIG1hcmdpbi10b3A6IC0wLjY1cmVtO1xuICBvdXRsaW5lOiBub25lO1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIHRvcDogNTAlO1xuICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMC4zcyBlYXNlLW91dCwgYm94LXNoYWRvdyAwLjNzIGVhc2Utb3V0O1xuICB3aWR0aDogMXJlbTsgfVxuICAuaW5wdXQtcmFuZ2VfX3NsaWRlcjphY3RpdmUge1xuICAgIHRyYW5zZm9ybTogc2NhbGUoMS4zKTsgfVxuICAuaW5wdXQtcmFuZ2VfX3NsaWRlcjpmb2N1cyB7XG4gICAgYm94LXNoYWRvdzogMCAwIDAgNXB4IHJnYmEoNjMsIDgxLCAxODEsIDAuMik7IH1cbiAgLmlucHV0LXJhbmdlLS1kaXNhYmxlZCAuaW5wdXQtcmFuZ2VfX3NsaWRlciB7XG4gICAgYmFja2dyb3VuZDogI2NjY2NjYztcbiAgICBib3JkZXI6IDFweCBzb2xpZCAjY2NjY2NjO1xuICAgIGJveC1zaGFkb3c6IG5vbmU7XG4gICAgdHJhbnNmb3JtOiBub25lOyB9XG5cbi5pbnB1dC1yYW5nZV9fc2xpZGVyLWNvbnRhaW5lciB7XG4gIHRyYW5zaXRpb246IGxlZnQgMC4zcyBlYXNlLW91dDsgfVxuXG4uaW5wdXQtcmFuZ2VfX2xhYmVsIHtcbiAgY29sb3I6ICNhYWFhYWE7XG4gIGZvbnQtc2l6ZTogMC44cmVtO1xuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVooMCk7XG4gIHdoaXRlLXNwYWNlOiBub3dyYXA7IH1cblxuLmlucHV0LXJhbmdlX19sYWJlbC0tbWluLFxuLmlucHV0LXJhbmdlX19sYWJlbC0tbWF4IHtcbiAgYm90dG9tOiAtMS40cmVtO1xuICBwb3NpdGlvbjogYWJzb2x1dGU7IH1cblxuLmlucHV0LXJhbmdlX19sYWJlbC0tbWluIHtcbiAgbGVmdDogMDsgfVxuXG4uaW5wdXQtcmFuZ2VfX2xhYmVsLS1tYXgge1xuICByaWdodDogMDsgfVxuXG4uaW5wdXQtcmFuZ2VfX2xhYmVsLS12YWx1ZSB7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgdG9wOiAtMS44cmVtOyB9XG5cbi5pbnB1dC1yYW5nZV9fbGFiZWwtY29udGFpbmVyIHtcbiAgbGVmdDogLTUwJTtcbiAgcG9zaXRpb246IHJlbGF0aXZlOyB9XG4gIC5pbnB1dC1yYW5nZV9fbGFiZWwtLW1heCAuaW5wdXQtcmFuZ2VfX2xhYmVsLWNvbnRhaW5lciB7XG4gICAgbGVmdDogNTAlOyB9XG5cbi5pbnB1dC1yYW5nZV9fdHJhY2sge1xuICBiYWNrZ3JvdW5kOiAjZWVlZWVlO1xuICBib3JkZXItcmFkaXVzOiAwLjNyZW07XG4gIGN1cnNvcjogcG9pbnRlcjtcbiAgZGlzcGxheTogYmxvY2s7XG4gIGhlaWdodDogMC4zcmVtO1xuICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gIHRyYW5zaXRpb246IGxlZnQgMC4zcyBlYXNlLW91dCwgd2lkdGggMC4zcyBlYXNlLW91dDsgfVxuICAuaW5wdXQtcmFuZ2UtLWRpc2FibGVkIC5pbnB1dC1yYW5nZV9fdHJhY2sge1xuICAgIGJhY2tncm91bmQ6ICNlZWVlZWU7IH1cblxuLmlucHV0LXJhbmdlX190cmFjay0tYmFja2dyb3VuZCB7XG4gIGxlZnQ6IDA7XG4gIG1hcmdpbi10b3A6IC0wLjE1cmVtO1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIHJpZ2h0OiAwO1xuICB0b3A6IDUwJTsgfVxuXG4uaW5wdXQtcmFuZ2VfX3RyYWNrLS1hY3RpdmUge1xuICBiYWNrZ3JvdW5kOiAjM2Y1MWI1OyB9XG5cbi5pbnB1dC1yYW5nZSB7XG4gIGhlaWdodDogMXJlbTtcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xuICBtYXJnaW4tdG9wOiAxLjJlbTtcbiAgbWFyZ2luLWJvdHRvbTogMS40ZW07XG59XG4gIFxuLlBvcG92ZXIge1xuICAgIHotaW5kZXg6IDIwMDA7XG59XG4uUG9wb3Zlci1ib2R5IHtcbiAgICBkaXNwbGF5OiBpbmxpbmUtZmxleDtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgIHBhZGRpbmc6IC41cmVtIDFyZW07XG4gICAgYmFja2dyb3VuZDogd2hpdGU7XG4gICAgYm9yZGVyLXJhZGl1czogMC4zcmVtO1xuICAgIG9wYWNpdHk6IC45NTtcbiAgICBib3gtc2hhZG93OiByZ2JhKDAsIDAsIDAsIDAuMTIpIDAgMXB4IDZweCwgcmdiYSgwLCAwLCAwLCAwLjEyKSAwIDFweCA0cHg7XG4gICAgZm9udC1zaXplOiAxNHB4O1xufVxuXG4uUG9wb3Zlci10aXBTaGFwZSB7XG4gICAgZmlsbDogJHtiYWNrR3JvdW5kQmx1ZX07XG59XG5cbi5Qb3BvdmVyLXdoaXRlIC5Qb3BvdmVyLXRpcFNoYXBlIHtcbiAgICBmaWxsOiAjMDBiY2Q0O1xufVxuXG4uUG9wb3Zlci13aGl0ZSAuUG9wb3Zlci1ib2R5IHtcbiAgICBiYWNrZ3JvdW5kOiB3aGl0ZTtcbn1cbiAgYDtcblxuZXhwb3J0IGRlZmF1bHQgU3R5bGU7XG4iXX0= */\n/*@ sourceURL=input-range-style.js */";
Style.__scopedHash = "821553959";
var _default = Style;
/* harmony default export */ __webpack_exports__["a"] = (_default);
;

(function () {
  var reactHotLoader = __webpack_require__("./node_modules/react-hot-loader/patch.js").default;

  var leaveModule = __webpack_require__("./node_modules/react-hot-loader/patch.js").leaveModule;

  if (!reactHotLoader) {
    return;
  }

  reactHotLoader.register(Style, "Style", "/Users/lichenma/Projects/SuDuoku/SuDuoku/input-range-style.js");
  reactHotLoader.register(_default, "default", "/Users/lichenma/Projects/SuDuoku/SuDuoku/input-range-style.js");
  leaveModule(module);
})();

;
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__("./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./node_modules/autobind-decorator/lib/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * @copyright 2015, Andrey Popp <8mayday@gmail.com>
 *
 * The decorator may be used on classes or methods
 * ```
 * @autobind
 * class FullBound {}
 *
 * class PartBound {
 *   @autobind
 *   method () {}
 * }
 * ```
 */


Object.defineProperty(exports, '__esModule', {
  value: true
});
exports['default'] = autobind;

function autobind() {
  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  if (args.length === 1) {
    return boundClass.apply(undefined, args);
  } else {
    return boundMethod.apply(undefined, args);
  }
}

/**
 * Use boundMethod to bind all methods on the target.prototype
 */
function boundClass(target) {
  // (Using reflect to get all keys including symbols)
  var keys = undefined;
  // Use Reflect if exists
  if (typeof Reflect !== 'undefined' && typeof Reflect.ownKeys === 'function') {
    keys = Reflect.ownKeys(target.prototype);
  } else {
    keys = Object.getOwnPropertyNames(target.prototype);
    // use symbols if support is provided
    if (typeof Object.getOwnPropertySymbols === 'function') {
      keys = keys.concat(Object.getOwnPropertySymbols(target.prototype));
    }
  }

  keys.forEach(function (key) {
    // Ignore special case target method
    if (key === 'constructor') {
      return;
    }

    var descriptor = Object.getOwnPropertyDescriptor(target.prototype, key);

    // Only methods need binding
    if (typeof descriptor.value === 'function') {
      Object.defineProperty(target.prototype, key, boundMethod(target, key, descriptor));
    }
  });
  return target;
}

/**
 * Return a descriptor removing the value and returning a getter
 * The getter will return a .bind version of the function
 * and memoize the result against a symbol on the instance
 */
function boundMethod(target, key, descriptor) {
  var fn = descriptor.value;

  if (typeof fn !== 'function') {
    throw new Error('@autobind decorator can only be applied to methods not: ' + typeof fn);
  }

  // In IE11 calling Object.defineProperty has a side-effect of evaluating the
  // getter for the property which is being replaced. This causes infinite
  // recursion and an "Out of stack space" error.
  var definingProperty = false;

  return {
    configurable: true,
    get: function get() {
      if (definingProperty || this === target.prototype || this.hasOwnProperty(key)) {
        return fn;
      }

      var boundFn = fn.bind(this);
      definingProperty = true;
      Object.defineProperty(this, key, {
        value: boundFn,
        configurable: true,
        writable: true
      });
      definingProperty = false;
      return boundFn;
    }
  };
}
module.exports = exports['default'];


/***/ }),

/***/ "./node_modules/babel-runtime/core-js/array/from.js":
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__("./node_modules/core-js/library/fn/array/from.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/core-js/get-iterator.js":
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__("./node_modules/core-js/library/fn/get-iterator.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/core-js/is-iterable.js":
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__("./node_modules/core-js/library/fn/is-iterable.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/core-js/map.js":
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__("./node_modules/core-js/library/fn/map.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/core-js/object/assign.js":
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__("./node_modules/core-js/library/fn/object/assign.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/core-js/object/create.js":
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__("./node_modules/core-js/library/fn/object/create.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/core-js/object/define-property.js":
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__("./node_modules/core-js/library/fn/object/define-property.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/core-js/object/get-prototype-of.js":
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__("./node_modules/core-js/library/fn/object/get-prototype-of.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/core-js/object/keys.js":
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__("./node_modules/core-js/library/fn/object/keys.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/core-js/object/set-prototype-of.js":
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__("./node_modules/core-js/library/fn/object/set-prototype-of.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/core-js/promise.js":
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__("./node_modules/core-js/library/fn/promise.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/core-js/set.js":
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__("./node_modules/core-js/library/fn/set.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/core-js/symbol.js":
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__("./node_modules/core-js/library/fn/symbol/index.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/core-js/symbol/iterator.js":
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__("./node_modules/core-js/library/fn/symbol/iterator.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/helpers/asyncToGenerator.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _promise = __webpack_require__("./node_modules/babel-runtime/core-js/promise.js");

var _promise2 = _interopRequireDefault(_promise);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (fn) {
  return function () {
    var gen = fn.apply(this, arguments);
    return new _promise2.default(function (resolve, reject) {
      function step(key, arg) {
        try {
          var info = gen[key](arg);
          var value = info.value;
        } catch (error) {
          reject(error);
          return;
        }

        if (info.done) {
          resolve(value);
        } else {
          return _promise2.default.resolve(value).then(function (value) {
            step("next", value);
          }, function (err) {
            step("throw", err);
          });
        }
      }

      return step("next");
    });
  };
};

/***/ }),

/***/ "./node_modules/babel-runtime/helpers/classCallCheck.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports.default = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

/***/ }),

/***/ "./node_modules/babel-runtime/helpers/createClass.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__("./node_modules/babel-runtime/core-js/object/define-property.js");

var _defineProperty2 = _interopRequireDefault(_defineProperty);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      (0, _defineProperty2.default)(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

/***/ }),

/***/ "./node_modules/babel-runtime/helpers/inherits.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _setPrototypeOf = __webpack_require__("./node_modules/babel-runtime/core-js/object/set-prototype-of.js");

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__("./node_modules/babel-runtime/core-js/object/create.js");

var _create2 = _interopRequireDefault(_create);

var _typeof2 = __webpack_require__("./node_modules/babel-runtime/helpers/typeof.js");

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : (0, _typeof3.default)(superClass)));
  }

  subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;
};

/***/ }),

/***/ "./node_modules/babel-runtime/helpers/possibleConstructorReturn.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _typeof2 = __webpack_require__("./node_modules/babel-runtime/helpers/typeof.js");

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && ((typeof call === "undefined" ? "undefined" : (0, _typeof3.default)(call)) === "object" || typeof call === "function") ? call : self;
};

/***/ }),

/***/ "./node_modules/babel-runtime/helpers/slicedToArray.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _isIterable2 = __webpack_require__("./node_modules/babel-runtime/core-js/is-iterable.js");

var _isIterable3 = _interopRequireDefault(_isIterable2);

var _getIterator2 = __webpack_require__("./node_modules/babel-runtime/core-js/get-iterator.js");

var _getIterator3 = _interopRequireDefault(_getIterator2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = (0, _getIterator3.default)(arr), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if ((0, _isIterable3.default)(Object(arr))) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();

/***/ }),

/***/ "./node_modules/babel-runtime/helpers/toConsumableArray.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _from = __webpack_require__("./node_modules/babel-runtime/core-js/array/from.js");

var _from2 = _interopRequireDefault(_from);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  } else {
    return (0, _from2.default)(arr);
  }
};

/***/ }),

/***/ "./node_modules/babel-runtime/helpers/typeof.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _iterator = __webpack_require__("./node_modules/babel-runtime/core-js/symbol/iterator.js");

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = __webpack_require__("./node_modules/babel-runtime/core-js/symbol.js");

var _symbol2 = _interopRequireDefault(_symbol);

var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof(obj);
} : function (obj) {
  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
};

/***/ }),

/***/ "./node_modules/babel-runtime/regenerator/index.js":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__("./node_modules/regenerator-runtime/runtime-module.js");


/***/ }),

/***/ "./node_modules/backo2/index.js":
/***/ (function(module, exports) {


/**
 * Expose `Backoff`.
 */

module.exports = Backoff;

/**
 * Initialize backoff timer with `opts`.
 *
 * - `min` initial timeout in milliseconds [100]
 * - `max` max timeout [10000]
 * - `jitter` [0]
 * - `factor` [2]
 *
 * @param {Object} opts
 * @api public
 */

function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 10000;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}

/**
 * Return the backoff duration.
 *
 * @return {Number}
 * @api public
 */

Backoff.prototype.duration = function(){
  var ms = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand =  Math.random();
    var deviation = Math.floor(rand * this.jitter * ms);
    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;
  }
  return Math.min(ms, this.max) | 0;
};

/**
 * Reset the number of attempts.
 *
 * @api public
 */

Backoff.prototype.reset = function(){
  this.attempts = 0;
};

/**
 * Set the minimum duration
 *
 * @api public
 */

Backoff.prototype.setMin = function(min){
  this.ms = min;
};

/**
 * Set the maximum duration
 *
 * @api public
 */

Backoff.prototype.setMax = function(max){
  this.max = max;
};

/**
 * Set the jitter
 *
 * @api public
 */

Backoff.prototype.setJitter = function(jitter){
  this.jitter = jitter;
};



/***/ }),

/***/ "./node_modules/base64-arraybuffer/lib/base64-arraybuffer.js":
/***/ (function(module, exports) {

/*
 * base64-arraybuffer
 * https://github.com/niklasvh/base64-arraybuffer
 *
 * Copyright (c) 2012 Niklas von Hertzen
 * Licensed under the MIT license.
 */
(function(chars){
  "use strict";

  exports.encode = function(arraybuffer) {
    var bytes = new Uint8Array(arraybuffer),
    i, len = bytes.length, base64 = "";

    for (i = 0; i < len; i+=3) {
      base64 += chars[bytes[i] >> 2];
      base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
      base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
      base64 += chars[bytes[i + 2] & 63];
    }

    if ((len % 3) === 2) {
      base64 = base64.substring(0, base64.length - 1) + "=";
    } else if (len % 3 === 1) {
      base64 = base64.substring(0, base64.length - 2) + "==";
    }

    return base64;
  };

  exports.decode =  function(base64) {
    var bufferLength = base64.length * 0.75,
    len = base64.length, i, p = 0,
    encoded1, encoded2, encoded3, encoded4;

    if (base64[base64.length - 1] === "=") {
      bufferLength--;
      if (base64[base64.length - 2] === "=") {
        bufferLength--;
      }
    }

    var arraybuffer = new ArrayBuffer(bufferLength),
    bytes = new Uint8Array(arraybuffer);

    for (i = 0; i < len; i+=4) {
      encoded1 = chars.indexOf(base64[i]);
      encoded2 = chars.indexOf(base64[i+1]);
      encoded3 = chars.indexOf(base64[i+2]);
      encoded4 = chars.indexOf(base64[i+3]);

      bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
      bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
      bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
    }

    return arraybuffer;
  };
})("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");


/***/ }),

/***/ "./node_modules/base64-js/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function placeHoldersCount (b64) {
  var len = b64.length
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
}

function byteLength (b64) {
  // base64 is 4/3 + up to two characters of the original data
  return (b64.length * 3 / 4) - placeHoldersCount(b64)
}

function toByteArray (b64) {
  var i, l, tmp, placeHolders, arr
  var len = b64.length
  placeHolders = placeHoldersCount(b64)

  arr = new Arr((len * 3 / 4) - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0; i < l; i += 4) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = ((uint8[i] << 16) & 0xFF0000) + ((uint8[i + 1] << 8) & 0xFF00) + (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}


/***/ }),

/***/ "./node_modules/buffer/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__("./node_modules/base64-js/index.js")
var ieee754 = __webpack_require__("./node_modules/ieee754/index.js")
var isArray = __webpack_require__("./node_modules/isarray/index.js")

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/color-convert/conversions.js":
/***/ (function(module, exports, __webpack_require__) {

/* MIT license */
var cssKeywords = __webpack_require__("./node_modules/color-name/index.js");

// NOTE: conversions should only return primitive values (i.e. arrays, or
//       values that give correct `typeof` results).
//       do not use box values types (i.e. Number(), String(), etc.)

var reverseKeywords = {};
for (var key in cssKeywords) {
	if (cssKeywords.hasOwnProperty(key)) {
		reverseKeywords[cssKeywords[key]] = key;
	}
}

var convert = module.exports = {
	rgb: {channels: 3, labels: 'rgb'},
	hsl: {channels: 3, labels: 'hsl'},
	hsv: {channels: 3, labels: 'hsv'},
	hwb: {channels: 3, labels: 'hwb'},
	cmyk: {channels: 4, labels: 'cmyk'},
	xyz: {channels: 3, labels: 'xyz'},
	lab: {channels: 3, labels: 'lab'},
	lch: {channels: 3, labels: 'lch'},
	hex: {channels: 1, labels: ['hex']},
	keyword: {channels: 1, labels: ['keyword']},
	ansi16: {channels: 1, labels: ['ansi16']},
	ansi256: {channels: 1, labels: ['ansi256']},
	hcg: {channels: 3, labels: ['h', 'c', 'g']},
	apple: {channels: 3, labels: ['r16', 'g16', 'b16']},
	gray: {channels: 1, labels: ['gray']}
};

// hide .channels and .labels properties
for (var model in convert) {
	if (convert.hasOwnProperty(model)) {
		if (!('channels' in convert[model])) {
			throw new Error('missing channels property: ' + model);
		}

		if (!('labels' in convert[model])) {
			throw new Error('missing channel labels property: ' + model);
		}

		if (convert[model].labels.length !== convert[model].channels) {
			throw new Error('channel and label counts mismatch: ' + model);
		}

		var channels = convert[model].channels;
		var labels = convert[model].labels;
		delete convert[model].channels;
		delete convert[model].labels;
		Object.defineProperty(convert[model], 'channels', {value: channels});
		Object.defineProperty(convert[model], 'labels', {value: labels});
	}
}

convert.rgb.hsl = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var min = Math.min(r, g, b);
	var max = Math.max(r, g, b);
	var delta = max - min;
	var h;
	var s;
	var l;

	if (max === min) {
		h = 0;
	} else if (r === max) {
		h = (g - b) / delta;
	} else if (g === max) {
		h = 2 + (b - r) / delta;
	} else if (b === max) {
		h = 4 + (r - g) / delta;
	}

	h = Math.min(h * 60, 360);

	if (h < 0) {
		h += 360;
	}

	l = (min + max) / 2;

	if (max === min) {
		s = 0;
	} else if (l <= 0.5) {
		s = delta / (max + min);
	} else {
		s = delta / (2 - max - min);
	}

	return [h, s * 100, l * 100];
};

convert.rgb.hsv = function (rgb) {
	var r = rgb[0];
	var g = rgb[1];
	var b = rgb[2];
	var min = Math.min(r, g, b);
	var max = Math.max(r, g, b);
	var delta = max - min;
	var h;
	var s;
	var v;

	if (max === 0) {
		s = 0;
	} else {
		s = (delta / max * 1000) / 10;
	}

	if (max === min) {
		h = 0;
	} else if (r === max) {
		h = (g - b) / delta;
	} else if (g === max) {
		h = 2 + (b - r) / delta;
	} else if (b === max) {
		h = 4 + (r - g) / delta;
	}

	h = Math.min(h * 60, 360);

	if (h < 0) {
		h += 360;
	}

	v = ((max / 255) * 1000) / 10;

	return [h, s, v];
};

convert.rgb.hwb = function (rgb) {
	var r = rgb[0];
	var g = rgb[1];
	var b = rgb[2];
	var h = convert.rgb.hsl(rgb)[0];
	var w = 1 / 255 * Math.min(r, Math.min(g, b));

	b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));

	return [h, w * 100, b * 100];
};

convert.rgb.cmyk = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var c;
	var m;
	var y;
	var k;

	k = Math.min(1 - r, 1 - g, 1 - b);
	c = (1 - r - k) / (1 - k) || 0;
	m = (1 - g - k) / (1 - k) || 0;
	y = (1 - b - k) / (1 - k) || 0;

	return [c * 100, m * 100, y * 100, k * 100];
};

/**
 * See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
 * */
function comparativeDistance(x, y) {
	return (
		Math.pow(x[0] - y[0], 2) +
		Math.pow(x[1] - y[1], 2) +
		Math.pow(x[2] - y[2], 2)
	);
}

convert.rgb.keyword = function (rgb) {
	var reversed = reverseKeywords[rgb];
	if (reversed) {
		return reversed;
	}

	var currentClosestDistance = Infinity;
	var currentClosestKeyword;

	for (var keyword in cssKeywords) {
		if (cssKeywords.hasOwnProperty(keyword)) {
			var value = cssKeywords[keyword];

			// Compute comparative distance
			var distance = comparativeDistance(rgb, value);

			// Check if its less, if so set as closest
			if (distance < currentClosestDistance) {
				currentClosestDistance = distance;
				currentClosestKeyword = keyword;
			}
		}
	}

	return currentClosestKeyword;
};

convert.keyword.rgb = function (keyword) {
	return cssKeywords[keyword];
};

convert.rgb.xyz = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;

	// assume sRGB
	r = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);
	g = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);
	b = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);

	var x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
	var y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
	var z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);

	return [x * 100, y * 100, z * 100];
};

convert.rgb.lab = function (rgb) {
	var xyz = convert.rgb.xyz(rgb);
	var x = xyz[0];
	var y = xyz[1];
	var z = xyz[2];
	var l;
	var a;
	var b;

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);

	l = (116 * y) - 16;
	a = 500 * (x - y);
	b = 200 * (y - z);

	return [l, a, b];
};

convert.hsl.rgb = function (hsl) {
	var h = hsl[0] / 360;
	var s = hsl[1] / 100;
	var l = hsl[2] / 100;
	var t1;
	var t2;
	var t3;
	var rgb;
	var val;

	if (s === 0) {
		val = l * 255;
		return [val, val, val];
	}

	if (l < 0.5) {
		t2 = l * (1 + s);
	} else {
		t2 = l + s - l * s;
	}

	t1 = 2 * l - t2;

	rgb = [0, 0, 0];
	for (var i = 0; i < 3; i++) {
		t3 = h + 1 / 3 * -(i - 1);
		if (t3 < 0) {
			t3++;
		}
		if (t3 > 1) {
			t3--;
		}

		if (6 * t3 < 1) {
			val = t1 + (t2 - t1) * 6 * t3;
		} else if (2 * t3 < 1) {
			val = t2;
		} else if (3 * t3 < 2) {
			val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
		} else {
			val = t1;
		}

		rgb[i] = val * 255;
	}

	return rgb;
};

convert.hsl.hsv = function (hsl) {
	var h = hsl[0];
	var s = hsl[1] / 100;
	var l = hsl[2] / 100;
	var smin = s;
	var lmin = Math.max(l, 0.01);
	var sv;
	var v;

	l *= 2;
	s *= (l <= 1) ? l : 2 - l;
	smin *= lmin <= 1 ? lmin : 2 - lmin;
	v = (l + s) / 2;
	sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);

	return [h, sv * 100, v * 100];
};

convert.hsv.rgb = function (hsv) {
	var h = hsv[0] / 60;
	var s = hsv[1] / 100;
	var v = hsv[2] / 100;
	var hi = Math.floor(h) % 6;

	var f = h - Math.floor(h);
	var p = 255 * v * (1 - s);
	var q = 255 * v * (1 - (s * f));
	var t = 255 * v * (1 - (s * (1 - f)));
	v *= 255;

	switch (hi) {
		case 0:
			return [v, t, p];
		case 1:
			return [q, v, p];
		case 2:
			return [p, v, t];
		case 3:
			return [p, q, v];
		case 4:
			return [t, p, v];
		case 5:
			return [v, p, q];
	}
};

convert.hsv.hsl = function (hsv) {
	var h = hsv[0];
	var s = hsv[1] / 100;
	var v = hsv[2] / 100;
	var vmin = Math.max(v, 0.01);
	var lmin;
	var sl;
	var l;

	l = (2 - s) * v;
	lmin = (2 - s) * vmin;
	sl = s * vmin;
	sl /= (lmin <= 1) ? lmin : 2 - lmin;
	sl = sl || 0;
	l /= 2;

	return [h, sl * 100, l * 100];
};

// http://dev.w3.org/csswg/css-color/#hwb-to-rgb
convert.hwb.rgb = function (hwb) {
	var h = hwb[0] / 360;
	var wh = hwb[1] / 100;
	var bl = hwb[2] / 100;
	var ratio = wh + bl;
	var i;
	var v;
	var f;
	var n;

	// wh + bl cant be > 1
	if (ratio > 1) {
		wh /= ratio;
		bl /= ratio;
	}

	i = Math.floor(6 * h);
	v = 1 - bl;
	f = 6 * h - i;

	if ((i & 0x01) !== 0) {
		f = 1 - f;
	}

	n = wh + f * (v - wh); // linear interpolation

	var r;
	var g;
	var b;
	switch (i) {
		default:
		case 6:
		case 0: r = v; g = n; b = wh; break;
		case 1: r = n; g = v; b = wh; break;
		case 2: r = wh; g = v; b = n; break;
		case 3: r = wh; g = n; b = v; break;
		case 4: r = n; g = wh; b = v; break;
		case 5: r = v; g = wh; b = n; break;
	}

	return [r * 255, g * 255, b * 255];
};

convert.cmyk.rgb = function (cmyk) {
	var c = cmyk[0] / 100;
	var m = cmyk[1] / 100;
	var y = cmyk[2] / 100;
	var k = cmyk[3] / 100;
	var r;
	var g;
	var b;

	r = 1 - Math.min(1, c * (1 - k) + k);
	g = 1 - Math.min(1, m * (1 - k) + k);
	b = 1 - Math.min(1, y * (1 - k) + k);

	return [r * 255, g * 255, b * 255];
};

convert.xyz.rgb = function (xyz) {
	var x = xyz[0] / 100;
	var y = xyz[1] / 100;
	var z = xyz[2] / 100;
	var r;
	var g;
	var b;

	r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
	g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
	b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);

	// assume sRGB
	r = r > 0.0031308
		? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)
		: r * 12.92;

	g = g > 0.0031308
		? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)
		: g * 12.92;

	b = b > 0.0031308
		? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)
		: b * 12.92;

	r = Math.min(Math.max(0, r), 1);
	g = Math.min(Math.max(0, g), 1);
	b = Math.min(Math.max(0, b), 1);

	return [r * 255, g * 255, b * 255];
};

convert.xyz.lab = function (xyz) {
	var x = xyz[0];
	var y = xyz[1];
	var z = xyz[2];
	var l;
	var a;
	var b;

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);

	l = (116 * y) - 16;
	a = 500 * (x - y);
	b = 200 * (y - z);

	return [l, a, b];
};

convert.lab.xyz = function (lab) {
	var l = lab[0];
	var a = lab[1];
	var b = lab[2];
	var x;
	var y;
	var z;

	y = (l + 16) / 116;
	x = a / 500 + y;
	z = y - b / 200;

	var y2 = Math.pow(y, 3);
	var x2 = Math.pow(x, 3);
	var z2 = Math.pow(z, 3);
	y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
	x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
	z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;

	x *= 95.047;
	y *= 100;
	z *= 108.883;

	return [x, y, z];
};

convert.lab.lch = function (lab) {
	var l = lab[0];
	var a = lab[1];
	var b = lab[2];
	var hr;
	var h;
	var c;

	hr = Math.atan2(b, a);
	h = hr * 360 / 2 / Math.PI;

	if (h < 0) {
		h += 360;
	}

	c = Math.sqrt(a * a + b * b);

	return [l, c, h];
};

convert.lch.lab = function (lch) {
	var l = lch[0];
	var c = lch[1];
	var h = lch[2];
	var a;
	var b;
	var hr;

	hr = h / 360 * 2 * Math.PI;
	a = c * Math.cos(hr);
	b = c * Math.sin(hr);

	return [l, a, b];
};

convert.rgb.ansi16 = function (args) {
	var r = args[0];
	var g = args[1];
	var b = args[2];
	var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2]; // hsv -> ansi16 optimization

	value = Math.round(value / 50);

	if (value === 0) {
		return 30;
	}

	var ansi = 30
		+ ((Math.round(b / 255) << 2)
		| (Math.round(g / 255) << 1)
		| Math.round(r / 255));

	if (value === 2) {
		ansi += 60;
	}

	return ansi;
};

convert.hsv.ansi16 = function (args) {
	// optimization here; we already know the value and don't need to get
	// it converted for us.
	return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
};

convert.rgb.ansi256 = function (args) {
	var r = args[0];
	var g = args[1];
	var b = args[2];

	// we use the extended greyscale palette here, with the exception of
	// black and white. normal palette only has 4 greyscale shades.
	if (r === g && g === b) {
		if (r < 8) {
			return 16;
		}

		if (r > 248) {
			return 231;
		}

		return Math.round(((r - 8) / 247) * 24) + 232;
	}

	var ansi = 16
		+ (36 * Math.round(r / 255 * 5))
		+ (6 * Math.round(g / 255 * 5))
		+ Math.round(b / 255 * 5);

	return ansi;
};

convert.ansi16.rgb = function (args) {
	var color = args % 10;

	// handle greyscale
	if (color === 0 || color === 7) {
		if (args > 50) {
			color += 3.5;
		}

		color = color / 10.5 * 255;

		return [color, color, color];
	}

	var mult = (~~(args > 50) + 1) * 0.5;
	var r = ((color & 1) * mult) * 255;
	var g = (((color >> 1) & 1) * mult) * 255;
	var b = (((color >> 2) & 1) * mult) * 255;

	return [r, g, b];
};

convert.ansi256.rgb = function (args) {
	// handle greyscale
	if (args >= 232) {
		var c = (args - 232) * 10 + 8;
		return [c, c, c];
	}

	args -= 16;

	var rem;
	var r = Math.floor(args / 36) / 5 * 255;
	var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
	var b = (rem % 6) / 5 * 255;

	return [r, g, b];
};

convert.rgb.hex = function (args) {
	var integer = ((Math.round(args[0]) & 0xFF) << 16)
		+ ((Math.round(args[1]) & 0xFF) << 8)
		+ (Math.round(args[2]) & 0xFF);

	var string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert.hex.rgb = function (args) {
	var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
	if (!match) {
		return [0, 0, 0];
	}

	var colorString = match[0];

	if (match[0].length === 3) {
		colorString = colorString.split('').map(function (char) {
			return char + char;
		}).join('');
	}

	var integer = parseInt(colorString, 16);
	var r = (integer >> 16) & 0xFF;
	var g = (integer >> 8) & 0xFF;
	var b = integer & 0xFF;

	return [r, g, b];
};

convert.rgb.hcg = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var max = Math.max(Math.max(r, g), b);
	var min = Math.min(Math.min(r, g), b);
	var chroma = (max - min);
	var grayscale;
	var hue;

	if (chroma < 1) {
		grayscale = min / (1 - chroma);
	} else {
		grayscale = 0;
	}

	if (chroma <= 0) {
		hue = 0;
	} else
	if (max === r) {
		hue = ((g - b) / chroma) % 6;
	} else
	if (max === g) {
		hue = 2 + (b - r) / chroma;
	} else {
		hue = 4 + (r - g) / chroma + 4;
	}

	hue /= 6;
	hue %= 1;

	return [hue * 360, chroma * 100, grayscale * 100];
};

convert.hsl.hcg = function (hsl) {
	var s = hsl[1] / 100;
	var l = hsl[2] / 100;
	var c = 1;
	var f = 0;

	if (l < 0.5) {
		c = 2.0 * s * l;
	} else {
		c = 2.0 * s * (1.0 - l);
	}

	if (c < 1.0) {
		f = (l - 0.5 * c) / (1.0 - c);
	}

	return [hsl[0], c * 100, f * 100];
};

convert.hsv.hcg = function (hsv) {
	var s = hsv[1] / 100;
	var v = hsv[2] / 100;

	var c = s * v;
	var f = 0;

	if (c < 1.0) {
		f = (v - c) / (1 - c);
	}

	return [hsv[0], c * 100, f * 100];
};

convert.hcg.rgb = function (hcg) {
	var h = hcg[0] / 360;
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;

	if (c === 0.0) {
		return [g * 255, g * 255, g * 255];
	}

	var pure = [0, 0, 0];
	var hi = (h % 1) * 6;
	var v = hi % 1;
	var w = 1 - v;
	var mg = 0;

	switch (Math.floor(hi)) {
		case 0:
			pure[0] = 1; pure[1] = v; pure[2] = 0; break;
		case 1:
			pure[0] = w; pure[1] = 1; pure[2] = 0; break;
		case 2:
			pure[0] = 0; pure[1] = 1; pure[2] = v; break;
		case 3:
			pure[0] = 0; pure[1] = w; pure[2] = 1; break;
		case 4:
			pure[0] = v; pure[1] = 0; pure[2] = 1; break;
		default:
			pure[0] = 1; pure[1] = 0; pure[2] = w;
	}

	mg = (1.0 - c) * g;

	return [
		(c * pure[0] + mg) * 255,
		(c * pure[1] + mg) * 255,
		(c * pure[2] + mg) * 255
	];
};

convert.hcg.hsv = function (hcg) {
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;

	var v = c + g * (1.0 - c);
	var f = 0;

	if (v > 0.0) {
		f = c / v;
	}

	return [hcg[0], f * 100, v * 100];
};

convert.hcg.hsl = function (hcg) {
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;

	var l = g * (1.0 - c) + 0.5 * c;
	var s = 0;

	if (l > 0.0 && l < 0.5) {
		s = c / (2 * l);
	} else
	if (l >= 0.5 && l < 1.0) {
		s = c / (2 * (1 - l));
	}

	return [hcg[0], s * 100, l * 100];
};

convert.hcg.hwb = function (hcg) {
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;
	var v = c + g * (1.0 - c);
	return [hcg[0], (v - c) * 100, (1 - v) * 100];
};

convert.hwb.hcg = function (hwb) {
	var w = hwb[1] / 100;
	var b = hwb[2] / 100;
	var v = 1 - b;
	var c = v - w;
	var g = 0;

	if (c < 1) {
		g = (v - c) / (1 - c);
	}

	return [hwb[0], c * 100, g * 100];
};

convert.apple.rgb = function (apple) {
	return [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];
};

convert.rgb.apple = function (rgb) {
	return [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];
};

convert.gray.rgb = function (args) {
	return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
};

convert.gray.hsl = convert.gray.hsv = function (args) {
	return [0, 0, args[0]];
};

convert.gray.hwb = function (gray) {
	return [0, 100, gray[0]];
};

convert.gray.cmyk = function (gray) {
	return [0, 0, 0, gray[0]];
};

convert.gray.lab = function (gray) {
	return [gray[0], 0, 0];
};

convert.gray.hex = function (gray) {
	var val = Math.round(gray[0] / 100 * 255) & 0xFF;
	var integer = (val << 16) + (val << 8) + val;

	var string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert.rgb.gray = function (rgb) {
	var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
	return [val / 255 * 100];
};


/***/ }),

/***/ "./node_modules/color-convert/index.js":
/***/ (function(module, exports, __webpack_require__) {

var conversions = __webpack_require__("./node_modules/color-convert/conversions.js");
var route = __webpack_require__("./node_modules/color-convert/route.js");

var convert = {};

var models = Object.keys(conversions);

function wrapRaw(fn) {
	var wrappedFn = function (args) {
		if (args === undefined || args === null) {
			return args;
		}

		if (arguments.length > 1) {
			args = Array.prototype.slice.call(arguments);
		}

		return fn(args);
	};

	// preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

function wrapRounded(fn) {
	var wrappedFn = function (args) {
		if (args === undefined || args === null) {
			return args;
		}

		if (arguments.length > 1) {
			args = Array.prototype.slice.call(arguments);
		}

		var result = fn(args);

		// we're assuming the result is an array here.
		// see notice in conversions.js; don't use box types
		// in conversion functions.
		if (typeof result === 'object') {
			for (var len = result.length, i = 0; i < len; i++) {
				result[i] = Math.round(result[i]);
			}
		}

		return result;
	};

	// preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

models.forEach(function (fromModel) {
	convert[fromModel] = {};

	Object.defineProperty(convert[fromModel], 'channels', {value: conversions[fromModel].channels});
	Object.defineProperty(convert[fromModel], 'labels', {value: conversions[fromModel].labels});

	var routes = route(fromModel);
	var routeModels = Object.keys(routes);

	routeModels.forEach(function (toModel) {
		var fn = routes[toModel];

		convert[fromModel][toModel] = wrapRounded(fn);
		convert[fromModel][toModel].raw = wrapRaw(fn);
	});
});

module.exports = convert;


/***/ }),

/***/ "./node_modules/color-convert/route.js":
/***/ (function(module, exports, __webpack_require__) {

var conversions = __webpack_require__("./node_modules/color-convert/conversions.js");

/*
	this function routes a model to all other models.

	all functions that are routed have a property `.conversion` attached
	to the returned synthetic function. This property is an array
	of strings, each with the steps in between the 'from' and 'to'
	color models (inclusive).

	conversions that are not possible simply are not included.
*/

function buildGraph() {
	var graph = {};
	// https://jsperf.com/object-keys-vs-for-in-with-closure/3
	var models = Object.keys(conversions);

	for (var len = models.length, i = 0; i < len; i++) {
		graph[models[i]] = {
			// http://jsperf.com/1-vs-infinity
			// micro-opt, but this is simple.
			distance: -1,
			parent: null
		};
	}

	return graph;
}

// https://en.wikipedia.org/wiki/Breadth-first_search
function deriveBFS(fromModel) {
	var graph = buildGraph();
	var queue = [fromModel]; // unshift -> queue -> pop

	graph[fromModel].distance = 0;

	while (queue.length) {
		var current = queue.pop();
		var adjacents = Object.keys(conversions[current]);

		for (var len = adjacents.length, i = 0; i < len; i++) {
			var adjacent = adjacents[i];
			var node = graph[adjacent];

			if (node.distance === -1) {
				node.distance = graph[current].distance + 1;
				node.parent = current;
				queue.unshift(adjacent);
			}
		}
	}

	return graph;
}

function link(from, to) {
	return function (args) {
		return to(from(args));
	};
}

function wrapConversion(toModel, graph) {
	var path = [graph[toModel].parent, toModel];
	var fn = conversions[graph[toModel].parent][toModel];

	var cur = graph[toModel].parent;
	while (graph[cur].parent) {
		path.unshift(graph[cur].parent);
		fn = link(conversions[graph[cur].parent][cur], fn);
		cur = graph[cur].parent;
	}

	fn.conversion = path;
	return fn;
}

module.exports = function (fromModel) {
	var graph = deriveBFS(fromModel);
	var conversion = {};

	var models = Object.keys(graph);
	for (var len = models.length, i = 0; i < len; i++) {
		var toModel = models[i];
		var node = graph[toModel];

		if (node.parent === null) {
			// no possible conversion, or this node is the source model.
			continue;
		}

		conversion[toModel] = wrapConversion(toModel, graph);
	}

	return conversion;
};



/***/ }),

/***/ "./node_modules/color-name/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
	"aliceblue": [240, 248, 255],
	"antiquewhite": [250, 235, 215],
	"aqua": [0, 255, 255],
	"aquamarine": [127, 255, 212],
	"azure": [240, 255, 255],
	"beige": [245, 245, 220],
	"bisque": [255, 228, 196],
	"black": [0, 0, 0],
	"blanchedalmond": [255, 235, 205],
	"blue": [0, 0, 255],
	"blueviolet": [138, 43, 226],
	"brown": [165, 42, 42],
	"burlywood": [222, 184, 135],
	"cadetblue": [95, 158, 160],
	"chartreuse": [127, 255, 0],
	"chocolate": [210, 105, 30],
	"coral": [255, 127, 80],
	"cornflowerblue": [100, 149, 237],
	"cornsilk": [255, 248, 220],
	"crimson": [220, 20, 60],
	"cyan": [0, 255, 255],
	"darkblue": [0, 0, 139],
	"darkcyan": [0, 139, 139],
	"darkgoldenrod": [184, 134, 11],
	"darkgray": [169, 169, 169],
	"darkgreen": [0, 100, 0],
	"darkgrey": [169, 169, 169],
	"darkkhaki": [189, 183, 107],
	"darkmagenta": [139, 0, 139],
	"darkolivegreen": [85, 107, 47],
	"darkorange": [255, 140, 0],
	"darkorchid": [153, 50, 204],
	"darkred": [139, 0, 0],
	"darksalmon": [233, 150, 122],
	"darkseagreen": [143, 188, 143],
	"darkslateblue": [72, 61, 139],
	"darkslategray": [47, 79, 79],
	"darkslategrey": [47, 79, 79],
	"darkturquoise": [0, 206, 209],
	"darkviolet": [148, 0, 211],
	"deeppink": [255, 20, 147],
	"deepskyblue": [0, 191, 255],
	"dimgray": [105, 105, 105],
	"dimgrey": [105, 105, 105],
	"dodgerblue": [30, 144, 255],
	"firebrick": [178, 34, 34],
	"floralwhite": [255, 250, 240],
	"forestgreen": [34, 139, 34],
	"fuchsia": [255, 0, 255],
	"gainsboro": [220, 220, 220],
	"ghostwhite": [248, 248, 255],
	"gold": [255, 215, 0],
	"goldenrod": [218, 165, 32],
	"gray": [128, 128, 128],
	"green": [0, 128, 0],
	"greenyellow": [173, 255, 47],
	"grey": [128, 128, 128],
	"honeydew": [240, 255, 240],
	"hotpink": [255, 105, 180],
	"indianred": [205, 92, 92],
	"indigo": [75, 0, 130],
	"ivory": [255, 255, 240],
	"khaki": [240, 230, 140],
	"lavender": [230, 230, 250],
	"lavenderblush": [255, 240, 245],
	"lawngreen": [124, 252, 0],
	"lemonchiffon": [255, 250, 205],
	"lightblue": [173, 216, 230],
	"lightcoral": [240, 128, 128],
	"lightcyan": [224, 255, 255],
	"lightgoldenrodyellow": [250, 250, 210],
	"lightgray": [211, 211, 211],
	"lightgreen": [144, 238, 144],
	"lightgrey": [211, 211, 211],
	"lightpink": [255, 182, 193],
	"lightsalmon": [255, 160, 122],
	"lightseagreen": [32, 178, 170],
	"lightskyblue": [135, 206, 250],
	"lightslategray": [119, 136, 153],
	"lightslategrey": [119, 136, 153],
	"lightsteelblue": [176, 196, 222],
	"lightyellow": [255, 255, 224],
	"lime": [0, 255, 0],
	"limegreen": [50, 205, 50],
	"linen": [250, 240, 230],
	"magenta": [255, 0, 255],
	"maroon": [128, 0, 0],
	"mediumaquamarine": [102, 205, 170],
	"mediumblue": [0, 0, 205],
	"mediumorchid": [186, 85, 211],
	"mediumpurple": [147, 112, 219],
	"mediumseagreen": [60, 179, 113],
	"mediumslateblue": [123, 104, 238],
	"mediumspringgreen": [0, 250, 154],
	"mediumturquoise": [72, 209, 204],
	"mediumvioletred": [199, 21, 133],
	"midnightblue": [25, 25, 112],
	"mintcream": [245, 255, 250],
	"mistyrose": [255, 228, 225],
	"moccasin": [255, 228, 181],
	"navajowhite": [255, 222, 173],
	"navy": [0, 0, 128],
	"oldlace": [253, 245, 230],
	"olive": [128, 128, 0],
	"olivedrab": [107, 142, 35],
	"orange": [255, 165, 0],
	"orangered": [255, 69, 0],
	"orchid": [218, 112, 214],
	"palegoldenrod": [238, 232, 170],
	"palegreen": [152, 251, 152],
	"paleturquoise": [175, 238, 238],
	"palevioletred": [219, 112, 147],
	"papayawhip": [255, 239, 213],
	"peachpuff": [255, 218, 185],
	"peru": [205, 133, 63],
	"pink": [255, 192, 203],
	"plum": [221, 160, 221],
	"powderblue": [176, 224, 230],
	"purple": [128, 0, 128],
	"rebeccapurple": [102, 51, 153],
	"red": [255, 0, 0],
	"rosybrown": [188, 143, 143],
	"royalblue": [65, 105, 225],
	"saddlebrown": [139, 69, 19],
	"salmon": [250, 128, 114],
	"sandybrown": [244, 164, 96],
	"seagreen": [46, 139, 87],
	"seashell": [255, 245, 238],
	"sienna": [160, 82, 45],
	"silver": [192, 192, 192],
	"skyblue": [135, 206, 235],
	"slateblue": [106, 90, 205],
	"slategray": [112, 128, 144],
	"slategrey": [112, 128, 144],
	"snow": [255, 250, 250],
	"springgreen": [0, 255, 127],
	"steelblue": [70, 130, 180],
	"tan": [210, 180, 140],
	"teal": [0, 128, 128],
	"thistle": [216, 191, 216],
	"tomato": [255, 99, 71],
	"turquoise": [64, 224, 208],
	"violet": [238, 130, 238],
	"wheat": [245, 222, 179],
	"white": [255, 255, 255],
	"whitesmoke": [245, 245, 245],
	"yellow": [255, 255, 0],
	"yellowgreen": [154, 205, 50]
};


/***/ }),

/***/ "./node_modules/color-string/index.js":
/***/ (function(module, exports, __webpack_require__) {

/* MIT license */
var colorNames = __webpack_require__("./node_modules/color-name/index.js");
var swizzle = __webpack_require__("./node_modules/simple-swizzle/index.js");

var reverseNames = {};

// create a list of reverse color names
for (var name in colorNames) {
	if (colorNames.hasOwnProperty(name)) {
		reverseNames[colorNames[name]] = name;
	}
}

var cs = module.exports = {
	to: {}
};

cs.get = function (string) {
	var prefix = string.substring(0, 3).toLowerCase();
	var val;
	var model;
	switch (prefix) {
		case 'hsl':
			val = cs.get.hsl(string);
			model = 'hsl';
			break;
		case 'hwb':
			val = cs.get.hwb(string);
			model = 'hwb';
			break;
		default:
			val = cs.get.rgb(string);
			model = 'rgb';
			break;
	}

	if (!val) {
		return null;
	}

	return {model: model, value: val};
};

cs.get.rgb = function (string) {
	if (!string) {
		return null;
	}

	var abbr = /^#([a-f0-9]{3,4})$/i;
	var hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
	var rgba = /^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/;
	var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/;
	var keyword = /(\D+)/;

	var rgb = [0, 0, 0, 1];
	var match;
	var i;
	var hexAlpha;

	if (match = string.match(hex)) {
		hexAlpha = match[2];
		match = match[1];

		for (i = 0; i < 3; i++) {
			// https://jsperf.com/slice-vs-substr-vs-substring-methods-long-string/19
			var i2 = i * 2;
			rgb[i] = parseInt(match.slice(i2, i2 + 2), 16);
		}

		if (hexAlpha) {
			rgb[3] = Math.round((parseInt(hexAlpha, 16) / 255) * 100) / 100;
		}
	} else if (match = string.match(abbr)) {
		match = match[1];
		hexAlpha = match[3];

		for (i = 0; i < 3; i++) {
			rgb[i] = parseInt(match[i] + match[i], 16);
		}

		if (hexAlpha) {
			rgb[3] = Math.round((parseInt(hexAlpha + hexAlpha, 16) / 255) * 100) / 100;
		}
	} else if (match = string.match(rgba)) {
		for (i = 0; i < 3; i++) {
			rgb[i] = parseInt(match[i + 1], 0);
		}

		if (match[4]) {
			rgb[3] = parseFloat(match[4]);
		}
	} else if (match = string.match(per)) {
		for (i = 0; i < 3; i++) {
			rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
		}

		if (match[4]) {
			rgb[3] = parseFloat(match[4]);
		}
	} else if (match = string.match(keyword)) {
		if (match[1] === 'transparent') {
			return [0, 0, 0, 0];
		}

		rgb = colorNames[match[1]];

		if (!rgb) {
			return null;
		}

		rgb[3] = 1;

		return rgb;
	} else {
		return null;
	}

	for (i = 0; i < 3; i++) {
		rgb[i] = clamp(rgb[i], 0, 255);
	}
	rgb[3] = clamp(rgb[3], 0, 1);

	return rgb;
};

cs.get.hsl = function (string) {
	if (!string) {
		return null;
	}

	var hsl = /^hsla?\(\s*([+-]?\d*[\.]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/;
	var match = string.match(hsl);

	if (match) {
		var alpha = parseFloat(match[4]);
		var h = ((parseFloat(match[1]) % 360) + 360) % 360;
		var s = clamp(parseFloat(match[2]), 0, 100);
		var l = clamp(parseFloat(match[3]), 0, 100);
		var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);

		return [h, s, l, a];
	}

	return null;
};

cs.get.hwb = function (string) {
	if (!string) {
		return null;
	}

	var hwb = /^hwb\(\s*([+-]?\d*[\.]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/;
	var match = string.match(hwb);

	if (match) {
		var alpha = parseFloat(match[4]);
		var h = ((parseFloat(match[1]) % 360) + 360) % 360;
		var w = clamp(parseFloat(match[2]), 0, 100);
		var b = clamp(parseFloat(match[3]), 0, 100);
		var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
		return [h, w, b, a];
	}

	return null;
};

cs.to.hex = function () {
	var rgba = swizzle(arguments);

	return (
		'#' +
		hexDouble(rgba[0]) +
		hexDouble(rgba[1]) +
		hexDouble(rgba[2]) +
		(rgba[3] < 1
			? (hexDouble(Math.round(rgba[3] * 255)))
			: '')
	);
};

cs.to.rgb = function () {
	var rgba = swizzle(arguments);

	return rgba.length < 4 || rgba[3] === 1
		? 'rgb(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ')'
		: 'rgba(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ', ' + rgba[3] + ')';
};

cs.to.rgb.percent = function () {
	var rgba = swizzle(arguments);

	var r = Math.round(rgba[0] / 255 * 100);
	var g = Math.round(rgba[1] / 255 * 100);
	var b = Math.round(rgba[2] / 255 * 100);

	return rgba.length < 4 || rgba[3] === 1
		? 'rgb(' + r + '%, ' + g + '%, ' + b + '%)'
		: 'rgba(' + r + '%, ' + g + '%, ' + b + '%, ' + rgba[3] + ')';
};

cs.to.hsl = function () {
	var hsla = swizzle(arguments);
	return hsla.length < 4 || hsla[3] === 1
		? 'hsl(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%)'
		: 'hsla(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%, ' + hsla[3] + ')';
};

// hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax
// (hwb have alpha optional & 1 is default value)
cs.to.hwb = function () {
	var hwba = swizzle(arguments);

	var a = '';
	if (hwba.length >= 4 && hwba[3] !== 1) {
		a = ', ' + hwba[3];
	}

	return 'hwb(' + hwba[0] + ', ' + hwba[1] + '%, ' + hwba[2] + '%' + a + ')';
};

cs.to.keyword = function (rgb) {
	return reverseNames[rgb.slice(0, 3)];
};

// helpers
function clamp(num, min, max) {
	return Math.min(Math.max(min, num), max);
}

function hexDouble(num) {
	var str = num.toString(16).toUpperCase();
	return (str.length < 2) ? '0' + str : str;
}


/***/ }),

/***/ "./node_modules/color/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var colorString = __webpack_require__("./node_modules/color-string/index.js");
var convert = __webpack_require__("./node_modules/color-convert/index.js");

var _slice = [].slice;

var skippedModels = [
	// to be honest, I don't really feel like keyword belongs in color convert, but eh.
	'keyword',

	// gray conflicts with some method names, and has its own method defined.
	'gray',

	// shouldn't really be in color-convert either...
	'hex'
];

var hashedModelKeys = {};
Object.keys(convert).forEach(function (model) {
	hashedModelKeys[_slice.call(convert[model].labels).sort().join('')] = model;
});

var limiters = {};

function Color(obj, model) {
	if (!(this instanceof Color)) {
		return new Color(obj, model);
	}

	if (model && model in skippedModels) {
		model = null;
	}

	if (model && !(model in convert)) {
		throw new Error('Unknown model: ' + model);
	}

	var i;
	var channels;

	if (!obj) {
		this.model = 'rgb';
		this.color = [0, 0, 0];
		this.valpha = 1;
	} else if (obj instanceof Color) {
		this.model = obj.model;
		this.color = obj.color.slice();
		this.valpha = obj.valpha;
	} else if (typeof obj === 'string') {
		var result = colorString.get(obj);
		if (result === null) {
			throw new Error('Unable to parse color from string: ' + obj);
		}

		this.model = result.model;
		channels = convert[this.model].channels;
		this.color = result.value.slice(0, channels);
		this.valpha = typeof result.value[channels] === 'number' ? result.value[channels] : 1;
	} else if (obj.length) {
		this.model = model || 'rgb';
		channels = convert[this.model].channels;
		var newArr = _slice.call(obj, 0, channels);
		this.color = zeroArray(newArr, channels);
		this.valpha = typeof obj[channels] === 'number' ? obj[channels] : 1;
	} else if (typeof obj === 'number') {
		// this is always RGB - can be converted later on.
		obj &= 0xFFFFFF;
		this.model = 'rgb';
		this.color = [
			(obj >> 16) & 0xFF,
			(obj >> 8) & 0xFF,
			obj & 0xFF
		];
		this.valpha = 1;
	} else {
		this.valpha = 1;

		var keys = Object.keys(obj);
		if ('alpha' in obj) {
			keys.splice(keys.indexOf('alpha'), 1);
			this.valpha = typeof obj.alpha === 'number' ? obj.alpha : 0;
		}

		var hashedKeys = keys.sort().join('');
		if (!(hashedKeys in hashedModelKeys)) {
			throw new Error('Unable to parse color from object: ' + JSON.stringify(obj));
		}

		this.model = hashedModelKeys[hashedKeys];

		var labels = convert[this.model].labels;
		var color = [];
		for (i = 0; i < labels.length; i++) {
			color.push(obj[labels[i]]);
		}

		this.color = zeroArray(color);
	}

	// perform limitations (clamping, etc.)
	if (limiters[this.model]) {
		channels = convert[this.model].channels;
		for (i = 0; i < channels; i++) {
			var limit = limiters[this.model][i];
			if (limit) {
				this.color[i] = limit(this.color[i]);
			}
		}
	}

	this.valpha = Math.max(0, Math.min(1, this.valpha));

	if (Object.freeze) {
		Object.freeze(this);
	}
}

Color.prototype = {
	toString: function () {
		return this.string();
	},

	toJSON: function () {
		return this[this.model]();
	},

	string: function (places) {
		var self = this.model in colorString.to ? this : this.rgb();
		self = self.round(typeof places === 'number' ? places : 1);
		var args = self.valpha === 1 ? self.color : self.color.concat(this.valpha);
		return colorString.to[self.model](args);
	},

	percentString: function (places) {
		var self = this.rgb().round(typeof places === 'number' ? places : 1);
		var args = self.valpha === 1 ? self.color : self.color.concat(this.valpha);
		return colorString.to.rgb.percent(args);
	},

	array: function () {
		return this.valpha === 1 ? this.color.slice() : this.color.concat(this.valpha);
	},

	object: function () {
		var result = {};
		var channels = convert[this.model].channels;
		var labels = convert[this.model].labels;

		for (var i = 0; i < channels; i++) {
			result[labels[i]] = this.color[i];
		}

		if (this.valpha !== 1) {
			result.alpha = this.valpha;
		}

		return result;
	},

	unitArray: function () {
		var rgb = this.rgb().color;
		rgb[0] /= 255;
		rgb[1] /= 255;
		rgb[2] /= 255;

		if (this.valpha !== 1) {
			rgb.push(this.valpha);
		}

		return rgb;
	},

	unitObject: function () {
		var rgb = this.rgb().object();
		rgb.r /= 255;
		rgb.g /= 255;
		rgb.b /= 255;

		if (this.valpha !== 1) {
			rgb.alpha = this.valpha;
		}

		return rgb;
	},

	round: function (places) {
		places = Math.max(places || 0, 0);
		return new Color(this.color.map(roundToPlace(places)).concat(this.valpha), this.model);
	},

	alpha: function (val) {
		if (arguments.length) {
			return new Color(this.color.concat(Math.max(0, Math.min(1, val))), this.model);
		}

		return this.valpha;
	},

	// rgb
	red: getset('rgb', 0, maxfn(255)),
	green: getset('rgb', 1, maxfn(255)),
	blue: getset('rgb', 2, maxfn(255)),

	hue: getset(['hsl', 'hsv', 'hsl', 'hwb', 'hcg'], 0, function (val) { return ((val % 360) + 360) % 360; }), // eslint-disable-line brace-style

	saturationl: getset('hsl', 1, maxfn(100)),
	lightness: getset('hsl', 2, maxfn(100)),

	saturationv: getset('hsv', 1, maxfn(100)),
	value: getset('hsv', 2, maxfn(100)),

	chroma: getset('hcg', 1, maxfn(100)),
	gray: getset('hcg', 2, maxfn(100)),

	white: getset('hwb', 1, maxfn(100)),
	wblack: getset('hwb', 2, maxfn(100)),

	cyan: getset('cmyk', 0, maxfn(100)),
	magenta: getset('cmyk', 1, maxfn(100)),
	yellow: getset('cmyk', 2, maxfn(100)),
	black: getset('cmyk', 3, maxfn(100)),

	x: getset('xyz', 0, maxfn(100)),
	y: getset('xyz', 1, maxfn(100)),
	z: getset('xyz', 2, maxfn(100)),

	l: getset('lab', 0, maxfn(100)),
	a: getset('lab', 1),
	b: getset('lab', 2),

	keyword: function (val) {
		if (arguments.length) {
			return new Color(val);
		}

		return convert[this.model].keyword(this.color);
	},

	hex: function (val) {
		if (arguments.length) {
			return new Color(val);
		}

		return colorString.to.hex(this.rgb().round().color);
	},

	rgbNumber: function () {
		var rgb = this.rgb().color;
		return ((rgb[0] & 0xFF) << 16) | ((rgb[1] & 0xFF) << 8) | (rgb[2] & 0xFF);
	},

	luminosity: function () {
		// http://www.w3.org/TR/WCAG20/#relativeluminancedef
		var rgb = this.rgb().color;

		var lum = [];
		for (var i = 0; i < rgb.length; i++) {
			var chan = rgb[i] / 255;
			lum[i] = (chan <= 0.03928) ? chan / 12.92 : Math.pow(((chan + 0.055) / 1.055), 2.4);
		}

		return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
	},

	contrast: function (color2) {
		// http://www.w3.org/TR/WCAG20/#contrast-ratiodef
		var lum1 = this.luminosity();
		var lum2 = color2.luminosity();

		if (lum1 > lum2) {
			return (lum1 + 0.05) / (lum2 + 0.05);
		}

		return (lum2 + 0.05) / (lum1 + 0.05);
	},

	level: function (color2) {
		var contrastRatio = this.contrast(color2);
		if (contrastRatio >= 7.1) {
			return 'AAA';
		}

		return (contrastRatio >= 4.5) ? 'AA' : '';
	},

	isDark: function () {
		// YIQ equation from http://24ways.org/2010/calculating-color-contrast
		var rgb = this.rgb().color;
		var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;
		return yiq < 128;
	},

	isLight: function () {
		return !this.isDark();
	},

	negate: function () {
		var rgb = this.rgb();
		for (var i = 0; i < 3; i++) {
			rgb.color[i] = 255 - rgb.color[i];
		}
		return rgb;
	},

	lighten: function (ratio) {
		var hsl = this.hsl();
		hsl.color[2] += hsl.color[2] * ratio;
		return hsl;
	},

	darken: function (ratio) {
		var hsl = this.hsl();
		hsl.color[2] -= hsl.color[2] * ratio;
		return hsl;
	},

	saturate: function (ratio) {
		var hsl = this.hsl();
		hsl.color[1] += hsl.color[1] * ratio;
		return hsl;
	},

	desaturate: function (ratio) {
		var hsl = this.hsl();
		hsl.color[1] -= hsl.color[1] * ratio;
		return hsl;
	},

	whiten: function (ratio) {
		var hwb = this.hwb();
		hwb.color[1] += hwb.color[1] * ratio;
		return hwb;
	},

	blacken: function (ratio) {
		var hwb = this.hwb();
		hwb.color[2] += hwb.color[2] * ratio;
		return hwb;
	},

	grayscale: function () {
		// http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale
		var rgb = this.rgb().color;
		var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
		return Color.rgb(val, val, val);
	},

	fade: function (ratio) {
		return this.alpha(this.valpha - (this.valpha * ratio));
	},

	opaquer: function (ratio) {
		return this.alpha(this.valpha + (this.valpha * ratio));
	},

	rotate: function (degrees) {
		var hsl = this.hsl();
		var hue = hsl.color[0];
		hue = (hue + degrees) % 360;
		hue = hue < 0 ? 360 + hue : hue;
		hsl.color[0] = hue;
		return hsl;
	},

	mix: function (mixinColor, weight) {
		// ported from sass implementation in C
		// https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209
		var color1 = mixinColor.rgb();
		var color2 = this.rgb();
		var p = weight === undefined ? 0.5 : weight;

		var w = 2 * p - 1;
		var a = color1.alpha() - color2.alpha();

		var w1 = (((w * a === -1) ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
		var w2 = 1 - w1;

		return Color.rgb(
				w1 * color1.red() + w2 * color2.red(),
				w1 * color1.green() + w2 * color2.green(),
				w1 * color1.blue() + w2 * color2.blue(),
				color1.alpha() * p + color2.alpha() * (1 - p));
	}
};

// model conversion methods and static constructors
Object.keys(convert).forEach(function (model) {
	if (skippedModels.indexOf(model) !== -1) {
		return;
	}

	var channels = convert[model].channels;

	// conversion methods
	Color.prototype[model] = function () {
		if (this.model === model) {
			return new Color(this);
		}

		if (arguments.length) {
			return new Color(arguments, model);
		}

		var newAlpha = typeof arguments[channels] === 'number' ? channels : this.valpha;
		return new Color(assertArray(convert[this.model][model].raw(this.color)).concat(newAlpha), model);
	};

	// 'static' construction methods
	Color[model] = function (color) {
		if (typeof color === 'number') {
			color = zeroArray(_slice.call(arguments), channels);
		}
		return new Color(color, model);
	};
});

function roundTo(num, places) {
	return Number(num.toFixed(places));
}

function roundToPlace(places) {
	return function (num) {
		return roundTo(num, places);
	};
}

function getset(model, channel, modifier) {
	model = Array.isArray(model) ? model : [model];

	model.forEach(function (m) {
		(limiters[m] || (limiters[m] = []))[channel] = modifier;
	});

	model = model[0];

	return function (val) {
		var result;

		if (arguments.length) {
			if (modifier) {
				val = modifier(val);
			}

			result = this[model]();
			result.color[channel] = val;
			return result;
		}

		result = this[model]().color[channel];
		if (modifier) {
			result = modifier(result);
		}

		return result;
	};
}

function maxfn(max) {
	return function (v) {
		return Math.max(0, Math.min(max, v));
	};
}

function assertArray(val) {
	return Array.isArray(val) ? val : [val];
}

function zeroArray(arr, length) {
	for (var i = 0; i < length; i++) {
		if (typeof arr[i] !== 'number') {
			arr[i] = 0;
		}
	}

	return arr;
}

module.exports = Color;


/***/ }),

/***/ "./node_modules/component-bind/index.js":
/***/ (function(module, exports) {

/**
 * Slice reference.
 */

var slice = [].slice;

/**
 * Bind `obj` to `fn`.
 *
 * @param {Object} obj
 * @param {Function|String} fn or string
 * @return {Function}
 * @api public
 */

module.exports = function(obj, fn){
  if ('string' == typeof fn) fn = obj[fn];
  if ('function' != typeof fn) throw new Error('bind() requires a function');
  var args = slice.call(arguments, 2);
  return function(){
    return fn.apply(obj, args.concat(slice.call(arguments)));
  }
};


/***/ }),

/***/ "./node_modules/component-emitter/index.js":
/***/ (function(module, exports, __webpack_require__) {


/**
 * Expose `Emitter`.
 */

if (true) {
  module.exports = Emitter;
}

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }

  // Remove event specific arrays for event types that no
  // one is subscribed for to avoid memory leak.
  if (callbacks.length === 0) {
    delete this._callbacks['$' + event];
  }

  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};

  var args = new Array(arguments.length - 1)
    , callbacks = this._callbacks['$' + event];

  for (var i = 1; i < arguments.length; i++) {
    args[i - 1] = arguments[i];
  }

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};


/***/ }),

/***/ "./node_modules/core-js/library/fn/array/from.js":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("./node_modules/core-js/library/modules/es6.string.iterator.js");
__webpack_require__("./node_modules/core-js/library/modules/es6.array.from.js");
module.exports = __webpack_require__("./node_modules/core-js/library/modules/_core.js").Array.from;


/***/ }),

/***/ "./node_modules/core-js/library/fn/get-iterator.js":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("./node_modules/core-js/library/modules/web.dom.iterable.js");
__webpack_require__("./node_modules/core-js/library/modules/es6.string.iterator.js");
module.exports = __webpack_require__("./node_modules/core-js/library/modules/core.get-iterator.js");


/***/ }),

/***/ "./node_modules/core-js/library/fn/is-iterable.js":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("./node_modules/core-js/library/modules/web.dom.iterable.js");
__webpack_require__("./node_modules/core-js/library/modules/es6.string.iterator.js");
module.exports = __webpack_require__("./node_modules/core-js/library/modules/core.is-iterable.js");


/***/ }),

/***/ "./node_modules/core-js/library/fn/map.js":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("./node_modules/core-js/library/modules/es6.object.to-string.js");
__webpack_require__("./node_modules/core-js/library/modules/es6.string.iterator.js");
__webpack_require__("./node_modules/core-js/library/modules/web.dom.iterable.js");
__webpack_require__("./node_modules/core-js/library/modules/es6.map.js");
__webpack_require__("./node_modules/core-js/library/modules/es7.map.to-json.js");
__webpack_require__("./node_modules/core-js/library/modules/es7.map.of.js");
__webpack_require__("./node_modules/core-js/library/modules/es7.map.from.js");
module.exports = __webpack_require__("./node_modules/core-js/library/modules/_core.js").Map;


/***/ }),

/***/ "./node_modules/core-js/library/fn/object/assign.js":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("./node_modules/core-js/library/modules/es6.object.assign.js");
module.exports = __webpack_require__("./node_modules/core-js/library/modules/_core.js").Object.assign;


/***/ }),

/***/ "./node_modules/core-js/library/fn/object/create.js":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("./node_modules/core-js/library/modules/es6.object.create.js");
var $Object = __webpack_require__("./node_modules/core-js/library/modules/_core.js").Object;
module.exports = function create(P, D) {
  return $Object.create(P, D);
};


/***/ }),

/***/ "./node_modules/core-js/library/fn/object/define-property.js":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("./node_modules/core-js/library/modules/es6.object.define-property.js");
var $Object = __webpack_require__("./node_modules/core-js/library/modules/_core.js").Object;
module.exports = function defineProperty(it, key, desc) {
  return $Object.defineProperty(it, key, desc);
};


/***/ }),

/***/ "./node_modules/core-js/library/fn/object/get-prototype-of.js":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("./node_modules/core-js/library/modules/es6.object.get-prototype-of.js");
module.exports = __webpack_require__("./node_modules/core-js/library/modules/_core.js").Object.getPrototypeOf;


/***/ }),

/***/ "./node_modules/core-js/library/fn/object/keys.js":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("./node_modules/core-js/library/modules/es6.object.keys.js");
module.exports = __webpack_require__("./node_modules/core-js/library/modules/_core.js").Object.keys;


/***/ }),

/***/ "./node_modules/core-js/library/fn/object/set-prototype-of.js":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("./node_modules/core-js/library/modules/es6.object.set-prototype-of.js");
module.exports = __webpack_require__("./node_modules/core-js/library/modules/_core.js").Object.setPrototypeOf;


/***/ }),

/***/ "./node_modules/core-js/library/fn/promise.js":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("./node_modules/core-js/library/modules/es6.object.to-string.js");
__webpack_require__("./node_modules/core-js/library/modules/es6.string.iterator.js");
__webpack_require__("./node_modules/core-js/library/modules/web.dom.iterable.js");
__webpack_require__("./node_modules/core-js/library/modules/es6.promise.js");
__webpack_require__("./node_modules/core-js/library/modules/es7.promise.finally.js");
__webpack_require__("./node_modules/core-js/library/modules/es7.promise.try.js");
module.exports = __webpack_require__("./node_modules/core-js/library/modules/_core.js").Promise;


/***/ }),

/***/ "./node_modules/core-js/library/fn/set.js":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("./node_modules/core-js/library/modules/es6.object.to-string.js");
__webpack_require__("./node_modules/core-js/library/modules/es6.string.iterator.js");
__webpack_require__("./node_modules/core-js/library/modules/web.dom.iterable.js");
__webpack_require__("./node_modules/core-js/library/modules/es6.set.js");
__webpack_require__("./node_modules/core-js/library/modules/es7.set.to-json.js");
__webpack_require__("./node_modules/core-js/library/modules/es7.set.of.js");
__webpack_require__("./node_modules/core-js/library/modules/es7.set.from.js");
module.exports = __webpack_require__("./node_modules/core-js/library/modules/_core.js").Set;


/***/ }),

/***/ "./node_modules/core-js/library/fn/symbol/index.js":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("./node_modules/core-js/library/modules/es6.symbol.js");
__webpack_require__("./node_modules/core-js/library/modules/es6.object.to-string.js");
__webpack_require__("./node_modules/core-js/library/modules/es7.symbol.async-iterator.js");
__webpack_require__("./node_modules/core-js/library/modules/es7.symbol.observable.js");
module.exports = __webpack_require__("./node_modules/core-js/library/modules/_core.js").Symbol;


/***/ }),

/***/ "./node_modules/core-js/library/fn/symbol/iterator.js":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("./node_modules/core-js/library/modules/es6.string.iterator.js");
__webpack_require__("./node_modules/core-js/library/modules/web.dom.iterable.js");
module.exports = __webpack_require__("./node_modules/core-js/library/modules/_wks-ext.js").f('iterator');


/***/ }),

/***/ "./node_modules/core-js/library/modules/_a-function.js":
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_add-to-unscopables.js":
/***/ (function(module, exports) {

module.exports = function () { /* empty */ };


/***/ }),

/***/ "./node_modules/core-js/library/modules/_an-instance.js":
/***/ (function(module, exports) {

module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_an-object.js":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("./node_modules/core-js/library/modules/_is-object.js");
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_array-from-iterable.js":
/***/ (function(module, exports, __webpack_require__) {

var forOf = __webpack_require__("./node_modules/core-js/library/modules/_for-of.js");

module.exports = function (iter, ITERATOR) {
  var result = [];
  forOf(iter, false, result.push, result, ITERATOR);
  return result;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_array-includes.js":
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__("./node_modules/core-js/library/modules/_to-iobject.js");
var toLength = __webpack_require__("./node_modules/core-js/library/modules/_to-length.js");
var toAbsoluteIndex = __webpack_require__("./node_modules/core-js/library/modules/_to-absolute-index.js");
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_array-methods.js":
/***/ (function(module, exports, __webpack_require__) {

// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx = __webpack_require__("./node_modules/core-js/library/modules/_ctx.js");
var IObject = __webpack_require__("./node_modules/core-js/library/modules/_iobject.js");
var toObject = __webpack_require__("./node_modules/core-js/library/modules/_to-object.js");
var toLength = __webpack_require__("./node_modules/core-js/library/modules/_to-length.js");
var asc = __webpack_require__("./node_modules/core-js/library/modules/_array-species-create.js");
module.exports = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || asc;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IObject(O);
    var f = ctx(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      val = self[index];
      res = f(val, index, O);
      if (TYPE) {
        if (IS_MAP) result[index] = res;   // map
        else if (res) switch (TYPE) {
          case 3: return true;             // some
          case 5: return val;              // find
          case 6: return index;            // findIndex
          case 2: result.push(val);        // filter
        } else if (IS_EVERY) return false; // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_array-species-constructor.js":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("./node_modules/core-js/library/modules/_is-object.js");
var isArray = __webpack_require__("./node_modules/core-js/library/modules/_is-array.js");
var SPECIES = __webpack_require__("./node_modules/core-js/library/modules/_wks.js")('species');

module.exports = function (original) {
  var C;
  if (isArray(original)) {
    C = original.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? Array : C;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_array-species-create.js":
/***/ (function(module, exports, __webpack_require__) {

// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = __webpack_require__("./node_modules/core-js/library/modules/_array-species-constructor.js");

module.exports = function (original, length) {
  return new (speciesConstructor(original))(length);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_classof.js":
/***/ (function(module, exports, __webpack_require__) {

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __webpack_require__("./node_modules/core-js/library/modules/_cof.js");
var TAG = __webpack_require__("./node_modules/core-js/library/modules/_wks.js")('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_cof.js":
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_collection-strong.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var dP = __webpack_require__("./node_modules/core-js/library/modules/_object-dp.js").f;
var create = __webpack_require__("./node_modules/core-js/library/modules/_object-create.js");
var redefineAll = __webpack_require__("./node_modules/core-js/library/modules/_redefine-all.js");
var ctx = __webpack_require__("./node_modules/core-js/library/modules/_ctx.js");
var anInstance = __webpack_require__("./node_modules/core-js/library/modules/_an-instance.js");
var forOf = __webpack_require__("./node_modules/core-js/library/modules/_for-of.js");
var $iterDefine = __webpack_require__("./node_modules/core-js/library/modules/_iter-define.js");
var step = __webpack_require__("./node_modules/core-js/library/modules/_iter-step.js");
var setSpecies = __webpack_require__("./node_modules/core-js/library/modules/_set-species.js");
var DESCRIPTORS = __webpack_require__("./node_modules/core-js/library/modules/_descriptors.js");
var fastKey = __webpack_require__("./node_modules/core-js/library/modules/_meta.js").fastKey;
var validate = __webpack_require__("./node_modules/core-js/library/modules/_validate-collection.js");
var SIZE = DESCRIPTORS ? '_s' : 'size';

var getEntry = function (that, key) {
  // fast case
  var index = fastKey(key);
  var entry;
  if (index !== 'F') return that._i[index];
  // frozen object case
  for (entry = that._f; entry; entry = entry.n) {
    if (entry.k == key) return entry;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;         // collection type
      that._i = create(null); // index
      that._f = undefined;    // first entry
      that._l = undefined;    // last entry
      that[SIZE] = 0;         // size
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
          entry.r = true;
          if (entry.p) entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function (key) {
        var that = validate(this, NAME);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.n;
          var prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if (prev) prev.n = next;
          if (next) next.p = prev;
          if (that._f == entry) that._f = next;
          if (that._l == entry) that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /* , that = undefined */) {
        validate(this, NAME);
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;
        while (entry = entry ? entry.n : this._f) {
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while (entry && entry.r) entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(validate(this, NAME), key);
      }
    });
    if (DESCRIPTORS) dP(C.prototype, 'size', {
      get: function () {
        return validate(this, NAME)[SIZE];
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var entry = getEntry(that, key);
    var prev, index;
    // change existing entry
    if (entry) {
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if (!that._f) that._f = entry;
      if (prev) prev.n = entry;
      that[SIZE]++;
      // add to index
      if (index !== 'F') that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function (C, NAME, IS_MAP) {
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function (iterated, kind) {
      this._t = validate(iterated, NAME); // target
      this._k = kind;                     // kind
      this._l = undefined;                // previous
    }, function () {
      var that = this;
      var kind = that._k;
      var entry = that._l;
      // revert to the last existing entry
      while (entry && entry.r) entry = entry.p;
      // get next entry
      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if (kind == 'keys') return step(0, entry.k);
      if (kind == 'values') return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_collection-to-json.js":
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var classof = __webpack_require__("./node_modules/core-js/library/modules/_classof.js");
var from = __webpack_require__("./node_modules/core-js/library/modules/_array-from-iterable.js");
module.exports = function (NAME) {
  return function toJSON() {
    if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
    return from(this);
  };
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_collection.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__("./node_modules/core-js/library/modules/_global.js");
var $export = __webpack_require__("./node_modules/core-js/library/modules/_export.js");
var meta = __webpack_require__("./node_modules/core-js/library/modules/_meta.js");
var fails = __webpack_require__("./node_modules/core-js/library/modules/_fails.js");
var hide = __webpack_require__("./node_modules/core-js/library/modules/_hide.js");
var redefineAll = __webpack_require__("./node_modules/core-js/library/modules/_redefine-all.js");
var forOf = __webpack_require__("./node_modules/core-js/library/modules/_for-of.js");
var anInstance = __webpack_require__("./node_modules/core-js/library/modules/_an-instance.js");
var isObject = __webpack_require__("./node_modules/core-js/library/modules/_is-object.js");
var setToStringTag = __webpack_require__("./node_modules/core-js/library/modules/_set-to-string-tag.js");
var dP = __webpack_require__("./node_modules/core-js/library/modules/_object-dp.js").f;
var each = __webpack_require__("./node_modules/core-js/library/modules/_array-methods.js")(0);
var DESCRIPTORS = __webpack_require__("./node_modules/core-js/library/modules/_descriptors.js");

module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};
  if (!DESCRIPTORS || typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
    new C().entries().next();
  }))) {
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    C = wrapper(function (target, iterable) {
      anInstance(target, C, NAME, '_c');
      target._c = new Base();
      if (iterable != undefined) forOf(iterable, IS_MAP, target[ADDER], target);
    });
    each('add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON'.split(','), function (KEY) {
      var IS_ADDER = KEY == 'add' || KEY == 'set';
      if (KEY in proto && !(IS_WEAK && KEY == 'clear')) hide(C.prototype, KEY, function (a, b) {
        anInstance(this, C, KEY);
        if (!IS_ADDER && IS_WEAK && !isObject(a)) return KEY == 'get' ? undefined : false;
        var result = this._c[KEY](a === 0 ? 0 : a, b);
        return IS_ADDER ? this : result;
      });
    });
    IS_WEAK || dP(C.prototype, 'size', {
      get: function () {
        return this._c.size;
      }
    });
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F, O);

  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

  return C;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_core.js":
/***/ (function(module, exports) {

var core = module.exports = { version: '2.5.3' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef


/***/ }),

/***/ "./node_modules/core-js/library/modules/_create-property.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $defineProperty = __webpack_require__("./node_modules/core-js/library/modules/_object-dp.js");
var createDesc = __webpack_require__("./node_modules/core-js/library/modules/_property-desc.js");

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));
  else object[index] = value;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_ctx.js":
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__("./node_modules/core-js/library/modules/_a-function.js");
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_defined.js":
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_descriptors.js":
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__("./node_modules/core-js/library/modules/_fails.js")(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),

/***/ "./node_modules/core-js/library/modules/_dom-create.js":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("./node_modules/core-js/library/modules/_is-object.js");
var document = __webpack_require__("./node_modules/core-js/library/modules/_global.js").document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_enum-bug-keys.js":
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');


/***/ }),

/***/ "./node_modules/core-js/library/modules/_enum-keys.js":
/***/ (function(module, exports, __webpack_require__) {

// all enumerable object keys, includes symbols
var getKeys = __webpack_require__("./node_modules/core-js/library/modules/_object-keys.js");
var gOPS = __webpack_require__("./node_modules/core-js/library/modules/_object-gops.js");
var pIE = __webpack_require__("./node_modules/core-js/library/modules/_object-pie.js");
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  } return result;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_export.js":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("./node_modules/core-js/library/modules/_global.js");
var core = __webpack_require__("./node_modules/core-js/library/modules/_core.js");
var ctx = __webpack_require__("./node_modules/core-js/library/modules/_ctx.js");
var hide = __webpack_require__("./node_modules/core-js/library/modules/_hide.js");
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var IS_WRAP = type & $export.W;
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE];
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
  var key, own, out;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if (own && key in exports) continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function (C) {
      var F = function (a, b, c) {
        if (this instanceof C) {
          switch (arguments.length) {
            case 0: return new C();
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if (IS_PROTO) {
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;


/***/ }),

/***/ "./node_modules/core-js/library/modules/_fails.js":
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_for-of.js":
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__("./node_modules/core-js/library/modules/_ctx.js");
var call = __webpack_require__("./node_modules/core-js/library/modules/_iter-call.js");
var isArrayIter = __webpack_require__("./node_modules/core-js/library/modules/_is-array-iter.js");
var anObject = __webpack_require__("./node_modules/core-js/library/modules/_an-object.js");
var toLength = __webpack_require__("./node_modules/core-js/library/modules/_to-length.js");
var getIterFn = __webpack_require__("./node_modules/core-js/library/modules/core.get-iterator-method.js");
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;


/***/ }),

/***/ "./node_modules/core-js/library/modules/_global.js":
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


/***/ }),

/***/ "./node_modules/core-js/library/modules/_has.js":
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_hide.js":
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__("./node_modules/core-js/library/modules/_object-dp.js");
var createDesc = __webpack_require__("./node_modules/core-js/library/modules/_property-desc.js");
module.exports = __webpack_require__("./node_modules/core-js/library/modules/_descriptors.js") ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_html.js":
/***/ (function(module, exports, __webpack_require__) {

var document = __webpack_require__("./node_modules/core-js/library/modules/_global.js").document;
module.exports = document && document.documentElement;


/***/ }),

/***/ "./node_modules/core-js/library/modules/_ie8-dom-define.js":
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__("./node_modules/core-js/library/modules/_descriptors.js") && !__webpack_require__("./node_modules/core-js/library/modules/_fails.js")(function () {
  return Object.defineProperty(__webpack_require__("./node_modules/core-js/library/modules/_dom-create.js")('div'), 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),

/***/ "./node_modules/core-js/library/modules/_invoke.js":
/***/ (function(module, exports) {

// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
  var un = that === undefined;
  switch (args.length) {
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return fn.apply(that, args);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_iobject.js":
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__("./node_modules/core-js/library/modules/_cof.js");
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_is-array-iter.js":
/***/ (function(module, exports, __webpack_require__) {

// check on default Array iterator
var Iterators = __webpack_require__("./node_modules/core-js/library/modules/_iterators.js");
var ITERATOR = __webpack_require__("./node_modules/core-js/library/modules/_wks.js")('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_is-array.js":
/***/ (function(module, exports, __webpack_require__) {

// 7.2.2 IsArray(argument)
var cof = __webpack_require__("./node_modules/core-js/library/modules/_cof.js");
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_is-object.js":
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_iter-call.js":
/***/ (function(module, exports, __webpack_require__) {

// call something on iterator step with safe closing on error
var anObject = __webpack_require__("./node_modules/core-js/library/modules/_an-object.js");
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_iter-create.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var create = __webpack_require__("./node_modules/core-js/library/modules/_object-create.js");
var descriptor = __webpack_require__("./node_modules/core-js/library/modules/_property-desc.js");
var setToStringTag = __webpack_require__("./node_modules/core-js/library/modules/_set-to-string-tag.js");
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__webpack_require__("./node_modules/core-js/library/modules/_hide.js")(IteratorPrototype, __webpack_require__("./node_modules/core-js/library/modules/_wks.js")('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_iter-define.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__("./node_modules/core-js/library/modules/_library.js");
var $export = __webpack_require__("./node_modules/core-js/library/modules/_export.js");
var redefine = __webpack_require__("./node_modules/core-js/library/modules/_redefine.js");
var hide = __webpack_require__("./node_modules/core-js/library/modules/_hide.js");
var has = __webpack_require__("./node_modules/core-js/library/modules/_has.js");
var Iterators = __webpack_require__("./node_modules/core-js/library/modules/_iterators.js");
var $iterCreate = __webpack_require__("./node_modules/core-js/library/modules/_iter-create.js");
var setToStringTag = __webpack_require__("./node_modules/core-js/library/modules/_set-to-string-tag.js");
var getPrototypeOf = __webpack_require__("./node_modules/core-js/library/modules/_object-gpo.js");
var ITERATOR = __webpack_require__("./node_modules/core-js/library/modules/_wks.js")('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = (!BUGGY && $native) || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && !has(IteratorPrototype, ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_iter-detect.js":
/***/ (function(module, exports, __webpack_require__) {

var ITERATOR = __webpack_require__("./node_modules/core-js/library/modules/_wks.js")('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_iter-step.js":
/***/ (function(module, exports) {

module.exports = function (done, value) {
  return { value: value, done: !!done };
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_iterators.js":
/***/ (function(module, exports) {

module.exports = {};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_library.js":
/***/ (function(module, exports) {

module.exports = true;


/***/ }),

/***/ "./node_modules/core-js/library/modules/_meta.js":
/***/ (function(module, exports, __webpack_require__) {

var META = __webpack_require__("./node_modules/core-js/library/modules/_uid.js")('meta');
var isObject = __webpack_require__("./node_modules/core-js/library/modules/_is-object.js");
var has = __webpack_require__("./node_modules/core-js/library/modules/_has.js");
var setDesc = __webpack_require__("./node_modules/core-js/library/modules/_object-dp.js").f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !__webpack_require__("./node_modules/core-js/library/modules/_fails.js")(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_microtask.js":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("./node_modules/core-js/library/modules/_global.js");
var macrotask = __webpack_require__("./node_modules/core-js/library/modules/_task.js").set;
var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = __webpack_require__("./node_modules/core-js/library/modules/_cof.js")(process) == 'process';

module.exports = function () {
  var head, last, notify;

  var flush = function () {
    var parent, fn;
    if (isNode && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (e) {
        if (head) notify();
        else last = undefined;
        throw e;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (isNode) {
    notify = function () {
      process.nextTick(flush);
    };
  // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339
  } else if (Observer && !(global.navigator && global.navigator.standalone)) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    var promise = Promise.resolve();
    notify = function () {
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function (fn) {
    var task = { fn: fn, next: undefined };
    if (last) last.next = task;
    if (!head) {
      head = task;
      notify();
    } last = task;
  };
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_new-promise-capability.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 25.4.1.5 NewPromiseCapability(C)
var aFunction = __webpack_require__("./node_modules/core-js/library/modules/_a-function.js");

function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}

module.exports.f = function (C) {
  return new PromiseCapability(C);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-assign.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 19.1.2.1 Object.assign(target, source, ...)
var getKeys = __webpack_require__("./node_modules/core-js/library/modules/_object-keys.js");
var gOPS = __webpack_require__("./node_modules/core-js/library/modules/_object-gops.js");
var pIE = __webpack_require__("./node_modules/core-js/library/modules/_object-pie.js");
var toObject = __webpack_require__("./node_modules/core-js/library/modules/_to-object.js");
var IObject = __webpack_require__("./node_modules/core-js/library/modules/_iobject.js");
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || __webpack_require__("./node_modules/core-js/library/modules/_fails.js")(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
  } return T;
} : $assign;


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-create.js":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __webpack_require__("./node_modules/core-js/library/modules/_an-object.js");
var dPs = __webpack_require__("./node_modules/core-js/library/modules/_object-dps.js");
var enumBugKeys = __webpack_require__("./node_modules/core-js/library/modules/_enum-bug-keys.js");
var IE_PROTO = __webpack_require__("./node_modules/core-js/library/modules/_shared-key.js")('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__("./node_modules/core-js/library/modules/_dom-create.js")('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  __webpack_require__("./node_modules/core-js/library/modules/_html.js").appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-dp.js":
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__("./node_modules/core-js/library/modules/_an-object.js");
var IE8_DOM_DEFINE = __webpack_require__("./node_modules/core-js/library/modules/_ie8-dom-define.js");
var toPrimitive = __webpack_require__("./node_modules/core-js/library/modules/_to-primitive.js");
var dP = Object.defineProperty;

exports.f = __webpack_require__("./node_modules/core-js/library/modules/_descriptors.js") ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-dps.js":
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__("./node_modules/core-js/library/modules/_object-dp.js");
var anObject = __webpack_require__("./node_modules/core-js/library/modules/_an-object.js");
var getKeys = __webpack_require__("./node_modules/core-js/library/modules/_object-keys.js");

module.exports = __webpack_require__("./node_modules/core-js/library/modules/_descriptors.js") ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-gopd.js":
/***/ (function(module, exports, __webpack_require__) {

var pIE = __webpack_require__("./node_modules/core-js/library/modules/_object-pie.js");
var createDesc = __webpack_require__("./node_modules/core-js/library/modules/_property-desc.js");
var toIObject = __webpack_require__("./node_modules/core-js/library/modules/_to-iobject.js");
var toPrimitive = __webpack_require__("./node_modules/core-js/library/modules/_to-primitive.js");
var has = __webpack_require__("./node_modules/core-js/library/modules/_has.js");
var IE8_DOM_DEFINE = __webpack_require__("./node_modules/core-js/library/modules/_ie8-dom-define.js");
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = __webpack_require__("./node_modules/core-js/library/modules/_descriptors.js") ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-gopn-ext.js":
/***/ (function(module, exports, __webpack_require__) {

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = __webpack_require__("./node_modules/core-js/library/modules/_to-iobject.js");
var gOPN = __webpack_require__("./node_modules/core-js/library/modules/_object-gopn.js").f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-gopn.js":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = __webpack_require__("./node_modules/core-js/library/modules/_object-keys-internal.js");
var hiddenKeys = __webpack_require__("./node_modules/core-js/library/modules/_enum-bug-keys.js").concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-gops.js":
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-gpo.js":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __webpack_require__("./node_modules/core-js/library/modules/_has.js");
var toObject = __webpack_require__("./node_modules/core-js/library/modules/_to-object.js");
var IE_PROTO = __webpack_require__("./node_modules/core-js/library/modules/_shared-key.js")('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-keys-internal.js":
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__("./node_modules/core-js/library/modules/_has.js");
var toIObject = __webpack_require__("./node_modules/core-js/library/modules/_to-iobject.js");
var arrayIndexOf = __webpack_require__("./node_modules/core-js/library/modules/_array-includes.js")(false);
var IE_PROTO = __webpack_require__("./node_modules/core-js/library/modules/_shared-key.js")('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-keys.js":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __webpack_require__("./node_modules/core-js/library/modules/_object-keys-internal.js");
var enumBugKeys = __webpack_require__("./node_modules/core-js/library/modules/_enum-bug-keys.js");

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-pie.js":
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-sap.js":
/***/ (function(module, exports, __webpack_require__) {

// most Object methods by ES6 should accept primitives
var $export = __webpack_require__("./node_modules/core-js/library/modules/_export.js");
var core = __webpack_require__("./node_modules/core-js/library/modules/_core.js");
var fails = __webpack_require__("./node_modules/core-js/library/modules/_fails.js");
module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_perform.js":
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return { e: false, v: exec() };
  } catch (e) {
    return { e: true, v: e };
  }
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_promise-resolve.js":
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__("./node_modules/core-js/library/modules/_an-object.js");
var isObject = __webpack_require__("./node_modules/core-js/library/modules/_is-object.js");
var newPromiseCapability = __webpack_require__("./node_modules/core-js/library/modules/_new-promise-capability.js");

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_property-desc.js":
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_redefine-all.js":
/***/ (function(module, exports, __webpack_require__) {

var hide = __webpack_require__("./node_modules/core-js/library/modules/_hide.js");
module.exports = function (target, src, safe) {
  for (var key in src) {
    if (safe && target[key]) target[key] = src[key];
    else hide(target, key, src[key]);
  } return target;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_redefine.js":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__("./node_modules/core-js/library/modules/_hide.js");


/***/ }),

/***/ "./node_modules/core-js/library/modules/_set-collection-from.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/proposal-setmap-offrom/
var $export = __webpack_require__("./node_modules/core-js/library/modules/_export.js");
var aFunction = __webpack_require__("./node_modules/core-js/library/modules/_a-function.js");
var ctx = __webpack_require__("./node_modules/core-js/library/modules/_ctx.js");
var forOf = __webpack_require__("./node_modules/core-js/library/modules/_for-of.js");

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { from: function from(source /* , mapFn, thisArg */) {
    var mapFn = arguments[1];
    var mapping, A, n, cb;
    aFunction(this);
    mapping = mapFn !== undefined;
    if (mapping) aFunction(mapFn);
    if (source == undefined) return new this();
    A = [];
    if (mapping) {
      n = 0;
      cb = ctx(mapFn, arguments[2], 2);
      forOf(source, false, function (nextItem) {
        A.push(cb(nextItem, n++));
      });
    } else {
      forOf(source, false, A.push, A);
    }
    return new this(A);
  } });
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_set-collection-of.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/proposal-setmap-offrom/
var $export = __webpack_require__("./node_modules/core-js/library/modules/_export.js");

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { of: function of() {
    var length = arguments.length;
    var A = new Array(length);
    while (length--) A[length] = arguments[length];
    return new this(A);
  } });
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_set-proto.js":
/***/ (function(module, exports, __webpack_require__) {

// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = __webpack_require__("./node_modules/core-js/library/modules/_is-object.js");
var anObject = __webpack_require__("./node_modules/core-js/library/modules/_an-object.js");
var check = function (O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function (test, buggy, set) {
      try {
        set = __webpack_require__("./node_modules/core-js/library/modules/_ctx.js")(Function.call, __webpack_require__("./node_modules/core-js/library/modules/_object-gopd.js").f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) { buggy = true; }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy) O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_set-species.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__("./node_modules/core-js/library/modules/_global.js");
var core = __webpack_require__("./node_modules/core-js/library/modules/_core.js");
var dP = __webpack_require__("./node_modules/core-js/library/modules/_object-dp.js");
var DESCRIPTORS = __webpack_require__("./node_modules/core-js/library/modules/_descriptors.js");
var SPECIES = __webpack_require__("./node_modules/core-js/library/modules/_wks.js")('species');

module.exports = function (KEY) {
  var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () { return this; }
  });
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_set-to-string-tag.js":
/***/ (function(module, exports, __webpack_require__) {

var def = __webpack_require__("./node_modules/core-js/library/modules/_object-dp.js").f;
var has = __webpack_require__("./node_modules/core-js/library/modules/_has.js");
var TAG = __webpack_require__("./node_modules/core-js/library/modules/_wks.js")('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_shared-key.js":
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__("./node_modules/core-js/library/modules/_shared.js")('keys');
var uid = __webpack_require__("./node_modules/core-js/library/modules/_uid.js");
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_shared.js":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("./node_modules/core-js/library/modules/_global.js");
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});
module.exports = function (key) {
  return store[key] || (store[key] = {});
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_species-constructor.js":
/***/ (function(module, exports, __webpack_require__) {

// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject = __webpack_require__("./node_modules/core-js/library/modules/_an-object.js");
var aFunction = __webpack_require__("./node_modules/core-js/library/modules/_a-function.js");
var SPECIES = __webpack_require__("./node_modules/core-js/library/modules/_wks.js")('species');
module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_string-at.js":
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__("./node_modules/core-js/library/modules/_to-integer.js");
var defined = __webpack_require__("./node_modules/core-js/library/modules/_defined.js");
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_task.js":
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__("./node_modules/core-js/library/modules/_ctx.js");
var invoke = __webpack_require__("./node_modules/core-js/library/modules/_invoke.js");
var html = __webpack_require__("./node_modules/core-js/library/modules/_html.js");
var cel = __webpack_require__("./node_modules/core-js/library/modules/_dom-create.js");
var global = __webpack_require__("./node_modules/core-js/library/modules/_global.js");
var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;
var run = function () {
  var id = +this;
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function (event) {
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (__webpack_require__("./node_modules/core-js/library/modules/_cof.js")(process) == 'process') {
    defer = function (id) {
      process.nextTick(ctx(run, id, 1));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function (id) {
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function (id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set: setTask,
  clear: clearTask
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_to-absolute-index.js":
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__("./node_modules/core-js/library/modules/_to-integer.js");
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_to-integer.js":
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_to-iobject.js":
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__("./node_modules/core-js/library/modules/_iobject.js");
var defined = __webpack_require__("./node_modules/core-js/library/modules/_defined.js");
module.exports = function (it) {
  return IObject(defined(it));
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_to-length.js":
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__("./node_modules/core-js/library/modules/_to-integer.js");
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_to-object.js":
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__("./node_modules/core-js/library/modules/_defined.js");
module.exports = function (it) {
  return Object(defined(it));
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_to-primitive.js":
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__("./node_modules/core-js/library/modules/_is-object.js");
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_uid.js":
/***/ (function(module, exports) {

var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_validate-collection.js":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("./node_modules/core-js/library/modules/_is-object.js");
module.exports = function (it, TYPE) {
  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_wks-define.js":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("./node_modules/core-js/library/modules/_global.js");
var core = __webpack_require__("./node_modules/core-js/library/modules/_core.js");
var LIBRARY = __webpack_require__("./node_modules/core-js/library/modules/_library.js");
var wksExt = __webpack_require__("./node_modules/core-js/library/modules/_wks-ext.js");
var defineProperty = __webpack_require__("./node_modules/core-js/library/modules/_object-dp.js").f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_wks-ext.js":
/***/ (function(module, exports, __webpack_require__) {

exports.f = __webpack_require__("./node_modules/core-js/library/modules/_wks.js");


/***/ }),

/***/ "./node_modules/core-js/library/modules/_wks.js":
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__("./node_modules/core-js/library/modules/_shared.js")('wks');
var uid = __webpack_require__("./node_modules/core-js/library/modules/_uid.js");
var Symbol = __webpack_require__("./node_modules/core-js/library/modules/_global.js").Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;


/***/ }),

/***/ "./node_modules/core-js/library/modules/core.get-iterator-method.js":
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__("./node_modules/core-js/library/modules/_classof.js");
var ITERATOR = __webpack_require__("./node_modules/core-js/library/modules/_wks.js")('iterator');
var Iterators = __webpack_require__("./node_modules/core-js/library/modules/_iterators.js");
module.exports = __webpack_require__("./node_modules/core-js/library/modules/_core.js").getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/core.get-iterator.js":
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__("./node_modules/core-js/library/modules/_an-object.js");
var get = __webpack_require__("./node_modules/core-js/library/modules/core.get-iterator-method.js");
module.exports = __webpack_require__("./node_modules/core-js/library/modules/_core.js").getIterator = function (it) {
  var iterFn = get(it);
  if (typeof iterFn != 'function') throw TypeError(it + ' is not iterable!');
  return anObject(iterFn.call(it));
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/core.is-iterable.js":
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__("./node_modules/core-js/library/modules/_classof.js");
var ITERATOR = __webpack_require__("./node_modules/core-js/library/modules/_wks.js")('iterator');
var Iterators = __webpack_require__("./node_modules/core-js/library/modules/_iterators.js");
module.exports = __webpack_require__("./node_modules/core-js/library/modules/_core.js").isIterable = function (it) {
  var O = Object(it);
  return O[ITERATOR] !== undefined
    || '@@iterator' in O
    // eslint-disable-next-line no-prototype-builtins
    || Iterators.hasOwnProperty(classof(O));
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.array.from.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ctx = __webpack_require__("./node_modules/core-js/library/modules/_ctx.js");
var $export = __webpack_require__("./node_modules/core-js/library/modules/_export.js");
var toObject = __webpack_require__("./node_modules/core-js/library/modules/_to-object.js");
var call = __webpack_require__("./node_modules/core-js/library/modules/_iter-call.js");
var isArrayIter = __webpack_require__("./node_modules/core-js/library/modules/_is-array-iter.js");
var toLength = __webpack_require__("./node_modules/core-js/library/modules/_to-length.js");
var createProperty = __webpack_require__("./node_modules/core-js/library/modules/_create-property.js");
var getIterFn = __webpack_require__("./node_modules/core-js/library/modules/core.get-iterator-method.js");

$export($export.S + $export.F * !__webpack_require__("./node_modules/core-js/library/modules/_iter-detect.js")(function (iter) { Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
    var O = toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = getIterFn(O);
    var length, result, step, iterator;
    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for (result = new C(length); length > index; index++) {
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});


/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.array.iterator.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var addToUnscopables = __webpack_require__("./node_modules/core-js/library/modules/_add-to-unscopables.js");
var step = __webpack_require__("./node_modules/core-js/library/modules/_iter-step.js");
var Iterators = __webpack_require__("./node_modules/core-js/library/modules/_iterators.js");
var toIObject = __webpack_require__("./node_modules/core-js/library/modules/_to-iobject.js");

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = __webpack_require__("./node_modules/core-js/library/modules/_iter-define.js")(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');


/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.map.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var strong = __webpack_require__("./node_modules/core-js/library/modules/_collection-strong.js");
var validate = __webpack_require__("./node_modules/core-js/library/modules/_validate-collection.js");
var MAP = 'Map';

// 23.1 Map Objects
module.exports = __webpack_require__("./node_modules/core-js/library/modules/_collection.js")(MAP, function (get) {
  return function Map() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key) {
    var entry = strong.getEntry(validate(this, MAP), key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value) {
    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
  }
}, strong, true);


/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.object.assign.js":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.1 Object.assign(target, source)
var $export = __webpack_require__("./node_modules/core-js/library/modules/_export.js");

$export($export.S + $export.F, 'Object', { assign: __webpack_require__("./node_modules/core-js/library/modules/_object-assign.js") });


/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.object.create.js":
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__("./node_modules/core-js/library/modules/_export.js");
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', { create: __webpack_require__("./node_modules/core-js/library/modules/_object-create.js") });


/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.object.define-property.js":
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__("./node_modules/core-js/library/modules/_export.js");
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !__webpack_require__("./node_modules/core-js/library/modules/_descriptors.js"), 'Object', { defineProperty: __webpack_require__("./node_modules/core-js/library/modules/_object-dp.js").f });


/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.object.get-prototype-of.js":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 Object.getPrototypeOf(O)
var toObject = __webpack_require__("./node_modules/core-js/library/modules/_to-object.js");
var $getPrototypeOf = __webpack_require__("./node_modules/core-js/library/modules/_object-gpo.js");

__webpack_require__("./node_modules/core-js/library/modules/_object-sap.js")('getPrototypeOf', function () {
  return function getPrototypeOf(it) {
    return $getPrototypeOf(toObject(it));
  };
});


/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.object.keys.js":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 Object.keys(O)
var toObject = __webpack_require__("./node_modules/core-js/library/modules/_to-object.js");
var $keys = __webpack_require__("./node_modules/core-js/library/modules/_object-keys.js");

__webpack_require__("./node_modules/core-js/library/modules/_object-sap.js")('keys', function () {
  return function keys(it) {
    return $keys(toObject(it));
  };
});


/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.object.set-prototype-of.js":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = __webpack_require__("./node_modules/core-js/library/modules/_export.js");
$export($export.S, 'Object', { setPrototypeOf: __webpack_require__("./node_modules/core-js/library/modules/_set-proto.js").set });


/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.object.to-string.js":
/***/ (function(module, exports) {



/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.promise.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__("./node_modules/core-js/library/modules/_library.js");
var global = __webpack_require__("./node_modules/core-js/library/modules/_global.js");
var ctx = __webpack_require__("./node_modules/core-js/library/modules/_ctx.js");
var classof = __webpack_require__("./node_modules/core-js/library/modules/_classof.js");
var $export = __webpack_require__("./node_modules/core-js/library/modules/_export.js");
var isObject = __webpack_require__("./node_modules/core-js/library/modules/_is-object.js");
var aFunction = __webpack_require__("./node_modules/core-js/library/modules/_a-function.js");
var anInstance = __webpack_require__("./node_modules/core-js/library/modules/_an-instance.js");
var forOf = __webpack_require__("./node_modules/core-js/library/modules/_for-of.js");
var speciesConstructor = __webpack_require__("./node_modules/core-js/library/modules/_species-constructor.js");
var task = __webpack_require__("./node_modules/core-js/library/modules/_task.js").set;
var microtask = __webpack_require__("./node_modules/core-js/library/modules/_microtask.js")();
var newPromiseCapabilityModule = __webpack_require__("./node_modules/core-js/library/modules/_new-promise-capability.js");
var perform = __webpack_require__("./node_modules/core-js/library/modules/_perform.js");
var promiseResolve = __webpack_require__("./node_modules/core-js/library/modules/_promise-resolve.js");
var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';
var empty = function () { /* empty */ };
var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;

var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);
    var FakePromise = (promise.constructor = {})[__webpack_require__("./node_modules/core-js/library/modules/_wks.js")('species')] = function (exec) {
      exec(empty, empty);
    };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
  } catch (e) { /* empty */ }
}();

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function (promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;
    var run = function (reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then;
      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value);
            if (domain) domain.exit();
          }
          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        reject(e);
      }
    };
    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};
var onUnhandled = function (promise) {
  task.call(global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;
    if (unhandled) {
      result = perform(function () {
        if (isNode) {
          process.emit('unhandledRejection', value, promise);
        } else if (handler = global.onunhandledrejection) {
          handler({ promise: promise, reason: value });
        } else if ((console = global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    } promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};
var isUnhandled = function (promise) {
  return promise._h !== 1 && (promise._a || promise._c).length === 0;
};
var onHandleUnhandled = function (promise) {
  task.call(global, function () {
    var handler;
    if (isNode) {
      process.emit('rejectionHandled', promise);
    } else if (handler = global.onrejectionhandled) {
      handler({ promise: promise, reason: promise._v });
    }
  });
};
var $reject = function (value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function (value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");
    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = { _w: promise, _d: false }; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({ _w: promise, _d: false }, e); // wrap
  }
};

// constructor polyfill
if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);
    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    this._c = [];             // <- awaiting reactions
    this._a = undefined;      // <- checked in isUnhandled reactions
    this._s = 0;              // <- state
    this._d = false;          // <- done
    this._v = undefined;      // <- value
    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false;          // <- notify
  };
  Internal.prototype = __webpack_require__("./node_modules/core-js/library/modules/_redefine-all.js")($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;
      this._c.push(reaction);
      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject = ctx($reject, promise, 1);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === $Promise || C === Wrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
__webpack_require__("./node_modules/core-js/library/modules/_set-to-string-tag.js")($Promise, PROMISE);
__webpack_require__("./node_modules/core-js/library/modules/_set-species.js")(PROMISE);
Wrapper = __webpack_require__("./node_modules/core-js/library/modules/_core.js")[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
  }
});
$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__("./node_modules/core-js/library/modules/_iter-detect.js")(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});


/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.set.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var strong = __webpack_require__("./node_modules/core-js/library/modules/_collection-strong.js");
var validate = __webpack_require__("./node_modules/core-js/library/modules/_validate-collection.js");
var SET = 'Set';

// 23.2 Set Objects
module.exports = __webpack_require__("./node_modules/core-js/library/modules/_collection.js")(SET, function (get) {
  return function Set() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value) {
    return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);
  }
}, strong);


/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.string.iterator.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $at = __webpack_require__("./node_modules/core-js/library/modules/_string-at.js")(true);

// 21.1.3.27 String.prototype[@@iterator]()
__webpack_require__("./node_modules/core-js/library/modules/_iter-define.js")(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});


/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.symbol.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ECMAScript 6 symbols shim
var global = __webpack_require__("./node_modules/core-js/library/modules/_global.js");
var has = __webpack_require__("./node_modules/core-js/library/modules/_has.js");
var DESCRIPTORS = __webpack_require__("./node_modules/core-js/library/modules/_descriptors.js");
var $export = __webpack_require__("./node_modules/core-js/library/modules/_export.js");
var redefine = __webpack_require__("./node_modules/core-js/library/modules/_redefine.js");
var META = __webpack_require__("./node_modules/core-js/library/modules/_meta.js").KEY;
var $fails = __webpack_require__("./node_modules/core-js/library/modules/_fails.js");
var shared = __webpack_require__("./node_modules/core-js/library/modules/_shared.js");
var setToStringTag = __webpack_require__("./node_modules/core-js/library/modules/_set-to-string-tag.js");
var uid = __webpack_require__("./node_modules/core-js/library/modules/_uid.js");
var wks = __webpack_require__("./node_modules/core-js/library/modules/_wks.js");
var wksExt = __webpack_require__("./node_modules/core-js/library/modules/_wks-ext.js");
var wksDefine = __webpack_require__("./node_modules/core-js/library/modules/_wks-define.js");
var enumKeys = __webpack_require__("./node_modules/core-js/library/modules/_enum-keys.js");
var isArray = __webpack_require__("./node_modules/core-js/library/modules/_is-array.js");
var anObject = __webpack_require__("./node_modules/core-js/library/modules/_an-object.js");
var isObject = __webpack_require__("./node_modules/core-js/library/modules/_is-object.js");
var toIObject = __webpack_require__("./node_modules/core-js/library/modules/_to-iobject.js");
var toPrimitive = __webpack_require__("./node_modules/core-js/library/modules/_to-primitive.js");
var createDesc = __webpack_require__("./node_modules/core-js/library/modules/_property-desc.js");
var _create = __webpack_require__("./node_modules/core-js/library/modules/_object-create.js");
var gOPNExt = __webpack_require__("./node_modules/core-js/library/modules/_object-gopn-ext.js");
var $GOPD = __webpack_require__("./node_modules/core-js/library/modules/_object-gopd.js");
var $DP = __webpack_require__("./node_modules/core-js/library/modules/_object-dp.js");
var $keys = __webpack_require__("./node_modules/core-js/library/modules/_object-keys.js");
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function';
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () { return dP(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  __webpack_require__("./node_modules/core-js/library/modules/_object-gopn.js").f = gOPNExt.f = $getOwnPropertyNames;
  __webpack_require__("./node_modules/core-js/library/modules/_object-pie.js").f = $propertyIsEnumerable;
  __webpack_require__("./node_modules/core-js/library/modules/_object-gops.js").f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !__webpack_require__("./node_modules/core-js/library/modules/_library.js")) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () { setter = true; },
  useSimple: function () { setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    if (!isArray(replacer)) replacer = function (key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__("./node_modules/core-js/library/modules/_hide.js")($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);


/***/ }),

/***/ "./node_modules/core-js/library/modules/es7.map.from.js":
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-map.from
__webpack_require__("./node_modules/core-js/library/modules/_set-collection-from.js")('Map');


/***/ }),

/***/ "./node_modules/core-js/library/modules/es7.map.of.js":
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-map.of
__webpack_require__("./node_modules/core-js/library/modules/_set-collection-of.js")('Map');


/***/ }),

/***/ "./node_modules/core-js/library/modules/es7.map.to-json.js":
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = __webpack_require__("./node_modules/core-js/library/modules/_export.js");

$export($export.P + $export.R, 'Map', { toJSON: __webpack_require__("./node_modules/core-js/library/modules/_collection-to-json.js")('Map') });


/***/ }),

/***/ "./node_modules/core-js/library/modules/es7.promise.finally.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// https://github.com/tc39/proposal-promise-finally

var $export = __webpack_require__("./node_modules/core-js/library/modules/_export.js");
var core = __webpack_require__("./node_modules/core-js/library/modules/_core.js");
var global = __webpack_require__("./node_modules/core-js/library/modules/_global.js");
var speciesConstructor = __webpack_require__("./node_modules/core-js/library/modules/_species-constructor.js");
var promiseResolve = __webpack_require__("./node_modules/core-js/library/modules/_promise-resolve.js");

$export($export.P + $export.R, 'Promise', { 'finally': function (onFinally) {
  var C = speciesConstructor(this, core.Promise || global.Promise);
  var isFunction = typeof onFinally == 'function';
  return this.then(
    isFunction ? function (x) {
      return promiseResolve(C, onFinally()).then(function () { return x; });
    } : onFinally,
    isFunction ? function (e) {
      return promiseResolve(C, onFinally()).then(function () { throw e; });
    } : onFinally
  );
} });


/***/ }),

/***/ "./node_modules/core-js/library/modules/es7.promise.try.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/proposal-promise-try
var $export = __webpack_require__("./node_modules/core-js/library/modules/_export.js");
var newPromiseCapability = __webpack_require__("./node_modules/core-js/library/modules/_new-promise-capability.js");
var perform = __webpack_require__("./node_modules/core-js/library/modules/_perform.js");

$export($export.S, 'Promise', { 'try': function (callbackfn) {
  var promiseCapability = newPromiseCapability.f(this);
  var result = perform(callbackfn);
  (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
  return promiseCapability.promise;
} });


/***/ }),

/***/ "./node_modules/core-js/library/modules/es7.set.from.js":
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-set.from
__webpack_require__("./node_modules/core-js/library/modules/_set-collection-from.js")('Set');


/***/ }),

/***/ "./node_modules/core-js/library/modules/es7.set.of.js":
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-set.of
__webpack_require__("./node_modules/core-js/library/modules/_set-collection-of.js")('Set');


/***/ }),

/***/ "./node_modules/core-js/library/modules/es7.set.to-json.js":
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = __webpack_require__("./node_modules/core-js/library/modules/_export.js");

$export($export.P + $export.R, 'Set', { toJSON: __webpack_require__("./node_modules/core-js/library/modules/_collection-to-json.js")('Set') });


/***/ }),

/***/ "./node_modules/core-js/library/modules/es7.symbol.async-iterator.js":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("./node_modules/core-js/library/modules/_wks-define.js")('asyncIterator');


/***/ }),

/***/ "./node_modules/core-js/library/modules/es7.symbol.observable.js":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("./node_modules/core-js/library/modules/_wks-define.js")('observable');


/***/ }),

/***/ "./node_modules/core-js/library/modules/web.dom.iterable.js":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("./node_modules/core-js/library/modules/es6.array.iterator.js");
var global = __webpack_require__("./node_modules/core-js/library/modules/_global.js");
var hide = __webpack_require__("./node_modules/core-js/library/modules/_hide.js");
var Iterators = __webpack_require__("./node_modules/core-js/library/modules/_iterators.js");
var TO_STRING_TAG = __webpack_require__("./node_modules/core-js/library/modules/_wks.js")('toStringTag');

var DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +
  'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +
  'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +
  'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +
  'TextTrackList,TouchList').split(',');

for (var i = 0; i < DOMIterables.length; i++) {
  var NAME = DOMIterables[i];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
  Iterators[NAME] = Iterators.Array;
}


/***/ }),

/***/ "./node_modules/css-vendor/lib/camelize.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports['default'] = camelize;
var regExp = /[-\s]+(.)?/g;

/**
 * Convert dash separated strings to camel cased.
 *
 * @param {String} str
 * @return {String}
 */
function camelize(str) {
  return str.replace(regExp, toUpper);
}

function toUpper(match, c) {
  return c ? c.toUpperCase() : '';
}

/***/ }),

/***/ "./node_modules/css-vendor/lib/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.supportedValue = exports.supportedProperty = exports.prefix = undefined;

var _prefix = __webpack_require__("./node_modules/css-vendor/lib/prefix.js");

var _prefix2 = _interopRequireDefault(_prefix);

var _supportedProperty = __webpack_require__("./node_modules/css-vendor/lib/supported-property.js");

var _supportedProperty2 = _interopRequireDefault(_supportedProperty);

var _supportedValue = __webpack_require__("./node_modules/css-vendor/lib/supported-value.js");

var _supportedValue2 = _interopRequireDefault(_supportedValue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

exports['default'] = {
  prefix: _prefix2['default'],
  supportedProperty: _supportedProperty2['default'],
  supportedValue: _supportedValue2['default']
}; /**
    * CSS Vendor prefix detection and property feature testing.
    *
    * @copyright Oleg Slobodskoi 2015
    * @website https://github.com/jsstyles/css-vendor
    * @license MIT
    */

exports.prefix = _prefix2['default'];
exports.supportedProperty = _supportedProperty2['default'];
exports.supportedValue = _supportedValue2['default'];

/***/ }),

/***/ "./node_modules/css-vendor/lib/prefix.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _isInBrowser = __webpack_require__("./node_modules/is-in-browser/dist/module.js");

var _isInBrowser2 = _interopRequireDefault(_isInBrowser);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var js = ''; /**
              * Export javascript style and css style vendor prefixes.
              * Based on "transform" support test.
              */

var css = '';

// We should not do anything if required serverside.
if (_isInBrowser2['default']) {
  // Order matters. We need to check Webkit the last one because
  // other vendors use to add Webkit prefixes to some properties
  var jsCssMap = {
    Moz: '-moz-',
    // IE did it wrong again ...
    ms: '-ms-',
    O: '-o-',
    Webkit: '-webkit-'
  };
  var style = document.createElement('p').style;
  var testProp = 'Transform';

  for (var key in jsCssMap) {
    if (key + testProp in style) {
      js = key;
      css = jsCssMap[key];
      break;
    }
  }
}

/**
 * Vendor prefix string for the current browser.
 *
 * @type {{js: String, css: String}}
 * @api public
 */
exports['default'] = { js: js, css: css };

/***/ }),

/***/ "./node_modules/css-vendor/lib/supported-property.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports['default'] = supportedProperty;

var _isInBrowser = __webpack_require__("./node_modules/is-in-browser/dist/module.js");

var _isInBrowser2 = _interopRequireDefault(_isInBrowser);

var _prefix = __webpack_require__("./node_modules/css-vendor/lib/prefix.js");

var _prefix2 = _interopRequireDefault(_prefix);

var _camelize = __webpack_require__("./node_modules/css-vendor/lib/camelize.js");

var _camelize2 = _interopRequireDefault(_camelize);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var el = void 0;
var cache = {};

if (_isInBrowser2['default']) {
  el = document.createElement('p');

  /**
   * We test every property on vendor prefix requirement.
   * Once tested, result is cached. It gives us up to 70% perf boost.
   * http://jsperf.com/element-style-object-access-vs-plain-object
   *
   * Prefill cache with known css properties to reduce amount of
   * properties we need to feature test at runtime.
   * http://davidwalsh.name/vendor-prefix
   */
  var computed = window.getComputedStyle(document.documentElement, '');
  for (var key in computed) {
    if (!isNaN(key)) cache[computed[key]] = computed[key];
  }
}

/**
 * Test if a property is supported, returns supported property with vendor
 * prefix if required. Returns `false` if not supported.
 *
 * @param {String} prop dash separated
 * @return {String|Boolean}
 * @api public
 */
function supportedProperty(prop) {
  // For server-side rendering.
  if (!el) return prop;

  // We have not tested this prop yet, lets do the test.
  if (cache[prop] != null) return cache[prop];

  // Camelization is required because we can't test using
  // css syntax for e.g. in FF.
  // Test if property is supported as it is.
  if ((0, _camelize2['default'])(prop) in el.style) {
    cache[prop] = prop;
  }
  // Test if property is supported with vendor prefix.
  else if (_prefix2['default'].js + (0, _camelize2['default'])('-' + prop) in el.style) {
      cache[prop] = _prefix2['default'].css + prop;
    } else {
      cache[prop] = false;
    }

  return cache[prop];
}

/***/ }),

/***/ "./node_modules/css-vendor/lib/supported-value.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports['default'] = supportedValue;

var _isInBrowser = __webpack_require__("./node_modules/is-in-browser/dist/module.js");

var _isInBrowser2 = _interopRequireDefault(_isInBrowser);

var _prefix = __webpack_require__("./node_modules/css-vendor/lib/prefix.js");

var _prefix2 = _interopRequireDefault(_prefix);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var cache = {};
var el = void 0;

if (_isInBrowser2['default']) el = document.createElement('p');

/**
 * Returns prefixed value if needed. Returns `false` if value is not supported.
 *
 * @param {String} property
 * @param {String} value
 * @return {String|Boolean}
 * @api public
 */
function supportedValue(property, value) {
  // For server-side rendering.
  if (!el) return value;

  // It is a string or a number as a string like '1'.
  // We want only prefixable values here.
  if (typeof value !== 'string' || !isNaN(parseInt(value, 10))) return value;

  var cacheKey = property + value;

  if (cache[cacheKey] != null) return cache[cacheKey];

  // IE can even throw an error in some cases, for e.g. style.content = 'bar'
  try {
    // Test value as it is.
    el.style[property] = value;
  } catch (err) {
    cache[cacheKey] = false;
    return false;
  }

  // Value is supported as it is.
  if (el.style[property] !== '') {
    cache[cacheKey] = value;
  } else {
    // Test value with vendor prefix.
    value = _prefix2['default'].css + value;

    // Hardcode test to convert "flex" to "-ms-flexbox" for IE10.
    if (value === '-ms-flex') value = '-ms-flexbox';

    el.style[property] = value;

    // Value is supported with vendor prefix.
    if (el.style[property] !== '') cache[cacheKey] = value;
  }

  if (!cache[cacheKey]) cache[cacheKey] = false;

  // Reset style value.
  el.style[property] = '';

  return cache[cacheKey];
}

/***/ }),

/***/ "./node_modules/debug/src/browser.js":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __webpack_require__("./node_modules/debug/src/debug.js");
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/debug/src/debug.js":
/***/ (function(module, exports, __webpack_require__) {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = __webpack_require__("./node_modules/ms/index.js");

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  return debug;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}


/***/ }),

/***/ "./node_modules/engine.io-client/lib/globalThis.browser.js":
/***/ (function(module, exports) {

module.exports = (() => {
  if (typeof self !== "undefined") {
    return self;
  } else if (typeof window !== "undefined") {
    return window;
  } else {
    return Function("return this")();
  }
})();


/***/ }),

/***/ "./node_modules/engine.io-client/lib/index.js":
/***/ (function(module, exports, __webpack_require__) {

const Socket = __webpack_require__("./node_modules/engine.io-client/lib/socket.js");

module.exports = (uri, opts) => new Socket(uri, opts);

/**
 * Expose deps for legacy compatibility
 * and standalone browser access.
 */

module.exports.Socket = Socket;
module.exports.protocol = Socket.protocol; // this is an int
module.exports.Transport = __webpack_require__("./node_modules/engine.io-client/lib/transport.js");
module.exports.transports = __webpack_require__("./node_modules/engine.io-client/lib/transports/index.js");
module.exports.parser = __webpack_require__("./node_modules/engine.io-parser/lib/index.js");


/***/ }),

/***/ "./node_modules/engine.io-client/lib/socket.js":
/***/ (function(module, exports, __webpack_require__) {

const transports = __webpack_require__("./node_modules/engine.io-client/lib/transports/index.js");
const Emitter = __webpack_require__("./node_modules/component-emitter/index.js");
const debug = __webpack_require__("./node_modules/engine.io-client/node_modules/debug/src/browser.js")("engine.io-client:socket");
const parser = __webpack_require__("./node_modules/engine.io-parser/lib/index.js");
const parseuri = __webpack_require__("./node_modules/parseuri/index.js");
const parseqs = __webpack_require__("./node_modules/parseqs/index.js");

class Socket extends Emitter {
  /**
   * Socket constructor.
   *
   * @param {String|Object} uri or options
   * @param {Object} options
   * @api public
   */
  constructor(uri, opts = {}) {
    super();

    if (uri && "object" === typeof uri) {
      opts = uri;
      uri = null;
    }

    if (uri) {
      uri = parseuri(uri);
      opts.hostname = uri.host;
      opts.secure = uri.protocol === "https" || uri.protocol === "wss";
      opts.port = uri.port;
      if (uri.query) opts.query = uri.query;
    } else if (opts.host) {
      opts.hostname = parseuri(opts.host).host;
    }

    this.secure =
      null != opts.secure
        ? opts.secure
        : typeof location !== "undefined" && "https:" === location.protocol;

    if (opts.hostname && !opts.port) {
      // if no port is specified manually, use the protocol default
      opts.port = this.secure ? "443" : "80";
    }

    this.hostname =
      opts.hostname ||
      (typeof location !== "undefined" ? location.hostname : "localhost");
    this.port =
      opts.port ||
      (typeof location !== "undefined" && location.port
        ? location.port
        : this.secure
        ? 443
        : 80);

    this.transports = opts.transports || ["polling", "websocket"];
    this.readyState = "";
    this.writeBuffer = [];
    this.prevBufferLen = 0;

    this.opts = Object.assign(
      {
        path: "/engine.io",
        agent: false,
        withCredentials: false,
        upgrade: true,
        jsonp: true,
        timestampParam: "t",
        policyPort: 843,
        rememberUpgrade: false,
        rejectUnauthorized: true,
        perMessageDeflate: {
          threshold: 1024
        },
        transportOptions: {}
      },
      opts
    );

    this.opts.path = this.opts.path.replace(/\/$/, "") + "/";

    if (typeof this.opts.query === "string") {
      this.opts.query = parseqs.decode(this.opts.query);
    }

    // set on handshake
    this.id = null;
    this.upgrades = null;
    this.pingInterval = null;
    this.pingTimeout = null;

    // set on heartbeat
    this.pingTimeoutTimer = null;

    this.open();
  }

  /**
   * Creates transport of the given type.
   *
   * @param {String} transport name
   * @return {Transport}
   * @api private
   */
  createTransport(name) {
    debug('creating transport "%s"', name);
    const query = clone(this.opts.query);

    // append engine.io protocol identifier
    query.EIO = parser.protocol;

    // transport name
    query.transport = name;

    // session id if we already have one
    if (this.id) query.sid = this.id;

    const opts = Object.assign(
      {},
      this.opts.transportOptions[name],
      this.opts,
      {
        query,
        socket: this,
        hostname: this.hostname,
        secure: this.secure,
        port: this.port
      }
    );

    debug("options: %j", opts);

    return new transports[name](opts);
  }

  /**
   * Initializes transport to use and starts probe.
   *
   * @api private
   */
  open() {
    let transport;
    if (
      this.opts.rememberUpgrade &&
      Socket.priorWebsocketSuccess &&
      this.transports.indexOf("websocket") !== -1
    ) {
      transport = "websocket";
    } else if (0 === this.transports.length) {
      // Emit error on next tick so it can be listened to
      const self = this;
      setTimeout(function() {
        self.emit("error", "No transports available");
      }, 0);
      return;
    } else {
      transport = this.transports[0];
    }
    this.readyState = "opening";

    // Retry with the next transport if the transport is disabled (jsonp: false)
    try {
      transport = this.createTransport(transport);
    } catch (e) {
      debug("error while creating transport: %s", e);
      this.transports.shift();
      this.open();
      return;
    }

    transport.open();
    this.setTransport(transport);
  }

  /**
   * Sets the current transport. Disables the existing one (if any).
   *
   * @api private
   */
  setTransport(transport) {
    debug("setting transport %s", transport.name);
    const self = this;

    if (this.transport) {
      debug("clearing existing transport %s", this.transport.name);
      this.transport.removeAllListeners();
    }

    // set up transport
    this.transport = transport;

    // set up transport listeners
    transport
      .on("drain", function() {
        self.onDrain();
      })
      .on("packet", function(packet) {
        self.onPacket(packet);
      })
      .on("error", function(e) {
        self.onError(e);
      })
      .on("close", function() {
        self.onClose("transport close");
      });
  }

  /**
   * Probes a transport.
   *
   * @param {String} transport name
   * @api private
   */
  probe(name) {
    debug('probing transport "%s"', name);
    let transport = this.createTransport(name, { probe: 1 });
    let failed = false;
    const self = this;

    Socket.priorWebsocketSuccess = false;

    function onTransportOpen() {
      if (self.onlyBinaryUpgrades) {
        const upgradeLosesBinary =
          !this.supportsBinary && self.transport.supportsBinary;
        failed = failed || upgradeLosesBinary;
      }
      if (failed) return;

      debug('probe transport "%s" opened', name);
      transport.send([{ type: "ping", data: "probe" }]);
      transport.once("packet", function(msg) {
        if (failed) return;
        if ("pong" === msg.type && "probe" === msg.data) {
          debug('probe transport "%s" pong', name);
          self.upgrading = true;
          self.emit("upgrading", transport);
          if (!transport) return;
          Socket.priorWebsocketSuccess = "websocket" === transport.name;

          debug('pausing current transport "%s"', self.transport.name);
          self.transport.pause(function() {
            if (failed) return;
            if ("closed" === self.readyState) return;
            debug("changing transport and sending upgrade packet");

            cleanup();

            self.setTransport(transport);
            transport.send([{ type: "upgrade" }]);
            self.emit("upgrade", transport);
            transport = null;
            self.upgrading = false;
            self.flush();
          });
        } else {
          debug('probe transport "%s" failed', name);
          const err = new Error("probe error");
          err.transport = transport.name;
          self.emit("upgradeError", err);
        }
      });
    }

    function freezeTransport() {
      if (failed) return;

      // Any callback called by transport should be ignored since now
      failed = true;

      cleanup();

      transport.close();
      transport = null;
    }

    // Handle any error that happens while probing
    function onerror(err) {
      const error = new Error("probe error: " + err);
      error.transport = transport.name;

      freezeTransport();

      debug('probe transport "%s" failed because of error: %s', name, err);

      self.emit("upgradeError", error);
    }

    function onTransportClose() {
      onerror("transport closed");
    }

    // When the socket is closed while we're probing
    function onclose() {
      onerror("socket closed");
    }

    // When the socket is upgraded while we're probing
    function onupgrade(to) {
      if (transport && to.name !== transport.name) {
        debug('"%s" works - aborting "%s"', to.name, transport.name);
        freezeTransport();
      }
    }

    // Remove all listeners on the transport and on self
    function cleanup() {
      transport.removeListener("open", onTransportOpen);
      transport.removeListener("error", onerror);
      transport.removeListener("close", onTransportClose);
      self.removeListener("close", onclose);
      self.removeListener("upgrading", onupgrade);
    }

    transport.once("open", onTransportOpen);
    transport.once("error", onerror);
    transport.once("close", onTransportClose);

    this.once("close", onclose);
    this.once("upgrading", onupgrade);

    transport.open();
  }

  /**
   * Called when connection is deemed open.
   *
   * @api public
   */
  onOpen() {
    debug("socket open");
    this.readyState = "open";
    Socket.priorWebsocketSuccess = "websocket" === this.transport.name;
    this.emit("open");
    this.flush();

    // we check for `readyState` in case an `open`
    // listener already closed the socket
    if (
      "open" === this.readyState &&
      this.opts.upgrade &&
      this.transport.pause
    ) {
      debug("starting upgrade probes");
      let i = 0;
      const l = this.upgrades.length;
      for (; i < l; i++) {
        this.probe(this.upgrades[i]);
      }
    }
  }

  /**
   * Handles a packet.
   *
   * @api private
   */
  onPacket(packet) {
    if (
      "opening" === this.readyState ||
      "open" === this.readyState ||
      "closing" === this.readyState
    ) {
      debug('socket receive: type "%s", data "%s"', packet.type, packet.data);

      this.emit("packet", packet);

      // Socket is live - any packet counts
      this.emit("heartbeat");

      switch (packet.type) {
        case "open":
          this.onHandshake(JSON.parse(packet.data));
          break;

        case "ping":
          this.resetPingTimeout();
          this.sendPacket("pong");
          this.emit("pong");
          break;

        case "error":
          const err = new Error("server error");
          err.code = packet.data;
          this.onError(err);
          break;

        case "message":
          this.emit("data", packet.data);
          this.emit("message", packet.data);
          break;
      }
    } else {
      debug('packet received with socket readyState "%s"', this.readyState);
    }
  }

  /**
   * Called upon handshake completion.
   *
   * @param {Object} handshake obj
   * @api private
   */
  onHandshake(data) {
    this.emit("handshake", data);
    this.id = data.sid;
    this.transport.query.sid = data.sid;
    this.upgrades = this.filterUpgrades(data.upgrades);
    this.pingInterval = data.pingInterval;
    this.pingTimeout = data.pingTimeout;
    this.onOpen();
    // In case open handler closes socket
    if ("closed" === this.readyState) return;
    this.resetPingTimeout();
  }

  /**
   * Sets and resets ping timeout timer based on server pings.
   *
   * @api private
   */
  resetPingTimeout() {
    clearTimeout(this.pingTimeoutTimer);
    this.pingTimeoutTimer = setTimeout(() => {
      this.onClose("ping timeout");
    }, this.pingInterval + this.pingTimeout);
  }

  /**
   * Called on `drain` event
   *
   * @api private
   */
  onDrain() {
    this.writeBuffer.splice(0, this.prevBufferLen);

    // setting prevBufferLen = 0 is very important
    // for example, when upgrading, upgrade packet is sent over,
    // and a nonzero prevBufferLen could cause problems on `drain`
    this.prevBufferLen = 0;

    if (0 === this.writeBuffer.length) {
      this.emit("drain");
    } else {
      this.flush();
    }
  }

  /**
   * Flush write buffers.
   *
   * @api private
   */
  flush() {
    if (
      "closed" !== this.readyState &&
      this.transport.writable &&
      !this.upgrading &&
      this.writeBuffer.length
    ) {
      debug("flushing %d packets in socket", this.writeBuffer.length);
      this.transport.send(this.writeBuffer);
      // keep track of current length of writeBuffer
      // splice writeBuffer and callbackBuffer on `drain`
      this.prevBufferLen = this.writeBuffer.length;
      this.emit("flush");
    }
  }

  /**
   * Sends a message.
   *
   * @param {String} message.
   * @param {Function} callback function.
   * @param {Object} options.
   * @return {Socket} for chaining.
   * @api public
   */
  write(msg, options, fn) {
    this.sendPacket("message", msg, options, fn);
    return this;
  }

  send(msg, options, fn) {
    this.sendPacket("message", msg, options, fn);
    return this;
  }

  /**
   * Sends a packet.
   *
   * @param {String} packet type.
   * @param {String} data.
   * @param {Object} options.
   * @param {Function} callback function.
   * @api private
   */
  sendPacket(type, data, options, fn) {
    if ("function" === typeof data) {
      fn = data;
      data = undefined;
    }

    if ("function" === typeof options) {
      fn = options;
      options = null;
    }

    if ("closing" === this.readyState || "closed" === this.readyState) {
      return;
    }

    options = options || {};
    options.compress = false !== options.compress;

    const packet = {
      type: type,
      data: data,
      options: options
    };
    this.emit("packetCreate", packet);
    this.writeBuffer.push(packet);
    if (fn) this.once("flush", fn);
    this.flush();
  }

  /**
   * Closes the connection.
   *
   * @api private
   */
  close() {
    const self = this;

    if ("opening" === this.readyState || "open" === this.readyState) {
      this.readyState = "closing";

      if (this.writeBuffer.length) {
        this.once("drain", function() {
          if (this.upgrading) {
            waitForUpgrade();
          } else {
            close();
          }
        });
      } else if (this.upgrading) {
        waitForUpgrade();
      } else {
        close();
      }
    }

    function close() {
      self.onClose("forced close");
      debug("socket closing - telling transport to close");
      self.transport.close();
    }

    function cleanupAndClose() {
      self.removeListener("upgrade", cleanupAndClose);
      self.removeListener("upgradeError", cleanupAndClose);
      close();
    }

    function waitForUpgrade() {
      // wait for upgrade to finish since we can't send packets while pausing a transport
      self.once("upgrade", cleanupAndClose);
      self.once("upgradeError", cleanupAndClose);
    }

    return this;
  }

  /**
   * Called upon transport error
   *
   * @api private
   */
  onError(err) {
    debug("socket error %j", err);
    Socket.priorWebsocketSuccess = false;
    this.emit("error", err);
    this.onClose("transport error", err);
  }

  /**
   * Called upon transport close.
   *
   * @api private
   */
  onClose(reason, desc) {
    if (
      "opening" === this.readyState ||
      "open" === this.readyState ||
      "closing" === this.readyState
    ) {
      debug('socket close with reason: "%s"', reason);
      const self = this;

      // clear timers
      clearTimeout(this.pingIntervalTimer);
      clearTimeout(this.pingTimeoutTimer);

      // stop event from firing again for transport
      this.transport.removeAllListeners("close");

      // ensure transport won't stay open
      this.transport.close();

      // ignore further transport communication
      this.transport.removeAllListeners();

      // set ready state
      this.readyState = "closed";

      // clear session id
      this.id = null;

      // emit close event
      this.emit("close", reason, desc);

      // clean buffers after, so users can still
      // grab the buffers on `close` event
      self.writeBuffer = [];
      self.prevBufferLen = 0;
    }
  }

  /**
   * Filters upgrades, returning only those matching client transports.
   *
   * @param {Array} server upgrades
   * @api private
   *
   */
  filterUpgrades(upgrades) {
    const filteredUpgrades = [];
    let i = 0;
    const j = upgrades.length;
    for (; i < j; i++) {
      if (~this.transports.indexOf(upgrades[i]))
        filteredUpgrades.push(upgrades[i]);
    }
    return filteredUpgrades;
  }
}

Socket.priorWebsocketSuccess = false;

/**
 * Protocol version.
 *
 * @api public
 */

Socket.protocol = parser.protocol; // this is an int

function clone(obj) {
  const o = {};
  for (let i in obj) {
    if (obj.hasOwnProperty(i)) {
      o[i] = obj[i];
    }
  }
  return o;
}

module.exports = Socket;


/***/ }),

/***/ "./node_modules/engine.io-client/lib/transport.js":
/***/ (function(module, exports, __webpack_require__) {

const parser = __webpack_require__("./node_modules/engine.io-parser/lib/index.js");
const Emitter = __webpack_require__("./node_modules/component-emitter/index.js");

class Transport extends Emitter {
  /**
   * Transport abstract constructor.
   *
   * @param {Object} options.
   * @api private
   */
  constructor(opts) {
    super();

    this.opts = opts;
    this.query = opts.query;
    this.readyState = "";
    this.socket = opts.socket;
  }

  /**
   * Emits an error.
   *
   * @param {String} str
   * @return {Transport} for chaining
   * @api public
   */
  onError(msg, desc) {
    const err = new Error(msg);
    err.type = "TransportError";
    err.description = desc;
    this.emit("error", err);
    return this;
  }

  /**
   * Opens the transport.
   *
   * @api public
   */
  open() {
    if ("closed" === this.readyState || "" === this.readyState) {
      this.readyState = "opening";
      this.doOpen();
    }

    return this;
  }

  /**
   * Closes the transport.
   *
   * @api private
   */
  close() {
    if ("opening" === this.readyState || "open" === this.readyState) {
      this.doClose();
      this.onClose();
    }

    return this;
  }

  /**
   * Sends multiple packets.
   *
   * @param {Array} packets
   * @api private
   */
  send(packets) {
    if ("open" === this.readyState) {
      this.write(packets);
    } else {
      throw new Error("Transport not open");
    }
  }

  /**
   * Called upon open
   *
   * @api private
   */
  onOpen() {
    this.readyState = "open";
    this.writable = true;
    this.emit("open");
  }

  /**
   * Called with data.
   *
   * @param {String} data
   * @api private
   */
  onData(data) {
    const packet = parser.decodePacket(data, this.socket.binaryType);
    this.onPacket(packet);
  }

  /**
   * Called with a decoded packet.
   */
  onPacket(packet) {
    this.emit("packet", packet);
  }

  /**
   * Called upon close.
   *
   * @api private
   */
  onClose() {
    this.readyState = "closed";
    this.emit("close");
  }
}

module.exports = Transport;


/***/ }),

/***/ "./node_modules/engine.io-client/lib/transports/index.js":
/***/ (function(module, exports, __webpack_require__) {

const XMLHttpRequest = __webpack_require__("./node_modules/engine.io-client/lib/xmlhttprequest.js");
const XHR = __webpack_require__("./node_modules/engine.io-client/lib/transports/polling-xhr.js");
const JSONP = __webpack_require__("./node_modules/engine.io-client/lib/transports/polling-jsonp.js");
const websocket = __webpack_require__("./node_modules/engine.io-client/lib/transports/websocket.js");

exports.polling = polling;
exports.websocket = websocket;

/**
 * Polling transport polymorphic constructor.
 * Decides on xhr vs jsonp based on feature detection.
 *
 * @api private
 */

function polling(opts) {
  let xhr;
  let xd = false;
  let xs = false;
  const jsonp = false !== opts.jsonp;

  if (typeof location !== "undefined") {
    const isSSL = "https:" === location.protocol;
    let port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    xd = opts.hostname !== location.hostname || port !== opts.port;
    xs = opts.secure !== isSSL;
  }

  opts.xdomain = xd;
  opts.xscheme = xs;
  xhr = new XMLHttpRequest(opts);

  if ("open" in xhr && !opts.forceJSONP) {
    return new XHR(opts);
  } else {
    if (!jsonp) throw new Error("JSONP disabled");
    return new JSONP(opts);
  }
}


/***/ }),

/***/ "./node_modules/engine.io-client/lib/transports/polling-jsonp.js":
/***/ (function(module, exports, __webpack_require__) {

const Polling = __webpack_require__("./node_modules/engine.io-client/lib/transports/polling.js");
const globalThis = __webpack_require__("./node_modules/engine.io-client/lib/globalThis.browser.js");

const rNewline = /\n/g;
const rEscapedNewline = /\\n/g;

/**
 * Global JSONP callbacks.
 */

let callbacks;

/**
 * Noop.
 */

function empty() {}

class JSONPPolling extends Polling {
  /**
   * JSONP Polling constructor.
   *
   * @param {Object} opts.
   * @api public
   */
  constructor(opts) {
    super(opts);

    this.query = this.query || {};

    // define global callbacks array if not present
    // we do this here (lazily) to avoid unneeded global pollution
    if (!callbacks) {
      // we need to consider multiple engines in the same page
      callbacks = globalThis.___eio = globalThis.___eio || [];
    }

    // callback identifier
    this.index = callbacks.length;

    // add callback to jsonp global
    const self = this;
    callbacks.push(function(msg) {
      self.onData(msg);
    });

    // append to query string
    this.query.j = this.index;

    // prevent spurious errors from being emitted when the window is unloaded
    if (typeof addEventListener === "function") {
      addEventListener(
        "beforeunload",
        function() {
          if (self.script) self.script.onerror = empty;
        },
        false
      );
    }
  }

  /**
   * JSONP only supports binary as base64 encoded strings
   */
  get supportsBinary() {
    return false;
  }

  /**
   * Closes the socket.
   *
   * @api private
   */
  doClose() {
    if (this.script) {
      this.script.parentNode.removeChild(this.script);
      this.script = null;
    }

    if (this.form) {
      this.form.parentNode.removeChild(this.form);
      this.form = null;
      this.iframe = null;
    }

    super.doClose();
  }

  /**
   * Starts a poll cycle.
   *
   * @api private
   */
  doPoll() {
    const self = this;
    const script = document.createElement("script");

    if (this.script) {
      this.script.parentNode.removeChild(this.script);
      this.script = null;
    }

    script.async = true;
    script.src = this.uri();
    script.onerror = function(e) {
      self.onError("jsonp poll error", e);
    };

    const insertAt = document.getElementsByTagName("script")[0];
    if (insertAt) {
      insertAt.parentNode.insertBefore(script, insertAt);
    } else {
      (document.head || document.body).appendChild(script);
    }
    this.script = script;

    const isUAgecko =
      "undefined" !== typeof navigator && /gecko/i.test(navigator.userAgent);

    if (isUAgecko) {
      setTimeout(function() {
        const iframe = document.createElement("iframe");
        document.body.appendChild(iframe);
        document.body.removeChild(iframe);
      }, 100);
    }
  }

  /**
   * Writes with a hidden iframe.
   *
   * @param {String} data to send
   * @param {Function} called upon flush.
   * @api private
   */
  doWrite(data, fn) {
    const self = this;
    let iframe;

    if (!this.form) {
      const form = document.createElement("form");
      const area = document.createElement("textarea");
      const id = (this.iframeId = "eio_iframe_" + this.index);

      form.className = "socketio";
      form.style.position = "absolute";
      form.style.top = "-1000px";
      form.style.left = "-1000px";
      form.target = id;
      form.method = "POST";
      form.setAttribute("accept-charset", "utf-8");
      area.name = "d";
      form.appendChild(area);
      document.body.appendChild(form);

      this.form = form;
      this.area = area;
    }

    this.form.action = this.uri();

    function complete() {
      initIframe();
      fn();
    }

    function initIframe() {
      if (self.iframe) {
        try {
          self.form.removeChild(self.iframe);
        } catch (e) {
          self.onError("jsonp polling iframe removal error", e);
        }
      }

      try {
        // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
        const html = '<iframe src="javascript:0" name="' + self.iframeId + '">';
        iframe = document.createElement(html);
      } catch (e) {
        iframe = document.createElement("iframe");
        iframe.name = self.iframeId;
        iframe.src = "javascript:0";
      }

      iframe.id = self.iframeId;

      self.form.appendChild(iframe);
      self.iframe = iframe;
    }

    initIframe();

    // escape \n to prevent it from being converted into \r\n by some UAs
    // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side
    data = data.replace(rEscapedNewline, "\\\n");
    this.area.value = data.replace(rNewline, "\\n");

    try {
      this.form.submit();
    } catch (e) {}

    if (this.iframe.attachEvent) {
      this.iframe.onreadystatechange = function() {
        if (self.iframe.readyState === "complete") {
          complete();
        }
      };
    } else {
      this.iframe.onload = complete;
    }
  }
}

module.exports = JSONPPolling;


/***/ }),

/***/ "./node_modules/engine.io-client/lib/transports/polling-xhr.js":
/***/ (function(module, exports, __webpack_require__) {

/* global attachEvent */

const XMLHttpRequest = __webpack_require__("./node_modules/engine.io-client/lib/xmlhttprequest.js");
const Polling = __webpack_require__("./node_modules/engine.io-client/lib/transports/polling.js");
const Emitter = __webpack_require__("./node_modules/component-emitter/index.js");
const { pick } = __webpack_require__("./node_modules/engine.io-client/lib/util.js");
const globalThis = __webpack_require__("./node_modules/engine.io-client/lib/globalThis.browser.js");

const debug = __webpack_require__("./node_modules/engine.io-client/node_modules/debug/src/browser.js")("engine.io-client:polling-xhr");

/**
 * Empty function
 */

function empty() {}

const hasXHR2 = (function() {
  const XMLHttpRequest = __webpack_require__("./node_modules/engine.io-client/lib/xmlhttprequest.js");
  const xhr = new XMLHttpRequest({ xdomain: false });
  return null != xhr.responseType;
})();

class XHR extends Polling {
  /**
   * XHR Polling constructor.
   *
   * @param {Object} opts
   * @api public
   */
  constructor(opts) {
    super(opts);

    if (typeof location !== "undefined") {
      const isSSL = "https:" === location.protocol;
      let port = location.port;

      // some user agents have empty `location.port`
      if (!port) {
        port = isSSL ? 443 : 80;
      }

      this.xd =
        (typeof location !== "undefined" &&
          opts.hostname !== location.hostname) ||
        port !== opts.port;
      this.xs = opts.secure !== isSSL;
    }
    /**
     * XHR supports binary
     */
    const forceBase64 = opts && opts.forceBase64;
    this.supportsBinary = hasXHR2 && !forceBase64;
  }

  /**
   * Creates a request.
   *
   * @param {String} method
   * @api private
   */
  request(opts = {}) {
    Object.assign(opts, { xd: this.xd, xs: this.xs }, this.opts);
    return new Request(this.uri(), opts);
  }

  /**
   * Sends data.
   *
   * @param {String} data to send.
   * @param {Function} called upon flush.
   * @api private
   */
  doWrite(data, fn) {
    const req = this.request({
      method: "POST",
      data: data
    });
    const self = this;
    req.on("success", fn);
    req.on("error", function(err) {
      self.onError("xhr post error", err);
    });
  }

  /**
   * Starts a poll cycle.
   *
   * @api private
   */
  doPoll() {
    debug("xhr poll");
    const req = this.request();
    const self = this;
    req.on("data", function(data) {
      self.onData(data);
    });
    req.on("error", function(err) {
      self.onError("xhr poll error", err);
    });
    this.pollXhr = req;
  }
}

class Request extends Emitter {
  /**
   * Request constructor
   *
   * @param {Object} options
   * @api public
   */
  constructor(uri, opts) {
    super();
    this.opts = opts;

    this.method = opts.method || "GET";
    this.uri = uri;
    this.async = false !== opts.async;
    this.data = undefined !== opts.data ? opts.data : null;

    this.create();
  }

  /**
   * Creates the XHR object and sends the request.
   *
   * @api private
   */
  create() {
    const opts = pick(
      this.opts,
      "agent",
      "enablesXDR",
      "pfx",
      "key",
      "passphrase",
      "cert",
      "ca",
      "ciphers",
      "rejectUnauthorized"
    );
    opts.xdomain = !!this.opts.xd;
    opts.xscheme = !!this.opts.xs;

    const xhr = (this.xhr = new XMLHttpRequest(opts));
    const self = this;

    try {
      debug("xhr open %s: %s", this.method, this.uri);
      xhr.open(this.method, this.uri, this.async);
      try {
        if (this.opts.extraHeaders) {
          xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
          for (let i in this.opts.extraHeaders) {
            if (this.opts.extraHeaders.hasOwnProperty(i)) {
              xhr.setRequestHeader(i, this.opts.extraHeaders[i]);
            }
          }
        }
      } catch (e) {}

      if ("POST" === this.method) {
        try {
          xhr.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
        } catch (e) {}
      }

      try {
        xhr.setRequestHeader("Accept", "*/*");
      } catch (e) {}

      // ie6 check
      if ("withCredentials" in xhr) {
        xhr.withCredentials = this.opts.withCredentials;
      }

      if (this.opts.requestTimeout) {
        xhr.timeout = this.opts.requestTimeout;
      }

      if (this.hasXDR()) {
        xhr.onload = function() {
          self.onLoad();
        };
        xhr.onerror = function() {
          self.onError(xhr.responseText);
        };
      } else {
        xhr.onreadystatechange = function() {
          if (4 !== xhr.readyState) return;
          if (200 === xhr.status || 1223 === xhr.status) {
            self.onLoad();
          } else {
            // make sure the `error` event handler that's user-set
            // does not throw in the same tick and gets caught here
            setTimeout(function() {
              self.onError(typeof xhr.status === "number" ? xhr.status : 0);
            }, 0);
          }
        };
      }

      debug("xhr data %s", this.data);
      xhr.send(this.data);
    } catch (e) {
      // Need to defer since .create() is called directly from the constructor
      // and thus the 'error' event can only be only bound *after* this exception
      // occurs.  Therefore, also, we cannot throw here at all.
      setTimeout(function() {
        self.onError(e);
      }, 0);
      return;
    }

    if (typeof document !== "undefined") {
      this.index = Request.requestsCount++;
      Request.requests[this.index] = this;
    }
  }

  /**
   * Called upon successful response.
   *
   * @api private
   */
  onSuccess() {
    this.emit("success");
    this.cleanup();
  }

  /**
   * Called if we have data.
   *
   * @api private
   */
  onData(data) {
    this.emit("data", data);
    this.onSuccess();
  }

  /**
   * Called upon error.
   *
   * @api private
   */
  onError(err) {
    this.emit("error", err);
    this.cleanup(true);
  }

  /**
   * Cleans up house.
   *
   * @api private
   */
  cleanup(fromError) {
    if ("undefined" === typeof this.xhr || null === this.xhr) {
      return;
    }
    // xmlhttprequest
    if (this.hasXDR()) {
      this.xhr.onload = this.xhr.onerror = empty;
    } else {
      this.xhr.onreadystatechange = empty;
    }

    if (fromError) {
      try {
        this.xhr.abort();
      } catch (e) {}
    }

    if (typeof document !== "undefined") {
      delete Request.requests[this.index];
    }

    this.xhr = null;
  }

  /**
   * Called upon load.
   *
   * @api private
   */
  onLoad() {
    const data = this.xhr.responseText;
    if (data !== null) {
      this.onData(data);
    }
  }

  /**
   * Check if it has XDomainRequest.
   *
   * @api private
   */
  hasXDR() {
    return typeof XDomainRequest !== "undefined" && !this.xs && this.enablesXDR;
  }

  /**
   * Aborts the request.
   *
   * @api public
   */
  abort() {
    this.cleanup();
  }
}

/**
 * Aborts pending requests when unloading the window. This is needed to prevent
 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
 * emitted.
 */

Request.requestsCount = 0;
Request.requests = {};

if (typeof document !== "undefined") {
  if (typeof attachEvent === "function") {
    attachEvent("onunload", unloadHandler);
  } else if (typeof addEventListener === "function") {
    const terminationEvent = "onpagehide" in globalThis ? "pagehide" : "unload";
    addEventListener(terminationEvent, unloadHandler, false);
  }
}

function unloadHandler() {
  for (let i in Request.requests) {
    if (Request.requests.hasOwnProperty(i)) {
      Request.requests[i].abort();
    }
  }
}

module.exports = XHR;
module.exports.Request = Request;


/***/ }),

/***/ "./node_modules/engine.io-client/lib/transports/polling.js":
/***/ (function(module, exports, __webpack_require__) {

const Transport = __webpack_require__("./node_modules/engine.io-client/lib/transport.js");
const parseqs = __webpack_require__("./node_modules/parseqs/index.js");
const parser = __webpack_require__("./node_modules/engine.io-parser/lib/index.js");
const yeast = __webpack_require__("./node_modules/yeast/index.js");

const debug = __webpack_require__("./node_modules/engine.io-client/node_modules/debug/src/browser.js")("engine.io-client:polling");

class Polling extends Transport {
  /**
   * Transport name.
   */
  get name() {
    return "polling";
  }

  /**
   * Opens the socket (triggers polling). We write a PING message to determine
   * when the transport is open.
   *
   * @api private
   */
  doOpen() {
    this.poll();
  }

  /**
   * Pauses polling.
   *
   * @param {Function} callback upon buffers are flushed and transport is paused
   * @api private
   */
  pause(onPause) {
    const self = this;

    this.readyState = "pausing";

    function pause() {
      debug("paused");
      self.readyState = "paused";
      onPause();
    }

    if (this.polling || !this.writable) {
      let total = 0;

      if (this.polling) {
        debug("we are currently polling - waiting to pause");
        total++;
        this.once("pollComplete", function() {
          debug("pre-pause polling complete");
          --total || pause();
        });
      }

      if (!this.writable) {
        debug("we are currently writing - waiting to pause");
        total++;
        this.once("drain", function() {
          debug("pre-pause writing complete");
          --total || pause();
        });
      }
    } else {
      pause();
    }
  }

  /**
   * Starts polling cycle.
   *
   * @api public
   */
  poll() {
    debug("polling");
    this.polling = true;
    this.doPoll();
    this.emit("poll");
  }

  /**
   * Overloads onData to detect payloads.
   *
   * @api private
   */
  onData(data) {
    const self = this;
    debug("polling got data %s", data);
    const callback = function(packet, index, total) {
      // if its the first message we consider the transport open
      if ("opening" === self.readyState && packet.type === "open") {
        self.onOpen();
      }

      // if its a close packet, we close the ongoing requests
      if ("close" === packet.type) {
        self.onClose();
        return false;
      }

      // otherwise bypass onData and handle the message
      self.onPacket(packet);
    };

    // decode payload
    parser.decodePayload(data, this.socket.binaryType).forEach(callback);

    // if an event did not trigger closing
    if ("closed" !== this.readyState) {
      // if we got data we're not polling
      this.polling = false;
      this.emit("pollComplete");

      if ("open" === this.readyState) {
        this.poll();
      } else {
        debug('ignoring poll - transport state "%s"', this.readyState);
      }
    }
  }

  /**
   * For polling, send a close packet.
   *
   * @api private
   */
  doClose() {
    const self = this;

    function close() {
      debug("writing close packet");
      self.write([{ type: "close" }]);
    }

    if ("open" === this.readyState) {
      debug("transport open - closing");
      close();
    } else {
      // in case we're trying to close while
      // handshaking is in progress (GH-164)
      debug("transport not open - deferring close");
      this.once("open", close);
    }
  }

  /**
   * Writes a packets payload.
   *
   * @param {Array} data packets
   * @param {Function} drain callback
   * @api private
   */
  write(packets) {
    this.writable = false;

    parser.encodePayload(packets, data => {
      this.doWrite(data, () => {
        this.writable = true;
        this.emit("drain");
      });
    });
  }

  /**
   * Generates uri for connection.
   *
   * @api private
   */
  uri() {
    let query = this.query || {};
    const schema = this.opts.secure ? "https" : "http";
    let port = "";

    // cache busting is forced
    if (false !== this.opts.timestampRequests) {
      query[this.opts.timestampParam] = yeast();
    }

    if (!this.supportsBinary && !query.sid) {
      query.b64 = 1;
    }

    query = parseqs.encode(query);

    // avoid port if default for schema
    if (
      this.opts.port &&
      (("https" === schema && Number(this.opts.port) !== 443) ||
        ("http" === schema && Number(this.opts.port) !== 80))
    ) {
      port = ":" + this.opts.port;
    }

    // prepend ? to query
    if (query.length) {
      query = "?" + query;
    }

    const ipv6 = this.opts.hostname.indexOf(":") !== -1;
    return (
      schema +
      "://" +
      (ipv6 ? "[" + this.opts.hostname + "]" : this.opts.hostname) +
      port +
      this.opts.path +
      query
    );
  }
}

module.exports = Polling;


/***/ }),

/***/ "./node_modules/engine.io-client/lib/transports/websocket-constructor.browser.js":
/***/ (function(module, exports, __webpack_require__) {

const globalThis = __webpack_require__("./node_modules/engine.io-client/lib/globalThis.browser.js");

module.exports = {
  WebSocket: globalThis.WebSocket || globalThis.MozWebSocket,
  usingBrowserWebSocket: true,
  defaultBinaryType: "arraybuffer"
};


/***/ }),

/***/ "./node_modules/engine.io-client/lib/transports/websocket.js":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {const Transport = __webpack_require__("./node_modules/engine.io-client/lib/transport.js");
const parser = __webpack_require__("./node_modules/engine.io-parser/lib/index.js");
const parseqs = __webpack_require__("./node_modules/parseqs/index.js");
const yeast = __webpack_require__("./node_modules/yeast/index.js");
const { pick } = __webpack_require__("./node_modules/engine.io-client/lib/util.js");
const {
  WebSocket,
  usingBrowserWebSocket,
  defaultBinaryType
} = __webpack_require__("./node_modules/engine.io-client/lib/transports/websocket-constructor.browser.js");

const debug = __webpack_require__("./node_modules/engine.io-client/node_modules/debug/src/browser.js")("engine.io-client:websocket");

// detect ReactNative environment
const isReactNative =
  typeof navigator !== "undefined" &&
  typeof navigator.product === "string" &&
  navigator.product.toLowerCase() === "reactnative";

class WS extends Transport {
  /**
   * WebSocket transport constructor.
   *
   * @api {Object} connection options
   * @api public
   */
  constructor(opts) {
    super(opts);

    this.supportsBinary = !opts.forceBase64;
  }

  /**
   * Transport name.
   *
   * @api public
   */
  get name() {
    return "websocket";
  }

  /**
   * Opens socket.
   *
   * @api private
   */
  doOpen() {
    if (!this.check()) {
      // let probe timeout
      return;
    }

    const uri = this.uri();
    const protocols = this.opts.protocols;

    // React Native only supports the 'headers' option, and will print a warning if anything else is passed
    const opts = isReactNative
      ? {}
      : pick(
          this.opts,
          "agent",
          "perMessageDeflate",
          "pfx",
          "key",
          "passphrase",
          "cert",
          "ca",
          "ciphers",
          "rejectUnauthorized",
          "localAddress"
        );

    if (this.opts.extraHeaders) {
      opts.headers = this.opts.extraHeaders;
    }

    try {
      this.ws =
        usingBrowserWebSocket && !isReactNative
          ? protocols
            ? new WebSocket(uri, protocols)
            : new WebSocket(uri)
          : new WebSocket(uri, protocols, opts);
    } catch (err) {
      return this.emit("error", err);
    }

    this.ws.binaryType = this.socket.binaryType || defaultBinaryType;

    this.addEventListeners();
  }

  /**
   * Adds event listeners to the socket
   *
   * @api private
   */
  addEventListeners() {
    const self = this;

    this.ws.onopen = function() {
      self.onOpen();
    };
    this.ws.onclose = function() {
      self.onClose();
    };
    this.ws.onmessage = function(ev) {
      self.onData(ev.data);
    };
    this.ws.onerror = function(e) {
      self.onError("websocket error", e);
    };
  }

  /**
   * Writes data to socket.
   *
   * @param {Array} array of packets.
   * @api private
   */
  write(packets) {
    const self = this;
    this.writable = false;

    // encodePacket efficient as it uses WS framing
    // no need for encodePayload
    let total = packets.length;
    let i = 0;
    const l = total;
    for (; i < l; i++) {
      (function(packet) {
        parser.encodePacket(packet, self.supportsBinary, function(data) {
          // always create a new object (GH-437)
          const opts = {};
          if (!usingBrowserWebSocket) {
            if (packet.options) {
              opts.compress = packet.options.compress;
            }

            if (self.opts.perMessageDeflate) {
              const len =
                "string" === typeof data
                  ? Buffer.byteLength(data)
                  : data.length;
              if (len < self.opts.perMessageDeflate.threshold) {
                opts.compress = false;
              }
            }
          }

          // Sometimes the websocket has already been closed but the browser didn't
          // have a chance of informing us about it yet, in that case send will
          // throw an error
          try {
            if (usingBrowserWebSocket) {
              // TypeError is thrown when passing the second argument on Safari
              self.ws.send(data);
            } else {
              self.ws.send(data, opts);
            }
          } catch (e) {
            debug("websocket closed before onclose event");
          }

          --total || done();
        });
      })(packets[i]);
    }

    function done() {
      self.emit("flush");

      // fake drain
      // defer to next tick to allow Socket to clear writeBuffer
      setTimeout(function() {
        self.writable = true;
        self.emit("drain");
      }, 0);
    }
  }

  /**
   * Called upon close
   *
   * @api private
   */
  onClose() {
    Transport.prototype.onClose.call(this);
  }

  /**
   * Closes socket.
   *
   * @api private
   */
  doClose() {
    if (typeof this.ws !== "undefined") {
      this.ws.close();
    }
  }

  /**
   * Generates uri for connection.
   *
   * @api private
   */
  uri() {
    let query = this.query || {};
    const schema = this.opts.secure ? "wss" : "ws";
    let port = "";

    // avoid port if default for schema
    if (
      this.opts.port &&
      (("wss" === schema && Number(this.opts.port) !== 443) ||
        ("ws" === schema && Number(this.opts.port) !== 80))
    ) {
      port = ":" + this.opts.port;
    }

    // append timestamp to URI
    if (this.opts.timestampRequests) {
      query[this.opts.timestampParam] = yeast();
    }

    // communicate binary support capabilities
    if (!this.supportsBinary) {
      query.b64 = 1;
    }

    query = parseqs.encode(query);

    // prepend ? to query
    if (query.length) {
      query = "?" + query;
    }

    const ipv6 = this.opts.hostname.indexOf(":") !== -1;
    return (
      schema +
      "://" +
      (ipv6 ? "[" + this.opts.hostname + "]" : this.opts.hostname) +
      port +
      this.opts.path +
      query
    );
  }

  /**
   * Feature detection for WebSocket.
   *
   * @return {Boolean} whether this transport is available.
   * @api public
   */
  check() {
    return (
      !!WebSocket &&
      !("__initialize" in WebSocket && this.name === WS.prototype.name)
    );
  }
}

module.exports = WS;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/engine.io-client/lib/util.js":
/***/ (function(module, exports) {

module.exports.pick = (obj, ...attr) => {
  return attr.reduce((acc, k) => {
    acc[k] = obj[k];
    return acc;
  }, {});
};


/***/ }),

/***/ "./node_modules/engine.io-client/lib/xmlhttprequest.js":
/***/ (function(module, exports, __webpack_require__) {

// browser shim for xmlhttprequest module

const hasCORS = __webpack_require__("./node_modules/has-cors/index.js");
const globalThis = __webpack_require__("./node_modules/engine.io-client/lib/globalThis.browser.js");

module.exports = function(opts) {
  const xdomain = opts.xdomain;

  // scheme must be same when usign XDomainRequest
  // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx
  const xscheme = opts.xscheme;

  // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.
  // https://github.com/Automattic/engine.io-client/pull/217
  const enablesXDR = opts.enablesXDR;

  // XMLHttpRequest can be disabled on IE
  try {
    if ("undefined" !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {
      return new XMLHttpRequest();
    }
  } catch (e) {}

  // Use XDomainRequest for IE8 if enablesXDR is true
  // because loading bar keeps flashing when using jsonp-polling
  // https://github.com/yujiosaka/socke.io-ie8-loading-example
  try {
    if ("undefined" !== typeof XDomainRequest && !xscheme && enablesXDR) {
      return new XDomainRequest();
    }
  } catch (e) {}

  if (!xdomain) {
    try {
      return new globalThis[["Active"].concat("Object").join("X")](
        "Microsoft.XMLHTTP"
      );
    } catch (e) {}
  }
};


/***/ }),

/***/ "./node_modules/engine.io-client/node_modules/debug/src/browser.js":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */
function log(...args) {
	// This hackery is required for IE8/9, where
	// the `console.log` function doesn't have 'apply'
	return typeof console === 'object' &&
		console.log &&
		console.log(...args);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug');
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = process.env.DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = __webpack_require__("./node_modules/engine.io-client/node_modules/debug/src/common.js")(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/engine.io-client/node_modules/debug/src/common.js":
/***/ (function(module, exports, __webpack_require__) {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = __webpack_require__("./node_modules/engine.io-client/node_modules/ms/index.js");

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* Active `debug` instances.
	*/
	createDebug.instances = [];

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return match;
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.enabled = createDebug.enabled(namespace);
		debug.useColors = createDebug.useColors();
		debug.color = selectColor(namespace);
		debug.destroy = destroy;
		debug.extend = extend;
		// Debug.formatArgs = formatArgs;
		// debug.rawLog = rawLog;

		// env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		createDebug.instances.push(debug);

		return debug;
	}

	function destroy() {
		const index = createDebug.instances.indexOf(this);
		if (index !== -1) {
			createDebug.instances.splice(index, 1);
			return true;
		}
		return false;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);

		createDebug.names = [];
		createDebug.skips = [];

		let i;
		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
		const len = split.length;

		for (i = 0; i < len; i++) {
			if (!split[i]) {
				// ignore empty strings
				continue;
			}

			namespaces = split[i].replace(/\*/g, '.*?');

			if (namespaces[0] === '-') {
				createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
			} else {
				createDebug.names.push(new RegExp('^' + namespaces + '$'));
			}
		}

		for (i = 0; i < createDebug.instances.length; i++) {
			const instance = createDebug.instances[i];
			instance.enabled = createDebug.enabled(instance.namespace);
		}
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names.map(toNamespace),
			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		if (name[name.length - 1] === '*') {
			return true;
		}

		let i;
		let len;

		for (i = 0, len = createDebug.skips.length; i < len; i++) {
			if (createDebug.skips[i].test(name)) {
				return false;
			}
		}

		for (i = 0, len = createDebug.names.length; i < len; i++) {
			if (createDebug.names[i].test(name)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/
	function toNamespace(regexp) {
		return regexp.toString()
			.substring(2, regexp.toString().length - 2)
			.replace(/\.\*\?$/, '*');
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

module.exports = setup;


/***/ }),

/***/ "./node_modules/engine.io-client/node_modules/ms/index.js":
/***/ (function(module, exports) {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}


/***/ }),

/***/ "./node_modules/engine.io-parser/lib/commons.js":
/***/ (function(module, exports) {

const PACKET_TYPES = Object.create(null); // no Map = no polyfill
PACKET_TYPES["open"] = "0";
PACKET_TYPES["close"] = "1";
PACKET_TYPES["ping"] = "2";
PACKET_TYPES["pong"] = "3";
PACKET_TYPES["message"] = "4";
PACKET_TYPES["upgrade"] = "5";
PACKET_TYPES["noop"] = "6";

const PACKET_TYPES_REVERSE = Object.create(null);
Object.keys(PACKET_TYPES).forEach(key => {
  PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;
});

const ERROR_PACKET = { type: "error", data: "parser error" };

module.exports = {
  PACKET_TYPES,
  PACKET_TYPES_REVERSE,
  ERROR_PACKET
};


/***/ }),

/***/ "./node_modules/engine.io-parser/lib/decodePacket.browser.js":
/***/ (function(module, exports, __webpack_require__) {

const { PACKET_TYPES_REVERSE, ERROR_PACKET } = __webpack_require__("./node_modules/engine.io-parser/lib/commons.js");

const withNativeArrayBuffer = typeof ArrayBuffer === "function";

let base64decoder;
if (withNativeArrayBuffer) {
  base64decoder = __webpack_require__("./node_modules/base64-arraybuffer/lib/base64-arraybuffer.js");
}

const decodePacket = (encodedPacket, binaryType) => {
  if (typeof encodedPacket !== "string") {
    return {
      type: "message",
      data: mapBinary(encodedPacket, binaryType)
    };
  }
  const type = encodedPacket.charAt(0);
  if (type === "b") {
    return {
      type: "message",
      data: decodeBase64Packet(encodedPacket.substring(1), binaryType)
    };
  }
  const packetType = PACKET_TYPES_REVERSE[type];
  if (!packetType) {
    return ERROR_PACKET;
  }
  return encodedPacket.length > 1
    ? {
        type: PACKET_TYPES_REVERSE[type],
        data: encodedPacket.substring(1)
      }
    : {
        type: PACKET_TYPES_REVERSE[type]
      };
};

const decodeBase64Packet = (data, binaryType) => {
  if (base64decoder) {
    const decoded = base64decoder.decode(data);
    return mapBinary(decoded, binaryType);
  } else {
    return { base64: true, data }; // fallback for old browsers
  }
};

const mapBinary = (data, binaryType) => {
  switch (binaryType) {
    case "blob":
      return data instanceof ArrayBuffer ? new Blob([data]) : data;
    case "arraybuffer":
    default:
      return data; // assuming the data is already an ArrayBuffer
  }
};

module.exports = decodePacket;


/***/ }),

/***/ "./node_modules/engine.io-parser/lib/encodePacket.browser.js":
/***/ (function(module, exports, __webpack_require__) {

const { PACKET_TYPES } = __webpack_require__("./node_modules/engine.io-parser/lib/commons.js");

const withNativeBlob =
  typeof Blob === "function" ||
  (typeof Blob !== "undefined" &&
    Object.prototype.toString.call(Blob) === "[object BlobConstructor]");
const withNativeArrayBuffer = typeof ArrayBuffer === "function";

// ArrayBuffer.isView method is not defined in IE10
const isView = obj => {
  return typeof ArrayBuffer.isView === "function"
    ? ArrayBuffer.isView(obj)
    : obj && obj.buffer instanceof ArrayBuffer;
};

const encodePacket = ({ type, data }, supportsBinary, callback) => {
  if (withNativeBlob && data instanceof Blob) {
    if (supportsBinary) {
      return callback(data);
    } else {
      return encodeBlobAsBase64(data, callback);
    }
  } else if (
    withNativeArrayBuffer &&
    (data instanceof ArrayBuffer || isView(data))
  ) {
    if (supportsBinary) {
      return callback(data instanceof ArrayBuffer ? data : data.buffer);
    } else {
      return encodeBlobAsBase64(new Blob([data]), callback);
    }
  }
  // plain string
  return callback(PACKET_TYPES[type] + (data || ""));
};

const encodeBlobAsBase64 = (data, callback) => {
  const fileReader = new FileReader();
  fileReader.onload = function() {
    const content = fileReader.result.split(",")[1];
    callback("b" + content);
  };
  return fileReader.readAsDataURL(data);
};

module.exports = encodePacket;


/***/ }),

/***/ "./node_modules/engine.io-parser/lib/index.js":
/***/ (function(module, exports, __webpack_require__) {

const encodePacket = __webpack_require__("./node_modules/engine.io-parser/lib/encodePacket.browser.js");
const decodePacket = __webpack_require__("./node_modules/engine.io-parser/lib/decodePacket.browser.js");

const SEPARATOR = String.fromCharCode(30); // see https://en.wikipedia.org/wiki/Delimiter#ASCII_delimited_text

const encodePayload = (packets, callback) => {
  // some packets may be added to the array while encoding, so the initial length must be saved
  const length = packets.length;
  const encodedPackets = new Array(length);
  let count = 0;

  packets.forEach((packet, i) => {
    // force base64 encoding for binary packets
    encodePacket(packet, false, encodedPacket => {
      encodedPackets[i] = encodedPacket;
      if (++count === length) {
        callback(encodedPackets.join(SEPARATOR));
      }
    });
  });
};

const decodePayload = (encodedPayload, binaryType) => {
  const encodedPackets = encodedPayload.split(SEPARATOR);
  const packets = [];
  for (let i = 0; i < encodedPackets.length; i++) {
    const decodedPacket = decodePacket(encodedPackets[i], binaryType);
    packets.push(decodedPacket);
    if (decodedPacket.type === "error") {
      break;
    }
  }
  return packets;
};

module.exports = {
  protocol: 4,
  encodePacket,
  encodePayload,
  decodePacket,
  decodePayload
};


/***/ }),

/***/ "./node_modules/fbjs/lib/EventListener.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var emptyFunction = __webpack_require__("./node_modules/fbjs/lib/emptyFunction.js");

/**
 * Upstream version of event listener. Does not take into account specific
 * nature of platform.
 */
var EventListener = {
  /**
   * Listen to DOM events during the bubble phase.
   *
   * @param {DOMEventTarget} target DOM element to register listener on.
   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
   * @param {function} callback Callback function.
   * @return {object} Object with a `remove` method.
   */
  listen: function listen(target, eventType, callback) {
    if (target.addEventListener) {
      target.addEventListener(eventType, callback, false);
      return {
        remove: function remove() {
          target.removeEventListener(eventType, callback, false);
        }
      };
    } else if (target.attachEvent) {
      target.attachEvent('on' + eventType, callback);
      return {
        remove: function remove() {
          target.detachEvent('on' + eventType, callback);
        }
      };
    }
  },

  /**
   * Listen to DOM events during the capture phase.
   *
   * @param {DOMEventTarget} target DOM element to register listener on.
   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
   * @param {function} callback Callback function.
   * @return {object} Object with a `remove` method.
   */
  capture: function capture(target, eventType, callback) {
    if (target.addEventListener) {
      target.addEventListener(eventType, callback, true);
      return {
        remove: function remove() {
          target.removeEventListener(eventType, callback, true);
        }
      };
    } else {
      if (true) {
        console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
      }
      return {
        remove: emptyFunction
      };
    }
  },

  registerDefault: function registerDefault() {}
};

module.exports = EventListener;

/***/ }),

/***/ "./node_modules/fbjs/lib/ExecutionEnvironment.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

/**
 * Simple, lightweight module assisting with the detection and context of
 * Worker. Helps avoid circular dependencies and allows code to reason about
 * whether or not they are in a Worker, even if they never include the main
 * `ReactWorker` dependency.
 */
var ExecutionEnvironment = {

  canUseDOM: canUseDOM,

  canUseWorkers: typeof Worker !== 'undefined',

  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),

  canUseViewport: canUseDOM && !!window.screen,

  isInWorker: !canUseDOM // For now, this is true - might change in the future.

};

module.exports = ExecutionEnvironment;

/***/ }),

/***/ "./node_modules/fbjs/lib/camelize.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var _hyphenPattern = /-(.)/g;

/**
 * Camelcases a hyphenated string, for example:
 *
 *   > camelize('background-color')
 *   < "backgroundColor"
 *
 * @param {string} string
 * @return {string}
 */
function camelize(string) {
  return string.replace(_hyphenPattern, function (_, character) {
    return character.toUpperCase();
  });
}

module.exports = camelize;

/***/ }),

/***/ "./node_modules/fbjs/lib/camelizeStyleName.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */



var camelize = __webpack_require__("./node_modules/fbjs/lib/camelize.js");

var msPattern = /^-ms-/;

/**
 * Camelcases a hyphenated CSS property name, for example:
 *
 *   > camelizeStyleName('background-color')
 *   < "backgroundColor"
 *   > camelizeStyleName('-moz-transition')
 *   < "MozTransition"
 *   > camelizeStyleName('-ms-transition')
 *   < "msTransition"
 *
 * As Andi Smith suggests
 * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
 * is converted to lowercase `ms`.
 *
 * @param {string} string
 * @return {string}
 */
function camelizeStyleName(string) {
  return camelize(string.replace(msPattern, 'ms-'));
}

module.exports = camelizeStyleName;

/***/ }),

/***/ "./node_modules/fbjs/lib/containsNode.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

var isTextNode = __webpack_require__("./node_modules/fbjs/lib/isTextNode.js");

/*eslint-disable no-bitwise */

/**
 * Checks if a given DOM node contains or is another DOM node.
 */
function containsNode(outerNode, innerNode) {
  if (!outerNode || !innerNode) {
    return false;
  } else if (outerNode === innerNode) {
    return true;
  } else if (isTextNode(outerNode)) {
    return false;
  } else if (isTextNode(innerNode)) {
    return containsNode(outerNode, innerNode.parentNode);
  } else if ('contains' in outerNode) {
    return outerNode.contains(innerNode);
  } else if (outerNode.compareDocumentPosition) {
    return !!(outerNode.compareDocumentPosition(innerNode) & 16);
  } else {
    return false;
  }
}

module.exports = containsNode;

/***/ }),

/***/ "./node_modules/fbjs/lib/emptyFunction.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
var emptyFunction = function emptyFunction() {};

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function () {
  return this;
};
emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

module.exports = emptyFunction;

/***/ }),

/***/ "./node_modules/fbjs/lib/emptyObject.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var emptyObject = {};

if (true) {
  Object.freeze(emptyObject);
}

module.exports = emptyObject;

/***/ }),

/***/ "./node_modules/fbjs/lib/focusNode.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



/**
 * @param {DOMElement} node input/textarea to focus
 */

function focusNode(node) {
  // IE8 can throw "Can't move focus to the control because it is invisible,
  // not enabled, or of a type that does not accept the focus." for all kinds of
  // reasons that are too expensive and fragile to test.
  try {
    node.focus();
  } catch (e) {}
}

module.exports = focusNode;

/***/ }),

/***/ "./node_modules/fbjs/lib/getActiveElement.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

/* eslint-disable fb-www/typeof-undefined */

/**
 * Same as document.activeElement but wraps in a try-catch block. In IE it is
 * not safe to call document.activeElement if there is nothing focused.
 *
 * The activeElement will be null only if the document or document body is not
 * yet defined.
 *
 * @param {?DOMDocument} doc Defaults to current document.
 * @return {?DOMElement}
 */
function getActiveElement(doc) /*?DOMElement*/{
  doc = doc || (typeof document !== 'undefined' ? document : undefined);
  if (typeof doc === 'undefined') {
    return null;
  }
  try {
    return doc.activeElement || doc.body;
  } catch (e) {
    return doc.body;
  }
}

module.exports = getActiveElement;

/***/ }),

/***/ "./node_modules/fbjs/lib/hyphenate.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var _uppercasePattern = /([A-Z])/g;

/**
 * Hyphenates a camelcased string, for example:
 *
 *   > hyphenate('backgroundColor')
 *   < "background-color"
 *
 * For CSS style names, use `hyphenateStyleName` instead which works properly
 * with all vendor prefixes, including `ms`.
 *
 * @param {string} string
 * @return {string}
 */
function hyphenate(string) {
  return string.replace(_uppercasePattern, '-$1').toLowerCase();
}

module.exports = hyphenate;

/***/ }),

/***/ "./node_modules/fbjs/lib/hyphenateStyleName.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */



var hyphenate = __webpack_require__("./node_modules/fbjs/lib/hyphenate.js");

var msPattern = /^ms-/;

/**
 * Hyphenates a camelcased CSS property name, for example:
 *
 *   > hyphenateStyleName('backgroundColor')
 *   < "background-color"
 *   > hyphenateStyleName('MozTransition')
 *   < "-moz-transition"
 *   > hyphenateStyleName('msTransition')
 *   < "-ms-transition"
 *
 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
 * is converted to `-ms-`.
 *
 * @param {string} string
 * @return {string}
 */
function hyphenateStyleName(string) {
  return hyphenate(string).replace(msPattern, '-ms-');
}

module.exports = hyphenateStyleName;

/***/ }),

/***/ "./node_modules/fbjs/lib/invariant.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var validateFormat = function validateFormat(format) {};

if (true) {
  validateFormat = function validateFormat(format) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  };
}

function invariant(condition, format, a, b, c, d, e, f) {
  validateFormat(format);

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
}

module.exports = invariant;

/***/ }),

/***/ "./node_modules/fbjs/lib/isNode.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

/**
 * @param {*} object The object to check.
 * @return {boolean} Whether or not the object is a DOM node.
 */
function isNode(object) {
  var doc = object ? object.ownerDocument || object : document;
  var defaultView = doc.defaultView || window;
  return !!(object && (typeof defaultView.Node === 'function' ? object instanceof defaultView.Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
}

module.exports = isNode;

/***/ }),

/***/ "./node_modules/fbjs/lib/isTextNode.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var isNode = __webpack_require__("./node_modules/fbjs/lib/isNode.js");

/**
 * @param {*} object The object to check.
 * @return {boolean} Whether or not the object is a DOM text node.
 */
function isTextNode(object) {
  return isNode(object) && object.nodeType == 3;
}

module.exports = isTextNode;

/***/ }),

/***/ "./node_modules/fbjs/lib/shallowEqual.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 * 
 */

/*eslint-disable no-self-compare */



var hasOwnProperty = Object.prototype.hasOwnProperty;

/**
 * inlined Object.is polyfill to avoid requiring consumers ship their own
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
 */
function is(x, y) {
  // SameValue algorithm
  if (x === y) {
    // Steps 1-5, 7-10
    // Steps 6.b-6.e: +0 != -0
    // Added the nonzero y check to make Flow happy, but it is redundant
    return x !== 0 || y !== 0 || 1 / x === 1 / y;
  } else {
    // Step 6.a: NaN == NaN
    return x !== x && y !== y;
  }
}

/**
 * Performs equality by iterating through keys on an object and returning false
 * when any key has values which are not strictly equal between the arguments.
 * Returns true when the values of all keys are strictly equal.
 */
function shallowEqual(objA, objB) {
  if (is(objA, objB)) {
    return true;
  }

  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  }

  // Test for A's keys different from B.
  for (var i = 0; i < keysA.length; i++) {
    if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }

  return true;
}

module.exports = shallowEqual;

/***/ }),

/***/ "./node_modules/fbjs/lib/warning.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var emptyFunction = __webpack_require__("./node_modules/fbjs/lib/emptyFunction.js");

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = emptyFunction;

if (true) {
  var printWarning = function printWarning(format) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  warning = function warning(condition, format) {
    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }

    if (format.indexOf('Failed Composite propType: ') === 0) {
      return; // Ignore CompositeComponent proptype check.
    }

    if (!condition) {
      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(undefined, [format].concat(args));
    }
  };
}

module.exports = warning;

/***/ }),

/***/ "./node_modules/has-cors/index.js":
/***/ (function(module, exports) {


/**
 * Module exports.
 *
 * Logic borrowed from Modernizr:
 *
 *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
 */

try {
  module.exports = typeof XMLHttpRequest !== 'undefined' &&
    'withCredentials' in new XMLHttpRequest();
} catch (err) {
  // if XMLHttp support is disabled in IE then it will throw
  // when trying to create
  module.exports = false;
}


/***/ }),

/***/ "./node_modules/ieee754/index.js":
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ "./node_modules/immutable/dist/immutable.es.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export version */
/* unused harmony export Collection */
/* unused harmony export Iterable */
/* unused harmony export Seq */
/* unused harmony export Map */
/* unused harmony export OrderedMap */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return List; });
/* unused harmony export Stack */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return Set; });
/* unused harmony export OrderedSet */
/* unused harmony export Record */
/* unused harmony export Range */
/* unused harmony export Repeat */
/* unused harmony export is */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return fromJS; });
/* unused harmony export hash */
/* unused harmony export isImmutable */
/* unused harmony export isCollection */
/* unused harmony export isKeyed */
/* unused harmony export isIndexed */
/* unused harmony export isAssociative */
/* unused harmony export isOrdered */
/* unused harmony export isValueObject */
/* unused harmony export get */
/* unused harmony export getIn */
/* unused harmony export has */
/* unused harmony export hasIn */
/* unused harmony export merge */
/* unused harmony export mergeDeep */
/* unused harmony export mergeWith */
/* unused harmony export mergeDeepWith */
/* unused harmony export remove */
/* unused harmony export removeIn */
/* unused harmony export set */
/* unused harmony export setIn */
/* unused harmony export update */
/* unused harmony export updateIn */
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// Used for setting prototype methods that IE8 chokes on.
var DELETE = 'delete';

// Constants describing the size of trie nodes.
var SHIFT = 5; // Resulted in best performance after ______?
var SIZE = 1 << SHIFT;
var MASK = SIZE - 1;

// A consistent shared value representing "not set" which equals nothing other
// than itself, and nothing that could be provided externally.
var NOT_SET = {};

// Boolean references, Rough equivalent of `bool &`.
var CHANGE_LENGTH = { value: false };
var DID_ALTER = { value: false };

function MakeRef(ref) {
  ref.value = false;
  return ref;
}

function SetRef(ref) {
  ref && (ref.value = true);
}

// A function which returns a value representing an "owner" for transient writes
// to tries. The return value will only ever equal itself, and will not equal
// the return of any subsequent call of this function.
function OwnerID() {}

function ensureSize(iter) {
  if (iter.size === undefined) {
    iter.size = iter.__iterate(returnTrue);
  }
  return iter.size;
}

function wrapIndex(iter, index) {
  // This implements "is array index" which the ECMAString spec defines as:
  //
  //     A String property name P is an array index if and only if
  //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal
  //     to 2^321.
  //
  // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects
  if (typeof index !== 'number') {
    var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32
    if ('' + uint32Index !== index || uint32Index === 4294967295) {
      return NaN;
    }
    index = uint32Index;
  }
  return index < 0 ? ensureSize(iter) + index : index;
}

function returnTrue() {
  return true;
}

function wholeSlice(begin, end, size) {
  return (
    ((begin === 0 && !isNeg(begin)) ||
      (size !== undefined && begin <= -size)) &&
    (end === undefined || (size !== undefined && end >= size))
  );
}

function resolveBegin(begin, size) {
  return resolveIndex(begin, size, 0);
}

function resolveEnd(end, size) {
  return resolveIndex(end, size, size);
}

function resolveIndex(index, size, defaultIndex) {
  // Sanitize indices using this shorthand for ToInt32(argument)
  // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
  return index === undefined
    ? defaultIndex
    : isNeg(index)
      ? size === Infinity ? size : Math.max(0, size + index) | 0
      : size === undefined || size === index
        ? index
        : Math.min(size, index) | 0;
}

function isNeg(value) {
  // Account for -0 which is negative, but not less than 0.
  return value < 0 || (value === 0 && 1 / value === -Infinity);
}

function isImmutable(maybeImmutable) {
  return isCollection(maybeImmutable) || isRecord(maybeImmutable);
}

function isCollection(maybeCollection) {
  return !!(maybeCollection && maybeCollection[IS_ITERABLE_SENTINEL]);
}

function isKeyed(maybeKeyed) {
  return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);
}

function isIndexed(maybeIndexed) {
  return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);
}

function isAssociative(maybeAssociative) {
  return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);
}

function isOrdered(maybeOrdered) {
  return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);
}

function isRecord(maybeRecord) {
  return !!(maybeRecord && maybeRecord[IS_RECORD_SENTINEL]);
}

function isValueObject(maybeValue) {
  return !!(
    maybeValue &&
    typeof maybeValue.equals === 'function' &&
    typeof maybeValue.hashCode === 'function'
  );
}

var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';
var IS_RECORD_SENTINEL = '@@__IMMUTABLE_RECORD__@@';

var Collection = function Collection(value) {
  return isCollection(value) ? value : Seq(value);
};

var KeyedCollection = (function (Collection) {
  function KeyedCollection(value) {
    return isKeyed(value) ? value : KeyedSeq(value);
  }

  if ( Collection ) KeyedCollection.__proto__ = Collection;
  KeyedCollection.prototype = Object.create( Collection && Collection.prototype );
  KeyedCollection.prototype.constructor = KeyedCollection;

  return KeyedCollection;
}(Collection));

var IndexedCollection = (function (Collection) {
  function IndexedCollection(value) {
    return isIndexed(value) ? value : IndexedSeq(value);
  }

  if ( Collection ) IndexedCollection.__proto__ = Collection;
  IndexedCollection.prototype = Object.create( Collection && Collection.prototype );
  IndexedCollection.prototype.constructor = IndexedCollection;

  return IndexedCollection;
}(Collection));

var SetCollection = (function (Collection) {
  function SetCollection(value) {
    return isCollection(value) && !isAssociative(value) ? value : SetSeq(value);
  }

  if ( Collection ) SetCollection.__proto__ = Collection;
  SetCollection.prototype = Object.create( Collection && Collection.prototype );
  SetCollection.prototype.constructor = SetCollection;

  return SetCollection;
}(Collection));

Collection.Keyed = KeyedCollection;
Collection.Indexed = IndexedCollection;
Collection.Set = SetCollection;

var ITERATE_KEYS = 0;
var ITERATE_VALUES = 1;
var ITERATE_ENTRIES = 2;

var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator';

var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;

var Iterator = function Iterator(next) {
  this.next = next;
};

Iterator.prototype.toString = function toString () {
  return '[Iterator]';
};

Iterator.KEYS = ITERATE_KEYS;
Iterator.VALUES = ITERATE_VALUES;
Iterator.ENTRIES = ITERATE_ENTRIES;

Iterator.prototype.inspect = Iterator.prototype.toSource = function() {
  return this.toString();
};
Iterator.prototype[ITERATOR_SYMBOL] = function() {
  return this;
};

function iteratorValue(type, k, v, iteratorResult) {
  var value = type === 0 ? k : type === 1 ? v : [k, v];
  iteratorResult
    ? (iteratorResult.value = value)
    : (iteratorResult = {
        value: value,
        done: false
      });
  return iteratorResult;
}

function iteratorDone() {
  return { value: undefined, done: true };
}

function hasIterator(maybeIterable) {
  return !!getIteratorFn(maybeIterable);
}

function isIterator(maybeIterator) {
  return maybeIterator && typeof maybeIterator.next === 'function';
}

function getIterator(iterable) {
  var iteratorFn = getIteratorFn(iterable);
  return iteratorFn && iteratorFn.call(iterable);
}

function getIteratorFn(iterable) {
  var iteratorFn =
    iterable &&
    ((REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL]) ||
      iterable[FAUX_ITERATOR_SYMBOL]);
  if (typeof iteratorFn === 'function') {
    return iteratorFn;
  }
}

var hasOwnProperty = Object.prototype.hasOwnProperty;

function isArrayLike(value) {
  return value && typeof value.length === 'number';
}

var Seq = (function (Collection$$1) {
  function Seq(value) {
    return value === null || value === undefined
      ? emptySequence()
      : isImmutable(value) ? value.toSeq() : seqFromValue(value);
  }

  if ( Collection$$1 ) Seq.__proto__ = Collection$$1;
  Seq.prototype = Object.create( Collection$$1 && Collection$$1.prototype );
  Seq.prototype.constructor = Seq;

  Seq.prototype.toSeq = function toSeq () {
    return this;
  };

  Seq.prototype.toString = function toString () {
    return this.__toString('Seq {', '}');
  };

  Seq.prototype.cacheResult = function cacheResult () {
    if (!this._cache && this.__iterateUncached) {
      this._cache = this.entrySeq().toArray();
      this.size = this._cache.length;
    }
    return this;
  };

  // abstract __iterateUncached(fn, reverse)

  Seq.prototype.__iterate = function __iterate (fn, reverse) {
    var this$1 = this;

    var cache = this._cache;
    if (cache) {
      var size = cache.length;
      var i = 0;
      while (i !== size) {
        var entry = cache[reverse ? size - ++i : i++];
        if (fn(entry[1], entry[0], this$1) === false) {
          break;
        }
      }
      return i;
    }
    return this.__iterateUncached(fn, reverse);
  };

  // abstract __iteratorUncached(type, reverse)

  Seq.prototype.__iterator = function __iterator (type, reverse) {
    var cache = this._cache;
    if (cache) {
      var size = cache.length;
      var i = 0;
      return new Iterator(function () {
        if (i === size) {
          return iteratorDone();
        }
        var entry = cache[reverse ? size - ++i : i++];
        return iteratorValue(type, entry[0], entry[1]);
      });
    }
    return this.__iteratorUncached(type, reverse);
  };

  return Seq;
}(Collection));

var KeyedSeq = (function (Seq) {
  function KeyedSeq(value) {
    return value === null || value === undefined
      ? emptySequence().toKeyedSeq()
      : isCollection(value)
        ? isKeyed(value) ? value.toSeq() : value.fromEntrySeq()
        : isRecord(value) ? value.toSeq() : keyedSeqFromValue(value);
  }

  if ( Seq ) KeyedSeq.__proto__ = Seq;
  KeyedSeq.prototype = Object.create( Seq && Seq.prototype );
  KeyedSeq.prototype.constructor = KeyedSeq;

  KeyedSeq.prototype.toKeyedSeq = function toKeyedSeq () {
    return this;
  };

  return KeyedSeq;
}(Seq));

var IndexedSeq = (function (Seq) {
  function IndexedSeq(value) {
    return value === null || value === undefined
      ? emptySequence()
      : isCollection(value)
        ? isKeyed(value) ? value.entrySeq() : value.toIndexedSeq()
        : isRecord(value)
          ? value.toSeq().entrySeq()
          : indexedSeqFromValue(value);
  }

  if ( Seq ) IndexedSeq.__proto__ = Seq;
  IndexedSeq.prototype = Object.create( Seq && Seq.prototype );
  IndexedSeq.prototype.constructor = IndexedSeq;

  IndexedSeq.of = function of (/*...values*/) {
    return IndexedSeq(arguments);
  };

  IndexedSeq.prototype.toIndexedSeq = function toIndexedSeq () {
    return this;
  };

  IndexedSeq.prototype.toString = function toString () {
    return this.__toString('Seq [', ']');
  };

  return IndexedSeq;
}(Seq));

var SetSeq = (function (Seq) {
  function SetSeq(value) {
    return (isCollection(value) && !isAssociative(value)
      ? value
      : IndexedSeq(value)
    ).toSetSeq();
  }

  if ( Seq ) SetSeq.__proto__ = Seq;
  SetSeq.prototype = Object.create( Seq && Seq.prototype );
  SetSeq.prototype.constructor = SetSeq;

  SetSeq.of = function of (/*...values*/) {
    return SetSeq(arguments);
  };

  SetSeq.prototype.toSetSeq = function toSetSeq () {
    return this;
  };

  return SetSeq;
}(Seq));

Seq.isSeq = isSeq;
Seq.Keyed = KeyedSeq;
Seq.Set = SetSeq;
Seq.Indexed = IndexedSeq;

var IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';

Seq.prototype[IS_SEQ_SENTINEL] = true;

// #pragma Root Sequences

var ArraySeq = (function (IndexedSeq) {
  function ArraySeq(array) {
    this._array = array;
    this.size = array.length;
  }

  if ( IndexedSeq ) ArraySeq.__proto__ = IndexedSeq;
  ArraySeq.prototype = Object.create( IndexedSeq && IndexedSeq.prototype );
  ArraySeq.prototype.constructor = ArraySeq;

  ArraySeq.prototype.get = function get (index, notSetValue) {
    return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;
  };

  ArraySeq.prototype.__iterate = function __iterate (fn, reverse) {
    var this$1 = this;

    var array = this._array;
    var size = array.length;
    var i = 0;
    while (i !== size) {
      var ii = reverse ? size - ++i : i++;
      if (fn(array[ii], ii, this$1) === false) {
        break;
      }
    }
    return i;
  };

  ArraySeq.prototype.__iterator = function __iterator (type, reverse) {
    var array = this._array;
    var size = array.length;
    var i = 0;
    return new Iterator(function () {
      if (i === size) {
        return iteratorDone();
      }
      var ii = reverse ? size - ++i : i++;
      return iteratorValue(type, ii, array[ii]);
    });
  };

  return ArraySeq;
}(IndexedSeq));

var ObjectSeq = (function (KeyedSeq) {
  function ObjectSeq(object) {
    var keys = Object.keys(object);
    this._object = object;
    this._keys = keys;
    this.size = keys.length;
  }

  if ( KeyedSeq ) ObjectSeq.__proto__ = KeyedSeq;
  ObjectSeq.prototype = Object.create( KeyedSeq && KeyedSeq.prototype );
  ObjectSeq.prototype.constructor = ObjectSeq;

  ObjectSeq.prototype.get = function get (key, notSetValue) {
    if (notSetValue !== undefined && !this.has(key)) {
      return notSetValue;
    }
    return this._object[key];
  };

  ObjectSeq.prototype.has = function has (key) {
    return hasOwnProperty.call(this._object, key);
  };

  ObjectSeq.prototype.__iterate = function __iterate (fn, reverse) {
    var this$1 = this;

    var object = this._object;
    var keys = this._keys;
    var size = keys.length;
    var i = 0;
    while (i !== size) {
      var key = keys[reverse ? size - ++i : i++];
      if (fn(object[key], key, this$1) === false) {
        break;
      }
    }
    return i;
  };

  ObjectSeq.prototype.__iterator = function __iterator (type, reverse) {
    var object = this._object;
    var keys = this._keys;
    var size = keys.length;
    var i = 0;
    return new Iterator(function () {
      if (i === size) {
        return iteratorDone();
      }
      var key = keys[reverse ? size - ++i : i++];
      return iteratorValue(type, key, object[key]);
    });
  };

  return ObjectSeq;
}(KeyedSeq));
ObjectSeq.prototype[IS_ORDERED_SENTINEL] = true;

var CollectionSeq = (function (IndexedSeq) {
  function CollectionSeq(collection) {
    this._collection = collection;
    this.size = collection.length || collection.size;
  }

  if ( IndexedSeq ) CollectionSeq.__proto__ = IndexedSeq;
  CollectionSeq.prototype = Object.create( IndexedSeq && IndexedSeq.prototype );
  CollectionSeq.prototype.constructor = CollectionSeq;

  CollectionSeq.prototype.__iterateUncached = function __iterateUncached (fn, reverse) {
    var this$1 = this;

    if (reverse) {
      return this.cacheResult().__iterate(fn, reverse);
    }
    var collection = this._collection;
    var iterator = getIterator(collection);
    var iterations = 0;
    if (isIterator(iterator)) {
      var step;
      while (!(step = iterator.next()).done) {
        if (fn(step.value, iterations++, this$1) === false) {
          break;
        }
      }
    }
    return iterations;
  };

  CollectionSeq.prototype.__iteratorUncached = function __iteratorUncached (type, reverse) {
    if (reverse) {
      return this.cacheResult().__iterator(type, reverse);
    }
    var collection = this._collection;
    var iterator = getIterator(collection);
    if (!isIterator(iterator)) {
      return new Iterator(iteratorDone);
    }
    var iterations = 0;
    return new Iterator(function () {
      var step = iterator.next();
      return step.done ? step : iteratorValue(type, iterations++, step.value);
    });
  };

  return CollectionSeq;
}(IndexedSeq));

var IteratorSeq = (function (IndexedSeq) {
  function IteratorSeq(iterator) {
    this._iterator = iterator;
    this._iteratorCache = [];
  }

  if ( IndexedSeq ) IteratorSeq.__proto__ = IndexedSeq;
  IteratorSeq.prototype = Object.create( IndexedSeq && IndexedSeq.prototype );
  IteratorSeq.prototype.constructor = IteratorSeq;

  IteratorSeq.prototype.__iterateUncached = function __iterateUncached (fn, reverse) {
    var this$1 = this;

    if (reverse) {
      return this.cacheResult().__iterate(fn, reverse);
    }
    var iterator = this._iterator;
    var cache = this._iteratorCache;
    var iterations = 0;
    while (iterations < cache.length) {
      if (fn(cache[iterations], iterations++, this$1) === false) {
        return iterations;
      }
    }
    var step;
    while (!(step = iterator.next()).done) {
      var val = step.value;
      cache[iterations] = val;
      if (fn(val, iterations++, this$1) === false) {
        break;
      }
    }
    return iterations;
  };

  IteratorSeq.prototype.__iteratorUncached = function __iteratorUncached (type, reverse) {
    if (reverse) {
      return this.cacheResult().__iterator(type, reverse);
    }
    var iterator = this._iterator;
    var cache = this._iteratorCache;
    var iterations = 0;
    return new Iterator(function () {
      if (iterations >= cache.length) {
        var step = iterator.next();
        if (step.done) {
          return step;
        }
        cache[iterations] = step.value;
      }
      return iteratorValue(type, iterations, cache[iterations++]);
    });
  };

  return IteratorSeq;
}(IndexedSeq));

// # pragma Helper functions

function isSeq(maybeSeq) {
  return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);
}

var EMPTY_SEQ;

function emptySequence() {
  return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));
}

function keyedSeqFromValue(value) {
  var seq = Array.isArray(value)
    ? new ArraySeq(value)
    : isIterator(value)
      ? new IteratorSeq(value)
      : hasIterator(value) ? new CollectionSeq(value) : undefined;
  if (seq) {
    return seq.fromEntrySeq();
  }
  if (typeof value === 'object') {
    return new ObjectSeq(value);
  }
  throw new TypeError(
    'Expected Array or collection object of [k, v] entries, or keyed object: ' +
      value
  );
}

function indexedSeqFromValue(value) {
  var seq = maybeIndexedSeqFromValue(value);
  if (seq) {
    return seq;
  }
  throw new TypeError(
    'Expected Array or collection object of values: ' + value
  );
}

function seqFromValue(value) {
  var seq = maybeIndexedSeqFromValue(value);
  if (seq) {
    return seq;
  }
  if (typeof value === 'object') {
    return new ObjectSeq(value);
  }
  throw new TypeError(
    'Expected Array or collection object of values, or keyed object: ' + value
  );
}

function maybeIndexedSeqFromValue(value) {
  return isArrayLike(value)
    ? new ArraySeq(value)
    : isIterator(value)
      ? new IteratorSeq(value)
      : hasIterator(value) ? new CollectionSeq(value) : undefined;
}

/**
 * An extension of the "same-value" algorithm as [described for use by ES6 Map
 * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)
 *
 * NaN is considered the same as NaN, however -0 and 0 are considered the same
 * value, which is different from the algorithm described by
 * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).
 *
 * This is extended further to allow Objects to describe the values they
 * represent, by way of `valueOf` or `equals` (and `hashCode`).
 *
 * Note: because of this extension, the key equality of Immutable.Map and the
 * value equality of Immutable.Set will differ from ES6 Map and Set.
 *
 * ### Defining custom values
 *
 * The easiest way to describe the value an object represents is by implementing
 * `valueOf`. For example, `Date` represents a value by returning a unix
 * timestamp for `valueOf`:
 *
 *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...
 *     var date2 = new Date(1234567890000);
 *     date1.valueOf(); // 1234567890000
 *     assert( date1 !== date2 );
 *     assert( Immutable.is( date1, date2 ) );
 *
 * Note: overriding `valueOf` may have other implications if you use this object
 * where JavaScript expects a primitive, such as implicit string coercion.
 *
 * For more complex types, especially collections, implementing `valueOf` may
 * not be performant. An alternative is to implement `equals` and `hashCode`.
 *
 * `equals` takes another object, presumably of similar type, and returns true
 * if it is equal. Equality is symmetrical, so the same result should be
 * returned if this and the argument are flipped.
 *
 *     assert( a.equals(b) === b.equals(a) );
 *
 * `hashCode` returns a 32bit integer number representing the object which will
 * be used to determine how to store the value object in a Map or Set. You must
 * provide both or neither methods, one must not exist without the other.
 *
 * Also, an important relationship between these methods must be upheld: if two
 * values are equal, they *must* return the same hashCode. If the values are not
 * equal, they might have the same hashCode; this is called a hash collision,
 * and while undesirable for performance reasons, it is acceptable.
 *
 *     if (a.equals(b)) {
 *       assert( a.hashCode() === b.hashCode() );
 *     }
 *
 * All Immutable collections are Value Objects: they implement `equals()`
 * and `hashCode()`.
 */
function is(valueA, valueB) {
  if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
    return true;
  }
  if (!valueA || !valueB) {
    return false;
  }
  if (
    typeof valueA.valueOf === 'function' &&
    typeof valueB.valueOf === 'function'
  ) {
    valueA = valueA.valueOf();
    valueB = valueB.valueOf();
    if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
      return true;
    }
    if (!valueA || !valueB) {
      return false;
    }
  }
  return !!(
    isValueObject(valueA) &&
    isValueObject(valueB) &&
    valueA.equals(valueB)
  );
}

var imul =
  typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2
    ? Math.imul
    : function imul(a, b) {
        a |= 0; // int
        b |= 0; // int
        var c = a & 0xffff;
        var d = b & 0xffff;
        // Shift by 0 fixes the sign on the high part.
        return (c * d + ((((a >>> 16) * d + c * (b >>> 16)) << 16) >>> 0)) | 0; // int
      };

// v8 has an optimization for storing 31-bit signed numbers.
// Values which have either 00 or 11 as the high order bits qualify.
// This function drops the highest order bit in a signed number, maintaining
// the sign bit.
function smi(i32) {
  return ((i32 >>> 1) & 0x40000000) | (i32 & 0xbfffffff);
}

function hash(o) {
  if (o === false || o === null || o === undefined) {
    return 0;
  }
  if (typeof o.valueOf === 'function') {
    o = o.valueOf();
    if (o === false || o === null || o === undefined) {
      return 0;
    }
  }
  if (o === true) {
    return 1;
  }
  var type = typeof o;
  if (type === 'number') {
    if (o !== o || o === Infinity) {
      return 0;
    }
    var h = o | 0;
    if (h !== o) {
      h ^= o * 0xffffffff;
    }
    while (o > 0xffffffff) {
      o /= 0xffffffff;
      h ^= o;
    }
    return smi(h);
  }
  if (type === 'string') {
    return o.length > STRING_HASH_CACHE_MIN_STRLEN
      ? cachedHashString(o)
      : hashString(o);
  }
  if (typeof o.hashCode === 'function') {
    // Drop any high bits from accidentally long hash codes.
    return smi(o.hashCode());
  }
  if (type === 'object') {
    return hashJSObj(o);
  }
  if (typeof o.toString === 'function') {
    return hashString(o.toString());
  }
  throw new Error('Value type ' + type + ' cannot be hashed.');
}

function cachedHashString(string) {
  var hashed = stringHashCache[string];
  if (hashed === undefined) {
    hashed = hashString(string);
    if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
      STRING_HASH_CACHE_SIZE = 0;
      stringHashCache = {};
    }
    STRING_HASH_CACHE_SIZE++;
    stringHashCache[string] = hashed;
  }
  return hashed;
}

// http://jsperf.com/hashing-strings
function hashString(string) {
  // This is the hash from JVM
  // The hash code for a string is computed as
  // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],
  // where s[i] is the ith character of the string and n is the length of
  // the string. We "mod" the result to make it between 0 (inclusive) and 2^31
  // (exclusive) by dropping high bits.
  var hashed = 0;
  for (var ii = 0; ii < string.length; ii++) {
    hashed = (31 * hashed + string.charCodeAt(ii)) | 0;
  }
  return smi(hashed);
}

function hashJSObj(obj) {
  var hashed;
  if (usingWeakMap) {
    hashed = weakMap.get(obj);
    if (hashed !== undefined) {
      return hashed;
    }
  }

  hashed = obj[UID_HASH_KEY];
  if (hashed !== undefined) {
    return hashed;
  }

  if (!canDefineProperty) {
    hashed = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];
    if (hashed !== undefined) {
      return hashed;
    }

    hashed = getIENodeHash(obj);
    if (hashed !== undefined) {
      return hashed;
    }
  }

  hashed = ++objHashUID;
  if (objHashUID & 0x40000000) {
    objHashUID = 0;
  }

  if (usingWeakMap) {
    weakMap.set(obj, hashed);
  } else if (isExtensible !== undefined && isExtensible(obj) === false) {
    throw new Error('Non-extensible objects are not allowed as keys.');
  } else if (canDefineProperty) {
    Object.defineProperty(obj, UID_HASH_KEY, {
      enumerable: false,
      configurable: false,
      writable: false,
      value: hashed
    });
  } else if (
    obj.propertyIsEnumerable !== undefined &&
    obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable
  ) {
    // Since we can't define a non-enumerable property on the object
    // we'll hijack one of the less-used non-enumerable properties to
    // save our hash on it. Since this is a function it will not show up in
    // `JSON.stringify` which is what we want.
    obj.propertyIsEnumerable = function() {
      return this.constructor.prototype.propertyIsEnumerable.apply(
        this,
        arguments
      );
    };
    obj.propertyIsEnumerable[UID_HASH_KEY] = hashed;
  } else if (obj.nodeType !== undefined) {
    // At this point we couldn't get the IE `uniqueID` to use as a hash
    // and we couldn't use a non-enumerable property to exploit the
    // dontEnum bug so we simply add the `UID_HASH_KEY` on the node
    // itself.
    obj[UID_HASH_KEY] = hashed;
  } else {
    throw new Error('Unable to set a non-enumerable property on object.');
  }

  return hashed;
}

// Get references to ES5 object methods.
var isExtensible = Object.isExtensible;

// True if Object.defineProperty works as expected. IE8 fails this test.
var canDefineProperty = (function() {
  try {
    Object.defineProperty({}, '@', {});
    return true;
  } catch (e) {
    return false;
  }
})();

// IE has a `uniqueID` property on DOM nodes. We can construct the hash from it
// and avoid memory leaks from the IE cloneNode bug.
function getIENodeHash(node) {
  if (node && node.nodeType > 0) {
    switch (node.nodeType) {
      case 1: // Element
        return node.uniqueID;
      case 9: // Document
        return node.documentElement && node.documentElement.uniqueID;
    }
  }
}

// If possible, use a WeakMap.
var usingWeakMap = typeof WeakMap === 'function';
var weakMap;
if (usingWeakMap) {
  weakMap = new WeakMap();
}

var objHashUID = 0;

var UID_HASH_KEY = '__immutablehash__';
if (typeof Symbol === 'function') {
  UID_HASH_KEY = Symbol(UID_HASH_KEY);
}

var STRING_HASH_CACHE_MIN_STRLEN = 16;
var STRING_HASH_CACHE_MAX_SIZE = 255;
var STRING_HASH_CACHE_SIZE = 0;
var stringHashCache = {};

var ToKeyedSequence = (function (KeyedSeq$$1) {
  function ToKeyedSequence(indexed, useKeys) {
    this._iter = indexed;
    this._useKeys = useKeys;
    this.size = indexed.size;
  }

  if ( KeyedSeq$$1 ) ToKeyedSequence.__proto__ = KeyedSeq$$1;
  ToKeyedSequence.prototype = Object.create( KeyedSeq$$1 && KeyedSeq$$1.prototype );
  ToKeyedSequence.prototype.constructor = ToKeyedSequence;

  ToKeyedSequence.prototype.get = function get (key, notSetValue) {
    return this._iter.get(key, notSetValue);
  };

  ToKeyedSequence.prototype.has = function has (key) {
    return this._iter.has(key);
  };

  ToKeyedSequence.prototype.valueSeq = function valueSeq () {
    return this._iter.valueSeq();
  };

  ToKeyedSequence.prototype.reverse = function reverse () {
    var this$1 = this;

    var reversedSequence = reverseFactory(this, true);
    if (!this._useKeys) {
      reversedSequence.valueSeq = function () { return this$1._iter.toSeq().reverse(); };
    }
    return reversedSequence;
  };

  ToKeyedSequence.prototype.map = function map (mapper, context) {
    var this$1 = this;

    var mappedSequence = mapFactory(this, mapper, context);
    if (!this._useKeys) {
      mappedSequence.valueSeq = function () { return this$1._iter.toSeq().map(mapper, context); };
    }
    return mappedSequence;
  };

  ToKeyedSequence.prototype.__iterate = function __iterate (fn, reverse) {
    var this$1 = this;

    return this._iter.__iterate(function (v, k) { return fn(v, k, this$1); }, reverse);
  };

  ToKeyedSequence.prototype.__iterator = function __iterator (type, reverse) {
    return this._iter.__iterator(type, reverse);
  };

  return ToKeyedSequence;
}(KeyedSeq));
ToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = true;

var ToIndexedSequence = (function (IndexedSeq$$1) {
  function ToIndexedSequence(iter) {
    this._iter = iter;
    this.size = iter.size;
  }

  if ( IndexedSeq$$1 ) ToIndexedSequence.__proto__ = IndexedSeq$$1;
  ToIndexedSequence.prototype = Object.create( IndexedSeq$$1 && IndexedSeq$$1.prototype );
  ToIndexedSequence.prototype.constructor = ToIndexedSequence;

  ToIndexedSequence.prototype.includes = function includes (value) {
    return this._iter.includes(value);
  };

  ToIndexedSequence.prototype.__iterate = function __iterate (fn, reverse) {
    var this$1 = this;

    var i = 0;
    reverse && ensureSize(this);
    return this._iter.__iterate(
      function (v) { return fn(v, reverse ? this$1.size - ++i : i++, this$1); },
      reverse
    );
  };

  ToIndexedSequence.prototype.__iterator = function __iterator (type, reverse) {
    var this$1 = this;

    var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
    var i = 0;
    reverse && ensureSize(this);
    return new Iterator(function () {
      var step = iterator.next();
      return step.done
        ? step
        : iteratorValue(
            type,
            reverse ? this$1.size - ++i : i++,
            step.value,
            step
          );
    });
  };

  return ToIndexedSequence;
}(IndexedSeq));

var ToSetSequence = (function (SetSeq$$1) {
  function ToSetSequence(iter) {
    this._iter = iter;
    this.size = iter.size;
  }

  if ( SetSeq$$1 ) ToSetSequence.__proto__ = SetSeq$$1;
  ToSetSequence.prototype = Object.create( SetSeq$$1 && SetSeq$$1.prototype );
  ToSetSequence.prototype.constructor = ToSetSequence;

  ToSetSequence.prototype.has = function has (key) {
    return this._iter.includes(key);
  };

  ToSetSequence.prototype.__iterate = function __iterate (fn, reverse) {
    var this$1 = this;

    return this._iter.__iterate(function (v) { return fn(v, v, this$1); }, reverse);
  };

  ToSetSequence.prototype.__iterator = function __iterator (type, reverse) {
    var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
    return new Iterator(function () {
      var step = iterator.next();
      return step.done
        ? step
        : iteratorValue(type, step.value, step.value, step);
    });
  };

  return ToSetSequence;
}(SetSeq));

var FromEntriesSequence = (function (KeyedSeq$$1) {
  function FromEntriesSequence(entries) {
    this._iter = entries;
    this.size = entries.size;
  }

  if ( KeyedSeq$$1 ) FromEntriesSequence.__proto__ = KeyedSeq$$1;
  FromEntriesSequence.prototype = Object.create( KeyedSeq$$1 && KeyedSeq$$1.prototype );
  FromEntriesSequence.prototype.constructor = FromEntriesSequence;

  FromEntriesSequence.prototype.entrySeq = function entrySeq () {
    return this._iter.toSeq();
  };

  FromEntriesSequence.prototype.__iterate = function __iterate (fn, reverse) {
    var this$1 = this;

    return this._iter.__iterate(function (entry) {
      // Check if entry exists first so array access doesn't throw for holes
      // in the parent iteration.
      if (entry) {
        validateEntry(entry);
        var indexedCollection = isCollection(entry);
        return fn(
          indexedCollection ? entry.get(1) : entry[1],
          indexedCollection ? entry.get(0) : entry[0],
          this$1
        );
      }
    }, reverse);
  };

  FromEntriesSequence.prototype.__iterator = function __iterator (type, reverse) {
    var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
    return new Iterator(function () {
      while (true) {
        var step = iterator.next();
        if (step.done) {
          return step;
        }
        var entry = step.value;
        // Check if entry exists first so array access doesn't throw for holes
        // in the parent iteration.
        if (entry) {
          validateEntry(entry);
          var indexedCollection = isCollection(entry);
          return iteratorValue(
            type,
            indexedCollection ? entry.get(0) : entry[0],
            indexedCollection ? entry.get(1) : entry[1],
            step
          );
        }
      }
    });
  };

  return FromEntriesSequence;
}(KeyedSeq));

ToIndexedSequence.prototype.cacheResult = ToKeyedSequence.prototype.cacheResult = ToSetSequence.prototype.cacheResult = FromEntriesSequence.prototype.cacheResult = cacheResultThrough;

function flipFactory(collection) {
  var flipSequence = makeSequence(collection);
  flipSequence._iter = collection;
  flipSequence.size = collection.size;
  flipSequence.flip = function () { return collection; };
  flipSequence.reverse = function() {
    var reversedSequence = collection.reverse.apply(this); // super.reverse()
    reversedSequence.flip = function () { return collection.reverse(); };
    return reversedSequence;
  };
  flipSequence.has = function (key) { return collection.includes(key); };
  flipSequence.includes = function (key) { return collection.has(key); };
  flipSequence.cacheResult = cacheResultThrough;
  flipSequence.__iterateUncached = function(fn, reverse) {
    var this$1 = this;

    return collection.__iterate(function (v, k) { return fn(k, v, this$1) !== false; }, reverse);
  };
  flipSequence.__iteratorUncached = function(type, reverse) {
    if (type === ITERATE_ENTRIES) {
      var iterator = collection.__iterator(type, reverse);
      return new Iterator(function () {
        var step = iterator.next();
        if (!step.done) {
          var k = step.value[0];
          step.value[0] = step.value[1];
          step.value[1] = k;
        }
        return step;
      });
    }
    return collection.__iterator(
      type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,
      reverse
    );
  };
  return flipSequence;
}

function mapFactory(collection, mapper, context) {
  var mappedSequence = makeSequence(collection);
  mappedSequence.size = collection.size;
  mappedSequence.has = function (key) { return collection.has(key); };
  mappedSequence.get = function (key, notSetValue) {
    var v = collection.get(key, NOT_SET);
    return v === NOT_SET
      ? notSetValue
      : mapper.call(context, v, key, collection);
  };
  mappedSequence.__iterateUncached = function(fn, reverse) {
    var this$1 = this;

    return collection.__iterate(
      function (v, k, c) { return fn(mapper.call(context, v, k, c), k, this$1) !== false; },
      reverse
    );
  };
  mappedSequence.__iteratorUncached = function(type, reverse) {
    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);
    return new Iterator(function () {
      var step = iterator.next();
      if (step.done) {
        return step;
      }
      var entry = step.value;
      var key = entry[0];
      return iteratorValue(
        type,
        key,
        mapper.call(context, entry[1], key, collection),
        step
      );
    });
  };
  return mappedSequence;
}

function reverseFactory(collection, useKeys) {
  var this$1 = this;

  var reversedSequence = makeSequence(collection);
  reversedSequence._iter = collection;
  reversedSequence.size = collection.size;
  reversedSequence.reverse = function () { return collection; };
  if (collection.flip) {
    reversedSequence.flip = function() {
      var flipSequence = flipFactory(collection);
      flipSequence.reverse = function () { return collection.flip(); };
      return flipSequence;
    };
  }
  reversedSequence.get = function (key, notSetValue) { return collection.get(useKeys ? key : -1 - key, notSetValue); };
  reversedSequence.has = function (key) { return collection.has(useKeys ? key : -1 - key); };
  reversedSequence.includes = function (value) { return collection.includes(value); };
  reversedSequence.cacheResult = cacheResultThrough;
  reversedSequence.__iterate = function(fn, reverse) {
    var this$1 = this;

    var i = 0;
    reverse && ensureSize(collection);
    return collection.__iterate(
      function (v, k) { return fn(v, useKeys ? k : reverse ? this$1.size - ++i : i++, this$1); },
      !reverse
    );
  };
  reversedSequence.__iterator = function (type, reverse) {
    var i = 0;
    reverse && ensureSize(collection);
    var iterator = collection.__iterator(ITERATE_ENTRIES, !reverse);
    return new Iterator(function () {
      var step = iterator.next();
      if (step.done) {
        return step;
      }
      var entry = step.value;
      return iteratorValue(
        type,
        useKeys ? entry[0] : reverse ? this$1.size - ++i : i++,
        entry[1],
        step
      );
    });
  };
  return reversedSequence;
}

function filterFactory(collection, predicate, context, useKeys) {
  var filterSequence = makeSequence(collection);
  if (useKeys) {
    filterSequence.has = function (key) {
      var v = collection.get(key, NOT_SET);
      return v !== NOT_SET && !!predicate.call(context, v, key, collection);
    };
    filterSequence.get = function (key, notSetValue) {
      var v = collection.get(key, NOT_SET);
      return v !== NOT_SET && predicate.call(context, v, key, collection)
        ? v
        : notSetValue;
    };
  }
  filterSequence.__iterateUncached = function(fn, reverse) {
    var this$1 = this;

    var iterations = 0;
    collection.__iterate(function (v, k, c) {
      if (predicate.call(context, v, k, c)) {
        iterations++;
        return fn(v, useKeys ? k : iterations - 1, this$1);
      }
    }, reverse);
    return iterations;
  };
  filterSequence.__iteratorUncached = function(type, reverse) {
    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);
    var iterations = 0;
    return new Iterator(function () {
      while (true) {
        var step = iterator.next();
        if (step.done) {
          return step;
        }
        var entry = step.value;
        var key = entry[0];
        var value = entry[1];
        if (predicate.call(context, value, key, collection)) {
          return iteratorValue(type, useKeys ? key : iterations++, value, step);
        }
      }
    });
  };
  return filterSequence;
}

function countByFactory(collection, grouper, context) {
  var groups = Map().asMutable();
  collection.__iterate(function (v, k) {
    groups.update(grouper.call(context, v, k, collection), 0, function (a) { return a + 1; });
  });
  return groups.asImmutable();
}

function groupByFactory(collection, grouper, context) {
  var isKeyedIter = isKeyed(collection);
  var groups = (isOrdered(collection) ? OrderedMap() : Map()).asMutable();
  collection.__iterate(function (v, k) {
    groups.update(
      grouper.call(context, v, k, collection),
      function (a) { return ((a = a || []), a.push(isKeyedIter ? [k, v] : v), a); }
    );
  });
  var coerce = collectionClass(collection);
  return groups.map(function (arr) { return reify(collection, coerce(arr)); });
}

function sliceFactory(collection, begin, end, useKeys) {
  var originalSize = collection.size;

  if (wholeSlice(begin, end, originalSize)) {
    return collection;
  }

  var resolvedBegin = resolveBegin(begin, originalSize);
  var resolvedEnd = resolveEnd(end, originalSize);

  // begin or end will be NaN if they were provided as negative numbers and
  // this collection's size is unknown. In that case, cache first so there is
  // a known size and these do not resolve to NaN.
  if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {
    return sliceFactory(collection.toSeq().cacheResult(), begin, end, useKeys);
  }

  // Note: resolvedEnd is undefined when the original sequence's length is
  // unknown and this slice did not supply an end and should contain all
  // elements after resolvedBegin.
  // In that case, resolvedSize will be NaN and sliceSize will remain undefined.
  var resolvedSize = resolvedEnd - resolvedBegin;
  var sliceSize;
  if (resolvedSize === resolvedSize) {
    sliceSize = resolvedSize < 0 ? 0 : resolvedSize;
  }

  var sliceSeq = makeSequence(collection);

  // If collection.size is undefined, the size of the realized sliceSeq is
  // unknown at this point unless the number of items to slice is 0
  sliceSeq.size =
    sliceSize === 0 ? sliceSize : (collection.size && sliceSize) || undefined;

  if (!useKeys && isSeq(collection) && sliceSize >= 0) {
    sliceSeq.get = function(index, notSetValue) {
      index = wrapIndex(this, index);
      return index >= 0 && index < sliceSize
        ? collection.get(index + resolvedBegin, notSetValue)
        : notSetValue;
    };
  }

  sliceSeq.__iterateUncached = function(fn, reverse) {
    var this$1 = this;

    if (sliceSize === 0) {
      return 0;
    }
    if (reverse) {
      return this.cacheResult().__iterate(fn, reverse);
    }
    var skipped = 0;
    var isSkipping = true;
    var iterations = 0;
    collection.__iterate(function (v, k) {
      if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {
        iterations++;
        return (
          fn(v, useKeys ? k : iterations - 1, this$1) !== false &&
          iterations !== sliceSize
        );
      }
    });
    return iterations;
  };

  sliceSeq.__iteratorUncached = function(type, reverse) {
    if (sliceSize !== 0 && reverse) {
      return this.cacheResult().__iterator(type, reverse);
    }
    // Don't bother instantiating parent iterator if taking 0.
    if (sliceSize === 0) {
      return new Iterator(iteratorDone);
    }
    var iterator = collection.__iterator(type, reverse);
    var skipped = 0;
    var iterations = 0;
    return new Iterator(function () {
      while (skipped++ < resolvedBegin) {
        iterator.next();
      }
      if (++iterations > sliceSize) {
        return iteratorDone();
      }
      var step = iterator.next();
      if (useKeys || type === ITERATE_VALUES || step.done) {
        return step;
      }
      if (type === ITERATE_KEYS) {
        return iteratorValue(type, iterations - 1, undefined, step);
      }
      return iteratorValue(type, iterations - 1, step.value[1], step);
    });
  };

  return sliceSeq;
}

function takeWhileFactory(collection, predicate, context) {
  var takeSequence = makeSequence(collection);
  takeSequence.__iterateUncached = function(fn, reverse) {
    var this$1 = this;

    if (reverse) {
      return this.cacheResult().__iterate(fn, reverse);
    }
    var iterations = 0;
    collection.__iterate(
      function (v, k, c) { return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$1); }
    );
    return iterations;
  };
  takeSequence.__iteratorUncached = function(type, reverse) {
    var this$1 = this;

    if (reverse) {
      return this.cacheResult().__iterator(type, reverse);
    }
    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);
    var iterating = true;
    return new Iterator(function () {
      if (!iterating) {
        return iteratorDone();
      }
      var step = iterator.next();
      if (step.done) {
        return step;
      }
      var entry = step.value;
      var k = entry[0];
      var v = entry[1];
      if (!predicate.call(context, v, k, this$1)) {
        iterating = false;
        return iteratorDone();
      }
      return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);
    });
  };
  return takeSequence;
}

function skipWhileFactory(collection, predicate, context, useKeys) {
  var skipSequence = makeSequence(collection);
  skipSequence.__iterateUncached = function(fn, reverse) {
    var this$1 = this;

    if (reverse) {
      return this.cacheResult().__iterate(fn, reverse);
    }
    var isSkipping = true;
    var iterations = 0;
    collection.__iterate(function (v, k, c) {
      if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {
        iterations++;
        return fn(v, useKeys ? k : iterations - 1, this$1);
      }
    });
    return iterations;
  };
  skipSequence.__iteratorUncached = function(type, reverse) {
    var this$1 = this;

    if (reverse) {
      return this.cacheResult().__iterator(type, reverse);
    }
    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);
    var skipping = true;
    var iterations = 0;
    return new Iterator(function () {
      var step;
      var k;
      var v;
      do {
        step = iterator.next();
        if (step.done) {
          if (useKeys || type === ITERATE_VALUES) {
            return step;
          }
          if (type === ITERATE_KEYS) {
            return iteratorValue(type, iterations++, undefined, step);
          }
          return iteratorValue(type, iterations++, step.value[1], step);
        }
        var entry = step.value;
        k = entry[0];
        v = entry[1];
        skipping && (skipping = predicate.call(context, v, k, this$1));
      } while (skipping);
      return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);
    });
  };
  return skipSequence;
}

function concatFactory(collection, values) {
  var isKeyedCollection = isKeyed(collection);
  var iters = [collection]
    .concat(values)
    .map(function (v) {
      if (!isCollection(v)) {
        v = isKeyedCollection
          ? keyedSeqFromValue(v)
          : indexedSeqFromValue(Array.isArray(v) ? v : [v]);
      } else if (isKeyedCollection) {
        v = KeyedCollection(v);
      }
      return v;
    })
    .filter(function (v) { return v.size !== 0; });

  if (iters.length === 0) {
    return collection;
  }

  if (iters.length === 1) {
    var singleton = iters[0];
    if (
      singleton === collection ||
      (isKeyedCollection && isKeyed(singleton)) ||
      (isIndexed(collection) && isIndexed(singleton))
    ) {
      return singleton;
    }
  }

  var concatSeq = new ArraySeq(iters);
  if (isKeyedCollection) {
    concatSeq = concatSeq.toKeyedSeq();
  } else if (!isIndexed(collection)) {
    concatSeq = concatSeq.toSetSeq();
  }
  concatSeq = concatSeq.flatten(true);
  concatSeq.size = iters.reduce(function (sum, seq) {
    if (sum !== undefined) {
      var size = seq.size;
      if (size !== undefined) {
        return sum + size;
      }
    }
  }, 0);
  return concatSeq;
}

function flattenFactory(collection, depth, useKeys) {
  var flatSequence = makeSequence(collection);
  flatSequence.__iterateUncached = function(fn, reverse) {
    if (reverse) {
      return this.cacheResult().__iterate(fn, reverse);
    }
    var iterations = 0;
    var stopped = false;
    function flatDeep(iter, currentDepth) {
      iter.__iterate(function (v, k) {
        if ((!depth || currentDepth < depth) && isCollection(v)) {
          flatDeep(v, currentDepth + 1);
        } else {
          iterations++;
          if (fn(v, useKeys ? k : iterations - 1, flatSequence) === false) {
            stopped = true;
          }
        }
        return !stopped;
      }, reverse);
    }
    flatDeep(collection, 0);
    return iterations;
  };
  flatSequence.__iteratorUncached = function(type, reverse) {
    if (reverse) {
      return this.cacheResult().__iterator(type, reverse);
    }
    var iterator = collection.__iterator(type, reverse);
    var stack = [];
    var iterations = 0;
    return new Iterator(function () {
      while (iterator) {
        var step = iterator.next();
        if (step.done !== false) {
          iterator = stack.pop();
          continue;
        }
        var v = step.value;
        if (type === ITERATE_ENTRIES) {
          v = v[1];
        }
        if ((!depth || stack.length < depth) && isCollection(v)) {
          stack.push(iterator);
          iterator = v.__iterator(type, reverse);
        } else {
          return useKeys ? step : iteratorValue(type, iterations++, v, step);
        }
      }
      return iteratorDone();
    });
  };
  return flatSequence;
}

function flatMapFactory(collection, mapper, context) {
  var coerce = collectionClass(collection);
  return collection
    .toSeq()
    .map(function (v, k) { return coerce(mapper.call(context, v, k, collection)); })
    .flatten(true);
}

function interposeFactory(collection, separator) {
  var interposedSequence = makeSequence(collection);
  interposedSequence.size = collection.size && collection.size * 2 - 1;
  interposedSequence.__iterateUncached = function(fn, reverse) {
    var this$1 = this;

    var iterations = 0;
    collection.__iterate(
      function (v) { return (!iterations || fn(separator, iterations++, this$1) !== false) &&
        fn(v, iterations++, this$1) !== false; },
      reverse
    );
    return iterations;
  };
  interposedSequence.__iteratorUncached = function(type, reverse) {
    var iterator = collection.__iterator(ITERATE_VALUES, reverse);
    var iterations = 0;
    var step;
    return new Iterator(function () {
      if (!step || iterations % 2) {
        step = iterator.next();
        if (step.done) {
          return step;
        }
      }
      return iterations % 2
        ? iteratorValue(type, iterations++, separator)
        : iteratorValue(type, iterations++, step.value, step);
    });
  };
  return interposedSequence;
}

function sortFactory(collection, comparator, mapper) {
  if (!comparator) {
    comparator = defaultComparator;
  }
  var isKeyedCollection = isKeyed(collection);
  var index = 0;
  var entries = collection
    .toSeq()
    .map(function (v, k) { return [k, v, index++, mapper ? mapper(v, k, collection) : v]; })
    .valueSeq()
    .toArray();
  entries.sort(function (a, b) { return comparator(a[3], b[3]) || a[2] - b[2]; }).forEach(
    isKeyedCollection
      ? function (v, i) {
          entries[i].length = 2;
        }
      : function (v, i) {
          entries[i] = v[1];
        }
  );
  return isKeyedCollection
    ? KeyedSeq(entries)
    : isIndexed(collection) ? IndexedSeq(entries) : SetSeq(entries);
}

function maxFactory(collection, comparator, mapper) {
  if (!comparator) {
    comparator = defaultComparator;
  }
  if (mapper) {
    var entry = collection
      .toSeq()
      .map(function (v, k) { return [v, mapper(v, k, collection)]; })
      .reduce(function (a, b) { return (maxCompare(comparator, a[1], b[1]) ? b : a); });
    return entry && entry[0];
  }
  return collection.reduce(function (a, b) { return (maxCompare(comparator, a, b) ? b : a); });
}

function maxCompare(comparator, a, b) {
  var comp = comparator(b, a);
  // b is considered the new max if the comparator declares them equal, but
  // they are not equal and b is in fact a nullish value.
  return (
    (comp === 0 && b !== a && (b === undefined || b === null || b !== b)) ||
    comp > 0
  );
}

function zipWithFactory(keyIter, zipper, iters, zipAll) {
  var zipSequence = makeSequence(keyIter);
  var sizes = new ArraySeq(iters).map(function (i) { return i.size; });
  zipSequence.size = zipAll ? sizes.max() : sizes.min();
  // Note: this a generic base implementation of __iterate in terms of
  // __iterator which may be more generically useful in the future.
  zipSequence.__iterate = function(fn, reverse) {
    var this$1 = this;

    /* generic:
    var iterator = this.__iterator(ITERATE_ENTRIES, reverse);
    var step;
    var iterations = 0;
    while (!(step = iterator.next()).done) {
      iterations++;
      if (fn(step.value[1], step.value[0], this) === false) {
        break;
      }
    }
    return iterations;
    */
    // indexed:
    var iterator = this.__iterator(ITERATE_VALUES, reverse);
    var step;
    var iterations = 0;
    while (!(step = iterator.next()).done) {
      if (fn(step.value, iterations++, this$1) === false) {
        break;
      }
    }
    return iterations;
  };
  zipSequence.__iteratorUncached = function(type, reverse) {
    var iterators = iters.map(
      function (i) { return ((i = Collection(i)), getIterator(reverse ? i.reverse() : i)); }
    );
    var iterations = 0;
    var isDone = false;
    return new Iterator(function () {
      var steps;
      if (!isDone) {
        steps = iterators.map(function (i) { return i.next(); });
        isDone = zipAll ? steps.every(function (s) { return s.done; }) : steps.some(function (s) { return s.done; });
      }
      if (isDone) {
        return iteratorDone();
      }
      return iteratorValue(
        type,
        iterations++,
        zipper.apply(null, steps.map(function (s) { return s.value; }))
      );
    });
  };
  return zipSequence;
}

// #pragma Helper Functions

function reify(iter, seq) {
  return iter === seq ? iter : isSeq(iter) ? seq : iter.constructor(seq);
}

function validateEntry(entry) {
  if (entry !== Object(entry)) {
    throw new TypeError('Expected [K, V] tuple: ' + entry);
  }
}

function collectionClass(collection) {
  return isKeyed(collection)
    ? KeyedCollection
    : isIndexed(collection) ? IndexedCollection : SetCollection;
}

function makeSequence(collection) {
  return Object.create(
    (isKeyed(collection)
      ? KeyedSeq
      : isIndexed(collection) ? IndexedSeq : SetSeq
    ).prototype
  );
}

function cacheResultThrough() {
  if (this._iter.cacheResult) {
    this._iter.cacheResult();
    this.size = this._iter.size;
    return this;
  }
  return Seq.prototype.cacheResult.call(this);
}

function defaultComparator(a, b) {
  if (a === undefined && b === undefined) {
    return 0;
  }

  if (a === undefined) {
    return 1;
  }

  if (b === undefined) {
    return -1;
  }

  return a > b ? 1 : a < b ? -1 : 0;
}

// http://jsperf.com/copy-array-inline
function arrCopy(arr, offset) {
  offset = offset || 0;
  var len = Math.max(0, arr.length - offset);
  var newArr = new Array(len);
  for (var ii = 0; ii < len; ii++) {
    newArr[ii] = arr[ii + offset];
  }
  return newArr;
}

function invariant(condition, error) {
  if (!condition) { throw new Error(error); }
}

function assertNotInfinite(size) {
  invariant(
    size !== Infinity,
    'Cannot perform this action with an infinite size.'
  );
}

function coerceKeyPath(keyPath) {
  if (isArrayLike(keyPath) && typeof keyPath !== 'string') {
    return keyPath;
  }
  if (isOrdered(keyPath)) {
    return keyPath.toArray();
  }
  throw new TypeError(
    'Invalid keyPath: expected Ordered Collection or Array: ' + keyPath
  );
}

function isPlainObj(value) {
  return (
    value && (value.constructor === Object || value.constructor === undefined)
  );
}

/**
 * Returns true if the value is a potentially-persistent data structure, either
 * provided by Immutable.js or a plain Array or Object.
 */
function isDataStructure(value) {
  return isImmutable(value) || Array.isArray(value) || isPlainObj(value);
}

/**
 * Converts a value to a string, adding quotes if a string was provided.
 */
function quoteString(value) {
  try {
    return typeof value === 'string' ? JSON.stringify(value) : String(value);
  } catch (_ignoreError) {
    return JSON.stringify(value);
  }
}

function has(collection, key) {
  return isImmutable(collection)
    ? collection.has(key)
    : isDataStructure(collection) && hasOwnProperty.call(collection, key);
}

function get(collection, key, notSetValue) {
  return isImmutable(collection)
    ? collection.get(key, notSetValue)
    : !has(collection, key)
      ? notSetValue
      : typeof collection.get === 'function'
        ? collection.get(key)
        : collection[key];
}

function shallowCopy(from) {
  if (Array.isArray(from)) {
    return arrCopy(from);
  }
  var to = {};
  for (var key in from) {
    if (hasOwnProperty.call(from, key)) {
      to[key] = from[key];
    }
  }
  return to;
}

function remove(collection, key) {
  if (!isDataStructure(collection)) {
    throw new TypeError(
      'Cannot update non-data-structure value: ' + collection
    );
  }
  if (isImmutable(collection)) {
    if (!collection.remove) {
      throw new TypeError(
        'Cannot update immutable value without .remove() method: ' + collection
      );
    }
    return collection.remove(key);
  }
  if (!hasOwnProperty.call(collection, key)) {
    return collection;
  }
  var collectionCopy = shallowCopy(collection);
  if (Array.isArray(collectionCopy)) {
    collectionCopy.splice(key, 1);
  } else {
    delete collectionCopy[key];
  }
  return collectionCopy;
}

function set(collection, key, value) {
  if (!isDataStructure(collection)) {
    throw new TypeError(
      'Cannot update non-data-structure value: ' + collection
    );
  }
  if (isImmutable(collection)) {
    if (!collection.set) {
      throw new TypeError(
        'Cannot update immutable value without .set() method: ' + collection
      );
    }
    return collection.set(key, value);
  }
  if (hasOwnProperty.call(collection, key) && value === collection[key]) {
    return collection;
  }
  var collectionCopy = shallowCopy(collection);
  collectionCopy[key] = value;
  return collectionCopy;
}

function updateIn(collection, keyPath, notSetValue, updater) {
  if (!updater) {
    updater = notSetValue;
    notSetValue = undefined;
  }
  var updatedValue = updateInDeeply(
    isImmutable(collection),
    collection,
    coerceKeyPath(keyPath),
    0,
    notSetValue,
    updater
  );
  return updatedValue === NOT_SET ? notSetValue : updatedValue;
}

function updateInDeeply(
  inImmutable,
  existing,
  keyPath,
  i,
  notSetValue,
  updater
) {
  var wasNotSet = existing === NOT_SET;
  if (i === keyPath.length) {
    var existingValue = wasNotSet ? notSetValue : existing;
    var newValue = updater(existingValue);
    return newValue === existingValue ? existing : newValue;
  }
  if (!wasNotSet && !isDataStructure(existing)) {
    throw new TypeError(
      'Cannot update within non-data-structure value in path [' +
        keyPath.slice(0, i).map(quoteString) +
        ']: ' +
        existing
    );
  }
  var key = keyPath[i];
  var nextExisting = wasNotSet ? NOT_SET : get(existing, key, NOT_SET);
  var nextUpdated = updateInDeeply(
    nextExisting === NOT_SET ? inImmutable : isImmutable(nextExisting),
    nextExisting,
    keyPath,
    i + 1,
    notSetValue,
    updater
  );
  return nextUpdated === nextExisting
    ? existing
    : nextUpdated === NOT_SET
      ? remove(existing, key)
      : set(
          wasNotSet ? (inImmutable ? emptyMap() : {}) : existing,
          key,
          nextUpdated
        );
}

function setIn$1(collection, keyPath, value) {
  return updateIn(collection, keyPath, NOT_SET, function () { return value; });
}

function setIn$$1(keyPath, v) {
  return setIn$1(this, keyPath, v);
}

function removeIn(collection, keyPath) {
  return updateIn(collection, keyPath, function () { return NOT_SET; });
}

function deleteIn(keyPath) {
  return removeIn(this, keyPath);
}

function update$1(collection, key, notSetValue, updater) {
  return updateIn(collection, [key], notSetValue, updater);
}

function update$$1(key, notSetValue, updater) {
  return arguments.length === 1
    ? key(this)
    : update$1(this, key, notSetValue, updater);
}

function updateIn$1(keyPath, notSetValue, updater) {
  return updateIn(this, keyPath, notSetValue, updater);
}

function merge() {
  var iters = [], len = arguments.length;
  while ( len-- ) iters[ len ] = arguments[ len ];

  return mergeIntoKeyedWith(this, iters);
}

function mergeWith(merger) {
  var iters = [], len = arguments.length - 1;
  while ( len-- > 0 ) iters[ len ] = arguments[ len + 1 ];

  return mergeIntoKeyedWith(this, iters, merger);
}

function mergeIntoKeyedWith(collection, collections, merger) {
  var iters = [];
  for (var ii = 0; ii < collections.length; ii++) {
    var collection$1 = KeyedCollection(collections[ii]);
    if (collection$1.size !== 0) {
      iters.push(collection$1);
    }
  }
  if (iters.length === 0) {
    return collection;
  }
  if (collection.size === 0 && !collection.__ownerID && iters.length === 1) {
    return collection.constructor(iters[0]);
  }
  return collection.withMutations(function (collection) {
    var mergeIntoCollection = merger
      ? function (value, key) {
          update$1(
            collection,
            key,
            NOT_SET,
            function (oldVal) { return (oldVal === NOT_SET ? value : merger(oldVal, value, key)); }
          );
        }
      : function (value, key) {
          collection.set(key, value);
        };
    for (var ii = 0; ii < iters.length; ii++) {
      iters[ii].forEach(mergeIntoCollection);
    }
  });
}

function merge$1(collection) {
  var sources = [], len = arguments.length - 1;
  while ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];

  return mergeWithSources(collection, sources);
}

function mergeWith$1(merger, collection) {
  var sources = [], len = arguments.length - 2;
  while ( len-- > 0 ) sources[ len ] = arguments[ len + 2 ];

  return mergeWithSources(collection, sources, merger);
}

function mergeDeep$1(collection) {
  var sources = [], len = arguments.length - 1;
  while ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];

  return mergeDeepWithSources(collection, sources);
}

function mergeDeepWith$1(merger, collection) {
  var sources = [], len = arguments.length - 2;
  while ( len-- > 0 ) sources[ len ] = arguments[ len + 2 ];

  return mergeDeepWithSources(collection, sources, merger);
}

function mergeDeepWithSources(collection, sources, merger) {
  return mergeWithSources(collection, sources, deepMergerWith(merger));
}

function mergeWithSources(collection, sources, merger) {
  if (!isDataStructure(collection)) {
    throw new TypeError(
      'Cannot merge into non-data-structure value: ' + collection
    );
  }
  if (isImmutable(collection)) {
    return collection.mergeWith
      ? collection.mergeWith.apply(collection, [ merger ].concat( sources ))
      : collection.concat.apply(collection, sources);
  }
  var isArray = Array.isArray(collection);
  var merged = collection;
  var Collection$$1 = isArray ? IndexedCollection : KeyedCollection;
  var mergeItem = isArray
    ? function (value) {
        // Copy on write
        if (merged === collection) {
          merged = shallowCopy(merged);
        }
        merged.push(value);
      }
    : function (value, key) {
        var hasVal = hasOwnProperty.call(merged, key);
        var nextVal =
          hasVal && merger ? merger(merged[key], value, key) : value;
        if (!hasVal || nextVal !== merged[key]) {
          // Copy on write
          if (merged === collection) {
            merged = shallowCopy(merged);
          }
          merged[key] = nextVal;
        }
      };
  for (var i = 0; i < sources.length; i++) {
    Collection$$1(sources[i]).forEach(mergeItem);
  }
  return merged;
}

function deepMergerWith(merger) {
  function deepMerger(oldValue, newValue, key) {
    return isDataStructure(oldValue) && isDataStructure(newValue)
      ? mergeWithSources(oldValue, [newValue], deepMerger)
      : merger ? merger(oldValue, newValue, key) : newValue;
  }
  return deepMerger;
}

function mergeDeep() {
  var iters = [], len = arguments.length;
  while ( len-- ) iters[ len ] = arguments[ len ];

  return mergeDeepWithSources(this, iters);
}

function mergeDeepWith(merger) {
  var iters = [], len = arguments.length - 1;
  while ( len-- > 0 ) iters[ len ] = arguments[ len + 1 ];

  return mergeDeepWithSources(this, iters, merger);
}

function mergeIn(keyPath) {
  var iters = [], len = arguments.length - 1;
  while ( len-- > 0 ) iters[ len ] = arguments[ len + 1 ];

  return updateIn(this, keyPath, emptyMap(), function (m) { return mergeWithSources(m, iters); });
}

function mergeDeepIn(keyPath) {
  var iters = [], len = arguments.length - 1;
  while ( len-- > 0 ) iters[ len ] = arguments[ len + 1 ];

  return updateIn(this, keyPath, emptyMap(), function (m) { return mergeDeepWithSources(m, iters); }
  );
}

function withMutations(fn) {
  var mutable = this.asMutable();
  fn(mutable);
  return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
}

function asMutable() {
  return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
}

function asImmutable() {
  return this.__ensureOwner();
}

function wasAltered() {
  return this.__altered;
}

var Map = (function (KeyedCollection$$1) {
  function Map(value) {
    return value === null || value === undefined
      ? emptyMap()
      : isMap(value) && !isOrdered(value)
        ? value
        : emptyMap().withMutations(function (map) {
            var iter = KeyedCollection$$1(value);
            assertNotInfinite(iter.size);
            iter.forEach(function (v, k) { return map.set(k, v); });
          });
  }

  if ( KeyedCollection$$1 ) Map.__proto__ = KeyedCollection$$1;
  Map.prototype = Object.create( KeyedCollection$$1 && KeyedCollection$$1.prototype );
  Map.prototype.constructor = Map;

  Map.of = function of () {
    var keyValues = [], len = arguments.length;
    while ( len-- ) keyValues[ len ] = arguments[ len ];

    return emptyMap().withMutations(function (map) {
      for (var i = 0; i < keyValues.length; i += 2) {
        if (i + 1 >= keyValues.length) {
          throw new Error('Missing value for key: ' + keyValues[i]);
        }
        map.set(keyValues[i], keyValues[i + 1]);
      }
    });
  };

  Map.prototype.toString = function toString () {
    return this.__toString('Map {', '}');
  };

  // @pragma Access

  Map.prototype.get = function get (k, notSetValue) {
    return this._root
      ? this._root.get(0, undefined, k, notSetValue)
      : notSetValue;
  };

  // @pragma Modification

  Map.prototype.set = function set (k, v) {
    return updateMap(this, k, v);
  };

  Map.prototype.remove = function remove (k) {
    return updateMap(this, k, NOT_SET);
  };

  Map.prototype.deleteAll = function deleteAll (keys) {
    var collection = Collection(keys);

    if (collection.size === 0) {
      return this;
    }

    return this.withMutations(function (map) {
      collection.forEach(function (key) { return map.remove(key); });
    });
  };

  Map.prototype.clear = function clear () {
    if (this.size === 0) {
      return this;
    }
    if (this.__ownerID) {
      this.size = 0;
      this._root = null;
      this.__hash = undefined;
      this.__altered = true;
      return this;
    }
    return emptyMap();
  };

  // @pragma Composition

  Map.prototype.sort = function sort (comparator) {
    // Late binding
    return OrderedMap(sortFactory(this, comparator));
  };

  Map.prototype.sortBy = function sortBy (mapper, comparator) {
    // Late binding
    return OrderedMap(sortFactory(this, comparator, mapper));
  };

  // @pragma Mutability

  Map.prototype.__iterator = function __iterator (type, reverse) {
    return new MapIterator(this, type, reverse);
  };

  Map.prototype.__iterate = function __iterate (fn, reverse) {
    var this$1 = this;

    var iterations = 0;
    this._root &&
      this._root.iterate(function (entry) {
        iterations++;
        return fn(entry[1], entry[0], this$1);
      }, reverse);
    return iterations;
  };

  Map.prototype.__ensureOwner = function __ensureOwner (ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }
    if (!ownerID) {
      if (this.size === 0) {
        return emptyMap();
      }
      this.__ownerID = ownerID;
      this.__altered = false;
      return this;
    }
    return makeMap(this.size, this._root, ownerID, this.__hash);
  };

  return Map;
}(KeyedCollection));

function isMap(maybeMap) {
  return !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);
}

Map.isMap = isMap;

var IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';

var MapPrototype = Map.prototype;
MapPrototype[IS_MAP_SENTINEL] = true;
MapPrototype[DELETE] = MapPrototype.remove;
MapPrototype.removeAll = MapPrototype.deleteAll;
MapPrototype.concat = MapPrototype.merge;
MapPrototype.setIn = setIn$$1;
MapPrototype.removeIn = MapPrototype.deleteIn = deleteIn;
MapPrototype.update = update$$1;
MapPrototype.updateIn = updateIn$1;
MapPrototype.merge = merge;
MapPrototype.mergeWith = mergeWith;
MapPrototype.mergeDeep = mergeDeep;
MapPrototype.mergeDeepWith = mergeDeepWith;
MapPrototype.mergeIn = mergeIn;
MapPrototype.mergeDeepIn = mergeDeepIn;
MapPrototype.withMutations = withMutations;
MapPrototype.wasAltered = wasAltered;
MapPrototype.asImmutable = asImmutable;
MapPrototype['@@transducer/init'] = MapPrototype.asMutable = asMutable;
MapPrototype['@@transducer/step'] = function(result, arr) {
  return result.set(arr[0], arr[1]);
};
MapPrototype['@@transducer/result'] = function(obj) {
  return obj.asImmutable();
};

// #pragma Trie Nodes

var ArrayMapNode = function ArrayMapNode(ownerID, entries) {
  this.ownerID = ownerID;
  this.entries = entries;
};

ArrayMapNode.prototype.get = function get (shift, keyHash, key, notSetValue) {
  var entries = this.entries;
  for (var ii = 0, len = entries.length; ii < len; ii++) {
    if (is(key, entries[ii][0])) {
      return entries[ii][1];
    }
  }
  return notSetValue;
};

ArrayMapNode.prototype.update = function update$$1 (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
  var removed = value === NOT_SET;

  var entries = this.entries;
  var idx = 0;
  var len = entries.length;
  for (; idx < len; idx++) {
    if (is(key, entries[idx][0])) {
      break;
    }
  }
  var exists = idx < len;

  if (exists ? entries[idx][1] === value : removed) {
    return this;
  }

  SetRef(didAlter);
  (removed || !exists) && SetRef(didChangeSize);

  if (removed && entries.length === 1) {
    return; // undefined
  }

  if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {
    return createNodes(ownerID, entries, key, value);
  }

  var isEditable = ownerID && ownerID === this.ownerID;
  var newEntries = isEditable ? entries : arrCopy(entries);

  if (exists) {
    if (removed) {
      idx === len - 1
        ? newEntries.pop()
        : (newEntries[idx] = newEntries.pop());
    } else {
      newEntries[idx] = [key, value];
    }
  } else {
    newEntries.push([key, value]);
  }

  if (isEditable) {
    this.entries = newEntries;
    return this;
  }

  return new ArrayMapNode(ownerID, newEntries);
};

var BitmapIndexedNode = function BitmapIndexedNode(ownerID, bitmap, nodes) {
  this.ownerID = ownerID;
  this.bitmap = bitmap;
  this.nodes = nodes;
};

BitmapIndexedNode.prototype.get = function get (shift, keyHash, key, notSetValue) {
  if (keyHash === undefined) {
    keyHash = hash(key);
  }
  var bit = 1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK);
  var bitmap = this.bitmap;
  return (bitmap & bit) === 0
    ? notSetValue
    : this.nodes[popCount(bitmap & (bit - 1))].get(
        shift + SHIFT,
        keyHash,
        key,
        notSetValue
      );
};

BitmapIndexedNode.prototype.update = function update$$1 (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
  if (keyHash === undefined) {
    keyHash = hash(key);
  }
  var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
  var bit = 1 << keyHashFrag;
  var bitmap = this.bitmap;
  var exists = (bitmap & bit) !== 0;

  if (!exists && value === NOT_SET) {
    return this;
  }

  var idx = popCount(bitmap & (bit - 1));
  var nodes = this.nodes;
  var node = exists ? nodes[idx] : undefined;
  var newNode = updateNode(
    node,
    ownerID,
    shift + SHIFT,
    keyHash,
    key,
    value,
    didChangeSize,
    didAlter
  );

  if (newNode === node) {
    return this;
  }

  if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {
    return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);
  }

  if (
    exists &&
    !newNode &&
    nodes.length === 2 &&
    isLeafNode(nodes[idx ^ 1])
  ) {
    return nodes[idx ^ 1];
  }

  if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {
    return newNode;
  }

  var isEditable = ownerID && ownerID === this.ownerID;
  var newBitmap = exists ? (newNode ? bitmap : bitmap ^ bit) : bitmap | bit;
  var newNodes = exists
    ? newNode
      ? setAt(nodes, idx, newNode, isEditable)
      : spliceOut(nodes, idx, isEditable)
    : spliceIn(nodes, idx, newNode, isEditable);

  if (isEditable) {
    this.bitmap = newBitmap;
    this.nodes = newNodes;
    return this;
  }

  return new BitmapIndexedNode(ownerID, newBitmap, newNodes);
};

var HashArrayMapNode = function HashArrayMapNode(ownerID, count, nodes) {
  this.ownerID = ownerID;
  this.count = count;
  this.nodes = nodes;
};

HashArrayMapNode.prototype.get = function get (shift, keyHash, key, notSetValue) {
  if (keyHash === undefined) {
    keyHash = hash(key);
  }
  var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
  var node = this.nodes[idx];
  return node
    ? node.get(shift + SHIFT, keyHash, key, notSetValue)
    : notSetValue;
};

HashArrayMapNode.prototype.update = function update$$1 (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
  if (keyHash === undefined) {
    keyHash = hash(key);
  }
  var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
  var removed = value === NOT_SET;
  var nodes = this.nodes;
  var node = nodes[idx];

  if (removed && !node) {
    return this;
  }

  var newNode = updateNode(
    node,
    ownerID,
    shift + SHIFT,
    keyHash,
    key,
    value,
    didChangeSize,
    didAlter
  );
  if (newNode === node) {
    return this;
  }

  var newCount = this.count;
  if (!node) {
    newCount++;
  } else if (!newNode) {
    newCount--;
    if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {
      return packNodes(ownerID, nodes, newCount, idx);
    }
  }

  var isEditable = ownerID && ownerID === this.ownerID;
  var newNodes = setAt(nodes, idx, newNode, isEditable);

  if (isEditable) {
    this.count = newCount;
    this.nodes = newNodes;
    return this;
  }

  return new HashArrayMapNode(ownerID, newCount, newNodes);
};

var HashCollisionNode = function HashCollisionNode(ownerID, keyHash, entries) {
  this.ownerID = ownerID;
  this.keyHash = keyHash;
  this.entries = entries;
};

HashCollisionNode.prototype.get = function get (shift, keyHash, key, notSetValue) {
  var entries = this.entries;
  for (var ii = 0, len = entries.length; ii < len; ii++) {
    if (is(key, entries[ii][0])) {
      return entries[ii][1];
    }
  }
  return notSetValue;
};

HashCollisionNode.prototype.update = function update$$1 (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
  if (keyHash === undefined) {
    keyHash = hash(key);
  }

  var removed = value === NOT_SET;

  if (keyHash !== this.keyHash) {
    if (removed) {
      return this;
    }
    SetRef(didAlter);
    SetRef(didChangeSize);
    return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);
  }

  var entries = this.entries;
  var idx = 0;
  var len = entries.length;
  for (; idx < len; idx++) {
    if (is(key, entries[idx][0])) {
      break;
    }
  }
  var exists = idx < len;

  if (exists ? entries[idx][1] === value : removed) {
    return this;
  }

  SetRef(didAlter);
  (removed || !exists) && SetRef(didChangeSize);

  if (removed && len === 2) {
    return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);
  }

  var isEditable = ownerID && ownerID === this.ownerID;
  var newEntries = isEditable ? entries : arrCopy(entries);

  if (exists) {
    if (removed) {
      idx === len - 1
        ? newEntries.pop()
        : (newEntries[idx] = newEntries.pop());
    } else {
      newEntries[idx] = [key, value];
    }
  } else {
    newEntries.push([key, value]);
  }

  if (isEditable) {
    this.entries = newEntries;
    return this;
  }

  return new HashCollisionNode(ownerID, this.keyHash, newEntries);
};

var ValueNode = function ValueNode(ownerID, keyHash, entry) {
  this.ownerID = ownerID;
  this.keyHash = keyHash;
  this.entry = entry;
};

ValueNode.prototype.get = function get (shift, keyHash, key, notSetValue) {
  return is(key, this.entry[0]) ? this.entry[1] : notSetValue;
};

ValueNode.prototype.update = function update$$1 (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
  var removed = value === NOT_SET;
  var keyMatch = is(key, this.entry[0]);
  if (keyMatch ? value === this.entry[1] : removed) {
    return this;
  }

  SetRef(didAlter);

  if (removed) {
    SetRef(didChangeSize);
    return; // undefined
  }

  if (keyMatch) {
    if (ownerID && ownerID === this.ownerID) {
      this.entry[1] = value;
      return this;
    }
    return new ValueNode(ownerID, this.keyHash, [key, value]);
  }

  SetRef(didChangeSize);
  return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);
};

// #pragma Iterators

ArrayMapNode.prototype.iterate = HashCollisionNode.prototype.iterate = function(
  fn,
  reverse
) {
  var entries = this.entries;
  for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {
    if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {
      return false;
    }
  }
};

BitmapIndexedNode.prototype.iterate = HashArrayMapNode.prototype.iterate = function(
  fn,
  reverse
) {
  var nodes = this.nodes;
  for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {
    var node = nodes[reverse ? maxIndex - ii : ii];
    if (node && node.iterate(fn, reverse) === false) {
      return false;
    }
  }
};

// eslint-disable-next-line no-unused-vars
ValueNode.prototype.iterate = function(fn, reverse) {
  return fn(this.entry);
};

var MapIterator = (function (Iterator$$1) {
  function MapIterator(map, type, reverse) {
    this._type = type;
    this._reverse = reverse;
    this._stack = map._root && mapIteratorFrame(map._root);
  }

  if ( Iterator$$1 ) MapIterator.__proto__ = Iterator$$1;
  MapIterator.prototype = Object.create( Iterator$$1 && Iterator$$1.prototype );
  MapIterator.prototype.constructor = MapIterator;

  MapIterator.prototype.next = function next () {
    var this$1 = this;

    var type = this._type;
    var stack = this._stack;
    while (stack) {
      var node = stack.node;
      var index = stack.index++;
      var maxIndex = (void 0);
      if (node.entry) {
        if (index === 0) {
          return mapIteratorValue(type, node.entry);
        }
      } else if (node.entries) {
        maxIndex = node.entries.length - 1;
        if (index <= maxIndex) {
          return mapIteratorValue(
            type,
            node.entries[this$1._reverse ? maxIndex - index : index]
          );
        }
      } else {
        maxIndex = node.nodes.length - 1;
        if (index <= maxIndex) {
          var subNode = node.nodes[this$1._reverse ? maxIndex - index : index];
          if (subNode) {
            if (subNode.entry) {
              return mapIteratorValue(type, subNode.entry);
            }
            stack = this$1._stack = mapIteratorFrame(subNode, stack);
          }
          continue;
        }
      }
      stack = this$1._stack = this$1._stack.__prev;
    }
    return iteratorDone();
  };

  return MapIterator;
}(Iterator));

function mapIteratorValue(type, entry) {
  return iteratorValue(type, entry[0], entry[1]);
}

function mapIteratorFrame(node, prev) {
  return {
    node: node,
    index: 0,
    __prev: prev
  };
}

function makeMap(size, root, ownerID, hash$$1) {
  var map = Object.create(MapPrototype);
  map.size = size;
  map._root = root;
  map.__ownerID = ownerID;
  map.__hash = hash$$1;
  map.__altered = false;
  return map;
}

var EMPTY_MAP;
function emptyMap() {
  return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
}

function updateMap(map, k, v) {
  var newRoot;
  var newSize;
  if (!map._root) {
    if (v === NOT_SET) {
      return map;
    }
    newSize = 1;
    newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);
  } else {
    var didChangeSize = MakeRef(CHANGE_LENGTH);
    var didAlter = MakeRef(DID_ALTER);
    newRoot = updateNode(
      map._root,
      map.__ownerID,
      0,
      undefined,
      k,
      v,
      didChangeSize,
      didAlter
    );
    if (!didAlter.value) {
      return map;
    }
    newSize = map.size + (didChangeSize.value ? (v === NOT_SET ? -1 : 1) : 0);
  }
  if (map.__ownerID) {
    map.size = newSize;
    map._root = newRoot;
    map.__hash = undefined;
    map.__altered = true;
    return map;
  }
  return newRoot ? makeMap(newSize, newRoot) : emptyMap();
}

function updateNode(
  node,
  ownerID,
  shift,
  keyHash,
  key,
  value,
  didChangeSize,
  didAlter
) {
  if (!node) {
    if (value === NOT_SET) {
      return node;
    }
    SetRef(didAlter);
    SetRef(didChangeSize);
    return new ValueNode(ownerID, keyHash, [key, value]);
  }
  return node.update(
    ownerID,
    shift,
    keyHash,
    key,
    value,
    didChangeSize,
    didAlter
  );
}

function isLeafNode(node) {
  return (
    node.constructor === ValueNode || node.constructor === HashCollisionNode
  );
}

function mergeIntoNode(node, ownerID, shift, keyHash, entry) {
  if (node.keyHash === keyHash) {
    return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);
  }

  var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;
  var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;

  var newNode;
  var nodes =
    idx1 === idx2
      ? [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)]
      : ((newNode = new ValueNode(ownerID, keyHash, entry)),
        idx1 < idx2 ? [node, newNode] : [newNode, node]);

  return new BitmapIndexedNode(ownerID, (1 << idx1) | (1 << idx2), nodes);
}

function createNodes(ownerID, entries, key, value) {
  if (!ownerID) {
    ownerID = new OwnerID();
  }
  var node = new ValueNode(ownerID, hash(key), [key, value]);
  for (var ii = 0; ii < entries.length; ii++) {
    var entry = entries[ii];
    node = node.update(ownerID, 0, undefined, entry[0], entry[1]);
  }
  return node;
}

function packNodes(ownerID, nodes, count, excluding) {
  var bitmap = 0;
  var packedII = 0;
  var packedNodes = new Array(count);
  for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {
    var node = nodes[ii];
    if (node !== undefined && ii !== excluding) {
      bitmap |= bit;
      packedNodes[packedII++] = node;
    }
  }
  return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
}

function expandNodes(ownerID, nodes, bitmap, including, node) {
  var count = 0;
  var expandedNodes = new Array(SIZE);
  for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
    expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;
  }
  expandedNodes[including] = node;
  return new HashArrayMapNode(ownerID, count + 1, expandedNodes);
}

function popCount(x) {
  x -= (x >> 1) & 0x55555555;
  x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
  x = (x + (x >> 4)) & 0x0f0f0f0f;
  x += x >> 8;
  x += x >> 16;
  return x & 0x7f;
}

function setAt(array, idx, val, canEdit) {
  var newArray = canEdit ? array : arrCopy(array);
  newArray[idx] = val;
  return newArray;
}

function spliceIn(array, idx, val, canEdit) {
  var newLen = array.length + 1;
  if (canEdit && idx + 1 === newLen) {
    array[idx] = val;
    return array;
  }
  var newArray = new Array(newLen);
  var after = 0;
  for (var ii = 0; ii < newLen; ii++) {
    if (ii === idx) {
      newArray[ii] = val;
      after = -1;
    } else {
      newArray[ii] = array[ii + after];
    }
  }
  return newArray;
}

function spliceOut(array, idx, canEdit) {
  var newLen = array.length - 1;
  if (canEdit && idx === newLen) {
    array.pop();
    return array;
  }
  var newArray = new Array(newLen);
  var after = 0;
  for (var ii = 0; ii < newLen; ii++) {
    if (ii === idx) {
      after = 1;
    }
    newArray[ii] = array[ii + after];
  }
  return newArray;
}

var MAX_ARRAY_MAP_SIZE = SIZE / 4;
var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;
var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;

var List = (function (IndexedCollection$$1) {
  function List(value) {
    var empty = emptyList();
    if (value === null || value === undefined) {
      return empty;
    }
    if (isList(value)) {
      return value;
    }
    var iter = IndexedCollection$$1(value);
    var size = iter.size;
    if (size === 0) {
      return empty;
    }
    assertNotInfinite(size);
    if (size > 0 && size < SIZE) {
      return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));
    }
    return empty.withMutations(function (list) {
      list.setSize(size);
      iter.forEach(function (v, i) { return list.set(i, v); });
    });
  }

  if ( IndexedCollection$$1 ) List.__proto__ = IndexedCollection$$1;
  List.prototype = Object.create( IndexedCollection$$1 && IndexedCollection$$1.prototype );
  List.prototype.constructor = List;

  List.of = function of (/*...values*/) {
    return this(arguments);
  };

  List.prototype.toString = function toString () {
    return this.__toString('List [', ']');
  };

  // @pragma Access

  List.prototype.get = function get (index, notSetValue) {
    index = wrapIndex(this, index);
    if (index >= 0 && index < this.size) {
      index += this._origin;
      var node = listNodeFor(this, index);
      return node && node.array[index & MASK];
    }
    return notSetValue;
  };

  // @pragma Modification

  List.prototype.set = function set (index, value) {
    return updateList(this, index, value);
  };

  List.prototype.remove = function remove (index) {
    return !this.has(index)
      ? this
      : index === 0
        ? this.shift()
        : index === this.size - 1 ? this.pop() : this.splice(index, 1);
  };

  List.prototype.insert = function insert (index, value) {
    return this.splice(index, 0, value);
  };

  List.prototype.clear = function clear () {
    if (this.size === 0) {
      return this;
    }
    if (this.__ownerID) {
      this.size = this._origin = this._capacity = 0;
      this._level = SHIFT;
      this._root = this._tail = null;
      this.__hash = undefined;
      this.__altered = true;
      return this;
    }
    return emptyList();
  };

  List.prototype.push = function push (/*...values*/) {
    var values = arguments;
    var oldSize = this.size;
    return this.withMutations(function (list) {
      setListBounds(list, 0, oldSize + values.length);
      for (var ii = 0; ii < values.length; ii++) {
        list.set(oldSize + ii, values[ii]);
      }
    });
  };

  List.prototype.pop = function pop () {
    return setListBounds(this, 0, -1);
  };

  List.prototype.unshift = function unshift (/*...values*/) {
    var values = arguments;
    return this.withMutations(function (list) {
      setListBounds(list, -values.length);
      for (var ii = 0; ii < values.length; ii++) {
        list.set(ii, values[ii]);
      }
    });
  };

  List.prototype.shift = function shift () {
    return setListBounds(this, 1);
  };

  // @pragma Composition

  List.prototype.concat = function concat (/*...collections*/) {
    var arguments$1 = arguments;

    var seqs = [];
    for (var i = 0; i < arguments.length; i++) {
      var argument = arguments$1[i];
      var seq = IndexedCollection$$1(
        typeof argument !== 'string' && hasIterator(argument)
          ? argument
          : [argument]
      );
      if (seq.size !== 0) {
        seqs.push(seq);
      }
    }
    if (seqs.length === 0) {
      return this;
    }
    if (this.size === 0 && !this.__ownerID && seqs.length === 1) {
      return this.constructor(seqs[0]);
    }
    return this.withMutations(function (list) {
      seqs.forEach(function (seq) { return seq.forEach(function (value) { return list.push(value); }); });
    });
  };

  List.prototype.setSize = function setSize (size) {
    return setListBounds(this, 0, size);
  };

  // @pragma Iteration

  List.prototype.slice = function slice (begin, end) {
    var size = this.size;
    if (wholeSlice(begin, end, size)) {
      return this;
    }
    return setListBounds(
      this,
      resolveBegin(begin, size),
      resolveEnd(end, size)
    );
  };

  List.prototype.__iterator = function __iterator (type, reverse) {
    var index = reverse ? this.size : 0;
    var values = iterateList(this, reverse);
    return new Iterator(function () {
      var value = values();
      return value === DONE
        ? iteratorDone()
        : iteratorValue(type, reverse ? --index : index++, value);
    });
  };

  List.prototype.__iterate = function __iterate (fn, reverse) {
    var this$1 = this;

    var index = reverse ? this.size : 0;
    var values = iterateList(this, reverse);
    var value;
    while ((value = values()) !== DONE) {
      if (fn(value, reverse ? --index : index++, this$1) === false) {
        break;
      }
    }
    return index;
  };

  List.prototype.__ensureOwner = function __ensureOwner (ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }
    if (!ownerID) {
      if (this.size === 0) {
        return emptyList();
      }
      this.__ownerID = ownerID;
      this.__altered = false;
      return this;
    }
    return makeList(
      this._origin,
      this._capacity,
      this._level,
      this._root,
      this._tail,
      ownerID,
      this.__hash
    );
  };

  return List;
}(IndexedCollection));

function isList(maybeList) {
  return !!(maybeList && maybeList[IS_LIST_SENTINEL]);
}

List.isList = isList;

var IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';

var ListPrototype = List.prototype;
ListPrototype[IS_LIST_SENTINEL] = true;
ListPrototype[DELETE] = ListPrototype.remove;
ListPrototype.merge = ListPrototype.concat;
ListPrototype.setIn = setIn$$1;
ListPrototype.deleteIn = ListPrototype.removeIn = deleteIn;
ListPrototype.update = update$$1;
ListPrototype.updateIn = updateIn$1;
ListPrototype.mergeIn = mergeIn;
ListPrototype.mergeDeepIn = mergeDeepIn;
ListPrototype.withMutations = withMutations;
ListPrototype.wasAltered = wasAltered;
ListPrototype.asImmutable = asImmutable;
ListPrototype['@@transducer/init'] = ListPrototype.asMutable = asMutable;
ListPrototype['@@transducer/step'] = function(result, arr) {
  return result.push(arr);
};
ListPrototype['@@transducer/result'] = function(obj) {
  return obj.asImmutable();
};

var VNode = function VNode(array, ownerID) {
  this.array = array;
  this.ownerID = ownerID;
};

// TODO: seems like these methods are very similar

VNode.prototype.removeBefore = function removeBefore (ownerID, level, index) {
  if (index === level ? 1 << level : 0 || this.array.length === 0) {
    return this;
  }
  var originIndex = (index >>> level) & MASK;
  if (originIndex >= this.array.length) {
    return new VNode([], ownerID);
  }
  var removingFirst = originIndex === 0;
  var newChild;
  if (level > 0) {
    var oldChild = this.array[originIndex];
    newChild =
      oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);
    if (newChild === oldChild && removingFirst) {
      return this;
    }
  }
  if (removingFirst && !newChild) {
    return this;
  }
  var editable = editableVNode(this, ownerID);
  if (!removingFirst) {
    for (var ii = 0; ii < originIndex; ii++) {
      editable.array[ii] = undefined;
    }
  }
  if (newChild) {
    editable.array[originIndex] = newChild;
  }
  return editable;
};

VNode.prototype.removeAfter = function removeAfter (ownerID, level, index) {
  if (index === (level ? 1 << level : 0) || this.array.length === 0) {
    return this;
  }
  var sizeIndex = ((index - 1) >>> level) & MASK;
  if (sizeIndex >= this.array.length) {
    return this;
  }

  var newChild;
  if (level > 0) {
    var oldChild = this.array[sizeIndex];
    newChild =
      oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);
    if (newChild === oldChild && sizeIndex === this.array.length - 1) {
      return this;
    }
  }

  var editable = editableVNode(this, ownerID);
  editable.array.splice(sizeIndex + 1);
  if (newChild) {
    editable.array[sizeIndex] = newChild;
  }
  return editable;
};

var DONE = {};

function iterateList(list, reverse) {
  var left = list._origin;
  var right = list._capacity;
  var tailPos = getTailOffset(right);
  var tail = list._tail;

  return iterateNodeOrLeaf(list._root, list._level, 0);

  function iterateNodeOrLeaf(node, level, offset) {
    return level === 0
      ? iterateLeaf(node, offset)
      : iterateNode(node, level, offset);
  }

  function iterateLeaf(node, offset) {
    var array = offset === tailPos ? tail && tail.array : node && node.array;
    var from = offset > left ? 0 : left - offset;
    var to = right - offset;
    if (to > SIZE) {
      to = SIZE;
    }
    return function () {
      if (from === to) {
        return DONE;
      }
      var idx = reverse ? --to : from++;
      return array && array[idx];
    };
  }

  function iterateNode(node, level, offset) {
    var values;
    var array = node && node.array;
    var from = offset > left ? 0 : (left - offset) >> level;
    var to = ((right - offset) >> level) + 1;
    if (to > SIZE) {
      to = SIZE;
    }
    return function () {
      while (true) {
        if (values) {
          var value = values();
          if (value !== DONE) {
            return value;
          }
          values = null;
        }
        if (from === to) {
          return DONE;
        }
        var idx = reverse ? --to : from++;
        values = iterateNodeOrLeaf(
          array && array[idx],
          level - SHIFT,
          offset + (idx << level)
        );
      }
    };
  }
}

function makeList(origin, capacity, level, root, tail, ownerID, hash) {
  var list = Object.create(ListPrototype);
  list.size = capacity - origin;
  list._origin = origin;
  list._capacity = capacity;
  list._level = level;
  list._root = root;
  list._tail = tail;
  list.__ownerID = ownerID;
  list.__hash = hash;
  list.__altered = false;
  return list;
}

var EMPTY_LIST;
function emptyList() {
  return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));
}

function updateList(list, index, value) {
  index = wrapIndex(list, index);

  if (index !== index) {
    return list;
  }

  if (index >= list.size || index < 0) {
    return list.withMutations(function (list) {
      index < 0
        ? setListBounds(list, index).set(0, value)
        : setListBounds(list, 0, index + 1).set(index, value);
    });
  }

  index += list._origin;

  var newTail = list._tail;
  var newRoot = list._root;
  var didAlter = MakeRef(DID_ALTER);
  if (index >= getTailOffset(list._capacity)) {
    newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);
  } else {
    newRoot = updateVNode(
      newRoot,
      list.__ownerID,
      list._level,
      index,
      value,
      didAlter
    );
  }

  if (!didAlter.value) {
    return list;
  }

  if (list.__ownerID) {
    list._root = newRoot;
    list._tail = newTail;
    list.__hash = undefined;
    list.__altered = true;
    return list;
  }
  return makeList(list._origin, list._capacity, list._level, newRoot, newTail);
}

function updateVNode(node, ownerID, level, index, value, didAlter) {
  var idx = (index >>> level) & MASK;
  var nodeHas = node && idx < node.array.length;
  if (!nodeHas && value === undefined) {
    return node;
  }

  var newNode;

  if (level > 0) {
    var lowerNode = node && node.array[idx];
    var newLowerNode = updateVNode(
      lowerNode,
      ownerID,
      level - SHIFT,
      index,
      value,
      didAlter
    );
    if (newLowerNode === lowerNode) {
      return node;
    }
    newNode = editableVNode(node, ownerID);
    newNode.array[idx] = newLowerNode;
    return newNode;
  }

  if (nodeHas && node.array[idx] === value) {
    return node;
  }

  SetRef(didAlter);

  newNode = editableVNode(node, ownerID);
  if (value === undefined && idx === newNode.array.length - 1) {
    newNode.array.pop();
  } else {
    newNode.array[idx] = value;
  }
  return newNode;
}

function editableVNode(node, ownerID) {
  if (ownerID && node && ownerID === node.ownerID) {
    return node;
  }
  return new VNode(node ? node.array.slice() : [], ownerID);
}

function listNodeFor(list, rawIndex) {
  if (rawIndex >= getTailOffset(list._capacity)) {
    return list._tail;
  }
  if (rawIndex < 1 << (list._level + SHIFT)) {
    var node = list._root;
    var level = list._level;
    while (node && level > 0) {
      node = node.array[(rawIndex >>> level) & MASK];
      level -= SHIFT;
    }
    return node;
  }
}

function setListBounds(list, begin, end) {
  // Sanitize begin & end using this shorthand for ToInt32(argument)
  // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
  if (begin !== undefined) {
    begin |= 0;
  }
  if (end !== undefined) {
    end |= 0;
  }
  var owner = list.__ownerID || new OwnerID();
  var oldOrigin = list._origin;
  var oldCapacity = list._capacity;
  var newOrigin = oldOrigin + begin;
  var newCapacity =
    end === undefined
      ? oldCapacity
      : end < 0 ? oldCapacity + end : oldOrigin + end;
  if (newOrigin === oldOrigin && newCapacity === oldCapacity) {
    return list;
  }

  // If it's going to end after it starts, it's empty.
  if (newOrigin >= newCapacity) {
    return list.clear();
  }

  var newLevel = list._level;
  var newRoot = list._root;

  // New origin might need creating a higher root.
  var offsetShift = 0;
  while (newOrigin + offsetShift < 0) {
    newRoot = new VNode(
      newRoot && newRoot.array.length ? [undefined, newRoot] : [],
      owner
    );
    newLevel += SHIFT;
    offsetShift += 1 << newLevel;
  }
  if (offsetShift) {
    newOrigin += offsetShift;
    oldOrigin += offsetShift;
    newCapacity += offsetShift;
    oldCapacity += offsetShift;
  }

  var oldTailOffset = getTailOffset(oldCapacity);
  var newTailOffset = getTailOffset(newCapacity);

  // New size might need creating a higher root.
  while (newTailOffset >= 1 << (newLevel + SHIFT)) {
    newRoot = new VNode(
      newRoot && newRoot.array.length ? [newRoot] : [],
      owner
    );
    newLevel += SHIFT;
  }

  // Locate or create the new tail.
  var oldTail = list._tail;
  var newTail =
    newTailOffset < oldTailOffset
      ? listNodeFor(list, newCapacity - 1)
      : newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;

  // Merge Tail into tree.
  if (
    oldTail &&
    newTailOffset > oldTailOffset &&
    newOrigin < oldCapacity &&
    oldTail.array.length
  ) {
    newRoot = editableVNode(newRoot, owner);
    var node = newRoot;
    for (var level = newLevel; level > SHIFT; level -= SHIFT) {
      var idx = (oldTailOffset >>> level) & MASK;
      node = node.array[idx] = editableVNode(node.array[idx], owner);
    }
    node.array[(oldTailOffset >>> SHIFT) & MASK] = oldTail;
  }

  // If the size has been reduced, there's a chance the tail needs to be trimmed.
  if (newCapacity < oldCapacity) {
    newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);
  }

  // If the new origin is within the tail, then we do not need a root.
  if (newOrigin >= newTailOffset) {
    newOrigin -= newTailOffset;
    newCapacity -= newTailOffset;
    newLevel = SHIFT;
    newRoot = null;
    newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);

    // Otherwise, if the root has been trimmed, garbage collect.
  } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {
    offsetShift = 0;

    // Identify the new top root node of the subtree of the old root.
    while (newRoot) {
      var beginIndex = (newOrigin >>> newLevel) & MASK;
      if ((beginIndex !== newTailOffset >>> newLevel) & MASK) {
        break;
      }
      if (beginIndex) {
        offsetShift += (1 << newLevel) * beginIndex;
      }
      newLevel -= SHIFT;
      newRoot = newRoot.array[beginIndex];
    }

    // Trim the new sides of the new root.
    if (newRoot && newOrigin > oldOrigin) {
      newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);
    }
    if (newRoot && newTailOffset < oldTailOffset) {
      newRoot = newRoot.removeAfter(
        owner,
        newLevel,
        newTailOffset - offsetShift
      );
    }
    if (offsetShift) {
      newOrigin -= offsetShift;
      newCapacity -= offsetShift;
    }
  }

  if (list.__ownerID) {
    list.size = newCapacity - newOrigin;
    list._origin = newOrigin;
    list._capacity = newCapacity;
    list._level = newLevel;
    list._root = newRoot;
    list._tail = newTail;
    list.__hash = undefined;
    list.__altered = true;
    return list;
  }
  return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);
}

function getTailOffset(size) {
  return size < SIZE ? 0 : ((size - 1) >>> SHIFT) << SHIFT;
}

var OrderedMap = (function (Map$$1) {
  function OrderedMap(value) {
    return value === null || value === undefined
      ? emptyOrderedMap()
      : isOrderedMap(value)
        ? value
        : emptyOrderedMap().withMutations(function (map) {
            var iter = KeyedCollection(value);
            assertNotInfinite(iter.size);
            iter.forEach(function (v, k) { return map.set(k, v); });
          });
  }

  if ( Map$$1 ) OrderedMap.__proto__ = Map$$1;
  OrderedMap.prototype = Object.create( Map$$1 && Map$$1.prototype );
  OrderedMap.prototype.constructor = OrderedMap;

  OrderedMap.of = function of (/*...values*/) {
    return this(arguments);
  };

  OrderedMap.prototype.toString = function toString () {
    return this.__toString('OrderedMap {', '}');
  };

  // @pragma Access

  OrderedMap.prototype.get = function get (k, notSetValue) {
    var index = this._map.get(k);
    return index !== undefined ? this._list.get(index)[1] : notSetValue;
  };

  // @pragma Modification

  OrderedMap.prototype.clear = function clear () {
    if (this.size === 0) {
      return this;
    }
    if (this.__ownerID) {
      this.size = 0;
      this._map.clear();
      this._list.clear();
      return this;
    }
    return emptyOrderedMap();
  };

  OrderedMap.prototype.set = function set (k, v) {
    return updateOrderedMap(this, k, v);
  };

  OrderedMap.prototype.remove = function remove (k) {
    return updateOrderedMap(this, k, NOT_SET);
  };

  OrderedMap.prototype.wasAltered = function wasAltered () {
    return this._map.wasAltered() || this._list.wasAltered();
  };

  OrderedMap.prototype.__iterate = function __iterate (fn, reverse) {
    var this$1 = this;

    return this._list.__iterate(
      function (entry) { return entry && fn(entry[1], entry[0], this$1); },
      reverse
    );
  };

  OrderedMap.prototype.__iterator = function __iterator (type, reverse) {
    return this._list.fromEntrySeq().__iterator(type, reverse);
  };

  OrderedMap.prototype.__ensureOwner = function __ensureOwner (ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }
    var newMap = this._map.__ensureOwner(ownerID);
    var newList = this._list.__ensureOwner(ownerID);
    if (!ownerID) {
      if (this.size === 0) {
        return emptyOrderedMap();
      }
      this.__ownerID = ownerID;
      this._map = newMap;
      this._list = newList;
      return this;
    }
    return makeOrderedMap(newMap, newList, ownerID, this.__hash);
  };

  return OrderedMap;
}(Map));

function isOrderedMap(maybeOrderedMap) {
  return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);
}

OrderedMap.isOrderedMap = isOrderedMap;

OrderedMap.prototype[IS_ORDERED_SENTINEL] = true;
OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;

function makeOrderedMap(map, list, ownerID, hash) {
  var omap = Object.create(OrderedMap.prototype);
  omap.size = map ? map.size : 0;
  omap._map = map;
  omap._list = list;
  omap.__ownerID = ownerID;
  omap.__hash = hash;
  return omap;
}

var EMPTY_ORDERED_MAP;
function emptyOrderedMap() {
  return (
    EMPTY_ORDERED_MAP ||
    (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()))
  );
}

function updateOrderedMap(omap, k, v) {
  var map = omap._map;
  var list = omap._list;
  var i = map.get(k);
  var has = i !== undefined;
  var newMap;
  var newList;
  if (v === NOT_SET) {
    // removed
    if (!has) {
      return omap;
    }
    if (list.size >= SIZE && list.size >= map.size * 2) {
      newList = list.filter(function (entry, idx) { return entry !== undefined && i !== idx; });
      newMap = newList
        .toKeyedSeq()
        .map(function (entry) { return entry[0]; })
        .flip()
        .toMap();
      if (omap.__ownerID) {
        newMap.__ownerID = newList.__ownerID = omap.__ownerID;
      }
    } else {
      newMap = map.remove(k);
      newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);
    }
  } else if (has) {
    if (v === list.get(i)[1]) {
      return omap;
    }
    newMap = map;
    newList = list.set(i, [k, v]);
  } else {
    newMap = map.set(k, list.size);
    newList = list.set(list.size, [k, v]);
  }
  if (omap.__ownerID) {
    omap.size = newMap.size;
    omap._map = newMap;
    omap._list = newList;
    omap.__hash = undefined;
    return omap;
  }
  return makeOrderedMap(newMap, newList);
}

var Stack = (function (IndexedCollection$$1) {
  function Stack(value) {
    return value === null || value === undefined
      ? emptyStack()
      : isStack(value) ? value : emptyStack().pushAll(value);
  }

  if ( IndexedCollection$$1 ) Stack.__proto__ = IndexedCollection$$1;
  Stack.prototype = Object.create( IndexedCollection$$1 && IndexedCollection$$1.prototype );
  Stack.prototype.constructor = Stack;

  Stack.of = function of (/*...values*/) {
    return this(arguments);
  };

  Stack.prototype.toString = function toString () {
    return this.__toString('Stack [', ']');
  };

  // @pragma Access

  Stack.prototype.get = function get (index, notSetValue) {
    var head = this._head;
    index = wrapIndex(this, index);
    while (head && index--) {
      head = head.next;
    }
    return head ? head.value : notSetValue;
  };

  Stack.prototype.peek = function peek () {
    return this._head && this._head.value;
  };

  // @pragma Modification

  Stack.prototype.push = function push (/*...values*/) {
    var arguments$1 = arguments;

    if (arguments.length === 0) {
      return this;
    }
    var newSize = this.size + arguments.length;
    var head = this._head;
    for (var ii = arguments.length - 1; ii >= 0; ii--) {
      head = {
        value: arguments$1[ii],
        next: head
      };
    }
    if (this.__ownerID) {
      this.size = newSize;
      this._head = head;
      this.__hash = undefined;
      this.__altered = true;
      return this;
    }
    return makeStack(newSize, head);
  };

  Stack.prototype.pushAll = function pushAll (iter) {
    iter = IndexedCollection$$1(iter);
    if (iter.size === 0) {
      return this;
    }
    if (this.size === 0 && isStack(iter)) {
      return iter;
    }
    assertNotInfinite(iter.size);
    var newSize = this.size;
    var head = this._head;
    iter.__iterate(function (value) {
      newSize++;
      head = {
        value: value,
        next: head
      };
    }, /* reverse */ true);
    if (this.__ownerID) {
      this.size = newSize;
      this._head = head;
      this.__hash = undefined;
      this.__altered = true;
      return this;
    }
    return makeStack(newSize, head);
  };

  Stack.prototype.pop = function pop () {
    return this.slice(1);
  };

  Stack.prototype.clear = function clear () {
    if (this.size === 0) {
      return this;
    }
    if (this.__ownerID) {
      this.size = 0;
      this._head = undefined;
      this.__hash = undefined;
      this.__altered = true;
      return this;
    }
    return emptyStack();
  };

  Stack.prototype.slice = function slice (begin, end) {
    if (wholeSlice(begin, end, this.size)) {
      return this;
    }
    var resolvedBegin = resolveBegin(begin, this.size);
    var resolvedEnd = resolveEnd(end, this.size);
    if (resolvedEnd !== this.size) {
      // super.slice(begin, end);
      return IndexedCollection$$1.prototype.slice.call(this, begin, end);
    }
    var newSize = this.size - resolvedBegin;
    var head = this._head;
    while (resolvedBegin--) {
      head = head.next;
    }
    if (this.__ownerID) {
      this.size = newSize;
      this._head = head;
      this.__hash = undefined;
      this.__altered = true;
      return this;
    }
    return makeStack(newSize, head);
  };

  // @pragma Mutability

  Stack.prototype.__ensureOwner = function __ensureOwner (ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }
    if (!ownerID) {
      if (this.size === 0) {
        return emptyStack();
      }
      this.__ownerID = ownerID;
      this.__altered = false;
      return this;
    }
    return makeStack(this.size, this._head, ownerID, this.__hash);
  };

  // @pragma Iteration

  Stack.prototype.__iterate = function __iterate (fn, reverse) {
    var this$1 = this;

    if (reverse) {
      return new ArraySeq(this.toArray()).__iterate(
        function (v, k) { return fn(v, k, this$1); },
        reverse
      );
    }
    var iterations = 0;
    var node = this._head;
    while (node) {
      if (fn(node.value, iterations++, this$1) === false) {
        break;
      }
      node = node.next;
    }
    return iterations;
  };

  Stack.prototype.__iterator = function __iterator (type, reverse) {
    if (reverse) {
      return new ArraySeq(this.toArray()).__iterator(type, reverse);
    }
    var iterations = 0;
    var node = this._head;
    return new Iterator(function () {
      if (node) {
        var value = node.value;
        node = node.next;
        return iteratorValue(type, iterations++, value);
      }
      return iteratorDone();
    });
  };

  return Stack;
}(IndexedCollection));

function isStack(maybeStack) {
  return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);
}

Stack.isStack = isStack;

var IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';

var StackPrototype = Stack.prototype;
StackPrototype[IS_STACK_SENTINEL] = true;
StackPrototype.shift = StackPrototype.pop;
StackPrototype.unshift = StackPrototype.push;
StackPrototype.unshiftAll = StackPrototype.pushAll;
StackPrototype.withMutations = withMutations;
StackPrototype.wasAltered = wasAltered;
StackPrototype.asImmutable = asImmutable;
StackPrototype['@@transducer/init'] = StackPrototype.asMutable = asMutable;
StackPrototype['@@transducer/step'] = function(result, arr) {
  return result.unshift(arr);
};
StackPrototype['@@transducer/result'] = function(obj) {
  return obj.asImmutable();
};

function makeStack(size, head, ownerID, hash) {
  var map = Object.create(StackPrototype);
  map.size = size;
  map._head = head;
  map.__ownerID = ownerID;
  map.__hash = hash;
  map.__altered = false;
  return map;
}

var EMPTY_STACK;
function emptyStack() {
  return EMPTY_STACK || (EMPTY_STACK = makeStack(0));
}

function deepEqual(a, b) {
  if (a === b) {
    return true;
  }

  if (
    !isCollection(b) ||
    (a.size !== undefined && b.size !== undefined && a.size !== b.size) ||
    (a.__hash !== undefined &&
      b.__hash !== undefined &&
      a.__hash !== b.__hash) ||
    isKeyed(a) !== isKeyed(b) ||
    isIndexed(a) !== isIndexed(b) ||
    isOrdered(a) !== isOrdered(b)
  ) {
    return false;
  }

  if (a.size === 0 && b.size === 0) {
    return true;
  }

  var notAssociative = !isAssociative(a);

  if (isOrdered(a)) {
    var entries = a.entries();
    return (
      b.every(function (v, k) {
        var entry = entries.next().value;
        return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));
      }) && entries.next().done
    );
  }

  var flipped = false;

  if (a.size === undefined) {
    if (b.size === undefined) {
      if (typeof a.cacheResult === 'function') {
        a.cacheResult();
      }
    } else {
      flipped = true;
      var _ = a;
      a = b;
      b = _;
    }
  }

  var allEqual = true;
  var bSize = b.__iterate(function (v, k) {
    if (
      notAssociative
        ? !a.has(v)
        : flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)
    ) {
      allEqual = false;
      return false;
    }
  });

  return allEqual && a.size === bSize;
}

/**
 * Contributes additional methods to a constructor
 */
function mixin(ctor, methods) {
  var keyCopier = function (key) {
    ctor.prototype[key] = methods[key];
  };
  Object.keys(methods).forEach(keyCopier);
  Object.getOwnPropertySymbols &&
    Object.getOwnPropertySymbols(methods).forEach(keyCopier);
  return ctor;
}

function toJS(value) {
  return isDataStructure(value)
    ? Seq(value)
        .map(toJS)
        .toJSON()
    : value;
}

var Set = (function (SetCollection$$1) {
  function Set(value) {
    return value === null || value === undefined
      ? emptySet()
      : isSet(value) && !isOrdered(value)
        ? value
        : emptySet().withMutations(function (set) {
            var iter = SetCollection$$1(value);
            assertNotInfinite(iter.size);
            iter.forEach(function (v) { return set.add(v); });
          });
  }

  if ( SetCollection$$1 ) Set.__proto__ = SetCollection$$1;
  Set.prototype = Object.create( SetCollection$$1 && SetCollection$$1.prototype );
  Set.prototype.constructor = Set;

  Set.of = function of (/*...values*/) {
    return this(arguments);
  };

  Set.fromKeys = function fromKeys (value) {
    return this(KeyedCollection(value).keySeq());
  };

  Set.intersect = function intersect (sets) {
    sets = Collection(sets).toArray();
    return sets.length
      ? SetPrototype.intersect.apply(Set(sets.pop()), sets)
      : emptySet();
  };

  Set.union = function union (sets) {
    sets = Collection(sets).toArray();
    return sets.length
      ? SetPrototype.union.apply(Set(sets.pop()), sets)
      : emptySet();
  };

  Set.prototype.toString = function toString () {
    return this.__toString('Set {', '}');
  };

  // @pragma Access

  Set.prototype.has = function has (value) {
    return this._map.has(value);
  };

  // @pragma Modification

  Set.prototype.add = function add (value) {
    return updateSet(this, this._map.set(value, value));
  };

  Set.prototype.remove = function remove (value) {
    return updateSet(this, this._map.remove(value));
  };

  Set.prototype.clear = function clear () {
    return updateSet(this, this._map.clear());
  };

  // @pragma Composition

  Set.prototype.union = function union () {
    var iters = [], len = arguments.length;
    while ( len-- ) iters[ len ] = arguments[ len ];

    iters = iters.filter(function (x) { return x.size !== 0; });
    if (iters.length === 0) {
      return this;
    }
    if (this.size === 0 && !this.__ownerID && iters.length === 1) {
      return this.constructor(iters[0]);
    }
    return this.withMutations(function (set) {
      for (var ii = 0; ii < iters.length; ii++) {
        SetCollection$$1(iters[ii]).forEach(function (value) { return set.add(value); });
      }
    });
  };

  Set.prototype.intersect = function intersect () {
    var iters = [], len = arguments.length;
    while ( len-- ) iters[ len ] = arguments[ len ];

    if (iters.length === 0) {
      return this;
    }
    iters = iters.map(function (iter) { return SetCollection$$1(iter); });
    var toRemove = [];
    this.forEach(function (value) {
      if (!iters.every(function (iter) { return iter.includes(value); })) {
        toRemove.push(value);
      }
    });
    return this.withMutations(function (set) {
      toRemove.forEach(function (value) {
        set.remove(value);
      });
    });
  };

  Set.prototype.subtract = function subtract () {
    var iters = [], len = arguments.length;
    while ( len-- ) iters[ len ] = arguments[ len ];

    if (iters.length === 0) {
      return this;
    }
    iters = iters.map(function (iter) { return SetCollection$$1(iter); });
    var toRemove = [];
    this.forEach(function (value) {
      if (iters.some(function (iter) { return iter.includes(value); })) {
        toRemove.push(value);
      }
    });
    return this.withMutations(function (set) {
      toRemove.forEach(function (value) {
        set.remove(value);
      });
    });
  };

  Set.prototype.sort = function sort (comparator) {
    // Late binding
    return OrderedSet(sortFactory(this, comparator));
  };

  Set.prototype.sortBy = function sortBy (mapper, comparator) {
    // Late binding
    return OrderedSet(sortFactory(this, comparator, mapper));
  };

  Set.prototype.wasAltered = function wasAltered () {
    return this._map.wasAltered();
  };

  Set.prototype.__iterate = function __iterate (fn, reverse) {
    var this$1 = this;

    return this._map.__iterate(function (k) { return fn(k, k, this$1); }, reverse);
  };

  Set.prototype.__iterator = function __iterator (type, reverse) {
    return this._map.__iterator(type, reverse);
  };

  Set.prototype.__ensureOwner = function __ensureOwner (ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }
    var newMap = this._map.__ensureOwner(ownerID);
    if (!ownerID) {
      if (this.size === 0) {
        return this.__empty();
      }
      this.__ownerID = ownerID;
      this._map = newMap;
      return this;
    }
    return this.__make(newMap, ownerID);
  };

  return Set;
}(SetCollection));

function isSet(maybeSet) {
  return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);
}

Set.isSet = isSet;

var IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';

var SetPrototype = Set.prototype;
SetPrototype[IS_SET_SENTINEL] = true;
SetPrototype[DELETE] = SetPrototype.remove;
SetPrototype.merge = SetPrototype.concat = SetPrototype.union;
SetPrototype.withMutations = withMutations;
SetPrototype.asImmutable = asImmutable;
SetPrototype['@@transducer/init'] = SetPrototype.asMutable = asMutable;
SetPrototype['@@transducer/step'] = function(result, arr) {
  return result.add(arr);
};
SetPrototype['@@transducer/result'] = function(obj) {
  return obj.asImmutable();
};

SetPrototype.__empty = emptySet;
SetPrototype.__make = makeSet;

function updateSet(set, newMap) {
  if (set.__ownerID) {
    set.size = newMap.size;
    set._map = newMap;
    return set;
  }
  return newMap === set._map
    ? set
    : newMap.size === 0 ? set.__empty() : set.__make(newMap);
}

function makeSet(map, ownerID) {
  var set = Object.create(SetPrototype);
  set.size = map ? map.size : 0;
  set._map = map;
  set.__ownerID = ownerID;
  return set;
}

var EMPTY_SET;
function emptySet() {
  return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));
}

/**
 * Returns a lazy seq of nums from start (inclusive) to end
 * (exclusive), by step, where start defaults to 0, step to 1, and end to
 * infinity. When start is equal to end, returns empty list.
 */
var Range = (function (IndexedSeq$$1) {
  function Range(start, end, step) {
    if (!(this instanceof Range)) {
      return new Range(start, end, step);
    }
    invariant(step !== 0, 'Cannot step a Range by 0');
    start = start || 0;
    if (end === undefined) {
      end = Infinity;
    }
    step = step === undefined ? 1 : Math.abs(step);
    if (end < start) {
      step = -step;
    }
    this._start = start;
    this._end = end;
    this._step = step;
    this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);
    if (this.size === 0) {
      if (EMPTY_RANGE) {
        return EMPTY_RANGE;
      }
      EMPTY_RANGE = this;
    }
  }

  if ( IndexedSeq$$1 ) Range.__proto__ = IndexedSeq$$1;
  Range.prototype = Object.create( IndexedSeq$$1 && IndexedSeq$$1.prototype );
  Range.prototype.constructor = Range;

  Range.prototype.toString = function toString () {
    if (this.size === 0) {
      return 'Range []';
    }
    return (
      'Range [ ' +
      this._start +
      '...' +
      this._end +
      (this._step !== 1 ? ' by ' + this._step : '') +
      ' ]'
    );
  };

  Range.prototype.get = function get (index, notSetValue) {
    return this.has(index)
      ? this._start + wrapIndex(this, index) * this._step
      : notSetValue;
  };

  Range.prototype.includes = function includes (searchValue) {
    var possibleIndex = (searchValue - this._start) / this._step;
    return (
      possibleIndex >= 0 &&
      possibleIndex < this.size &&
      possibleIndex === Math.floor(possibleIndex)
    );
  };

  Range.prototype.slice = function slice (begin, end) {
    if (wholeSlice(begin, end, this.size)) {
      return this;
    }
    begin = resolveBegin(begin, this.size);
    end = resolveEnd(end, this.size);
    if (end <= begin) {
      return new Range(0, 0);
    }
    return new Range(
      this.get(begin, this._end),
      this.get(end, this._end),
      this._step
    );
  };

  Range.prototype.indexOf = function indexOf (searchValue) {
    var offsetValue = searchValue - this._start;
    if (offsetValue % this._step === 0) {
      var index = offsetValue / this._step;
      if (index >= 0 && index < this.size) {
        return index;
      }
    }
    return -1;
  };

  Range.prototype.lastIndexOf = function lastIndexOf (searchValue) {
    return this.indexOf(searchValue);
  };

  Range.prototype.__iterate = function __iterate (fn, reverse) {
    var this$1 = this;

    var size = this.size;
    var step = this._step;
    var value = reverse ? this._start + (size - 1) * step : this._start;
    var i = 0;
    while (i !== size) {
      if (fn(value, reverse ? size - ++i : i++, this$1) === false) {
        break;
      }
      value += reverse ? -step : step;
    }
    return i;
  };

  Range.prototype.__iterator = function __iterator (type, reverse) {
    var size = this.size;
    var step = this._step;
    var value = reverse ? this._start + (size - 1) * step : this._start;
    var i = 0;
    return new Iterator(function () {
      if (i === size) {
        return iteratorDone();
      }
      var v = value;
      value += reverse ? -step : step;
      return iteratorValue(type, reverse ? size - ++i : i++, v);
    });
  };

  Range.prototype.equals = function equals (other) {
    return other instanceof Range
      ? this._start === other._start &&
          this._end === other._end &&
          this._step === other._step
      : deepEqual(this, other);
  };

  return Range;
}(IndexedSeq));

var EMPTY_RANGE;

function getIn$1(collection, searchKeyPath, notSetValue) {
  var keyPath = coerceKeyPath(searchKeyPath);
  var i = 0;
  while (i !== keyPath.length) {
    collection = get(collection, keyPath[i++], NOT_SET);
    if (collection === NOT_SET) {
      return notSetValue;
    }
  }
  return collection;
}

function getIn$$1(searchKeyPath, notSetValue) {
  return getIn$1(this, searchKeyPath, notSetValue);
}

function hasIn$1(collection, keyPath) {
  return getIn$1(collection, keyPath, NOT_SET) !== NOT_SET;
}

function hasIn$$1(searchKeyPath) {
  return hasIn$1(this, searchKeyPath);
}

function toObject() {
  assertNotInfinite(this.size);
  var object = {};
  this.__iterate(function (v, k) {
    object[k] = v;
  });
  return object;
}

// Note: all of these methods are deprecated.
Collection.isIterable = isCollection;
Collection.isKeyed = isKeyed;
Collection.isIndexed = isIndexed;
Collection.isAssociative = isAssociative;
Collection.isOrdered = isOrdered;

Collection.Iterator = Iterator;

mixin(Collection, {
  // ### Conversion to other types

  toArray: function toArray() {
    assertNotInfinite(this.size);
    var array = new Array(this.size || 0);
    var useTuples = isKeyed(this);
    var i = 0;
    this.__iterate(function (v, k) {
      // Keyed collections produce an array of tuples.
      array[i++] = useTuples ? [k, v] : v;
    });
    return array;
  },

  toIndexedSeq: function toIndexedSeq() {
    return new ToIndexedSequence(this);
  },

  toJS: function toJS$1() {
    return toJS(this);
  },

  toKeyedSeq: function toKeyedSeq() {
    return new ToKeyedSequence(this, true);
  },

  toMap: function toMap() {
    // Use Late Binding here to solve the circular dependency.
    return Map(this.toKeyedSeq());
  },

  toObject: toObject,

  toOrderedMap: function toOrderedMap() {
    // Use Late Binding here to solve the circular dependency.
    return OrderedMap(this.toKeyedSeq());
  },

  toOrderedSet: function toOrderedSet() {
    // Use Late Binding here to solve the circular dependency.
    return OrderedSet(isKeyed(this) ? this.valueSeq() : this);
  },

  toSet: function toSet() {
    // Use Late Binding here to solve the circular dependency.
    return Set(isKeyed(this) ? this.valueSeq() : this);
  },

  toSetSeq: function toSetSeq() {
    return new ToSetSequence(this);
  },

  toSeq: function toSeq() {
    return isIndexed(this)
      ? this.toIndexedSeq()
      : isKeyed(this) ? this.toKeyedSeq() : this.toSetSeq();
  },

  toStack: function toStack() {
    // Use Late Binding here to solve the circular dependency.
    return Stack(isKeyed(this) ? this.valueSeq() : this);
  },

  toList: function toList() {
    // Use Late Binding here to solve the circular dependency.
    return List(isKeyed(this) ? this.valueSeq() : this);
  },

  // ### Common JavaScript methods and properties

  toString: function toString() {
    return '[Collection]';
  },

  __toString: function __toString(head, tail) {
    if (this.size === 0) {
      return head + tail;
    }
    return (
      head +
      ' ' +
      this.toSeq()
        .map(this.__toStringMapper)
        .join(', ') +
      ' ' +
      tail
    );
  },

  // ### ES6 Collection methods (ES6 Array and Map)

  concat: function concat() {
    var values = [], len = arguments.length;
    while ( len-- ) values[ len ] = arguments[ len ];

    return reify(this, concatFactory(this, values));
  },

  includes: function includes(searchValue) {
    return this.some(function (value) { return is(value, searchValue); });
  },

  entries: function entries() {
    return this.__iterator(ITERATE_ENTRIES);
  },

  every: function every(predicate, context) {
    assertNotInfinite(this.size);
    var returnValue = true;
    this.__iterate(function (v, k, c) {
      if (!predicate.call(context, v, k, c)) {
        returnValue = false;
        return false;
      }
    });
    return returnValue;
  },

  filter: function filter(predicate, context) {
    return reify(this, filterFactory(this, predicate, context, true));
  },

  find: function find(predicate, context, notSetValue) {
    var entry = this.findEntry(predicate, context);
    return entry ? entry[1] : notSetValue;
  },

  forEach: function forEach(sideEffect, context) {
    assertNotInfinite(this.size);
    return this.__iterate(context ? sideEffect.bind(context) : sideEffect);
  },

  join: function join(separator) {
    assertNotInfinite(this.size);
    separator = separator !== undefined ? '' + separator : ',';
    var joined = '';
    var isFirst = true;
    this.__iterate(function (v) {
      isFirst ? (isFirst = false) : (joined += separator);
      joined += v !== null && v !== undefined ? v.toString() : '';
    });
    return joined;
  },

  keys: function keys() {
    return this.__iterator(ITERATE_KEYS);
  },

  map: function map(mapper, context) {
    return reify(this, mapFactory(this, mapper, context));
  },

  reduce: function reduce$1(reducer, initialReduction, context) {
    return reduce(
      this,
      reducer,
      initialReduction,
      context,
      arguments.length < 2,
      false
    );
  },

  reduceRight: function reduceRight(reducer, initialReduction, context) {
    return reduce(
      this,
      reducer,
      initialReduction,
      context,
      arguments.length < 2,
      true
    );
  },

  reverse: function reverse() {
    return reify(this, reverseFactory(this, true));
  },

  slice: function slice(begin, end) {
    return reify(this, sliceFactory(this, begin, end, true));
  },

  some: function some(predicate, context) {
    return !this.every(not(predicate), context);
  },

  sort: function sort(comparator) {
    return reify(this, sortFactory(this, comparator));
  },

  values: function values() {
    return this.__iterator(ITERATE_VALUES);
  },

  // ### More sequential methods

  butLast: function butLast() {
    return this.slice(0, -1);
  },

  isEmpty: function isEmpty() {
    return this.size !== undefined ? this.size === 0 : !this.some(function () { return true; });
  },

  count: function count(predicate, context) {
    return ensureSize(
      predicate ? this.toSeq().filter(predicate, context) : this
    );
  },

  countBy: function countBy(grouper, context) {
    return countByFactory(this, grouper, context);
  },

  equals: function equals(other) {
    return deepEqual(this, other);
  },

  entrySeq: function entrySeq() {
    var collection = this;
    if (collection._cache) {
      // We cache as an entries array, so we can just return the cache!
      return new ArraySeq(collection._cache);
    }
    var entriesSequence = collection
      .toSeq()
      .map(entryMapper)
      .toIndexedSeq();
    entriesSequence.fromEntrySeq = function () { return collection.toSeq(); };
    return entriesSequence;
  },

  filterNot: function filterNot(predicate, context) {
    return this.filter(not(predicate), context);
  },

  findEntry: function findEntry(predicate, context, notSetValue) {
    var found = notSetValue;
    this.__iterate(function (v, k, c) {
      if (predicate.call(context, v, k, c)) {
        found = [k, v];
        return false;
      }
    });
    return found;
  },

  findKey: function findKey(predicate, context) {
    var entry = this.findEntry(predicate, context);
    return entry && entry[0];
  },

  findLast: function findLast(predicate, context, notSetValue) {
    return this.toKeyedSeq()
      .reverse()
      .find(predicate, context, notSetValue);
  },

  findLastEntry: function findLastEntry(predicate, context, notSetValue) {
    return this.toKeyedSeq()
      .reverse()
      .findEntry(predicate, context, notSetValue);
  },

  findLastKey: function findLastKey(predicate, context) {
    return this.toKeyedSeq()
      .reverse()
      .findKey(predicate, context);
  },

  first: function first() {
    return this.find(returnTrue);
  },

  flatMap: function flatMap(mapper, context) {
    return reify(this, flatMapFactory(this, mapper, context));
  },

  flatten: function flatten(depth) {
    return reify(this, flattenFactory(this, depth, true));
  },

  fromEntrySeq: function fromEntrySeq() {
    return new FromEntriesSequence(this);
  },

  get: function get(searchKey, notSetValue) {
    return this.find(function (_, key) { return is(key, searchKey); }, undefined, notSetValue);
  },

  getIn: getIn$$1,

  groupBy: function groupBy(grouper, context) {
    return groupByFactory(this, grouper, context);
  },

  has: function has(searchKey) {
    return this.get(searchKey, NOT_SET) !== NOT_SET;
  },

  hasIn: hasIn$$1,

  isSubset: function isSubset(iter) {
    iter = typeof iter.includes === 'function' ? iter : Collection(iter);
    return this.every(function (value) { return iter.includes(value); });
  },

  isSuperset: function isSuperset(iter) {
    iter = typeof iter.isSubset === 'function' ? iter : Collection(iter);
    return iter.isSubset(this);
  },

  keyOf: function keyOf(searchValue) {
    return this.findKey(function (value) { return is(value, searchValue); });
  },

  keySeq: function keySeq() {
    return this.toSeq()
      .map(keyMapper)
      .toIndexedSeq();
  },

  last: function last() {
    return this.toSeq()
      .reverse()
      .first();
  },

  lastKeyOf: function lastKeyOf(searchValue) {
    return this.toKeyedSeq()
      .reverse()
      .keyOf(searchValue);
  },

  max: function max(comparator) {
    return maxFactory(this, comparator);
  },

  maxBy: function maxBy(mapper, comparator) {
    return maxFactory(this, comparator, mapper);
  },

  min: function min(comparator) {
    return maxFactory(
      this,
      comparator ? neg(comparator) : defaultNegComparator
    );
  },

  minBy: function minBy(mapper, comparator) {
    return maxFactory(
      this,
      comparator ? neg(comparator) : defaultNegComparator,
      mapper
    );
  },

  rest: function rest() {
    return this.slice(1);
  },

  skip: function skip(amount) {
    return amount === 0 ? this : this.slice(Math.max(0, amount));
  },

  skipLast: function skipLast(amount) {
    return amount === 0 ? this : this.slice(0, -Math.max(0, amount));
  },

  skipWhile: function skipWhile(predicate, context) {
    return reify(this, skipWhileFactory(this, predicate, context, true));
  },

  skipUntil: function skipUntil(predicate, context) {
    return this.skipWhile(not(predicate), context);
  },

  sortBy: function sortBy(mapper, comparator) {
    return reify(this, sortFactory(this, comparator, mapper));
  },

  take: function take(amount) {
    return this.slice(0, Math.max(0, amount));
  },

  takeLast: function takeLast(amount) {
    return this.slice(-Math.max(0, amount));
  },

  takeWhile: function takeWhile(predicate, context) {
    return reify(this, takeWhileFactory(this, predicate, context));
  },

  takeUntil: function takeUntil(predicate, context) {
    return this.takeWhile(not(predicate), context);
  },

  update: function update(fn) {
    return fn(this);
  },

  valueSeq: function valueSeq() {
    return this.toIndexedSeq();
  },

  // ### Hashable Object

  hashCode: function hashCode() {
    return this.__hash || (this.__hash = hashCollection(this));
  }

  // ### Internal

  // abstract __iterate(fn, reverse)

  // abstract __iterator(type, reverse)
});

var CollectionPrototype = Collection.prototype;
CollectionPrototype[IS_ITERABLE_SENTINEL] = true;
CollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.values;
CollectionPrototype.toJSON = CollectionPrototype.toArray;
CollectionPrototype.__toStringMapper = quoteString;
CollectionPrototype.inspect = CollectionPrototype.toSource = function() {
  return this.toString();
};
CollectionPrototype.chain = CollectionPrototype.flatMap;
CollectionPrototype.contains = CollectionPrototype.includes;

mixin(KeyedCollection, {
  // ### More sequential methods

  flip: function flip() {
    return reify(this, flipFactory(this));
  },

  mapEntries: function mapEntries(mapper, context) {
    var this$1 = this;

    var iterations = 0;
    return reify(
      this,
      this.toSeq()
        .map(function (v, k) { return mapper.call(context, [k, v], iterations++, this$1); })
        .fromEntrySeq()
    );
  },

  mapKeys: function mapKeys(mapper, context) {
    var this$1 = this;

    return reify(
      this,
      this.toSeq()
        .flip()
        .map(function (k, v) { return mapper.call(context, k, v, this$1); })
        .flip()
    );
  }
});

var KeyedCollectionPrototype = KeyedCollection.prototype;
KeyedCollectionPrototype[IS_KEYED_SENTINEL] = true;
KeyedCollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.entries;
KeyedCollectionPrototype.toJSON = toObject;
KeyedCollectionPrototype.__toStringMapper = function (v, k) { return quoteString(k) + ': ' + quoteString(v); };

mixin(IndexedCollection, {
  // ### Conversion to other types

  toKeyedSeq: function toKeyedSeq() {
    return new ToKeyedSequence(this, false);
  },

  // ### ES6 Collection methods (ES6 Array and Map)

  filter: function filter(predicate, context) {
    return reify(this, filterFactory(this, predicate, context, false));
  },

  findIndex: function findIndex(predicate, context) {
    var entry = this.findEntry(predicate, context);
    return entry ? entry[0] : -1;
  },

  indexOf: function indexOf(searchValue) {
    var key = this.keyOf(searchValue);
    return key === undefined ? -1 : key;
  },

  lastIndexOf: function lastIndexOf(searchValue) {
    var key = this.lastKeyOf(searchValue);
    return key === undefined ? -1 : key;
  },

  reverse: function reverse() {
    return reify(this, reverseFactory(this, false));
  },

  slice: function slice(begin, end) {
    return reify(this, sliceFactory(this, begin, end, false));
  },

  splice: function splice(index, removeNum /*, ...values*/) {
    var numArgs = arguments.length;
    removeNum = Math.max(removeNum || 0, 0);
    if (numArgs === 0 || (numArgs === 2 && !removeNum)) {
      return this;
    }
    // If index is negative, it should resolve relative to the size of the
    // collection. However size may be expensive to compute if not cached, so
    // only call count() if the number is in fact negative.
    index = resolveBegin(index, index < 0 ? this.count() : this.size);
    var spliced = this.slice(0, index);
    return reify(
      this,
      numArgs === 1
        ? spliced
        : spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))
    );
  },

  // ### More collection methods

  findLastIndex: function findLastIndex(predicate, context) {
    var entry = this.findLastEntry(predicate, context);
    return entry ? entry[0] : -1;
  },

  first: function first() {
    return this.get(0);
  },

  flatten: function flatten(depth) {
    return reify(this, flattenFactory(this, depth, false));
  },

  get: function get(index, notSetValue) {
    index = wrapIndex(this, index);
    return index < 0 ||
      (this.size === Infinity || (this.size !== undefined && index > this.size))
      ? notSetValue
      : this.find(function (_, key) { return key === index; }, undefined, notSetValue);
  },

  has: function has(index) {
    index = wrapIndex(this, index);
    return (
      index >= 0 &&
      (this.size !== undefined
        ? this.size === Infinity || index < this.size
        : this.indexOf(index) !== -1)
    );
  },

  interpose: function interpose(separator) {
    return reify(this, interposeFactory(this, separator));
  },

  interleave: function interleave(/*...collections*/) {
    var collections = [this].concat(arrCopy(arguments));
    var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, collections);
    var interleaved = zipped.flatten(true);
    if (zipped.size) {
      interleaved.size = zipped.size * collections.length;
    }
    return reify(this, interleaved);
  },

  keySeq: function keySeq() {
    return Range(0, this.size);
  },

  last: function last() {
    return this.get(-1);
  },

  skipWhile: function skipWhile(predicate, context) {
    return reify(this, skipWhileFactory(this, predicate, context, false));
  },

  zip: function zip(/*, ...collections */) {
    var collections = [this].concat(arrCopy(arguments));
    return reify(this, zipWithFactory(this, defaultZipper, collections));
  },

  zipAll: function zipAll(/*, ...collections */) {
    var collections = [this].concat(arrCopy(arguments));
    return reify(this, zipWithFactory(this, defaultZipper, collections, true));
  },

  zipWith: function zipWith(zipper /*, ...collections */) {
    var collections = arrCopy(arguments);
    collections[0] = this;
    return reify(this, zipWithFactory(this, zipper, collections));
  }
});

var IndexedCollectionPrototype = IndexedCollection.prototype;
IndexedCollectionPrototype[IS_INDEXED_SENTINEL] = true;
IndexedCollectionPrototype[IS_ORDERED_SENTINEL] = true;

mixin(SetCollection, {
  // ### ES6 Collection methods (ES6 Array and Map)

  get: function get(value, notSetValue) {
    return this.has(value) ? value : notSetValue;
  },

  includes: function includes(value) {
    return this.has(value);
  },

  // ### More sequential methods

  keySeq: function keySeq() {
    return this.valueSeq();
  }
});

SetCollection.prototype.has = CollectionPrototype.includes;
SetCollection.prototype.contains = SetCollection.prototype.includes;

// Mixin subclasses

mixin(KeyedSeq, KeyedCollection.prototype);
mixin(IndexedSeq, IndexedCollection.prototype);
mixin(SetSeq, SetCollection.prototype);

// #pragma Helper functions

function reduce(collection, reducer, reduction, context, useFirst, reverse) {
  assertNotInfinite(collection.size);
  collection.__iterate(function (v, k, c) {
    if (useFirst) {
      useFirst = false;
      reduction = v;
    } else {
      reduction = reducer.call(context, reduction, v, k, c);
    }
  }, reverse);
  return reduction;
}

function keyMapper(v, k) {
  return k;
}

function entryMapper(v, k) {
  return [k, v];
}

function not(predicate) {
  return function() {
    return !predicate.apply(this, arguments);
  };
}

function neg(predicate) {
  return function() {
    return -predicate.apply(this, arguments);
  };
}

function defaultZipper() {
  return arrCopy(arguments);
}

function defaultNegComparator(a, b) {
  return a < b ? 1 : a > b ? -1 : 0;
}

function hashCollection(collection) {
  if (collection.size === Infinity) {
    return 0;
  }
  var ordered = isOrdered(collection);
  var keyed = isKeyed(collection);
  var h = ordered ? 1 : 0;
  var size = collection.__iterate(
    keyed
      ? ordered
        ? function (v, k) {
            h = (31 * h + hashMerge(hash(v), hash(k))) | 0;
          }
        : function (v, k) {
            h = (h + hashMerge(hash(v), hash(k))) | 0;
          }
      : ordered
        ? function (v) {
            h = (31 * h + hash(v)) | 0;
          }
        : function (v) {
            h = (h + hash(v)) | 0;
          }
  );
  return murmurHashOfSize(size, h);
}

function murmurHashOfSize(size, h) {
  h = imul(h, 0xcc9e2d51);
  h = imul((h << 15) | (h >>> -15), 0x1b873593);
  h = imul((h << 13) | (h >>> -13), 5);
  h = ((h + 0xe6546b64) | 0) ^ size;
  h = imul(h ^ (h >>> 16), 0x85ebca6b);
  h = imul(h ^ (h >>> 13), 0xc2b2ae35);
  h = smi(h ^ (h >>> 16));
  return h;
}

function hashMerge(a, b) {
  return (a ^ (b + 0x9e3779b9 + (a << 6) + (a >> 2))) | 0; // int
}

var OrderedSet = (function (Set$$1) {
  function OrderedSet(value) {
    return value === null || value === undefined
      ? emptyOrderedSet()
      : isOrderedSet(value)
        ? value
        : emptyOrderedSet().withMutations(function (set) {
            var iter = SetCollection(value);
            assertNotInfinite(iter.size);
            iter.forEach(function (v) { return set.add(v); });
          });
  }

  if ( Set$$1 ) OrderedSet.__proto__ = Set$$1;
  OrderedSet.prototype = Object.create( Set$$1 && Set$$1.prototype );
  OrderedSet.prototype.constructor = OrderedSet;

  OrderedSet.of = function of (/*...values*/) {
    return this(arguments);
  };

  OrderedSet.fromKeys = function fromKeys (value) {
    return this(KeyedCollection(value).keySeq());
  };

  OrderedSet.prototype.toString = function toString () {
    return this.__toString('OrderedSet {', '}');
  };

  return OrderedSet;
}(Set));

function isOrderedSet(maybeOrderedSet) {
  return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);
}

OrderedSet.isOrderedSet = isOrderedSet;

var OrderedSetPrototype = OrderedSet.prototype;
OrderedSetPrototype[IS_ORDERED_SENTINEL] = true;
OrderedSetPrototype.zip = IndexedCollectionPrototype.zip;
OrderedSetPrototype.zipWith = IndexedCollectionPrototype.zipWith;

OrderedSetPrototype.__empty = emptyOrderedSet;
OrderedSetPrototype.__make = makeOrderedSet;

function makeOrderedSet(map, ownerID) {
  var set = Object.create(OrderedSetPrototype);
  set.size = map ? map.size : 0;
  set._map = map;
  set.__ownerID = ownerID;
  return set;
}

var EMPTY_ORDERED_SET;
function emptyOrderedSet() {
  return (
    EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()))
  );
}

var Record = function Record(defaultValues, name) {
  var hasInitialized;

  var RecordType = function Record(values) {
    var this$1 = this;

    if (values instanceof RecordType) {
      return values;
    }
    if (!(this instanceof RecordType)) {
      return new RecordType(values);
    }
    if (!hasInitialized) {
      hasInitialized = true;
      var keys = Object.keys(defaultValues);
      var indices = (RecordTypePrototype._indices = {});
      RecordTypePrototype._name = name;
      RecordTypePrototype._keys = keys;
      RecordTypePrototype._defaultValues = defaultValues;
      for (var i = 0; i < keys.length; i++) {
        var propName = keys[i];
        indices[propName] = i;
        if (RecordTypePrototype[propName]) {
          /* eslint-disable no-console */
          typeof console === 'object' &&
            console.warn &&
            console.warn(
              'Cannot define ' +
                recordName(this$1) +
                ' with property "' +
                propName +
                '" since that property name is part of the Record API.'
            );
          /* eslint-enable no-console */
        } else {
          setProp(RecordTypePrototype, propName);
        }
      }
    }
    this.__ownerID = undefined;
    this._values = List().withMutations(function (l) {
      l.setSize(this$1._keys.length);
      KeyedCollection(values).forEach(function (v, k) {
        l.set(this$1._indices[k], v === this$1._defaultValues[k] ? undefined : v);
      });
    });
  };

  var RecordTypePrototype = (RecordType.prototype = Object.create(
    RecordPrototype
  ));
  RecordTypePrototype.constructor = RecordType;

  return RecordType;
};

Record.prototype.toString = function toString () {
    var this$1 = this;

  var str = recordName(this) + ' { ';
  var keys = this._keys;
  var k;
  for (var i = 0, l = keys.length; i !== l; i++) {
    k = keys[i];
    str += (i ? ', ' : '') + k + ': ' + quoteString(this$1.get(k));
  }
  return str + ' }';
};

Record.prototype.equals = function equals (other) {
  return (
    this === other ||
    (other &&
      this._keys === other._keys &&
      recordSeq(this).equals(recordSeq(other)))
  );
};

Record.prototype.hashCode = function hashCode () {
  return recordSeq(this).hashCode();
};

// @pragma Access

Record.prototype.has = function has (k) {
  return this._indices.hasOwnProperty(k);
};

Record.prototype.get = function get (k, notSetValue) {
  if (!this.has(k)) {
    return notSetValue;
  }
  var index = this._indices[k];
  var value = this._values.get(index);
  return value === undefined ? this._defaultValues[k] : value;
};

// @pragma Modification

Record.prototype.set = function set (k, v) {
  if (this.has(k)) {
    var newValues = this._values.set(
      this._indices[k],
      v === this._defaultValues[k] ? undefined : v
    );
    if (newValues !== this._values && !this.__ownerID) {
      return makeRecord(this, newValues);
    }
  }
  return this;
};

Record.prototype.remove = function remove (k) {
  return this.set(k);
};

Record.prototype.clear = function clear () {
  var newValues = this._values.clear().setSize(this._keys.length);
  return this.__ownerID ? this : makeRecord(this, newValues);
};

Record.prototype.wasAltered = function wasAltered () {
  return this._values.wasAltered();
};

Record.prototype.toSeq = function toSeq () {
  return recordSeq(this);
};

Record.prototype.toJS = function toJS$1 () {
  return toJS(this);
};

Record.prototype.entries = function entries () {
  return this.__iterator(ITERATE_ENTRIES);
};

Record.prototype.__iterator = function __iterator (type, reverse) {
  return recordSeq(this).__iterator(type, reverse);
};

Record.prototype.__iterate = function __iterate (fn, reverse) {
  return recordSeq(this).__iterate(fn, reverse);
};

Record.prototype.__ensureOwner = function __ensureOwner (ownerID) {
  if (ownerID === this.__ownerID) {
    return this;
  }
  var newValues = this._values.__ensureOwner(ownerID);
  if (!ownerID) {
    this.__ownerID = ownerID;
    this._values = newValues;
    return this;
  }
  return makeRecord(this, newValues, ownerID);
};

Record.isRecord = isRecord;
Record.getDescriptiveName = recordName;
var RecordPrototype = Record.prototype;
RecordPrototype[IS_RECORD_SENTINEL] = true;
RecordPrototype[DELETE] = RecordPrototype.remove;
RecordPrototype.deleteIn = RecordPrototype.removeIn = deleteIn;
RecordPrototype.getIn = getIn$$1;
RecordPrototype.hasIn = CollectionPrototype.hasIn;
RecordPrototype.merge = merge;
RecordPrototype.mergeWith = mergeWith;
RecordPrototype.mergeIn = mergeIn;
RecordPrototype.mergeDeep = mergeDeep;
RecordPrototype.mergeDeepWith = mergeDeepWith;
RecordPrototype.mergeDeepIn = mergeDeepIn;
RecordPrototype.setIn = setIn$$1;
RecordPrototype.update = update$$1;
RecordPrototype.updateIn = updateIn$1;
RecordPrototype.withMutations = withMutations;
RecordPrototype.asMutable = asMutable;
RecordPrototype.asImmutable = asImmutable;
RecordPrototype[ITERATOR_SYMBOL] = RecordPrototype.entries;
RecordPrototype.toJSON = RecordPrototype.toObject =
  CollectionPrototype.toObject;
RecordPrototype.inspect = RecordPrototype.toSource = function() {
  return this.toString();
};

function makeRecord(likeRecord, values, ownerID) {
  var record = Object.create(Object.getPrototypeOf(likeRecord));
  record._values = values;
  record.__ownerID = ownerID;
  return record;
}

function recordName(record) {
  return record._name || record.constructor.name || 'Record';
}

function recordSeq(record) {
  return keyedSeqFromValue(record._keys.map(function (k) { return [k, record.get(k)]; }));
}

function setProp(prototype, name) {
  try {
    Object.defineProperty(prototype, name, {
      get: function() {
        return this.get(name);
      },
      set: function(value) {
        invariant(this.__ownerID, 'Cannot set on an immutable record.');
        this.set(name, value);
      }
    });
  } catch (error) {
    // Object.defineProperty failed. Probably IE8.
  }
}

/**
 * Returns a lazy Seq of `value` repeated `times` times. When `times` is
 * undefined, returns an infinite sequence of `value`.
 */
var Repeat = (function (IndexedSeq$$1) {
  function Repeat(value, times) {
    if (!(this instanceof Repeat)) {
      return new Repeat(value, times);
    }
    this._value = value;
    this.size = times === undefined ? Infinity : Math.max(0, times);
    if (this.size === 0) {
      if (EMPTY_REPEAT) {
        return EMPTY_REPEAT;
      }
      EMPTY_REPEAT = this;
    }
  }

  if ( IndexedSeq$$1 ) Repeat.__proto__ = IndexedSeq$$1;
  Repeat.prototype = Object.create( IndexedSeq$$1 && IndexedSeq$$1.prototype );
  Repeat.prototype.constructor = Repeat;

  Repeat.prototype.toString = function toString () {
    if (this.size === 0) {
      return 'Repeat []';
    }
    return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';
  };

  Repeat.prototype.get = function get (index, notSetValue) {
    return this.has(index) ? this._value : notSetValue;
  };

  Repeat.prototype.includes = function includes (searchValue) {
    return is(this._value, searchValue);
  };

  Repeat.prototype.slice = function slice (begin, end) {
    var size = this.size;
    return wholeSlice(begin, end, size)
      ? this
      : new Repeat(
          this._value,
          resolveEnd(end, size) - resolveBegin(begin, size)
        );
  };

  Repeat.prototype.reverse = function reverse () {
    return this;
  };

  Repeat.prototype.indexOf = function indexOf (searchValue) {
    if (is(this._value, searchValue)) {
      return 0;
    }
    return -1;
  };

  Repeat.prototype.lastIndexOf = function lastIndexOf (searchValue) {
    if (is(this._value, searchValue)) {
      return this.size;
    }
    return -1;
  };

  Repeat.prototype.__iterate = function __iterate (fn, reverse) {
    var this$1 = this;

    var size = this.size;
    var i = 0;
    while (i !== size) {
      if (fn(this$1._value, reverse ? size - ++i : i++, this$1) === false) {
        break;
      }
    }
    return i;
  };

  Repeat.prototype.__iterator = function __iterator (type, reverse) {
    var this$1 = this;

    var size = this.size;
    var i = 0;
    return new Iterator(
      function () { return i === size
          ? iteratorDone()
          : iteratorValue(type, reverse ? size - ++i : i++, this$1._value); }
    );
  };

  Repeat.prototype.equals = function equals (other) {
    return other instanceof Repeat
      ? is(this._value, other._value)
      : deepEqual(other);
  };

  return Repeat;
}(IndexedSeq));

var EMPTY_REPEAT;

function fromJS(value, converter) {
  return fromJSWith(
    [],
    converter || defaultConverter,
    value,
    '',
    converter && converter.length > 2 ? [] : undefined,
    { '': value }
  );
}

function fromJSWith(stack, converter, value, key, keyPath, parentValue) {
  var toSeq = Array.isArray(value)
    ? IndexedSeq
    : isPlainObj(value) ? KeyedSeq : null;
  if (toSeq) {
    if (~stack.indexOf(value)) {
      throw new TypeError('Cannot convert circular structure to Immutable');
    }
    stack.push(value);
    keyPath && key !== '' && keyPath.push(key);
    var converted = converter.call(
      parentValue,
      key,
      toSeq(value).map(function (v, k) { return fromJSWith(stack, converter, v, k, keyPath, value); }
      ),
      keyPath && keyPath.slice()
    );
    stack.pop();
    keyPath && keyPath.pop();
    return converted;
  }
  return value;
}

function defaultConverter(k, v) {
  return isKeyed(v) ? v.toMap() : v.toList();
}

var version = "4.0.0-rc.9";

// Functional read/write API
var Immutable = {
  version: version,

  Collection: Collection,
  // Note: Iterable is deprecated
  Iterable: Collection,

  Seq: Seq,
  Map: Map,
  OrderedMap: OrderedMap,
  List: List,
  Stack: Stack,
  Set: Set,
  OrderedSet: OrderedSet,

  Record: Record,
  Range: Range,
  Repeat: Repeat,

  is: is,
  fromJS: fromJS,
  hash: hash,

  isImmutable: isImmutable,
  isCollection: isCollection,
  isKeyed: isKeyed,
  isIndexed: isIndexed,
  isAssociative: isAssociative,
  isOrdered: isOrdered,
  isValueObject: isValueObject,

  get: get,
  getIn: getIn$1,
  has: has,
  hasIn: hasIn$1,
  merge: merge$1,
  mergeDeep: mergeDeep$1,
  mergeWith: mergeWith$1,
  mergeDeepWith: mergeDeepWith$1,
  remove: remove,
  removeIn: removeIn,
  set: set,
  setIn: setIn$1,
  update: update$1,
  updateIn: updateIn
};

// Note: Iterable is deprecated
var Iterable = Collection;


/* unused harmony default export */ var _unused_webpack_default_export = (Immutable);


/***/ }),

/***/ "./node_modules/is-in-browser/dist/module.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBrowser", function() { return isBrowser; });
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var isBrowser = (typeof window === "undefined" ? "undefined" : _typeof(window)) === "object" && (typeof document === "undefined" ? "undefined" : _typeof(document)) === 'object' && document.nodeType === 9;

/* harmony default export */ __webpack_exports__["default"] = (isBrowser);


/***/ }),

/***/ "./node_modules/isarray/index.js":
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ "./node_modules/lodash._getnative/index.js":
/***/ (function(module, exports) {

/**
 * lodash 3.9.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** `Object#toString` result references. */
var funcTag = '[object Function]';

/** Used to detect host constructors (Safari > 5). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/**
 * Checks if `value` is object-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var fnToString = Function.prototype.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = object == null ? undefined : object[key];
  return isNative(value) ? value : undefined;
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in older versions of Chrome and Safari which return 'function' for regexes
  // and Safari 8 equivalents which return 'object' for typed array constructors.
  return isObject(value) && objToString.call(value) == funcTag;
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is a native function.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
 * @example
 *
 * _.isNative(Array.prototype.push);
 * // => true
 *
 * _.isNative(_);
 * // => false
 */
function isNative(value) {
  if (value == null) {
    return false;
  }
  if (isFunction(value)) {
    return reIsNative.test(fnToString.call(value));
  }
  return isObjectLike(value) && reIsHostCtor.test(value);
}

module.exports = getNative;


/***/ }),

/***/ "./node_modules/lodash.debounce/index.js":
/***/ (function(module, exports, __webpack_require__) {

/**
 * lodash 3.1.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var getNative = __webpack_require__("./node_modules/lodash._getnative/index.js");

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/* Native method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeNow = getNative(Date, 'now');

/**
 * Gets the number of milliseconds that have elapsed since the Unix epoch
 * (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @category Date
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => logs the number of milliseconds it took for the deferred function to be invoked
 */
var now = nativeNow || function() {
  return new Date().getTime();
};

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed invocations. Provide an options object to indicate that `func`
 * should be invoked on the leading and/or trailing edge of the `wait` timeout.
 * Subsequent calls to the debounced function return the result of the last
 * `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
 * on the trailing edge of the timeout only if the the debounced function is
 * invoked more than once during the `wait` timeout.
 *
 * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options] The options object.
 * @param {boolean} [options.leading=false] Specify invoking on the leading
 *  edge of the timeout.
 * @param {number} [options.maxWait] The maximum time `func` is allowed to be
 *  delayed before it is invoked.
 * @param {boolean} [options.trailing=true] Specify invoking on the trailing
 *  edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // avoid costly calculations while the window size is in flux
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // invoke `sendMail` when the click event is fired, debouncing subsequent calls
 * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // ensure `batchLog` is invoked once after 1 second of debounced calls
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', _.debounce(batchLog, 250, {
 *   'maxWait': 1000
 * }));
 *
 * // cancel a debounced call
 * var todoChanges = _.debounce(batchLog, 1000);
 * Object.observe(models.todo, todoChanges);
 *
 * Object.observe(models, function(changes) {
 *   if (_.find(changes, { 'user': 'todo', 'type': 'delete'})) {
 *     todoChanges.cancel();
 *   }
 * }, ['delete']);
 *
 * // ...at some point `models.todo` is changed
 * models.todo.completed = true;
 *
 * // ...before 1 second has passed `models.todo` is deleted
 * // which cancels the debounced `todoChanges` call
 * delete models.todo;
 */
function debounce(func, wait, options) {
  var args,
      maxTimeoutId,
      result,
      stamp,
      thisArg,
      timeoutId,
      trailingCall,
      lastCalled = 0,
      maxWait = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = wait < 0 ? 0 : (+wait || 0);
  if (options === true) {
    var leading = true;
    trailing = false;
  } else if (isObject(options)) {
    leading = !!options.leading;
    maxWait = 'maxWait' in options && nativeMax(+options.maxWait || 0, wait);
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function cancel() {
    if (timeoutId) {
      clearTimeout(timeoutId);
    }
    if (maxTimeoutId) {
      clearTimeout(maxTimeoutId);
    }
    lastCalled = 0;
    maxTimeoutId = timeoutId = trailingCall = undefined;
  }

  function complete(isCalled, id) {
    if (id) {
      clearTimeout(id);
    }
    maxTimeoutId = timeoutId = trailingCall = undefined;
    if (isCalled) {
      lastCalled = now();
      result = func.apply(thisArg, args);
      if (!timeoutId && !maxTimeoutId) {
        args = thisArg = undefined;
      }
    }
  }

  function delayed() {
    var remaining = wait - (now() - stamp);
    if (remaining <= 0 || remaining > wait) {
      complete(trailingCall, maxTimeoutId);
    } else {
      timeoutId = setTimeout(delayed, remaining);
    }
  }

  function maxDelayed() {
    complete(trailing, timeoutId);
  }

  function debounced() {
    args = arguments;
    stamp = now();
    thisArg = this;
    trailingCall = trailing && (timeoutId || !leading);

    if (maxWait === false) {
      var leadingCall = leading && !timeoutId;
    } else {
      if (!maxTimeoutId && !leading) {
        lastCalled = stamp;
      }
      var remaining = maxWait - (stamp - lastCalled),
          isCalled = remaining <= 0 || remaining > maxWait;

      if (isCalled) {
        if (maxTimeoutId) {
          maxTimeoutId = clearTimeout(maxTimeoutId);
        }
        lastCalled = stamp;
        result = func.apply(thisArg, args);
      }
      else if (!maxTimeoutId) {
        maxTimeoutId = setTimeout(maxDelayed, remaining);
      }
    }
    if (isCalled && timeoutId) {
      timeoutId = clearTimeout(timeoutId);
    }
    else if (!timeoutId && wait !== maxWait) {
      timeoutId = setTimeout(delayed, wait);
    }
    if (leadingCall) {
      isCalled = true;
      result = func.apply(thisArg, args);
    }
    if (isCalled && !timeoutId && !maxTimeoutId) {
      args = thisArg = undefined;
    }
    return result;
  }
  debounced.cancel = cancel;
  return debounced;
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

module.exports = debounce;


/***/ }),

/***/ "./node_modules/lodash.throttle/index.js":
/***/ (function(module, exports, __webpack_require__) {

/**
 * lodash 3.0.4 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var debounce = __webpack_require__("./node_modules/lodash.debounce/index.js");

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed invocations. Provide an options object to indicate
 * that `func` should be invoked on the leading and/or trailing edge of the
 * `wait` timeout. Subsequent calls to the throttled function return the
 * result of the last `func` call.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
 * on the trailing edge of the timeout only if the the throttled function is
 * invoked more than once during the `wait` timeout.
 *
 * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options] The options object.
 * @param {boolean} [options.leading=true] Specify invoking on the leading
 *  edge of the timeout.
 * @param {boolean} [options.trailing=true] Specify invoking on the trailing
 *  edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // avoid excessively updating the position while scrolling
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // invoke `renewToken` when the click event is fired, but not more than once every 5 minutes
 * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
 *   'trailing': false
 * }));
 *
 * // cancel a trailing throttled call
 * jQuery(window).on('popstate', throttled.cancel);
 */
function throttle(func, wait, options) {
  var leading = true,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if (options === false) {
    leading = false;
  } else if (isObject(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }
  return debounce(func, wait, { 'leading': leading, 'maxWait': +wait, 'trailing': trailing });
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

module.exports = throttle;


/***/ }),

/***/ "./node_modules/ms/index.js":
/***/ (function(module, exports) {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (ms >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (ms >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (ms >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  return plural(ms, d, 'day') ||
    plural(ms, h, 'hour') ||
    plural(ms, m, 'minute') ||
    plural(ms, s, 'second') ||
    ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) {
    return;
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }
  return Math.ceil(ms / n) + ' ' + name + 's';
}


/***/ }),

/***/ "./node_modules/next/dist/lib/head.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _set = __webpack_require__("./node_modules/babel-runtime/core-js/set.js");

var _set2 = _interopRequireDefault(_set);

var _toConsumableArray2 = __webpack_require__("./node_modules/babel-runtime/helpers/toConsumableArray.js");

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _getPrototypeOf = __webpack_require__("./node_modules/babel-runtime/core-js/object/get-prototype-of.js");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = __webpack_require__("./node_modules/babel-runtime/helpers/classCallCheck.js");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__("./node_modules/babel-runtime/helpers/createClass.js");

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __webpack_require__("./node_modules/babel-runtime/helpers/possibleConstructorReturn.js");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__("./node_modules/babel-runtime/helpers/inherits.js");

var _inherits3 = _interopRequireDefault(_inherits2);

exports.defaultHead = defaultHead;

var _react = __webpack_require__("./node_modules/react/cjs/react.development.js");

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__("./node_modules/prop-types/index.js");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _sideEffect = __webpack_require__("./node_modules/next/dist/lib/side-effect.js");

var _sideEffect2 = _interopRequireDefault(_sideEffect);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Head = function (_React$Component) {
  (0, _inherits3.default)(Head, _React$Component);

  function Head() {
    (0, _classCallCheck3.default)(this, Head);
    return (0, _possibleConstructorReturn3.default)(this, (Head.__proto__ || (0, _getPrototypeOf2.default)(Head)).apply(this, arguments));
  }

  (0, _createClass3.default)(Head, [{
    key: 'render',
    value: function render() {
      return null;
    }
  }]);
  return Head;
}(_react2.default.Component);

Head.contextTypes = {
  headManager: _propTypes2.default.object
};
function defaultHead() {
  return [_react2.default.createElement('meta', { charSet: 'utf-8', className: 'next-head' })];
}

function reduceComponents(components) {
  var _components$map$map$r;

  return (_components$map$map$r = components.map(function (c) {
    return c.props.children;
  }).map(function (children) {
    return _react2.default.Children.toArray(children);
  }).reduce(function (a, b) {
    return a.concat(b);
  }, []).reduce(function (a, b) {
    if (_react2.default.Fragment && b.type === _react2.default.Fragment) {
      return a.concat(_react2.default.Children.toArray(b.props.children));
    }
    return a.concat(b);
  }, []).reverse()).concat.apply(_components$map$map$r, (0, _toConsumableArray3.default)(defaultHead())).filter(function (c) {
    return !!c;
  }).filter(unique()).reverse().map(function (c) {
    var className = (c.props && c.props.className ? c.props.className + ' ' : '') + 'next-head';
    return _react2.default.cloneElement(c, { className: className });
  });
}

function mapOnServer(head) {
  return head;
}

function onStateChange(head) {
  if (this.context && this.context.headManager) {
    this.context.headManager.updateHead(head);
  }
}

var METATYPES = ['name', 'httpEquiv', 'charSet', 'itemProp', 'property'];

// returns a function for filtering head child elements
// which shouldn't be duplicated, like <title/>.

function unique() {
  var keys = new _set2.default();
  var tags = new _set2.default();
  var metaTypes = new _set2.default();
  var metaCategories = {};

  return function (h) {
    if (h.key && h.key.startsWith('.$')) {
      if (keys.has(h.key)) return false;
      keys.add(h.key);
    }
    switch (h.type) {
      case 'title':
      case 'base':
        if (tags.has(h.type)) return false;
        tags.add(h.type);
        break;
      case 'meta':
        for (var i = 0, len = METATYPES.length; i < len; i++) {
          var metatype = METATYPES[i];
          if (!h.props.hasOwnProperty(metatype)) continue;

          if (metatype === 'charSet') {
            if (metaTypes.has(metatype)) return false;
            metaTypes.add(metatype);
          } else {
            var category = h.props[metatype];
            var categories = metaCategories[metatype] || new _set2.default();
            if (categories.has(category)) return false;
            categories.add(category);
            metaCategories[metatype] = categories;
          }
        }
        break;
    }
    return true;
  };
}

exports.default = (0, _sideEffect2.default)(reduceComponents, onStateChange, mapOnServer)(Head);

/***/ }),

/***/ "./node_modules/next/dist/lib/side-effect.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = __webpack_require__("./node_modules/babel-runtime/core-js/object/get-prototype-of.js");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = __webpack_require__("./node_modules/babel-runtime/helpers/classCallCheck.js");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__("./node_modules/babel-runtime/helpers/createClass.js");

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __webpack_require__("./node_modules/babel-runtime/helpers/possibleConstructorReturn.js");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__("./node_modules/babel-runtime/helpers/inherits.js");

var _inherits3 = _interopRequireDefault(_inherits2);

var _toConsumableArray2 = __webpack_require__("./node_modules/babel-runtime/helpers/toConsumableArray.js");

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _set = __webpack_require__("./node_modules/babel-runtime/core-js/set.js");

var _set2 = _interopRequireDefault(_set);

exports.default = withSideEffect;

var _react = __webpack_require__("./node_modules/react/cjs/react.development.js");

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__("./node_modules/next/dist/lib/utils.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function withSideEffect(reduceComponentsToState, handleStateChangeOnClient, mapStateOnServer) {
  if (typeof reduceComponentsToState !== 'function') {
    throw new Error('Expected reduceComponentsToState to be a function.');
  }

  if (typeof handleStateChangeOnClient !== 'function') {
    throw new Error('Expected handleStateChangeOnClient to be a function.');
  }

  if (typeof mapStateOnServer !== 'undefined' && typeof mapStateOnServer !== 'function') {
    throw new Error('Expected mapStateOnServer to either be undefined or a function.');
  }

  return function wrap(WrappedComponent) {
    if (typeof WrappedComponent !== 'function') {
      throw new Error('Expected WrappedComponent to be a React component.');
    }

    var mountedInstances = new _set2.default();
    var state = void 0;

    function emitChange(component) {
      state = reduceComponentsToState([].concat((0, _toConsumableArray3.default)(mountedInstances)));

      if (SideEffect.canUseDOM) {
        handleStateChangeOnClient.call(component, state);
      } else if (mapStateOnServer) {
        state = mapStateOnServer(state);
      }
    }

    var SideEffect = function (_Component) {
      (0, _inherits3.default)(SideEffect, _Component);

      function SideEffect() {
        (0, _classCallCheck3.default)(this, SideEffect);
        return (0, _possibleConstructorReturn3.default)(this, (SideEffect.__proto__ || (0, _getPrototypeOf2.default)(SideEffect)).apply(this, arguments));
      }

      (0, _createClass3.default)(SideEffect, [{
        key: 'componentWillMount',
        value: function componentWillMount() {
          mountedInstances.add(this);
          emitChange(this);
        }
      }, {
        key: 'componentDidUpdate',
        value: function componentDidUpdate() {
          emitChange(this);
        }
      }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
          mountedInstances.delete(this);
          emitChange(this);
        }
      }, {
        key: 'render',
        value: function render() {
          return _react2.default.createElement(
            WrappedComponent,
            null,
            this.props.children
          );
        }
      }], [{
        key: 'peek',
        value: function peek() {
          return state;
        }

        // Expose canUseDOM so tests can monkeypatch it

        // Try to use displayName of wrapped component

      }, {
        key: 'rewind',
        value: function rewind() {
          if (SideEffect.canUseDOM) {
            throw new Error('You may only call rewind() on the server. Call peek() to read the current state.');
          }

          var recordedState = state;
          state = undefined;
          mountedInstances.clear();
          return recordedState;
        }
      }]);
      return SideEffect;
    }(_react.Component);

    SideEffect.displayName = 'SideEffect(' + (0, _utils.getDisplayName)(WrappedComponent) + ')';
    SideEffect.contextTypes = WrappedComponent.contextTypes;
    SideEffect.canUseDOM = typeof window !== 'undefined';


    return SideEffect;
  };
}

/***/ }),

/***/ "./node_modules/next/dist/lib/utils.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.loadGetInitialProps = undefined;

var _regenerator = __webpack_require__("./node_modules/babel-runtime/regenerator/index.js");

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = __webpack_require__("./node_modules/babel-runtime/helpers/asyncToGenerator.js");

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _assign = __webpack_require__("./node_modules/babel-runtime/core-js/object/assign.js");

var _assign2 = _interopRequireDefault(_assign);

var loadGetInitialProps = exports.loadGetInitialProps = function () {
  var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(Component, ctx) {
    var props, compName, message;
    return _regenerator2.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (Component.getInitialProps) {
              _context.next = 2;
              break;
            }

            return _context.abrupt('return', {});

          case 2:
            _context.next = 4;
            return Component.getInitialProps(ctx);

          case 4:
            props = _context.sent;

            if (!(ctx.res && isResSent(ctx.res))) {
              _context.next = 7;
              break;
            }

            return _context.abrupt('return', props);

          case 7:
            if (props) {
              _context.next = 11;
              break;
            }

            compName = getDisplayName(Component);
            message = '"' + compName + '.getInitialProps()" should resolve to an object. But found "' + props + '" instead.';
            throw new Error(message);

          case 11:
            return _context.abrupt('return', props);

          case 12:
          case 'end':
            return _context.stop();
        }
      }
    }, _callee, this);
  }));

  return function loadGetInitialProps(_x2, _x3) {
    return _ref.apply(this, arguments);
  };
}();

exports.warn = warn;
exports.execOnce = execOnce;
exports.deprecated = deprecated;
exports.printAndExit = printAndExit;
exports.getDisplayName = getDisplayName;
exports.isResSent = isResSent;
exports.getLocationOrigin = getLocationOrigin;
exports.getURL = getURL;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function warn(message) {
  if (true) {
    console.error(message);
  }
}

function execOnce(fn) {
  var _this = this;

  var used = false;
  return function () {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    if (!used) {
      used = true;
      fn.apply(_this, args);
    }
  };
}

function deprecated(fn, message) {
  if (false) return fn;

  var warned = false;
  var newFn = function newFn() {
    if (!warned) {
      warned = true;
      console.error(message);
    }

    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return fn.apply(this, args);
  };

  // copy all properties
  (0, _assign2.default)(newFn, fn);

  return newFn;
}

function printAndExit(message) {
  var code = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

  if (code === 0) {
    console.log(message);
  } else {
    console.error(message);
  }

  process.exit(code);
}

function getDisplayName(Component) {
  return Component.displayName || Component.name || 'Unknown';
}

function isResSent(res) {
  return res.finished || res.headersSent;
}

function getLocationOrigin() {
  var _window$location = window.location,
      protocol = _window$location.protocol,
      hostname = _window$location.hostname,
      port = _window$location.port;

  return protocol + '//' + hostname + (port ? ':' + port : '');
}

function getURL() {
  var href = window.location.href;

  var origin = getLocationOrigin();
  return href.substring(origin.length);
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/next/head.js":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__("./node_modules/next/dist/lib/head.js")


/***/ }),

/***/ "./node_modules/object-assign/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),

/***/ "./node_modules/parseqs/index.js":
/***/ (function(module, exports) {

/**
 * Compiles a querystring
 * Returns string representation of the object
 *
 * @param {Object}
 * @api private
 */

exports.encode = function (obj) {
  var str = '';

  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      if (str.length) str += '&';
      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
    }
  }

  return str;
};

/**
 * Parses a simple querystring into an object
 *
 * @param {String} qs
 * @api private
 */

exports.decode = function(qs){
  var qry = {};
  var pairs = qs.split('&');
  for (var i = 0, l = pairs.length; i < l; i++) {
    var pair = pairs[i].split('=');
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }
  return qry;
};


/***/ }),

/***/ "./node_modules/parseuri/index.js":
/***/ (function(module, exports) {

/**
 * Parses an URI
 *
 * @author Steven Levithan <stevenlevithan.com> (MIT license)
 * @api private
 */

var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

var parts = [
    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
];

module.exports = function parseuri(str) {
    var src = str,
        b = str.indexOf('['),
        e = str.indexOf(']');

    if (b != -1 && e != -1) {
        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
    }

    var m = re.exec(str || ''),
        uri = {},
        i = 14;

    while (i--) {
        uri[parts[i]] = m[i] || '';
    }

    if (b != -1 && e != -1) {
        uri.source = src;
        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
        uri.ipv6uri = true;
    }

    uri.pathNames = pathNames(uri, uri['path']);
    uri.queryKey = queryKey(uri, uri['query']);

    return uri;
};

function pathNames(obj, path) {
    var regx = /\/{2,9}/g,
        names = path.replace(regx, "/").split("/");

    if (path.substr(0, 1) == '/' || path.length === 0) {
        names.splice(0, 1);
    }
    if (path.substr(path.length - 1, 1) == '/') {
        names.splice(names.length - 1, 1);
    }

    return names;
}

function queryKey(uri, query) {
    var data = {};

    query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function ($0, $1, $2) {
        if ($1) {
            data[$1] = $2;
        }
    });

    return data;
}


/***/ }),

/***/ "./node_modules/process/browser.js":
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/prop-types/checkPropTypes.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (true) {
  var invariant = __webpack_require__("./node_modules/fbjs/lib/invariant.js");
  var warning = __webpack_require__("./node_modules/fbjs/lib/warning.js");
  var ReactPropTypesSecret = __webpack_require__("./node_modules/prop-types/lib/ReactPropTypesSecret.js");
  var loggedTypeFailures = {};
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (true) {
    for (var typeSpecName in typeSpecs) {
      if (typeSpecs.hasOwnProperty(typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          invariant(typeof typeSpecs[typeSpecName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'the `prop-types` package, but received `%s`.', componentName || 'React class', location, typeSpecName, typeof typeSpecs[typeSpecName]);
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error);
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          warning(false, 'Failed %s type: %s%s', location, error.message, stack != null ? stack : '');
        }
      }
    }
  }
}

module.exports = checkPropTypes;


/***/ }),

/***/ "./node_modules/prop-types/factoryWithTypeCheckers.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var emptyFunction = __webpack_require__("./node_modules/fbjs/lib/emptyFunction.js");
var invariant = __webpack_require__("./node_modules/fbjs/lib/invariant.js");
var warning = __webpack_require__("./node_modules/fbjs/lib/warning.js");
var assign = __webpack_require__("./node_modules/object-assign/index.js");

var ReactPropTypesSecret = __webpack_require__("./node_modules/prop-types/lib/ReactPropTypesSecret.js");
var checkPropTypes = __webpack_require__("./node_modules/prop-types/checkPropTypes.js");

module.exports = function(isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker,
    exact: createStrictShapeTypeChecker,
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message) {
    this.message = message;
    this.stack = '';
  }
  // Make `instanceof Error` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if (true) {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          invariant(
            false,
            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
            'Use `PropTypes.checkPropTypes()` to call them. ' +
            'Read more at http://fb.me/use-check-prop-types'
          );
        } else if ("development" !== 'production' && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;
          if (
            !manualPropTypeCallCache[cacheKey] &&
            // Avoid spamming the console because they are often not actionable except for lib authors
            manualPropTypeWarningCount < 3
          ) {
            warning(
              false,
              'You are manually calling a React.PropTypes validation ' +
              'function for the `%s` prop on `%s`. This is deprecated ' +
              'and will throw in the standalone `prop-types` package. ' +
              'You may be seeing this warning due to a third-party PropTypes ' +
              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.',
              propFullName,
              componentName
            );
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }
          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunction.thatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
       true ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
      return emptyFunction.thatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues);
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (propValue.hasOwnProperty(key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
       true ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
      return emptyFunction.thatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (typeof checker !== 'function') {
        warning(
          false,
          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
          'received %s at index %s.',
          getPostfixForTypeWarning(checker),
          i
        );
        return emptyFunction.thatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
          return null;
        }
      }

      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createStrictShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      // We need to check all keys in case some are required but missing from
      // props.
      var allKeys = assign({}, props[propName], shapeTypes);
      for (var key in allKeys) {
        var checker = shapeTypes[key];
        if (!checker) {
          return new PropTypeError(
            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
            '\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')
          );
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of `typeof` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue;
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);
    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;
      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;
      default:
        return type;
    }
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),

/***/ "./node_modules/prop-types/index.js":
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (true) {
  var REACT_ELEMENT_TYPE = (typeof Symbol === 'function' &&
    Symbol.for &&
    Symbol.for('react.element')) ||
    0xeac7;

  var isValidElement = function(object) {
    return typeof object === 'object' &&
      object !== null &&
      object.$$typeof === REACT_ELEMENT_TYPE;
  };

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = __webpack_require__("./node_modules/prop-types/factoryWithTypeCheckers.js")(isValidElement, throwOnDirectAccess);
} else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = require('./factoryWithThrowingShims')();
}


/***/ }),

/***/ "./node_modules/prop-types/lib/ReactPropTypesSecret.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),

/***/ "./node_modules/react-hot-loader/lib/global/generation.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
var generation = 0;

var increment = exports.increment = function increment() {
  return generation++;
};
var get = exports.get = function get() {
  return generation;
};

/***/ }),

/***/ "./node_modules/react-hot-loader/lib/global/modules.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.leave = exports.enter = exports.isOpened = exports.hotModule = undefined;

var _logger = __webpack_require__("./node_modules/react-hot-loader/lib/logger.js");

var _logger2 = _interopRequireDefault(_logger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var openedModules = {};

var hotModules = {};

var createHotModule = function createHotModule() {
  return { instances: [], updateTimeout: 0 };
};

var hotModule = exports.hotModule = function hotModule(moduleId) {
  if (!hotModules[moduleId]) {
    hotModules[moduleId] = createHotModule();
  }
  return hotModules[moduleId];
};

var isOpened = exports.isOpened = function isOpened(sourceModule) {
  return sourceModule && !!openedModules[sourceModule.id];
};

var enter = exports.enter = function enter(sourceModule) {
  if (sourceModule && sourceModule.id) {
    openedModules[sourceModule.id] = true;
  } else {
    _logger2.default.warn('React-hot-loader: no `module` variable found. Do you shadow system variable?');
  }
};

var leave = exports.leave = function leave(sourceModule) {
  if (sourceModule && sourceModule.id) {
    delete openedModules[sourceModule.id];
  }
};

/***/ }),

/***/ "./node_modules/react-hot-loader/lib/internal/reactUtils.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.isFragmentNode = exports.updateInstance = exports.getInternalInstance = exports.getComponentDisplayName = exports.isCompositeComponent = undefined;

var _react = __webpack_require__("./node_modules/react/cjs/react.development.js");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable no-underscore-dangle */

var isCompositeComponent = exports.isCompositeComponent = function isCompositeComponent(type) {
  return typeof type === 'function';
};

var getComponentDisplayName = exports.getComponentDisplayName = function getComponentDisplayName(type) {
  return type.displayName || type.name || 'Component';
};

var getInternalInstance = exports.getInternalInstance = function getInternalInstance(instance) {
  return instance._reactInternalFiber || // React 16
  instance._reactInternalInstance || // React 15
  null;
};

var updateInstance = exports.updateInstance = function updateInstance(instance) {
  var updater = instance.updater,
      forceUpdate = instance.forceUpdate;

  if (typeof forceUpdate === 'function') {
    instance.forceUpdate();
  } else if (updater && typeof updater.enqueueForceUpdate === 'function') {
    updater.enqueueForceUpdate(instance);
  }
};

var isFragmentNode = exports.isFragmentNode = function isFragmentNode(_ref) {
  var type = _ref.type;
  return _react2.default.Fragment && type === _react2.default.Fragment;
};

/***/ }),

/***/ "./node_modules/react-hot-loader/lib/logger.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _reactHotLoader = __webpack_require__("./node_modules/react-hot-loader/lib/reactHotLoader.js");

var _reactHotLoader2 = _interopRequireDefault(_reactHotLoader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var logger = {
  debug: function debug() {
    if (['debug'].includes(_reactHotLoader2.default.config.logLevel)) {
      var _console;

      (_console = console).debug.apply(_console, arguments);
    }
  },
  log: function log() {
    if (['debug', 'log'].includes(_reactHotLoader2.default.config.logLevel)) {
      var _console2;

      (_console2 = console).log.apply(_console2, arguments);
    }
  },
  warn: function warn() {
    if (['debug', 'log', 'warn'].includes(_reactHotLoader2.default.config.logLevel)) {
      var _console3;

      (_console3 = console).warn.apply(_console3, arguments);
    }
  },
  error: function error() {
    if (['debug', 'log', 'warn', 'error'].includes(_reactHotLoader2.default.config.logLevel)) {
      var _console4;

      (_console4 = console).error.apply(_console4, arguments);
    }
  }
}; /* eslint-disable no-console */
exports.default = logger;

/***/ }),

/***/ "./node_modules/react-hot-loader/lib/patch.dev.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.leaveModule = exports.enterModule = undefined;

var _modules = __webpack_require__("./node_modules/react-hot-loader/lib/global/modules.js");

Object.defineProperty(exports, 'enterModule', {
  enumerable: true,
  get: function get() {
    return _modules.enter;
  }
});
Object.defineProperty(exports, 'leaveModule', {
  enumerable: true,
  get: function get() {
    return _modules.leave;
  }
});

var _react = __webpack_require__("./node_modules/react/cjs/react.development.js");

var _react2 = _interopRequireDefault(_react);

var _reactHotLoader = __webpack_require__("./node_modules/react-hot-loader/lib/reactHotLoader.js");

var _reactHotLoader2 = _interopRequireDefault(_reactHotLoader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_reactHotLoader2.default.patch(_react2.default);

exports.default = _reactHotLoader2.default;

/***/ }),

/***/ "./node_modules/react-hot-loader/lib/patch.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* eslint-disable global-require, import/no-mutable-exports */

if (false) {
  module.exports = require('./prod/patch.prod');
} else {
  module.exports = __webpack_require__("./node_modules/react-hot-loader/lib/patch.dev.js");
}

/***/ }),

/***/ "./node_modules/react-hot-loader/lib/reactHotLoader.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; /* eslint-disable no-use-before-define */


var _reactUtils = __webpack_require__("./node_modules/react-hot-loader/lib/internal/reactUtils.js");

var _generation = __webpack_require__("./node_modules/react-hot-loader/lib/global/generation.js");

var _proxies = __webpack_require__("./node_modules/react-hot-loader/lib/reconciler/proxies.js");

function resolveType(type) {
  if (!(0, _reactUtils.isCompositeComponent)(type)) return type;

  var proxy = reactHotLoader.disableProxyCreation ? (0, _proxies.getProxyByType)(type) : (0, _proxies.createProxyForType)(type);

  return proxy ? proxy.get() : type;
}

var reactHotLoader = {
  register: function register(type, uniqueLocalName, fileName) {
    if ((0, _reactUtils.isCompositeComponent)(type) && typeof uniqueLocalName === 'string' && uniqueLocalName && typeof fileName === 'string' && fileName) {
      (0, _generation.increment)();
      (0, _proxies.updateProxyById)(fileName + '#' + uniqueLocalName, type);
    }
  },
  reset: function reset() {
    (0, _proxies.resetProxies)();
  },
  patch: function patch(React) {
    if (!React.createElement.isPatchedByReactHotLoader) {
      var originalCreateElement = React.createElement;
      // Trick React into rendering a proxy so that
      // its state is preserved when the class changes.
      // This will update the proxy if it's for a known type.
      React.createElement = function (type) {
        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        return originalCreateElement.apply(undefined, [resolveType(type)].concat(args));
      };
      React.createElement.isPatchedByReactHotLoader = true;
    }

    if (!React.createFactory.isPatchedByReactHotLoader) {
      // Patch React.createFactory to use patched createElement
      // because the original implementation uses the internal,
      // unpatched ReactElement.createElement
      React.createFactory = function (type) {
        var factory = React.createElement.bind(null, type);
        factory.type = type;
        return factory;
      };
      React.createFactory.isPatchedByReactHotLoader = true;
    }

    if (!React.Children.only.isPatchedByReactHotLoader) {
      var originalChildrenOnly = React.Children.only;
      // Use the same trick as React.createElement
      React.Children.only = function (children) {
        return originalChildrenOnly(_extends({}, children, { type: resolveType(children.type) }));
      };
      React.Children.only.isPatchedByReactHotLoader = true;
    }

    reactHotLoader.reset();
  },


  disableProxyCreation: false,

  config: {
    logLevel: 'error'
  }
};

exports.default = reactHotLoader;

/***/ }),

/***/ "./node_modules/react-hot-loader/lib/reconciler/proxies.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.resetProxies = exports.createProxyForType = exports.updateProxyById = exports.getProxyByType = exports.getIdByType = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _reactStandIn = __webpack_require__("./node_modules/react-stand-in/lib/index.js");

var _reactStandIn2 = _interopRequireDefault(_reactStandIn);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var proxiesByID = void 0;
var idsByType = void 0;

var elementCount = 0;

var generateTypeId = function generateTypeId() {
  return 'auto-' + elementCount++;
};

var getIdByType = exports.getIdByType = function getIdByType(type) {
  return idsByType.get(type);
};

var getProxyByType = exports.getProxyByType = function getProxyByType(type) {
  return proxiesByID[getIdByType(type)];
};

var autoWrapper = function autoWrapper(element) {
  // post wrap on post render
  if (!element) {
    return element;
  }
  if (Array.isArray(element)) {
    return element.map(autoWrapper);
  }
  if (typeof element.type === 'function') {
    var proxy = getProxyByType(element.type);
    if (proxy) {
      return _extends({}, element, {
        type: proxy.get()
      });
    }
  }
  return element;
};

var updateProxyById = exports.updateProxyById = function updateProxyById(id, type) {
  // Remember the ID.
  idsByType.set(type, id);

  if (!proxiesByID[id]) {
    proxiesByID[id] = (0, _reactStandIn2.default)(type, id, autoWrapper);
  } else {
    proxiesByID[id].update(type);
  }
  return proxiesByID[id];
};

var createProxyForType = exports.createProxyForType = function createProxyForType(type) {
  return getProxyByType(type) || updateProxyById(generateTypeId(), type);
};

var resetProxies = exports.resetProxies = function resetProxies() {
  proxiesByID = {};
  idsByType = new WeakMap();
};

/***/ }),

/***/ "./node_modules/react-hot-loader/patch.js":
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable import/no-unresolved */
module.exports = __webpack_require__("./node_modules/react-hot-loader/lib/patch.js")


/***/ }),

/***/ "./node_modules/react-input-range/lib/js/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _inputRange = __webpack_require__("./node_modules/react-input-range/lib/js/input-range/input-range.js");

var _inputRange2 = _interopRequireDefault(_inputRange);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @ignore
 * @typedef {Object} ClientRect
 * @property {number} height
 * @property {number} left
 * @property {number} top
 * @property {number} width
 */

/**
 * @typedef {Object} InputRangeClassNames
 * @property {string} activeTrack
 * @property {string} disabledInputRange
 * @property {string} inputRange
 * @property {string} labelContainer
 * @property {string} maxLabel
 * @property {string} minLabel
 * @property {string} slider
 * @property {string} sliderContainer
 * @property {string} track
 * @property {string} valueLabel
 */

/**
 * @typedef {Function} LabelFormatter
 * @param {number} value
 * @param {string} type
 * @return {string}
 */

/**
 * @ignore
 * @typedef {Object} Point
 * @property {number} x
 * @property {number} y
 */

/**
 * @typedef {Object} Range
 * @property {number} min - Min value
 * @property {number} max - Max value
 */

exports.default = _inputRange2.default;
module.exports = exports['default'];
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/react-input-range/lib/js/input-range/default-class-names.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Default CSS class names
 * @ignore
 * @type {InputRangeClassNames}
 */
var DEFAULT_CLASS_NAMES = {
  activeTrack: 'input-range__track input-range__track--active',
  disabledInputRange: 'input-range input-range--disabled',
  inputRange: 'input-range',
  labelContainer: 'input-range__label-container',
  maxLabel: 'input-range__label input-range__label--max',
  minLabel: 'input-range__label input-range__label--min',
  slider: 'input-range__slider',
  sliderContainer: 'input-range__slider-container',
  track: 'input-range__track input-range__track--background',
  valueLabel: 'input-range__label input-range__label--value'
};

exports.default = DEFAULT_CLASS_NAMES;
module.exports = exports['default'];
//# sourceMappingURL=default-class-names.js.map

/***/ }),

/***/ "./node_modules/react-input-range/lib/js/input-range/input-range.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _desc, _value, _class;

var _react = __webpack_require__("./node_modules/react/cjs/react.development.js");

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__("./node_modules/prop-types/index.js");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _autobindDecorator = __webpack_require__("./node_modules/autobind-decorator/lib/index.js");

var _autobindDecorator2 = _interopRequireDefault(_autobindDecorator);

var _valueTransformer = __webpack_require__("./node_modules/react-input-range/lib/js/input-range/value-transformer.js");

var valueTransformer = _interopRequireWildcard(_valueTransformer);

var _defaultClassNames = __webpack_require__("./node_modules/react-input-range/lib/js/input-range/default-class-names.js");

var _defaultClassNames2 = _interopRequireDefault(_defaultClassNames);

var _label = __webpack_require__("./node_modules/react-input-range/lib/js/input-range/label.js");

var _label2 = _interopRequireDefault(_label);

var _rangePropType = __webpack_require__("./node_modules/react-input-range/lib/js/input-range/range-prop-type.js");

var _rangePropType2 = _interopRequireDefault(_rangePropType);

var _valuePropType = __webpack_require__("./node_modules/react-input-range/lib/js/input-range/value-prop-type.js");

var _valuePropType2 = _interopRequireDefault(_valuePropType);

var _slider = __webpack_require__("./node_modules/react-input-range/lib/js/input-range/slider.js");

var _slider2 = _interopRequireDefault(_slider);

var _track = __webpack_require__("./node_modules/react-input-range/lib/js/input-range/track.js");

var _track2 = _interopRequireDefault(_track);

var _utils = __webpack_require__("./node_modules/react-input-range/lib/js/utils/index.js");

var _keyCodes = __webpack_require__("./node_modules/react-input-range/lib/js/input-range/key-codes.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
}

/**
 * A React component that allows users to input numeric values within a range
 * by dragging its sliders.
 */
var InputRange = (_class = function (_React$Component) {
  _inherits(InputRange, _React$Component);

  _createClass(InputRange, null, [{
    key: 'propTypes',

    /**
     * @ignore
     * @override
     * @return {Object}
     */
    get: function get() {
      return {
        allowSameValues: _propTypes2.default.bool,
        ariaLabelledby: _propTypes2.default.string,
        ariaControls: _propTypes2.default.string,
        classNames: _propTypes2.default.objectOf(_propTypes2.default.string),
        disabled: _propTypes2.default.bool,
        draggableTrack: _propTypes2.default.bool,
        formatLabel: _propTypes2.default.func,
        maxValue: _rangePropType2.default,
        minValue: _rangePropType2.default,
        name: _propTypes2.default.string,
        onChangeStart: _propTypes2.default.func,
        onChange: _propTypes2.default.func.isRequired,
        onChangeComplete: _propTypes2.default.func,
        step: _propTypes2.default.number,
        value: _valuePropType2.default
      };
    }

    /**
     * @ignore
     * @override
     * @return {Object}
     */

  }, {
    key: 'defaultProps',
    get: function get() {
      return {
        allowSameValues: false,
        classNames: _defaultClassNames2.default,
        disabled: false,
        maxValue: 10,
        minValue: 0,
        step: 1
      };
    }

    /**
     * @param {Object} props
     * @param {boolean} [props.allowSameValues]
     * @param {string} [props.ariaLabelledby]
     * @param {string} [props.ariaControls]
     * @param {InputRangeClassNames} [props.classNames]
     * @param {boolean} [props.disabled = false]
     * @param {Function} [props.formatLabel]
     * @param {number|Range} [props.maxValue = 10]
     * @param {number|Range} [props.minValue = 0]
     * @param {string} [props.name]
     * @param {string} props.onChange
     * @param {Function} [props.onChangeComplete]
     * @param {Function} [props.onChangeStart]
     * @param {number} [props.step = 1]
     * @param {number|Range} props.value
     */

  }]);

  function InputRange(props) {
    _classCallCheck(this, InputRange);

    /**
     * @private
     * @type {?number}
     */
    var _this = _possibleConstructorReturn(this, (InputRange.__proto__ || Object.getPrototypeOf(InputRange)).call(this, props));

    _this.startValue = null;

    /**
     * @private
     * @type {?Component}
     */
    _this.node = null;

    /**
     * @private
     * @type {?Component}
     */
    _this.trackNode = null;

    /**
     * @private
     * @type {bool}
     */
    _this.isSliderDragging = false;

    /**
     * @private
     * @type {?string}
     */
    _this.lastKeyMoved = null;
    return _this;
  }

  /**
   * @ignore
   * @override
   * @return {void}
   */


  _createClass(InputRange, [{
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this.removeDocumentMouseUpListener();
      this.removeDocumentTouchEndListener();
    }

    /**
     * Return the CSS class name of the component
     * @private
     * @return {string}
     */

  }, {
    key: 'getComponentClassName',
    value: function getComponentClassName() {
      if (!this.props.disabled) {
        return this.props.classNames.inputRange;
      }

      return this.props.classNames.disabledInputRange;
    }

    /**
     * Return the bounding rect of the track
     * @private
     * @return {ClientRect}
     */

  }, {
    key: 'getTrackClientRect',
    value: function getTrackClientRect() {
      return this.trackNode.getClientRect();
    }

    /**
     * Return the slider key closest to a point
     * @private
     * @param {Point} position
     * @return {string}
     */

  }, {
    key: 'getKeyByPosition',
    value: function getKeyByPosition(position) {
      var values = valueTransformer.getValueFromProps(this.props, this.isMultiValue());
      var positions = valueTransformer.getPositionsFromValues(values, this.props.minValue, this.props.maxValue, this.getTrackClientRect());

      if (this.isMultiValue()) {
        var distanceToMin = (0, _utils.distanceTo)(position, positions.min);
        var distanceToMax = (0, _utils.distanceTo)(position, positions.max);

        if (distanceToMin < distanceToMax) {
          return 'min';
        }
      }

      return 'max';
    }

    /**
     * Return all the slider keys
     * @private
     * @return {string[]}
     */

  }, {
    key: 'getKeys',
    value: function getKeys() {
      if (this.isMultiValue()) {
        return ['min', 'max'];
      }

      return ['max'];
    }

    /**
     * Return true if the difference between the new and the current value is
     * greater or equal to the step amount of the component
     * @private
     * @param {Range} values
     * @return {boolean}
     */

  }, {
    key: 'hasStepDifference',
    value: function hasStepDifference(values) {
      var currentValues = valueTransformer.getValueFromProps(this.props, this.isMultiValue());

      return (0, _utils.length)(values.min, currentValues.min) >= this.props.step || (0, _utils.length)(values.max, currentValues.max) >= this.props.step;
    }

    /**
     * Return true if the component accepts a min and max value
     * @private
     * @return {boolean}
     */

  }, {
    key: 'isMultiValue',
    value: function isMultiValue() {
      return (0, _utils.isObject)(this.props.value);
    }

    /**
     * Return true if the range is within the max and min value of the component
     * @private
     * @param {Range} values
     * @return {boolean}
     */

  }, {
    key: 'isWithinRange',
    value: function isWithinRange(values) {
      if (this.isMultiValue()) {
        return values.min >= this.props.minValue && values.max <= this.props.maxValue && this.props.allowSameValues ? values.min <= values.max : values.min < values.max;
      }

      return values.max >= this.props.minValue && values.max <= this.props.maxValue;
    }

    /**
     * Return true if the new value should trigger a render
     * @private
     * @param {Range} values
     * @return {boolean}
     */

  }, {
    key: 'shouldUpdate',
    value: function shouldUpdate(values) {
      return this.isWithinRange(values) && this.hasStepDifference(values);
    }

    /**
     * Update the position of a slider
     * @private
     * @param {string} key
     * @param {Point} position
     * @return {void}
     */

  }, {
    key: 'updatePosition',
    value: function updatePosition(key, position) {
      var values = valueTransformer.getValueFromProps(this.props, this.isMultiValue());
      var positions = valueTransformer.getPositionsFromValues(values, this.props.minValue, this.props.maxValue, this.getTrackClientRect());

      positions[key] = position;
      this.lastKeyMoved = key;

      this.updatePositions(positions);
    }

    /**
     * Update the positions of multiple sliders
     * @private
     * @param {Object} positions
     * @param {Point} positions.min
     * @param {Point} positions.max
     * @return {void}
     */

  }, {
    key: 'updatePositions',
    value: function updatePositions(positions) {
      var values = {
        min: valueTransformer.getValueFromPosition(positions.min, this.props.minValue, this.props.maxValue, this.getTrackClientRect()),
        max: valueTransformer.getValueFromPosition(positions.max, this.props.minValue, this.props.maxValue, this.getTrackClientRect())
      };

      var transformedValues = {
        min: valueTransformer.getStepValueFromValue(values.min, this.props.step),
        max: valueTransformer.getStepValueFromValue(values.max, this.props.step)
      };

      this.updateValues(transformedValues);
    }

    /**
     * Update the value of a slider
     * @private
     * @param {string} key
     * @param {number} value
     * @return {void}
     */

  }, {
    key: 'updateValue',
    value: function updateValue(key, value) {
      var values = valueTransformer.getValueFromProps(this.props, this.isMultiValue());

      values[key] = value;

      this.updateValues(values);
    }

    /**
     * Update the values of multiple sliders
     * @private
     * @param {Range|number} values
     * @return {void}
     */

  }, {
    key: 'updateValues',
    value: function updateValues(values) {
      if (!this.shouldUpdate(values)) {
        return;
      }

      this.props.onChange(this.isMultiValue() ? values : values.max);
    }

    /**
     * Increment the value of a slider by key name
     * @private
     * @param {string} key
     * @return {void}
     */

  }, {
    key: 'incrementValue',
    value: function incrementValue(key) {
      var values = valueTransformer.getValueFromProps(this.props, this.isMultiValue());
      var value = values[key] + this.props.step;

      this.updateValue(key, value);
    }

    /**
     * Decrement the value of a slider by key name
     * @private
     * @param {string} key
     * @return {void}
     */

  }, {
    key: 'decrementValue',
    value: function decrementValue(key) {
      var values = valueTransformer.getValueFromProps(this.props, this.isMultiValue());
      var value = values[key] - this.props.step;

      this.updateValue(key, value);
    }

    /**
     * Listen to mouseup event
     * @private
     * @return {void}
     */

  }, {
    key: 'addDocumentMouseUpListener',
    value: function addDocumentMouseUpListener() {
      this.removeDocumentMouseUpListener();
      this.node.ownerDocument.addEventListener('mouseup', this.handleMouseUp);
    }

    /**
     * Listen to touchend event
     * @private
     * @return {void}
     */

  }, {
    key: 'addDocumentTouchEndListener',
    value: function addDocumentTouchEndListener() {
      this.removeDocumentTouchEndListener();
      this.node.ownerDocument.addEventListener('touchend', this.handleTouchEnd);
    }

    /**
     * Stop listening to mouseup event
     * @private
     * @return {void}
     */

  }, {
    key: 'removeDocumentMouseUpListener',
    value: function removeDocumentMouseUpListener() {
      this.node.ownerDocument.removeEventListener('mouseup', this.handleMouseUp);
    }

    /**
     * Stop listening to touchend event
     * @private
     * @return {void}
     */

  }, {
    key: 'removeDocumentTouchEndListener',
    value: function removeDocumentTouchEndListener() {
      this.node.ownerDocument.removeEventListener('touchend', this.handleTouchEnd);
    }

    /**
     * Handle any "mousemove" event received by the slider
     * @private
     * @param {SyntheticEvent} event
     * @param {string} key
     * @return {void}
     */

  }, {
    key: 'handleSliderDrag',
    value: function handleSliderDrag(event, key) {
      var _this2 = this;

      if (this.props.disabled) {
        return;
      }

      var position = valueTransformer.getPositionFromEvent(event, this.getTrackClientRect());
      this.isSliderDragging = true;
      requestAnimationFrame(function () {
        return _this2.updatePosition(key, position);
      });
    }

    /**
     * Handle any "mousemove" event received by the track
     * @private
     * @param {SyntheticEvent} event
     * @return {void}
     */

  }, {
    key: 'handleTrackDrag',
    value: function handleTrackDrag(event, prevEvent) {
      if (this.props.disabled || !this.props.draggableTrack || this.isSliderDragging) {
        return;
      }

      var _props = this.props,
          maxValue = _props.maxValue,
          minValue = _props.minValue,
          _props$value = _props.value,
          max = _props$value.max,
          min = _props$value.min;


      var position = valueTransformer.getPositionFromEvent(event, this.getTrackClientRect());
      var value = valueTransformer.getValueFromPosition(position, minValue, maxValue, this.getTrackClientRect());
      var stepValue = valueTransformer.getStepValueFromValue(value, this.props.step);

      var prevPosition = valueTransformer.getPositionFromEvent(prevEvent, this.getTrackClientRect());
      var prevValue = valueTransformer.getValueFromPosition(prevPosition, minValue, maxValue, this.getTrackClientRect());
      var prevStepValue = valueTransformer.getStepValueFromValue(prevValue, this.props.step);

      var offset = prevStepValue - stepValue;

      var transformedValues = {
        min: min - offset,
        max: max - offset
      };

      this.updateValues(transformedValues);
    }

    /**
     * Handle any "keydown" event received by the slider
     * @private
     * @param {SyntheticEvent} event
     * @param {string} key
     * @return {void}
     */

  }, {
    key: 'handleSliderKeyDown',
    value: function handleSliderKeyDown(event, key) {
      if (this.props.disabled) {
        return;
      }

      switch (event.keyCode) {
        case _keyCodes.LEFT_ARROW:
        case _keyCodes.DOWN_ARROW:
          event.preventDefault();
          this.decrementValue(key);
          break;

        case _keyCodes.RIGHT_ARROW:
        case _keyCodes.UP_ARROW:
          event.preventDefault();
          this.incrementValue(key);
          break;

        default:
          break;
      }
    }

    /**
     * Handle any "mousedown" event received by the track
     * @private
     * @param {SyntheticEvent} event
     * @param {Point} position
     * @return {void}
     */

  }, {
    key: 'handleTrackMouseDown',
    value: function handleTrackMouseDown(event, position) {
      if (this.props.disabled) {
        return;
      }

      var _props2 = this.props,
          maxValue = _props2.maxValue,
          minValue = _props2.minValue,
          _props2$value = _props2.value,
          max = _props2$value.max,
          min = _props2$value.min;


      event.preventDefault();

      var value = valueTransformer.getValueFromPosition(position, minValue, maxValue, this.getTrackClientRect());
      var stepValue = valueTransformer.getStepValueFromValue(value, this.props.step);

      if (!this.props.draggableTrack || stepValue > max || stepValue < min) {
        this.updatePosition(this.getKeyByPosition(position), position);
      }
    }

    /**
     * Handle the start of any mouse/touch event
     * @private
     * @return {void}
     */

  }, {
    key: 'handleInteractionStart',
    value: function handleInteractionStart() {
      if (this.props.onChangeStart) {
        this.props.onChangeStart(this.props.value);
      }

      if (this.props.onChangeComplete && !(0, _utils.isDefined)(this.startValue)) {
        this.startValue = this.props.value;
      }
    }

    /**
     * Handle the end of any mouse/touch event
     * @private
     * @return {void}
     */

  }, {
    key: 'handleInteractionEnd',
    value: function handleInteractionEnd() {
      if (this.isSliderDragging) {
        this.isSliderDragging = false;
      }

      if (!this.props.onChangeComplete || !(0, _utils.isDefined)(this.startValue)) {
        return;
      }

      if (this.startValue !== this.props.value) {
        this.props.onChangeComplete(this.props.value);
      }

      this.startValue = null;
    }

    /**
     * Handle any "keydown" event received by the component
     * @private
     * @param {SyntheticEvent} event
     * @return {void}
     */

  }, {
    key: 'handleKeyDown',
    value: function handleKeyDown(event) {
      this.handleInteractionStart(event);
    }

    /**
     * Handle any "keyup" event received by the component
     * @private
     * @param {SyntheticEvent} event
     * @return {void}
     */

  }, {
    key: 'handleKeyUp',
    value: function handleKeyUp(event) {
      this.handleInteractionEnd(event);
    }

    /**
     * Handle any "mousedown" event received by the component
     * @private
     * @param {SyntheticEvent} event
     * @return {void}
     */

  }, {
    key: 'handleMouseDown',
    value: function handleMouseDown(event) {
      this.handleInteractionStart(event);
      this.addDocumentMouseUpListener();
    }

    /**
     * Handle any "mouseup" event received by the component
     * @private
     * @param {SyntheticEvent} event
     */

  }, {
    key: 'handleMouseUp',
    value: function handleMouseUp(event) {
      this.handleInteractionEnd(event);
      this.removeDocumentMouseUpListener();
    }

    /**
     * Handle any "touchstart" event received by the component
     * @private
     * @param {SyntheticEvent} event
     * @return {void}
     */

  }, {
    key: 'handleTouchStart',
    value: function handleTouchStart(event) {
      this.handleInteractionStart(event);
      this.addDocumentTouchEndListener();
    }

    /**
     * Handle any "touchend" event received by the component
     * @private
     * @param {SyntheticEvent} event
     */

  }, {
    key: 'handleTouchEnd',
    value: function handleTouchEnd(event) {
      this.handleInteractionEnd(event);
      this.removeDocumentTouchEndListener();
    }

    /**
     * Return JSX of sliders
     * @private
     * @return {JSX.Element}
     */

  }, {
    key: 'renderSliders',
    value: function renderSliders() {
      var _this3 = this;

      var values = valueTransformer.getValueFromProps(this.props, this.isMultiValue());
      var percentages = valueTransformer.getPercentagesFromValues(values, this.props.minValue, this.props.maxValue);
      var keys = this.props.allowSameValues && this.lastKeyMoved === 'min' ? this.getKeys().reverse() : this.getKeys();

      return keys.map(function (key) {
        var value = values[key];
        var percentage = percentages[key];

        var _props3 = _this3.props,
            maxValue = _props3.maxValue,
            minValue = _props3.minValue;


        if (key === 'min') {
          maxValue = values.max;
        } else {
          minValue = values.min;
        }

        var slider = _react2.default.createElement(_slider2.default, {
          ariaLabelledby: _this3.props.ariaLabelledby,
          ariaControls: _this3.props.ariaControls,
          classNames: _this3.props.classNames,
          formatLabel: _this3.props.formatLabel,
          key: key,
          maxValue: maxValue,
          minValue: minValue,
          onSliderDrag: _this3.handleSliderDrag,
          onSliderKeyDown: _this3.handleSliderKeyDown,
          percentage: percentage,
          type: key,
          value: value });

        return slider;
      });
    }

    /**
     * Return JSX of hidden inputs
     * @private
     * @return {JSX.Element}
     */

  }, {
    key: 'renderHiddenInputs',
    value: function renderHiddenInputs() {
      var _this4 = this;

      if (!this.props.name) {
        return [];
      }

      var isMultiValue = this.isMultiValue();
      var values = valueTransformer.getValueFromProps(this.props, isMultiValue);

      return this.getKeys().map(function (key) {
        var value = values[key];
        var name = isMultiValue ? '' + _this4.props.name + (0, _utils.captialize)(key) : _this4.props.name;

        return _react2.default.createElement('input', { key: key, type: 'hidden', name: name, value: value });
      });
    }

    /**
     * @ignore
     * @override
     * @return {JSX.Element}
     */

  }, {
    key: 'render',
    value: function render() {
      var _this5 = this;

      var componentClassName = this.getComponentClassName();
      var values = valueTransformer.getValueFromProps(this.props, this.isMultiValue());
      var percentages = valueTransformer.getPercentagesFromValues(values, this.props.minValue, this.props.maxValue);

      return _react2.default.createElement(
        'div',
        {
          'aria-disabled': this.props.disabled,
          ref: function ref(node) {
            _this5.node = node;
          },
          className: componentClassName,
          onKeyDown: this.handleKeyDown,
          onKeyUp: this.handleKeyUp,
          onMouseDown: this.handleMouseDown,
          onTouchStart: this.handleTouchStart },
        _react2.default.createElement(
          _label2.default,
          {
            classNames: this.props.classNames,
            formatLabel: this.props.formatLabel,
            type: 'min' },
          this.props.minValue
        ),
        _react2.default.createElement(
          _track2.default,
          {
            classNames: this.props.classNames,
            draggableTrack: this.props.draggableTrack,
            ref: function ref(trackNode) {
              _this5.trackNode = trackNode;
            },
            percentages: percentages,
            onTrackDrag: this.handleTrackDrag,
            onTrackMouseDown: this.handleTrackMouseDown },
          this.renderSliders()
        ),
        _react2.default.createElement(
          _label2.default,
          {
            classNames: this.props.classNames,
            formatLabel: this.props.formatLabel,
            type: 'max' },
          this.props.maxValue
        ),
        this.renderHiddenInputs()
      );
    }
  }]);

  return InputRange;
}(_react2.default.Component), (_applyDecoratedDescriptor(_class.prototype, 'handleSliderDrag', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'handleSliderDrag'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'handleTrackDrag', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'handleTrackDrag'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'handleSliderKeyDown', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'handleSliderKeyDown'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'handleTrackMouseDown', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'handleTrackMouseDown'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'handleInteractionStart', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'handleInteractionStart'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'handleInteractionEnd', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'handleInteractionEnd'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'handleKeyDown', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'handleKeyDown'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'handleKeyUp', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'handleKeyUp'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'handleMouseDown', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'handleMouseDown'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'handleMouseUp', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'handleMouseUp'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'handleTouchStart', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'handleTouchStart'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'handleTouchEnd', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'handleTouchEnd'), _class.prototype)), _class);
exports.default = InputRange;
module.exports = exports['default'];
//# sourceMappingURL=input-range.js.map

/***/ }),

/***/ "./node_modules/react-input-range/lib/js/input-range/key-codes.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/** @ignore */
var DOWN_ARROW = exports.DOWN_ARROW = 40;

/** @ignore */
var LEFT_ARROW = exports.LEFT_ARROW = 37;

/** @ignore */
var RIGHT_ARROW = exports.RIGHT_ARROW = 39;

/** @ignore */
var UP_ARROW = exports.UP_ARROW = 38;
//# sourceMappingURL=key-codes.js.map

/***/ }),

/***/ "./node_modules/react-input-range/lib/js/input-range/label.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = Label;

var _react = __webpack_require__("./node_modules/react/cjs/react.development.js");

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__("./node_modules/prop-types/index.js");

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @ignore
 * @param {Object} props
 * @param {InputRangeClassNames} props.classNames
 * @param {Function} props.formatLabel
 * @param {string} props.type
 */
function Label(props) {
  var labelValue = props.formatLabel ? props.formatLabel(props.children, props.type) : props.children;

  return _react2.default.createElement(
    'span',
    { className: props.classNames[props.type + 'Label'] },
    _react2.default.createElement(
      'span',
      { className: props.classNames.labelContainer },
      labelValue
    )
  );
}

/**
 * @type {Object}
 * @property {Function} children
 * @property {Function} classNames
 * @property {Function} formatLabel
 * @property {Function} type
 */
Label.propTypes = {
  children: _propTypes2.default.node.isRequired,
  classNames: _propTypes2.default.objectOf(_propTypes2.default.string).isRequired,
  formatLabel: _propTypes2.default.func,
  type: _propTypes2.default.string.isRequired
};
module.exports = exports['default'];
//# sourceMappingURL=label.js.map

/***/ }),

/***/ "./node_modules/react-input-range/lib/js/input-range/range-prop-type.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = rangePropType;

var _utils = __webpack_require__("./node_modules/react-input-range/lib/js/utils/index.js");

/**
 * @ignore
 * @param {Object} props - React component props
 * @return {?Error} Return Error if validation fails
 */
function rangePropType(props) {
  var maxValue = props.maxValue,
      minValue = props.minValue;


  if (!(0, _utils.isNumber)(minValue) || !(0, _utils.isNumber)(maxValue)) {
    return new Error('"minValue" and "maxValue" must be a number');
  }

  if (minValue >= maxValue) {
    return new Error('"minValue" must be smaller than "maxValue"');
  }
}
module.exports = exports['default'];
//# sourceMappingURL=range-prop-type.js.map

/***/ }),

/***/ "./node_modules/react-input-range/lib/js/input-range/slider.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _desc, _value, _class;

var _react = __webpack_require__("./node_modules/react/cjs/react.development.js");

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__("./node_modules/prop-types/index.js");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _autobindDecorator = __webpack_require__("./node_modules/autobind-decorator/lib/index.js");

var _autobindDecorator2 = _interopRequireDefault(_autobindDecorator);

var _label = __webpack_require__("./node_modules/react-input-range/lib/js/input-range/label.js");

var _label2 = _interopRequireDefault(_label);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
}

/**
 * @ignore
 */
var Slider = (_class = function (_React$Component) {
  _inherits(Slider, _React$Component);

  _createClass(Slider, null, [{
    key: 'propTypes',

    /**
     * Accepted propTypes of Slider
     * @override
     * @return {Object}
     * @property {Function} ariaLabelledby
     * @property {Function} ariaControls
     * @property {Function} className
     * @property {Function} formatLabel
     * @property {Function} maxValue
     * @property {Function} minValue
     * @property {Function} onSliderDrag
     * @property {Function} onSliderKeyDown
     * @property {Function} percentage
     * @property {Function} type
     * @property {Function} value
     */
    get: function get() {
      return {
        ariaLabelledby: _propTypes2.default.string,
        ariaControls: _propTypes2.default.string,
        classNames: _propTypes2.default.objectOf(_propTypes2.default.string).isRequired,
        formatLabel: _propTypes2.default.func,
        maxValue: _propTypes2.default.number,
        minValue: _propTypes2.default.number,
        onSliderDrag: _propTypes2.default.func.isRequired,
        onSliderKeyDown: _propTypes2.default.func.isRequired,
        percentage: _propTypes2.default.number.isRequired,
        type: _propTypes2.default.string.isRequired,
        value: _propTypes2.default.number.isRequired
      };
    }

    /**
     * @param {Object} props
     * @param {string} [props.ariaLabelledby]
     * @param {string} [props.ariaControls]
     * @param {InputRangeClassNames} props.classNames
     * @param {Function} [props.formatLabel]
     * @param {number} [props.maxValue]
     * @param {number} [props.minValue]
     * @param {Function} props.onSliderKeyDown
     * @param {Function} props.onSliderDrag
     * @param {number} props.percentage
     * @param {number} props.type
     * @param {number} props.value
     */

  }]);

  function Slider(props) {
    _classCallCheck(this, Slider);

    /**
     * @private
     * @type {?Component}
     */
    var _this = _possibleConstructorReturn(this, (Slider.__proto__ || Object.getPrototypeOf(Slider)).call(this, props));

    _this.node = null;
    return _this;
  }

  /**
   * @ignore
   * @override
   * @return {void}
   */


  _createClass(Slider, [{
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this.removeDocumentMouseMoveListener();
      this.removeDocumentMouseUpListener();
      this.removeDocumentTouchEndListener();
      this.removeDocumentTouchMoveListener();
    }

    /**
     * @private
     * @return {Object}
     */

  }, {
    key: 'getStyle',
    value: function getStyle() {
      var perc = (this.props.percentage || 0) * 100;
      var style = {
        position: 'absolute',
        left: perc + '%'
      };

      return style;
    }

    /**
     * Listen to mousemove event
     * @private
     * @return {void}
     */

  }, {
    key: 'addDocumentMouseMoveListener',
    value: function addDocumentMouseMoveListener() {
      this.removeDocumentMouseMoveListener();
      this.node.ownerDocument.addEventListener('mousemove', this.handleMouseMove);
    }

    /**
     * Listen to mouseup event
     * @private
     * @return {void}
     */

  }, {
    key: 'addDocumentMouseUpListener',
    value: function addDocumentMouseUpListener() {
      this.removeDocumentMouseUpListener();
      this.node.ownerDocument.addEventListener('mouseup', this.handleMouseUp);
    }

    /**
     * Listen to touchmove event
     * @private
     * @return {void}
     */

  }, {
    key: 'addDocumentTouchMoveListener',
    value: function addDocumentTouchMoveListener() {
      this.removeDocumentTouchMoveListener();
      this.node.ownerDocument.addEventListener('touchmove', this.handleTouchMove);
    }

    /**
     * Listen to touchend event
     * @private
     * @return {void}
     */

  }, {
    key: 'addDocumentTouchEndListener',
    value: function addDocumentTouchEndListener() {
      this.removeDocumentTouchEndListener();
      this.node.ownerDocument.addEventListener('touchend', this.handleTouchEnd);
    }

    /**
     * @private
     * @return {void}
     */

  }, {
    key: 'removeDocumentMouseMoveListener',
    value: function removeDocumentMouseMoveListener() {
      this.node.ownerDocument.removeEventListener('mousemove', this.handleMouseMove);
    }

    /**
     * @private
     * @return {void}
     */

  }, {
    key: 'removeDocumentMouseUpListener',
    value: function removeDocumentMouseUpListener() {
      this.node.ownerDocument.removeEventListener('mouseup', this.handleMouseUp);
    }

    /**
     * @private
     * @return {void}
     */

  }, {
    key: 'removeDocumentTouchMoveListener',
    value: function removeDocumentTouchMoveListener() {
      this.node.ownerDocument.removeEventListener('touchmove', this.handleTouchMove);
    }

    /**
     * @private
     * @return {void}
     */

  }, {
    key: 'removeDocumentTouchEndListener',
    value: function removeDocumentTouchEndListener() {
      this.node.ownerDocument.removeEventListener('touchend', this.handleTouchEnd);
    }

    /**
     * @private
     * @return {void}
     */

  }, {
    key: 'handleMouseDown',
    value: function handleMouseDown() {
      this.addDocumentMouseMoveListener();
      this.addDocumentMouseUpListener();
    }

    /**
     * @private
     * @return {void}
     */

  }, {
    key: 'handleMouseUp',
    value: function handleMouseUp() {
      this.removeDocumentMouseMoveListener();
      this.removeDocumentMouseUpListener();
    }

    /**
     * @private
     * @param {SyntheticEvent} event
     * @return {void}
     */

  }, {
    key: 'handleMouseMove',
    value: function handleMouseMove(event) {
      this.props.onSliderDrag(event, this.props.type);
    }

    /**
     * @private
     * @return {void}
     */

  }, {
    key: 'handleTouchStart',
    value: function handleTouchStart() {
      this.addDocumentTouchEndListener();
      this.addDocumentTouchMoveListener();
    }

    /**
     * @private
     * @param {SyntheticEvent} event
     * @return {void}
     */

  }, {
    key: 'handleTouchMove',
    value: function handleTouchMove(event) {
      this.props.onSliderDrag(event, this.props.type);
    }

    /**
     * @private
     * @return {void}
     */

  }, {
    key: 'handleTouchEnd',
    value: function handleTouchEnd() {
      this.removeDocumentTouchMoveListener();
      this.removeDocumentTouchEndListener();
    }

    /**
     * @private
     * @param {SyntheticEvent} event
     * @return {void}
     */

  }, {
    key: 'handleKeyDown',
    value: function handleKeyDown(event) {
      this.props.onSliderKeyDown(event, this.props.type);
    }

    /**
     * @override
     * @return {JSX.Element}
     */

  }, {
    key: 'render',
    value: function render() {
      var _this2 = this;

      var style = this.getStyle();

      return _react2.default.createElement(
        'span',
        {
          className: this.props.classNames.sliderContainer,
          ref: function ref(node) {
            _this2.node = node;
          },
          style: style },
        _react2.default.createElement(
          _label2.default,
          {
            classNames: this.props.classNames,
            formatLabel: this.props.formatLabel,
            type: 'value' },
          this.props.value
        ),
        _react2.default.createElement('div', {
          'aria-labelledby': this.props.ariaLabelledby,
          'aria-controls': this.props.ariaControls,
          'aria-valuemax': this.props.maxValue,
          'aria-valuemin': this.props.minValue,
          'aria-valuenow': this.props.value,
          className: this.props.classNames.slider,
          draggable: 'false',
          onKeyDown: this.handleKeyDown,
          onMouseDown: this.handleMouseDown,
          onTouchStart: this.handleTouchStart,
          role: 'slider',
          tabIndex: '0' })
      );
    }
  }]);

  return Slider;
}(_react2.default.Component), (_applyDecoratedDescriptor(_class.prototype, 'handleMouseDown', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'handleMouseDown'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'handleMouseUp', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'handleMouseUp'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'handleMouseMove', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'handleMouseMove'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'handleTouchStart', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'handleTouchStart'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'handleTouchMove', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'handleTouchMove'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'handleTouchEnd', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'handleTouchEnd'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'handleKeyDown', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'handleKeyDown'), _class.prototype)), _class);
exports.default = Slider;
module.exports = exports['default'];
//# sourceMappingURL=slider.js.map

/***/ }),

/***/ "./node_modules/react-input-range/lib/js/input-range/track.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _desc, _value, _class;

var _react = __webpack_require__("./node_modules/react/cjs/react.development.js");

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__("./node_modules/prop-types/index.js");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _autobindDecorator = __webpack_require__("./node_modules/autobind-decorator/lib/index.js");

var _autobindDecorator2 = _interopRequireDefault(_autobindDecorator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
}

/**
 * @ignore
 */
var Track = (_class = function (_React$Component) {
  _inherits(Track, _React$Component);

  _createClass(Track, null, [{
    key: 'propTypes',

    /**
     * @override
     * @return {Object}
     * @property {Function} children
     * @property {Function} classNames
     * @property {Boolean} draggableTrack
     * @property {Function} onTrackDrag
     * @property {Function} onTrackMouseDown
     * @property {Function} percentages
     */
    get: function get() {
      return {
        children: _propTypes2.default.node.isRequired,
        classNames: _propTypes2.default.objectOf(_propTypes2.default.string).isRequired,
        draggableTrack: _propTypes2.default.bool,
        onTrackDrag: _propTypes2.default.func,
        onTrackMouseDown: _propTypes2.default.func.isRequired,
        percentages: _propTypes2.default.objectOf(_propTypes2.default.number).isRequired
      };
    }

    /**
     * @param {Object} props
     * @param {InputRangeClassNames} props.classNames
     * @param {Boolean} props.draggableTrack
     * @param {Function} props.onTrackDrag
     * @param {Function} props.onTrackMouseDown
     * @param {number} props.percentages
     */

  }]);

  function Track(props) {
    _classCallCheck(this, Track);

    /**
     * @private
     * @type {?Component}
     */
    var _this = _possibleConstructorReturn(this, (Track.__proto__ || Object.getPrototypeOf(Track)).call(this, props));

    _this.node = null;
    _this.trackDragEvent = null;
    return _this;
  }

  /**
   * @private
   * @return {ClientRect}
   */


  _createClass(Track, [{
    key: 'getClientRect',
    value: function getClientRect() {
      return this.node.getBoundingClientRect();
    }

    /**
     * @private
     * @return {Object} CSS styles
     */

  }, {
    key: 'getActiveTrackStyle',
    value: function getActiveTrackStyle() {
      var width = (this.props.percentages.max - this.props.percentages.min) * 100 + '%';
      var left = this.props.percentages.min * 100 + '%';

      return { left: left, width: width };
    }

    /**
     * Listen to mousemove event
     * @private
     * @return {void}
     */

  }, {
    key: 'addDocumentMouseMoveListener',
    value: function addDocumentMouseMoveListener() {
      this.removeDocumentMouseMoveListener();
      this.node.ownerDocument.addEventListener('mousemove', this.handleMouseMove);
    }

    /**
     * Listen to mouseup event
     * @private
     * @return {void}
     */

  }, {
    key: 'addDocumentMouseUpListener',
    value: function addDocumentMouseUpListener() {
      this.removeDocumentMouseUpListener();
      this.node.ownerDocument.addEventListener('mouseup', this.handleMouseUp);
    }

    /**
     * @private
     * @return {void}
     */

  }, {
    key: 'removeDocumentMouseMoveListener',
    value: function removeDocumentMouseMoveListener() {
      this.node.ownerDocument.removeEventListener('mousemove', this.handleMouseMove);
    }

    /**
     * @private
     * @return {void}
     */

  }, {
    key: 'removeDocumentMouseUpListener',
    value: function removeDocumentMouseUpListener() {
      this.node.ownerDocument.removeEventListener('mouseup', this.handleMouseUp);
    }

    /**
     * @private
     * @param {SyntheticEvent} event
     * @return {void}
     */

  }, {
    key: 'handleMouseMove',
    value: function handleMouseMove(event) {
      if (!this.props.draggableTrack) {
        return;
      }

      if (this.trackDragEvent !== null) {
        this.props.onTrackDrag(event, this.trackDragEvent);
      }

      this.trackDragEvent = event;
    }

    /**
     * @private
     * @return {void}
     */

  }, {
    key: 'handleMouseUp',
    value: function handleMouseUp() {
      if (!this.props.draggableTrack) {
        return;
      }

      this.removeDocumentMouseMoveListener();
      this.removeDocumentMouseUpListener();
      this.trackDragEvent = null;
    }

    /**
     * @private
     * @param {SyntheticEvent} event - User event
     */

  }, {
    key: 'handleMouseDown',
    value: function handleMouseDown(event) {
      var clientX = event.touches ? event.touches[0].clientX : event.clientX;
      var trackClientRect = this.getClientRect();
      var position = {
        x: clientX - trackClientRect.left,
        y: 0
      };

      this.props.onTrackMouseDown(event, position);

      if (this.props.draggableTrack) {
        this.addDocumentMouseMoveListener();
        this.addDocumentMouseUpListener();
      }
    }

    /**
     * @private
     * @param {SyntheticEvent} event - User event
     */

  }, {
    key: 'handleTouchStart',
    value: function handleTouchStart(event) {
      event.preventDefault();

      this.handleMouseDown(event);
    }

    /**
     * @override
     * @return {JSX.Element}
     */

  }, {
    key: 'render',
    value: function render() {
      var _this2 = this;

      var activeTrackStyle = this.getActiveTrackStyle();

      return _react2.default.createElement(
        'div',
        {
          className: this.props.classNames.track,
          onMouseDown: this.handleMouseDown,
          onTouchStart: this.handleTouchStart,
          ref: function ref(node) {
            _this2.node = node;
          } },
        _react2.default.createElement('div', {
          style: activeTrackStyle,
          className: this.props.classNames.activeTrack }),
        this.props.children
      );
    }
  }]);

  return Track;
}(_react2.default.Component), (_applyDecoratedDescriptor(_class.prototype, 'handleMouseMove', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'handleMouseMove'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'handleMouseUp', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'handleMouseUp'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'handleMouseDown', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'handleMouseDown'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'handleTouchStart', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'handleTouchStart'), _class.prototype)), _class);
exports.default = Track;
module.exports = exports['default'];
//# sourceMappingURL=track.js.map

/***/ }),

/***/ "./node_modules/react-input-range/lib/js/input-range/value-prop-type.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = valuePropType;

var _utils = __webpack_require__("./node_modules/react-input-range/lib/js/utils/index.js");

/**
 * @ignore
 * @param {Object} props
 * @return {?Error} Return Error if validation fails
 */
function valuePropType(props, propName) {
  var maxValue = props.maxValue,
      minValue = props.minValue;

  var value = props[propName];

  if (!(0, _utils.isNumber)(value) && (!(0, _utils.isObject)(value) || !(0, _utils.isNumber)(value.min) || !(0, _utils.isNumber)(value.max))) {
    return new Error('"' + propName + '" must be a number or a range object');
  }

  if ((0, _utils.isNumber)(value) && (value < minValue || value > maxValue)) {
    return new Error('"' + propName + '" must be in between "minValue" and "maxValue"');
  }

  if ((0, _utils.isObject)(value) && (value.min < minValue || value.min > maxValue || value.max < minValue || value.max > maxValue)) {
    return new Error('"' + propName + '" must be in between "minValue" and "maxValue"');
  }
}
module.exports = exports['default'];
//# sourceMappingURL=value-prop-type.js.map

/***/ }),

/***/ "./node_modules/react-input-range/lib/js/input-range/value-transformer.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.getPercentageFromPosition = getPercentageFromPosition;
exports.getValueFromPosition = getValueFromPosition;
exports.getValueFromProps = getValueFromProps;
exports.getPercentageFromValue = getPercentageFromValue;
exports.getPercentagesFromValues = getPercentagesFromValues;
exports.getPositionFromValue = getPositionFromValue;
exports.getPositionsFromValues = getPositionsFromValues;
exports.getPositionFromEvent = getPositionFromEvent;
exports.getStepValueFromValue = getStepValueFromValue;

var _utils = __webpack_require__("./node_modules/react-input-range/lib/js/utils/index.js");

/**
 * Convert a point into a percentage value
 * @ignore
 * @param {Point} position
 * @param {ClientRect} clientRect
 * @return {number} Percentage value
 */
function getPercentageFromPosition(position, clientRect) {
  var length = clientRect.width;
  var sizePerc = position.x / length;

  return sizePerc || 0;
}

/**
 * Convert a point into a model value
 * @ignore
 * @param {Point} position
 * @param {number} minValue
 * @param {number} maxValue
 * @param {ClientRect} clientRect
 * @return {number}
 */
function getValueFromPosition(position, minValue, maxValue, clientRect) {
  var sizePerc = getPercentageFromPosition(position, clientRect);
  var valueDiff = maxValue - minValue;

  return minValue + valueDiff * sizePerc;
}

/**
 * Convert props into a range value
 * @ignore
 * @param {Object} props
 * @param {boolean} isMultiValue
 * @return {Range}
 */
function getValueFromProps(props, isMultiValue) {
  if (isMultiValue) {
    return _extends({}, props.value);
  }

  return {
    min: props.minValue,
    max: props.value
  };
}

/**
 * Convert a model value into a percentage value
 * @ignore
 * @param {number} value
 * @param {number} minValue
 * @param {number} maxValue
 * @return {number}
 */
function getPercentageFromValue(value, minValue, maxValue) {
  var validValue = (0, _utils.clamp)(value, minValue, maxValue);
  var valueDiff = maxValue - minValue;
  var valuePerc = (validValue - minValue) / valueDiff;

  return valuePerc || 0;
}

/**
 * Convert model values into percentage values
 * @ignore
 * @param {Range} values
 * @param {number} minValue
 * @param {number} maxValue
 * @return {Range}
 */
function getPercentagesFromValues(values, minValue, maxValue) {
  return {
    min: getPercentageFromValue(values.min, minValue, maxValue),
    max: getPercentageFromValue(values.max, minValue, maxValue)
  };
}

/**
 * Convert a value into a point
 * @ignore
 * @param {number} value
 * @param {number} minValue
 * @param {number} maxValue
 * @param {ClientRect} clientRect
 * @return {Point} Position
 */
function getPositionFromValue(value, minValue, maxValue, clientRect) {
  var length = clientRect.width;
  var valuePerc = getPercentageFromValue(value, minValue, maxValue);
  var positionValue = valuePerc * length;

  return {
    x: positionValue,
    y: 0
  };
}

/**
 * Convert a range of values into points
 * @ignore
 * @param {Range} values
 * @param {number} minValue
 * @param {number} maxValue
 * @param {ClientRect} clientRect
 * @return {Range}
 */
function getPositionsFromValues(values, minValue, maxValue, clientRect) {
  return {
    min: getPositionFromValue(values.min, minValue, maxValue, clientRect),
    max: getPositionFromValue(values.max, minValue, maxValue, clientRect)
  };
}

/**
 * Convert an event into a point
 * @ignore
 * @param {Event} event
 * @param {ClientRect} clientRect
 * @return {Point}
 */
function getPositionFromEvent(event, clientRect) {
  var length = clientRect.width;

  var _ref = event.touches ? event.touches[0] : event,
      clientX = _ref.clientX;

  return {
    x: (0, _utils.clamp)(clientX - clientRect.left, 0, length),
    y: 0
  };
}

/**
 * Convert a value into a step value
 * @ignore
 * @param {number} value
 * @param {number} valuePerStep
 * @return {number}
 */
function getStepValueFromValue(value, valuePerStep) {
  return Math.round(value / valuePerStep) * valuePerStep;
}
//# sourceMappingURL=value-transformer.js.map

/***/ }),

/***/ "./node_modules/react-input-range/lib/js/utils/captialize.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = captialize;
/**
 * Captialize a string
 * @ignore
 * @param {string} string
 * @return {string}
 */
function captialize(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}
module.exports = exports["default"];
//# sourceMappingURL=captialize.js.map

/***/ }),

/***/ "./node_modules/react-input-range/lib/js/utils/clamp.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = clamp;
/**
 * Clamp a value between a min and max value
 * @ignore
 * @param {number} value
 * @param {number} min
 * @param {number} max
 * @return {number}
 */
function clamp(value, min, max) {
  return Math.min(Math.max(value, min), max);
}
module.exports = exports["default"];
//# sourceMappingURL=clamp.js.map

/***/ }),

/***/ "./node_modules/react-input-range/lib/js/utils/distance-to.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = distanceTo;
/**
 * Calculate the distance between pointA and pointB
 * @ignore
 * @param {Point} pointA
 * @param {Point} pointB
 * @return {number} Distance
 */
function distanceTo(pointA, pointB) {
  var xDiff = Math.pow(pointB.x - pointA.x, 2);
  var yDiff = Math.pow(pointB.y - pointA.y, 2);

  return Math.sqrt(xDiff + yDiff);
}
module.exports = exports["default"];
//# sourceMappingURL=distance-to.js.map

/***/ }),

/***/ "./node_modules/react-input-range/lib/js/utils/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _captialize = __webpack_require__("./node_modules/react-input-range/lib/js/utils/captialize.js");

Object.defineProperty(exports, 'captialize', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_captialize).default;
  }
});

var _clamp = __webpack_require__("./node_modules/react-input-range/lib/js/utils/clamp.js");

Object.defineProperty(exports, 'clamp', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_clamp).default;
  }
});

var _distanceTo = __webpack_require__("./node_modules/react-input-range/lib/js/utils/distance-to.js");

Object.defineProperty(exports, 'distanceTo', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_distanceTo).default;
  }
});

var _isDefined = __webpack_require__("./node_modules/react-input-range/lib/js/utils/is-defined.js");

Object.defineProperty(exports, 'isDefined', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_isDefined).default;
  }
});

var _isNumber = __webpack_require__("./node_modules/react-input-range/lib/js/utils/is-number.js");

Object.defineProperty(exports, 'isNumber', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_isNumber).default;
  }
});

var _isObject = __webpack_require__("./node_modules/react-input-range/lib/js/utils/is-object.js");

Object.defineProperty(exports, 'isObject', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_isObject).default;
  }
});

var _length = __webpack_require__("./node_modules/react-input-range/lib/js/utils/length.js");

Object.defineProperty(exports, 'length', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_length).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/react-input-range/lib/js/utils/is-defined.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isDefined;
/**
 * Check if a value is defined
 * @ignore
 * @param {*} value
 * @return {boolean}
 */
function isDefined(value) {
  return value !== undefined && value !== null;
}
module.exports = exports["default"];
//# sourceMappingURL=is-defined.js.map

/***/ }),

/***/ "./node_modules/react-input-range/lib/js/utils/is-number.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isNumber;
/**
 * Check if a value is a number
 * @ignore
 * @param {*} value
 * @return {boolean}
 */
function isNumber(value) {
  return typeof value === 'number';
}
module.exports = exports['default'];
//# sourceMappingURL=is-number.js.map

/***/ }),

/***/ "./node_modules/react-input-range/lib/js/utils/is-object.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.default = isObject;
/**
 * Check if a value is an object
 * @ignore
 * @param {*} value
 * @return {boolean}
 */
function isObject(value) {
  return value !== null && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object';
}
module.exports = exports['default'];
//# sourceMappingURL=is-object.js.map

/***/ }),

/***/ "./node_modules/react-input-range/lib/js/utils/length.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = length;
/**
 * Calculate the absolute difference between two numbers
 * @ignore
 * @param {number} numA
 * @param {number} numB
 * @return {number}
 */
function length(numA, numB) {
  return Math.abs(numA - numB);
}
module.exports = exports["default"];
//# sourceMappingURL=length.js.map

/***/ }),

/***/ "./node_modules/react-popover/build/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__("./node_modules/react/cjs/react.development.js");

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__("./node_modules/prop-types/index.js");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactDom = __webpack_require__("./node_modules/react-dom/cjs/react-dom.development.js");

var _reactDom2 = _interopRequireDefault(_reactDom);

var _debug = __webpack_require__("./node_modules/debug/src/browser.js");

var _debug2 = _interopRequireDefault(_debug);

var _lodash = __webpack_require__("./node_modules/lodash.throttle/index.js");

var _lodash2 = _interopRequireDefault(_lodash);

var _cssVendor = __webpack_require__("./node_modules/css-vendor/lib/index.js");

var cssVendor = _interopRequireWildcard(_cssVendor);

var _onResize = __webpack_require__("./node_modules/react-popover/build/on-resize.js");

var _onResize2 = _interopRequireDefault(_onResize);

var _layout = __webpack_require__("./node_modules/react-popover/build/layout.js");

var _layout2 = _interopRequireDefault(_layout);

var _platform = __webpack_require__("./node_modules/react-popover/build/platform.js");

var _platform2 = _interopRequireDefault(_platform);

var _utils = __webpack_require__("./node_modules/react-popover/build/utils.js");

var _utils2 = _interopRequireDefault(_utils);

var _tip = __webpack_require__("./node_modules/react-popover/build/tip.js");

var _tip2 = _interopRequireDefault(_tip);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var log = (0, _debug2.default)("react-popover");

var supportedCSSValue = _utils2.default.clientOnly(cssVendor.supportedValue);

var jsprefix = function jsprefix(x) {
  return "" + cssVendor.prefix.js + x;
};

var cssprefix = function cssprefix(x) {
  return "" + cssVendor.prefix.css + x;
};

var cssvalue = function cssvalue(prop, value) {
  return supportedCSSValue(prop, value) || cssprefix(value);
};

var coreStyle = {
  position: "absolute",
  top: 0,
  left: 0,
  display: cssvalue("display", "flex")
};

var faces = {
  above: "down",
  right: "left",
  below: "up",
  left: "right"

  /* Flow mappings. Each map maps the flow domain to another domain. */

};var flowToTipTranslations = {
  row: "translateY",
  column: "translateX"
};

var flowToPopoverTranslations = {
  row: "translateX",
  column: "translateY"
};

var Popover = function (_React$Component) {
  _inherits(Popover, _React$Component);

  function Popover(props) {
    _classCallCheck(this, Popover);

    var _this = _possibleConstructorReturn(this, (Popover.__proto__ || Object.getPrototypeOf(Popover)).call(this, props));

    _this.checkTargetReposition = function () {
      if (_this.measureTargetBounds()) _this.resolvePopoverLayout();
    };

    _this.checkForOuterAction = function (event) {
      var isOuterAction = !_this.containerEl.contains(event.target) && !_this.targetEl.contains(event.target);
      if (isOuterAction) _this.props.onOuterAction(event);
    };

    _this.onTargetResize = function () {
      log("Recalculating layout because _target_ resized!");
      _this.measureTargetBounds();
      _this.resolvePopoverLayout();
    };

    _this.onPopoverResize = function () {
      log("Recalculating layout because _popover_ resized!");
      _this.measurePopoverSize();
      _this.resolvePopoverLayout();
    };

    _this.onFrameScroll = function () {
      log("Recalculating layout because _frame_ scrolled!");
      _this.measureTargetBounds();
      _this.resolvePopoverLayout();
    };

    _this.onFrameResize = function () {
      log("Recalculating layout because _frame_ resized!");
      _this.measureFrameBounds();
      _this.resolvePopoverLayout();
    };

    _this.getContainerNodeRef = function (containerEl) {
      Object.assign(_this, { containerEl: containerEl });
    };

    _this.state = {
      standing: "above",
      exited: !_this.props.isOpen, // for animation-dependent rendering, should popover close/open?
      exiting: false, // for tracking in-progress animations
      toggle: _this.props.isOpen || false // for business logic tracking, should popover close/open?
    };
    return _this;
  }

  _createClass(Popover, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      /* Our component needs a DOM Node reference to the child so that it can be
      measured so that we can correctly layout the popover. We do not have any
      control over the child so cannot leverage refs. We could wrap our own
      primitive component around the child but that could lead to breaking the
      uses layout (e.g. the child is a flex item). Leveraging findDOMNode seems
      to be the only functional solution, despite all the general warnings not to
      use it. We have a legitimate use-case. */
      // eslint-disable-next-line
      this.targetEl = _reactDom2.default.findDOMNode(this);
      if (this.props.isOpen) this.enter();
    }
  }, {
    key: "componentWillReceiveProps",
    value: function componentWillReceiveProps(propsNext) {
      //log(`Component received props!`, propsNext)
      var willOpen = !this.props.isOpen && propsNext.isOpen;
      var willClose = this.props.isOpen && !propsNext.isOpen;

      if (willOpen) this.open();else if (willClose) this.close();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(propsPrev, statePrev) {
      //log(`Component did update!`)
      var didOpen = !statePrev.toggle && this.state.toggle;
      var didClose = statePrev.toggle && !this.state.toggle;

      if (didOpen) this.enter();else if (didClose) this.exit();
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      /* If the Popover is unmounted while animating,
      clear the animation so no setState occured */
      this.animateExitStop();
      /* If the Popover was never opened then then tracking
      initialization never took place and so calling untrack
      would be an error. Also see issue 55. */
      if (this.hasTracked) this.untrackPopover();
    }
  }, {
    key: "resolvePopoverLayout",
    value: function resolvePopoverLayout() {
      /* Find the optimal zone to position self. Measure the size of each zone and use the one with
      the greatest area. */

      var pickerSettings = {
        preferPlace: this.props.preferPlace,
        place: this.props.place

        /* This is a kludge that solves a general problem very specifically for Popover.
        The problem is subtle. When Popover positioning changes such that it resolves at
        a different orientation, its Size will change because the Tip will toggle between
        extending Height or Width. The general problem of course is that calculating
        zone positioning based on current size is non-trivial if the Size can change once
        resolved to a different zone. Infinite recursion can be triggered as we noted here:
        https://github.com/littlebits/react-popover/issues/18. As an example of how this
        could happen in another way: Imagine the user changes the CSS styling of the popover
        based on whether it was `row` or `column` flow. TODO: Find a solution to generally
        solve this problem so that the user is free to change the Popover styles in any
        way at any time for any arbitrary trigger. There may be value in investigating the
        http://overconstrained.io community for its general layout system via the
        constraint-solver Cassowary. */
      };if (this.zone) this.size[this.zone.flow === "row" ? "h" : "w"] += this.props.tipSize;
      var zone = _layout2.default.pickZone(pickerSettings, this.frameBounds, this.targetBounds, this.size);
      if (this.zone) this.size[this.zone.flow === "row" ? "h" : "w"] -= this.props.tipSize;

      var tb = this.targetBounds;
      this.zone = zone;
      log("zone", zone);

      this.setState({
        standing: zone.standing
      });

      var axis = _layout2.default.axes[zone.flow];
      log("axes", axis);

      var dockingEdgeBufferLength = Math.round(getComputedStyle(this.bodyEl).borderRadius.slice(0, -2)) || 0;
      var scrollSize = _layout2.default.El.calcScrollSize(this.frameEl);
      scrollSize.main = scrollSize[axis.main.size];
      scrollSize.cross = scrollSize[axis.cross.size];

      /* When positioning self on the cross-axis do not exceed frame bounds. The strategy to achieve
      this is thus: First position cross-axis self to the cross-axis-center of the the target. Then,
      offset self by the amount that self is past the boundaries of frame. */
      var pos = _layout2.default.calcRelPos(zone, tb, this.size);

      /* Offset allows users to control the distance betweent the tip and the target. */
      pos[axis.main.start] += this.props.offset * zone.order;

      /* Constrain containerEl Position within frameEl. Try not to penetrate a visually-pleasing buffer from
      frameEl. `frameBuffer` length is based on tipSize and its offset. */

      var frameBuffer = this.props.tipSize + this.props.offset;
      var hangingBufferLength = dockingEdgeBufferLength * 2 + this.props.tipSize * 2 + frameBuffer;
      var frameCrossStart = this.frameBounds[axis.cross.start];
      var frameCrossEnd = this.frameBounds[axis.cross.end];
      var frameCrossLength = this.frameBounds[axis.cross.size];
      var frameCrossInnerLength = frameCrossLength - frameBuffer * 2;
      var frameCrossInnerStart = frameCrossStart + frameBuffer;
      var frameCrossInnerEnd = frameCrossEnd - frameBuffer;
      var popoverCrossStart = pos[axis.cross.start];
      var popoverCrossEnd = pos[axis.cross.end];

      /* If the popover dose not fit into frameCrossLength then just position it to the `frameCrossStart`.
      popoverCrossLength` will now be forced to overflow into the `Frame` */
      if (pos.crossLength > frameCrossLength) {
        log("popoverCrossLength does not fit frame.");
        pos[axis.cross.start] = 0;

        /* If the `popoverCrossStart` is forced beyond some threshold of `targetCrossLength` then bound
        it (`popoverCrossStart`). */
      } else if (tb[axis.cross.end] < hangingBufferLength) {
        log("popoverCrossStart cannot hang any further without losing target.");
        pos[axis.cross.start] = tb[axis.cross.end] - hangingBufferLength;

        /* checking if the cross start of the target area is within the frame and it makes sense
        to try fitting popover into the frame. */
      } else if (tb[axis.cross.start] > frameCrossInnerEnd) {
        log("popoverCrossStart cannot hang any further without losing target.");
        pos[axis.cross.start] = tb[axis.cross.start] - this.size[axis.cross.size];

        /* If the `popoverCrossStart` does not fit within the inner frame (honouring buffers) then
        just center the popover in the remaining `frameCrossLength`. */
      } else if (pos.crossLength > frameCrossInnerLength) {
        log("popoverCrossLength does not fit within buffered frame.");
        pos[axis.cross.start] = (frameCrossLength - pos.crossLength) / 2;
      } else if (popoverCrossStart < frameCrossInnerStart) {
        log("popoverCrossStart cannot reverse without exceeding frame.");
        pos[axis.cross.start] = frameCrossInnerStart;
      } else if (popoverCrossEnd > frameCrossInnerEnd) {
        log("popoverCrossEnd cannot travel without exceeding frame.");
        pos[axis.cross.start] = pos[axis.cross.start] - (pos[axis.cross.end] - frameCrossInnerEnd);
      }

      /* So far the link position has been calculated relative to the target. To calculate the absolute
      position we need to factor the `Frame``s scroll position */

      pos[axis.cross.start] += scrollSize.cross;
      pos[axis.main.start] += scrollSize.main;

      /* Apply `flow` and `order` styles. This can impact subsequent measurements of height and width
      of the container. When tip changes orientation position due to changes from/to `row`/`column`
      width`/`height` will be impacted. Our layout monitoring will catch these cases and automatically
      recalculate layout. */

      this.containerEl.style.flexFlow = zone.flow;
      this.containerEl.style[jsprefix("FlexFlow")] = this.containerEl.style.flexFlow;
      this.bodyEl.style.order = zone.order;
      this.bodyEl.style[jsprefix("Order")] = this.bodyEl.style.order;

      /* Apply Absolute Positioning. */

      log("pos", pos);
      this.containerEl.style.top = pos.y + "px";
      this.containerEl.style.left = pos.x + "px";

      /* Calculate Tip Position */

      var tipCrossPos =
      /* Get the absolute tipCrossCenter. Tip is positioned relative to containerEl
      but it aims at targetCenter which is positioned relative to frameEl... we
      need to cancel the containerEl positioning so as to hit our intended position. */
      _layout2.default.centerOfBoundsFromBounds(zone.flow, "cross", tb, pos) +
      /* centerOfBounds does not account for scroll so we need to manually add that
      here. */
      scrollSize.cross -
      /* Center tip relative to self. We do not have to calcualte half-of-tip-size since tip-size
      specifies the length from base to tip which is half of total length already. */
      this.props.tipSize;

      if (tipCrossPos < dockingEdgeBufferLength) tipCrossPos = dockingEdgeBufferLength;else if (tipCrossPos > pos.crossLength - dockingEdgeBufferLength - this.props.tipSize * 2) {
        tipCrossPos = pos.crossLength - dockingEdgeBufferLength - this.props.tipSize * 2;
      }

      this.tipEl.style.transform = flowToTipTranslations[zone.flow] + "(" + tipCrossPos + "px)";
      this.tipEl.style[jsprefix("Transform")] = this.tipEl.style.transform;
    }
  }, {
    key: "measurePopoverSize",
    value: function measurePopoverSize() {
      this.size = _layout2.default.El.calcSize(this.containerEl);
    }
  }, {
    key: "measureTargetBounds",
    value: function measureTargetBounds() {
      var newTargetBounds = _layout2.default.El.calcBounds(this.targetEl);

      if (this.targetBounds && _layout2.default.equalCoords(this.targetBounds, newTargetBounds)) {
        return false;
      }

      this.targetBounds = newTargetBounds;
      return true;
    }
  }, {
    key: "open",
    value: function open() {
      if (this.state.exiting) this.animateExitStop();
      this.setState({ toggle: true, exited: false });
    }
  }, {
    key: "close",
    value: function close() {
      this.setState({ toggle: false });
    }
  }, {
    key: "enter",
    value: function enter() {
      if (_platform2.default.isServer) return;
      log("enter!");
      this.trackPopover();
      this.animateEnter();
    }
  }, {
    key: "exit",
    value: function exit() {
      log("exit!");
      this.animateExit();
      this.untrackPopover();
    }
  }, {
    key: "animateExitStop",
    value: function animateExitStop() {
      clearTimeout(this.exitingAnimationTimer1);
      clearTimeout(this.exitingAnimationTimer2);
      this.setState({ exiting: false });
    }
  }, {
    key: "animateExit",
    value: function animateExit() {
      var _this2 = this;

      this.setState({ exiting: true });
      this.exitingAnimationTimer2 = setTimeout(function () {
        setTimeout(function () {
          _this2.containerEl.style.transform = flowToPopoverTranslations[_this2.zone.flow] + "(" + _this2.zone.order * 50 + "px)";
          _this2.containerEl.style.opacity = "0";
        }, 0);
      }, 0);

      this.exitingAnimationTimer1 = setTimeout(function () {
        _this2.setState({ exited: true, exiting: false });
      }, this.props.enterExitTransitionDurationMs);
    }
  }, {
    key: "animateEnter",
    value: function animateEnter() {
      /* Prepare `entering` style so that we can then animate it toward `entered`. */

      this.containerEl.style.transform = flowToPopoverTranslations[this.zone.flow] + "(" + this.zone.order * 50 + "px)";
      this.containerEl.style[jsprefix("Transform")] = this.containerEl.style.transform;
      this.containerEl.style.opacity = "0";

      /* After initial layout apply transition animations. */
      /* Hack: http://stackoverflow.com/questions/3485365/how-can-i-force-webkit-to-redraw-repaint-to-propagate-style-changes */
      this.containerEl.offsetHeight;

      /* If enterExitTransitionDurationMs is falsy, tip animation should be also disabled */
      if (this.props.enterExitTransitionDurationMs) {
        this.tipEl.style.transition = "transform 150ms ease-in";
        this.tipEl.style[jsprefix("Transition")] = cssprefix("transform") + " 150ms ease-in";
      }
      this.containerEl.style.transitionProperty = "top, left, opacity, transform";
      this.containerEl.style.transitionDuration = this.props.enterExitTransitionDurationMs + "ms";
      this.containerEl.style.transitionTimingFunction = "cubic-bezier(0.230, 1.000, 0.320, 1.000)";
      this.containerEl.style.opacity = "1";
      this.containerEl.style.transform = "translateY(0)";
      this.containerEl.style[jsprefix("Transform")] = this.containerEl.style.transform;
    }
  }, {
    key: "trackPopover",
    value: function trackPopover() {
      var minScrollRefreshIntervalMs = 200;
      var minResizeRefreshIntervalMs = 200;

      /* Get references to DOM elements. */

      this.bodyEl = this.containerEl.querySelector(".Popover-body");
      this.tipEl = this.containerEl.querySelector(".Popover-tip");

      /* Note: frame is hardcoded to window now but we think it will
      be a nice feature in the future to allow other frames to be used
      such as local elements that further constrain the popover`s world. */

      this.frameEl = _platform2.default.window;
      this.hasTracked = true;

      /* Set a general interval for checking if target position changed. There is no way
      to know this information without polling. */
      if (this.props.refreshIntervalMs) {
        this.checkLayoutInterval = setInterval(this.checkTargetReposition, this.props.refreshIntervalMs);
      }

      /* Watch for boundary changes in all deps, and when one of them changes, recalculate layout.
      This layout monitoring must be bound immediately because a layout recalculation can recursively
      cause a change in boundaries. So if we did a one-time force-layout before watching boundaries
      our final position calculations could be wrong. See comments in resolver function for details
      about which parts can trigger recursive recalculation. */

      this.onFrameScroll = (0, _lodash2.default)(this.onFrameScroll, minScrollRefreshIntervalMs);
      this.onFrameResize = (0, _lodash2.default)(this.onFrameResize, minResizeRefreshIntervalMs);
      this.onPopoverResize = (0, _lodash2.default)(this.onPopoverResize, minResizeRefreshIntervalMs);
      this.onTargetResize = (0, _lodash2.default)(this.onTargetResize, minResizeRefreshIntervalMs);

      this.frameEl.addEventListener("scroll", this.onFrameScroll);
      _onResize2.default.on(this.frameEl, this.onFrameResize);
      _onResize2.default.on(this.containerEl, this.onPopoverResize);
      _onResize2.default.on(this.targetEl, this.onTargetResize);

      /* Track user actions on the page. Anything that occurs _outside_ the Popover boundaries
      should close the Popover. */

      _platform2.default.document.addEventListener("mousedown", this.checkForOuterAction);
      _platform2.default.document.addEventListener("touchstart", this.checkForOuterAction);

      /* Kickstart layout at first boot. */

      this.measurePopoverSize();
      this.measureFrameBounds();
      this.measureTargetBounds();
      this.resolvePopoverLayout();
    }
  }, {
    key: "untrackPopover",
    value: function untrackPopover() {
      clearInterval(this.checkLayoutInterval);
      this.frameEl.removeEventListener("scroll", this.onFrameScroll);
      _onResize2.default.off(this.frameEl, this.onFrameResize);
      _onResize2.default.off(this.containerEl, this.onPopoverResize);
      _onResize2.default.off(this.targetEl, this.onTargetResize);
      _platform2.default.document.removeEventListener("mousedown", this.checkForOuterAction);
      _platform2.default.document.removeEventListener("touchstart", this.checkForOuterAction);
      this.hasTracked = false;
    }
  }, {
    key: "measureFrameBounds",
    value: function measureFrameBounds() {
      this.frameBounds = _layout2.default.El.calcBounds(this.frameEl);
    }
  }, {
    key: "render",
    value: function render() {
      var _props = this.props,
          _props$className = _props.className,
          className = _props$className === undefined ? "" : _props$className,
          _props$style = _props.style,
          style = _props$style === undefined ? {} : _props$style,
          tipSize = _props.tipSize;
      var standing = this.state.standing;


      var popoverProps = {
        className: "Popover Popover-" + standing + " " + className,
        style: _extends({}, coreStyle, style)
      };

      var popover = this.state.exited ? null : _react2.default.createElement(
        "div",
        _extends({ ref: this.getContainerNodeRef }, popoverProps),
        _react2.default.createElement("div", { className: "Popover-body", children: this.props.body }),
        _react2.default.createElement(_tip2.default, { direction: faces[standing], size: tipSize })
      );
      return [this.props.children, _platform2.default.isClient && _reactDom2.default.createPortal(popover, this.props.appendTarget)];
    }
  }]);

  return Popover;
}(_react2.default.Component);

Popover.propTypes = {
  body: _propTypes2.default.node.isRequired,
  children: _propTypes2.default.element.isRequired,
  appendTarget: _propTypes2.default.object,
  className: _propTypes2.default.string,
  enterExitTransitionDurationMs: _propTypes2.default.number,
  isOpen: _propTypes2.default.bool,
  offset: _propTypes2.default.number,
  place: _propTypes2.default.oneOf(_layout2.default.validTypeValues),
  preferPlace: _propTypes2.default.oneOf(_layout2.default.validTypeValues),
  refreshIntervalMs: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.bool]),
  style: _propTypes2.default.object,
  tipSize: _propTypes2.default.number,
  onOuterAction: _propTypes2.default.func
};
Popover.defaultProps = {
  tipSize: 7,
  preferPlace: null,
  place: null,
  offset: 4,
  isOpen: false,
  onOuterAction: _utils2.default.noop,
  enterExitTransitionDurationMs: 500,
  children: null,
  refreshIntervalMs: 200,
  appendTarget: _platform2.default.isClient ? _platform2.default.document.body : null
};
exports.default = Popover;

/***/ }),

/***/ "./node_modules/react-popover/build/layout.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.equalCoords = exports.doesFitWithin = exports.centerOfBoundsFromBounds = exports.centerOfBounds = exports.centerOfSize = exports.axes = exports.pickZone = exports.place = exports.calcRelPos = exports.validTypeValues = exports.types = exports.El = undefined;

var _platform = __webpack_require__("./node_modules/react-popover/build/platform.js");

var _utils = __webpack_require__("./node_modules/react-popover/build/utils.js");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/* Axes System

This allows us to at-will work in a different orientation
without having to manually keep track of knowing if we should be using
x or y positions. */

var axes = {
  row: {},
  column: {}
};

axes.row.main = {
  start: "x",
  end: "x2",
  size: "w"
};
axes.row.cross = {
  start: "y",
  end: "y2",
  size: "h"
};
axes.column.main = axes.row.cross;
axes.column.cross = axes.row.main;

var types = [{ name: "side", values: ["start", "end"] }, { name: "standing", values: ["above", "right", "below", "left"] }, { name: "flow", values: ["column", "row"] }];

var validTypeValues = types.reduce(function (xs, _ref) {
  var values = _ref.values;
  return xs.concat(values);
}, []);

var centerOfSize = function centerOfSize(flow, axis, size) {
  return size[axes[flow][axis].size] / 2;
};

var centerOfBounds = function centerOfBounds(flow, axis, bounds) {
  return bounds[axes[flow][axis].start] + bounds[axes[flow][axis].size] / 2;
};

var centerOfBoundsFromBounds = function centerOfBoundsFromBounds(flow, axis, boundsTo, boundsFrom) {
  return centerOfBounds(flow, axis, boundsTo) - boundsFrom[axes[flow][axis].start];
};

var place = function place(flow, axis, align, bounds, size) {
  var axisProps = axes[flow][axis];
  return align === "center" ? centerOfBounds(flow, axis, bounds) - centerOfSize(flow, axis, size) : align === "end" ? bounds[axisProps.end] : align === "start"
  /* DOM rendering unfolds leftward. Therefore if the slave is positioned before
  the master then the slave`s position must in addition be pulled back
  by its [the slave`s] own length. */
  ? bounds[axisProps.start] - size[axisProps.size] : null;
};

/* Element Layout Queries */

var El = {};

El.calcBounds = function (el) {

  if (el === _platform.window) {
    return {
      x: 0,
      y: 0,
      x2: el.innerWidth,
      y2: el.innerHeight,
      w: el.innerWidth,
      h: el.innerHeight
    };
  }

  var b = el.getBoundingClientRect();

  return {
    x: b.left,
    y: b.top,
    x2: b.right,
    y2: b.bottom,
    w: b.right - b.left,
    h: b.bottom - b.top
  };
};

El.calcSize = function (el) {
  return el === _platform.window ? { w: el.innerWidth, h: el.innerHeight } : { w: el.offsetWidth, h: el.offsetHeight };
};

El.calcScrollSize = function (el) {
  return el === _platform.window ? {
    w: el.scrollX || el.pageXOffset,
    h: el.scrollY || el.pageYOffset
  } : { w: el.scrollLeft, h: el.scrollTop };
};

/* Misc Utilities */

var getPreferenceType = function getPreferenceType(preference) {
  return types.reduce(function (found, type) {
    return found ? found : type.values.indexOf(preference) !== -1 ? type.name : null;
  }, null);
};

/* Dimension Fit Checks */

var fitWithinChecker = function fitWithinChecker(dimension) {
  return function (domainSize, itemSize) {
    return domainSize[dimension] >= itemSize[dimension];
  };
};

var doesWidthFitWithin = fitWithinChecker("w");
var doesHeightFitWithin = fitWithinChecker("h");

var doesFitWithin = function doesFitWithin(domainSize, itemSize) {
  return doesWidthFitWithin(domainSize, itemSize) && doesHeightFitWithin(domainSize, itemSize);
};

/* Errors */

var createPreferenceError = function createPreferenceError(givenValue) {
  return new Error("The given layout placement of \"" + givenValue + "\" is not a valid choice. Valid choices are: " + validTypeValues.join(" | ") + ".");
};

/* Algorithm for picking the best fitting zone for popover. The current technique will loop through all zones picking the last one that fits.
In the case that none fit we should pick the least-not-fitting zone. */

var pickZone = function pickZone(opts, frameBounds, targetBounds, size) {
  var t = targetBounds;
  var f = frameBounds;
  var zones = [{ side: "start", standing: "above", flow: "column", order: -1, w: f.x2, h: t.y }, { side: "end", standing: "right", flow: "row", order: 1, w: f.x2 - t.x2, h: f.y2 }, { side: "end", standing: "below", flow: "column", order: 1, w: f.x2, h: f.y2 - t.y2 }, { side: "start", standing: "left", flow: "row", order: -1, w: t.x, h: f.y2 }];

  /* Order the zones by the amount of popup that would be cut out if that zone is used.
     The first one in the array is the one that cuts the least amount.
      const area = size.w * size.h  // Popup area is constant and it does not change the order
  */
  zones.forEach(function (z) {
    // TODO Update to satisfy linter
    // eslint-disable-next-line no-param-reassign
    z.cutOff = /* area */-Math.max(0, Math.min(z.w, size.w)) * Math.max(0, Math.min(z.h, size.h));
  });
  zones.sort(function (a, b) {
    return a.cutOff - b.cutOff;
  });

  var availZones = zones.filter(function (zone) {
    return doesFitWithin(zone, size);
  });

  /* If a place is required pick it from the available zones if possible. */

  if (opts.place) {
    var type = getPreferenceType(opts.place);
    if (!type) throw createPreferenceError(opts.place);
    var finder = function finder(z) {
      return z[type] === opts.place;
    };
    return (0, _utils.find)(finder, availZones) || (0, _utils.find)(finder, zones);
  }

  /* If the preferred side is part of the available zones, use that otherwise
  pick the largest available zone. If there are no available zones, pick the
  largest zone. */

  if (opts.preferPlace) {
    var preferenceType = getPreferenceType(opts.preferPlace);
    if (!preferenceType) throw createPreferenceError(opts.preferPlace);

    // Try to fit first in zone where the pop up fit completely
    var preferredAvailZones = availZones.filter(function (zone) {
      return zone[preferenceType] === opts.preferPlace;
    });
    if (preferredAvailZones.length) return preferredAvailZones[0];

    // If there are not areas where the pop up fit completely, it uses the preferred ones
    // in order from the one the fit better
    var preferredZones = zones.filter(function (zone) {
      return zone[preferenceType] === opts.preferPlace;
    });
    if (!availZones.length && preferredZones.length) return preferredZones[0];
  }

  // Return a zone that fit completely or the one that fit the best
  return availZones.length ? availZones[0] : zones[0];
};

/* TODO Document this. */

var calcRelPos = function calcRelPos(zone, masterBounds, slaveSize) {
  var _ref2;

  var _axes$zone$flow = axes[zone.flow],
      main = _axes$zone$flow.main,
      cross = _axes$zone$flow.cross;
  /* TODO: The slave is hard-coded to align cross-center with master. */

  var crossAlign = "center";
  var mainStart = place(zone.flow, "main", zone.side, masterBounds, slaveSize);
  var mainSize = slaveSize[main.size];
  var crossStart = place(zone.flow, "cross", crossAlign, masterBounds, slaveSize);
  var crossSize = slaveSize[cross.size];

  return _ref2 = {}, _defineProperty(_ref2, main.start, mainStart), _defineProperty(_ref2, "mainLength", mainSize), _defineProperty(_ref2, main.end, mainStart + mainSize), _defineProperty(_ref2, cross.start, crossStart), _defineProperty(_ref2, "crossLength", crossSize), _defineProperty(_ref2, cross.end, crossStart + crossSize), _ref2;
};

exports.default = {
  El: El,
  types: types,
  validTypeValues: validTypeValues,
  calcRelPos: calcRelPos,
  place: place,
  pickZone: pickZone,
  axes: axes,
  centerOfSize: centerOfSize,
  centerOfBounds: centerOfBounds,
  centerOfBoundsFromBounds: centerOfBoundsFromBounds,
  doesFitWithin: doesFitWithin,
  equalCoords: _utils.equalRecords
};
exports.El = El;
exports.types = types;
exports.validTypeValues = validTypeValues;
exports.calcRelPos = calcRelPos;
exports.place = place;
exports.pickZone = pickZone;
exports.axes = axes;
exports.centerOfSize = centerOfSize;
exports.centerOfBounds = centerOfBounds;
exports.centerOfBoundsFromBounds = centerOfBoundsFromBounds;
exports.doesFitWithin = doesFitWithin;
exports.equalCoords = _utils.equalRecords;

/***/ }),

/***/ "./node_modules/react-popover/build/on-resize.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.removeEventListener = exports.addEventListener = exports.off = exports.on = undefined;

var _platform = __webpack_require__("./node_modules/react-popover/build/platform.js");

var _utils = __webpack_require__("./node_modules/react-popover/build/utils.js");

/* eslint no-param-reassign: 0 */

var requestAnimationFrame = _platform.isServer ? _utils.noop : _platform.window.requestAnimationFrame || _platform.window.mozRequestAnimationFrame || _platform.window.webkitRequestAnimationFrame || function (fn) {
  _platform.window.setTimeout(fn, 20);
};

var cancelAnimationFrame = _platform.isServer ? _utils.noop : _platform.window.cancelAnimationFrame || _platform.window.mozCancelAnimationFrame || _platform.window.webkitCancelAnimationFrame || _platform.window.clearTimeout;

var isIE = _platform.isServer ? false : navigator.userAgent.match(/Trident/);

var namespace = "__resizeDetector__";

var uninitialize = function uninitialize(el) {
  el[namespace].destroy();
  el[namespace] = undefined;
};

var createElementHack = function createElementHack() {
  var el = document.createElement("object");
  el.className = "resize-sensor";
  el.setAttribute("style", "display: block; position: absolute; top: 0; left: 0; height: 100%; width: 100%; overflow: hidden; pointer-events: none; z-index: -1;");
  el.setAttribute("class", "resize-sensor");
  el.type = "text/html";
  el.data = "about:blank";
  return el;
};

var initialize = function initialize(el) {

  var detector = el[namespace] = {};
  detector.listeners = [];

  var onResize = function onResize(e) {
    /* Keep in mind e.target could be el OR objEl. In this current implementation we don't seem to need to know this but its important
    to not forget e.g. in some future refactoring scenario. */
    if (detector.resizeRAF) cancelAnimationFrame(detector.resizeRAF);
    detector.resizeRAF = requestAnimationFrame(function () {
      detector.listeners.forEach(function (fn) {
        fn(e);
      });
    });
  };

  if (isIE) {
    /* We do not support ie8 and below (or ie9 in compat mode).
    Therefore there is no presence of `attachEvent` here. */
    el.addEventListener("onresize", onResize);
    detector.destroy = function () {
      el.removeEventListener("onresize", onResize);
    };
  } else {
    if (getComputedStyle(el).position === "static") {
      detector.elWasStaticPosition = true;
      el.style.position = "relative";
    }
    var objEl = createElementHack();
    objEl.onload = function () /* event */{
      this.contentDocument.defaultView.addEventListener("resize", onResize);
    };
    detector.destroy = function () {
      if (detector.elWasStaticPosition) el.style.position = "";
      // Event handlers will be automatically removed.
      // http://stackoverflow.com/questions/12528049/if-a-dom-element-is-removed-are-its-listeners-also-removed-from-memory
      el.removeChild(objEl);
    };

    el.appendChild(objEl);
  }
};

var on = function on(el, fn) {

  /* Window object natively publishes resize events. We handle it as a
  special case here so that users do not have to think about two APIs. */

  if (el === _platform.window) {
    _platform.window.addEventListener("resize", fn);
    return;
  }

  /* Not caching namespace read here beacuse not guaranteed that its available. */

  if (!el[namespace]) initialize(el);
  el[namespace].listeners.push(fn);
};

var off = function off(el, fn) {
  if (el === _platform.window) {
    _platform.window.removeEventListener("resize", fn);
    return;
  }
  var detector = el[namespace];
  if (!detector) return;
  var i = detector.listeners.indexOf(fn);
  if (i !== -1) detector.listeners.splice(i, 1);
  if (!detector.listeners.length) uninitialize(el);
};

exports.default = {
  on: on,
  off: off,
  addEventListener: on,
  removeEventListener: off
};
exports.on = on;
exports.off = off;
exports.addEventListener = on;
exports.removeEventListener = off;

/***/ }),

/***/ "./node_modules/react-popover/build/platform.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var isServer = typeof window === "undefined";
var isClient = !isServer;
var WINDOW = isClient ? window : null;
var DOCUMENT = isClient ? document : null;

exports.default = {
  isServer: isServer,
  isClient: isClient,
  window: WINDOW,
  document: DOCUMENT
};
exports.isServer = isServer;
exports.isClient = isClient;
exports.window = WINDOW;
exports.document = DOCUMENT;

/***/ }),

/***/ "./node_modules/react-popover/build/tip.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__("./node_modules/react/cjs/react.development.js");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Tip = function Tip(props) {
  var direction = props.direction;

  var size = props.size || 24;
  var isPortrait = direction === "up" || direction === "down";
  var mainLength = size;
  var crossLength = size * 2;
  var points = direction === "up" ? "0," + mainLength + " " + mainLength + ",0, " + crossLength + "," + mainLength : direction === "down" ? "0,0 " + mainLength + "," + mainLength + ", " + crossLength + ",0" : direction === "left" ? mainLength + ",0 0," + mainLength + ", " + mainLength + "," + crossLength : "0,0 " + mainLength + "," + mainLength + ", 0," + crossLength;
  var svgProps = {
    className: "Popover-tip",
    width: isPortrait ? crossLength : mainLength,
    height: isPortrait ? mainLength : crossLength
  };

  return _react2.default.createElement(
    "svg",
    svgProps,
    _react2.default.createElement("polygon", {
      className: "Popover-tipShape",
      points: points
    })
  );
};

exports.default = Tip;

/***/ }),

/***/ "./node_modules/react-popover/build/utils.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.clientOnly = exports.noop = exports.equalRecords = exports.find = undefined;

var _platform = __webpack_require__("./node_modules/react-popover/build/platform.js");

var find = function find(f, xs) {
  return xs.reduce(function (b, x) {
    return b ? b : f(x) ? x : null;
  }, null);
};

var equalRecords = function equalRecords(o1, o2) {
  for (var key in o1) {
    if (o1[key] !== o2[key]) return false;
  }return true;
};

var noop = function noop() {
  return undefined;
};

var clientOnly = function clientOnly(f) {
  return _platform.isClient ? f : noop;
};

exports.default = {
  find: find,
  equalRecords: equalRecords,
  noop: noop,
  clientOnly: clientOnly
};
exports.find = find;
exports.equalRecords = equalRecords;
exports.noop = noop;
exports.clientOnly = clientOnly;

/***/ }),

/***/ "./node_modules/react-popover/index.js":
/***/ (function(module, exports, __webpack_require__) {

// http://stackoverflow.com/questions/33505992/babel-6-changes-how-it-exports-default

const lib = __webpack_require__("./node_modules/react-popover/build/index.js")
module.exports = lib.default


/***/ }),

/***/ "./node_modules/react-stand-in/lib/config.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
var config = {
  logger: console
};

var setConfig = exports.setConfig = function setConfig(obj) {
  Object.assign(config, obj);
};

exports.default = config;

/***/ }),

/***/ "./node_modules/react-stand-in/lib/constants.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
var PREFIX = exports.PREFIX = '__reactstandin__';
var PROXY_KEY = exports.PROXY_KEY = PREFIX + 'key';
var GENERATION = exports.GENERATION = PREFIX + 'proxyGeneration';
var REGENERATE_METHOD = exports.REGENERATE_METHOD = PREFIX + 'regenerateByEval';
var UNWRAP_PROXY = exports.UNWRAP_PROXY = PREFIX + 'getCurrent';
var CACHED_RESULT = exports.CACHED_RESULT = PREFIX + 'cachedResult';

/***/ }),

/***/ "./node_modules/react-stand-in/lib/createClassProxy.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__("./node_modules/react/cjs/react.development.js");

var _transferStaticProps = __webpack_require__("./node_modules/react-stand-in/lib/transferStaticProps.js");

var _transferStaticProps2 = _interopRequireDefault(_transferStaticProps);

var _constants = __webpack_require__("./node_modules/react-stand-in/lib/constants.js");

var _utils = __webpack_require__("./node_modules/react-stand-in/lib/utils.js");

var _inject = __webpack_require__("./node_modules/react-stand-in/lib/inject.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var has = Object.prototype.hasOwnProperty;

var proxies = new WeakMap();

var defaultRenderOptions = {
  preRender: _utils.identity,
  postRender: function postRender(result) {
    return result;
  }
};

var defineClassMember = function defineClassMember(Class, methodName, methodBody) {
  return (0, _utils.safeDefineProperty)(Class.prototype, methodName, {
    configurable: true,
    writable: true,
    enumerable: false,
    value: methodBody
  });
};

function createClassProxy(InitialComponent, proxyKey, options) {
  var renderOptions = _extends({}, defaultRenderOptions, options);
  // Prevent double wrapping.
  // Given a proxy class, return the existing proxy managing it.
  var existingProxy = proxies.get(InitialComponent);

  if (existingProxy) {
    return existingProxy;
  }

  var CurrentComponent = void 0;
  var savedDescriptors = {};
  var injectedMembers = {};
  var proxyGeneration = 0;
  var isFunctionalComponent = !(0, _utils.isReactClass)(InitialComponent);

  var lastInstance = null;

  function postConstructionAction() {
    this[_constants.GENERATION] = 0;

    // As long we can't override constructor
    // every class shall evolve from a base class
    (0, _inject.inject)(this, proxyGeneration, injectedMembers);

    lastInstance = this;
  }

  function proxiedUpdate() {
    (0, _inject.inject)(this, proxyGeneration, injectedMembers);
  }

  function lifeCycleWrapperFactory(wrapperName) {
    return function wrappedMethod() {
      proxiedUpdate.call(this);

      for (var _len = arguments.length, rest = Array(_len), _key = 0; _key < _len; _key++) {
        rest[_key] = arguments[_key];
      }

      return !isFunctionalComponent && CurrentComponent.prototype[wrapperName] && CurrentComponent.prototype[wrapperName].apply(this, rest);
    };
  }

  var componentWillReceiveProps = lifeCycleWrapperFactory('componentWillReceiveProps');
  var componentWillUpdate = lifeCycleWrapperFactory('componentWillUpdate');

  function proxiedRender() {
    proxiedUpdate.call(this);
    renderOptions.preRender(this);

    var result = void 0;

    // We need to use hasOwnProperty here, as the cached result is a React node
    // and can be null or some other falsy value.
    if (has.call(this, _constants.CACHED_RESULT)) {
      result = this[_constants.CACHED_RESULT];
      delete this[_constants.CACHED_RESULT];
    } else if (isFunctionalComponent) {
      result = CurrentComponent(this.props, this.context);
    } else {
      result = CurrentComponent.prototype.render.call(this);
    }

    return renderOptions.postRender(result);
  }

  var defineProxyMethods = function defineProxyMethods(Proxy) {
    defineClassMember(Proxy, 'render', proxiedRender);
    defineClassMember(Proxy, 'componentWillReceiveProps', componentWillReceiveProps);
    defineClassMember(Proxy, 'componentWillUpdate', componentWillUpdate);
  };

  var ProxyFacade = void 0;
  var ProxyComponent = null;

  if (!isFunctionalComponent) {
    ProxyComponent = (0, _utils.proxyClassCreator)(InitialComponent, postConstructionAction);

    defineProxyMethods(ProxyComponent);

    ProxyFacade = ProxyComponent;
  } else {
    // This function only gets called for the initial mount. The actual
    // rendered component instance will be the return value.

    // eslint-disable-next-line func-names
    ProxyFacade = function ProxyFacade(props, context) {
      var result = CurrentComponent(props, context);

      // This is a Relay-style container constructor. We can't do the prototype-
      // style wrapping for this as we do elsewhere, so just we just pass it
      // through as-is.
      if ((0, _utils.isReactComponentInstance)(result)) {
        ProxyComponent = null;
        return result;
      }

      // Otherwise, it's a normal functional component. Build the real proxy
      // and use it going forward.
      ProxyComponent = (0, _utils.proxyClassCreator)(_react.Component, postConstructionAction);

      defineProxyMethods(ProxyComponent);

      var determinateResult = new ProxyComponent(props, context);

      // Cache the initial render result so we don't call the component function
      // a second time for the initial render.
      determinateResult[_constants.CACHED_RESULT] = result;
      return determinateResult;
    };
  }

  function get() {
    return ProxyFacade;
  }

  function getCurrent() {
    return CurrentComponent;
  }

  (0, _utils.safeDefineProperty)(ProxyFacade, _constants.UNWRAP_PROXY, {
    configurable: false,
    writable: false,
    enumerable: false,
    value: getCurrent
  });

  (0, _utils.safeDefineProperty)(ProxyFacade, _constants.PROXY_KEY, {
    configurable: false,
    writable: false,
    enumerable: false,
    value: proxyKey
  });

  (0, _utils.safeDefineProperty)(ProxyFacade, 'toString', {
    configurable: true,
    writable: false,
    enumerable: false,
    value: function toString() {
      return String(CurrentComponent);
    }
  });

  function update(NextComponent) {
    if (typeof NextComponent !== 'function') {
      throw new Error('Expected a constructor.');
    }

    if (NextComponent === CurrentComponent) {
      return;
    }

    // Prevent proxy cycles
    var existingProxy = proxies.get(NextComponent);
    if (existingProxy) {
      update(existingProxy[_constants.UNWRAP_PROXY]());
      return;
    }

    isFunctionalComponent = !(0, _utils.isReactClass)(NextComponent);
    proxyGeneration++;

    // Save the next constructor so we call it
    var PreviousComponent = CurrentComponent;
    CurrentComponent = NextComponent;

    // Try to infer displayName
    var displayName = (0, _utils.getDisplayName)(CurrentComponent);
    ProxyFacade.displayName = displayName;

    if (ProxyComponent) {
      (0, _utils.safeDefineProperty)(ProxyComponent, 'name', {
        value: displayName
      });
    }

    savedDescriptors = (0, _transferStaticProps2.default)(ProxyFacade, savedDescriptors, PreviousComponent, NextComponent);

    if (isFunctionalComponent || !ProxyComponent) {
      // nothing
    } else {
      (0, _inject.checkLifeCycleMethods)(ProxyComponent, NextComponent);
      Object.setPrototypeOf(ProxyComponent.prototype, NextComponent.prototype);
      if (proxyGeneration > 1) {
        injectedMembers = (0, _inject.mergeComponents)(ProxyComponent, NextComponent, InitialComponent, lastInstance, injectedMembers);
      }
    }
  }

  update(InitialComponent);

  var proxy = { get: get, update: update };
  proxies.set(ProxyFacade, proxy);

  (0, _utils.safeDefineProperty)(proxy, _constants.UNWRAP_PROXY, {
    configurable: false,
    writable: false,
    enumerable: false,
    value: getCurrent
  });

  return proxy;
}

exports.default = createClassProxy;

/***/ }),

/***/ "./node_modules/react-stand-in/lib/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _constants = __webpack_require__("./node_modules/react-stand-in/lib/constants.js");

Object.keys(_constants).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _constants[key];
    }
  });
});

var _createClassProxy = __webpack_require__("./node_modules/react-stand-in/lib/createClassProxy.js");

Object.defineProperty(exports, 'default', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_createClassProxy).default;
  }
});

var _config = __webpack_require__("./node_modules/react-stand-in/lib/config.js");

Object.defineProperty(exports, 'setConfig', {
  enumerable: true,
  get: function get() {
    return _config.setConfig;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),

/***/ "./node_modules/react-stand-in/lib/inject.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.inject = exports.checkLifeCycleMethods = exports.mergeComponents = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _utils = __webpack_require__("./node_modules/react-stand-in/lib/utils.js");

var _constants = __webpack_require__("./node_modules/react-stand-in/lib/constants.js");

var _config = __webpack_require__("./node_modules/react-stand-in/lib/config.js");

var _config2 = _interopRequireDefault(_config);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function mergeComponents(ProxyComponent, NextComponent, InitialComponent, lastInstance, injectedMembers) {
  var injectedCode = {};
  try {
    var nextInstance = (0, _utils.safeReactConstructor)(NextComponent, lastInstance);

    try {
      // Bypass babel class inheritance checking
      (0, _utils.deepPrototypeUpdate)(InitialComponent, NextComponent);
    } catch (e) {
      // It was ES6 class
    }

    var proxyInstance = (0, _utils.safeReactConstructor)(ProxyComponent, lastInstance);

    if (!nextInstance || !proxyInstance) {
      return injectedCode;
    }

    var mergedAttrs = _extends({}, proxyInstance, nextInstance);
    var hasRegenerate = proxyInstance[_constants.REGENERATE_METHOD];
    var ownKeys = (0, _utils.getOwnKeys)(Object.getPrototypeOf(ProxyComponent.prototype));
    Object.keys(mergedAttrs).forEach(function (key) {
      if (key.startsWith(_constants.PREFIX)) return;
      var nextAttr = nextInstance[key];
      var prevAttr = proxyInstance[key];
      if (prevAttr && nextAttr) {
        if ((0, _utils.isNativeFunction)(nextAttr) || (0, _utils.isNativeFunction)(prevAttr)) {
          // this is bound method
          var isSameArity = nextAttr.length === prevAttr.length;
          var existsInPrototype = ownKeys.indexOf(key) >= 0 || ProxyComponent.prototype[key];
          if (isSameArity && existsInPrototype) {
            if (hasRegenerate) {
              injectedCode[key] = 'Object.getPrototypeOf(this)[\'' + key + '\'].bind(this)';
            } else {
              _config2.default.logger.warn('React-stand-in:,', 'Non-controlled class', ProxyComponent.name, 'contains a new native or bound function ', key, nextAttr, '. Unable to reproduce');
            }
          } else {
            _config2.default.logger.warn('React-stand-in:', 'Updated class ', ProxyComponent.name, 'contains native or bound function ', key, nextAttr, '. Unable to reproduce, use arrow functions instead.', '(arity: ' + nextAttr.length + '/' + prevAttr.length + ', proto: ' + (existsInPrototype ? 'yes' : 'no'));
          }
          return;
        }

        var nextString = String(nextAttr);
        var injectedBefore = injectedMembers[key];
        if (nextString !== String(prevAttr) || injectedBefore && nextString !== String(injectedBefore)) {
          if (!hasRegenerate) {
            if (nextString.indexOf('function') < 0 && nextString.indexOf('=>') < 0) {
              // just copy prop over
              injectedCode[key] = nextAttr;
            } else {
              _config2.default.logger.warn('React-stand-in:', ' Updated class ', ProxyComponent.name, 'had different code for', key, nextAttr, '. Unable to reproduce. Regeneration support needed.');
            }
          } else {
            injectedCode[key] = nextAttr;
          }
        }
      }
    });
  } catch (e) {
    _config2.default.logger.warn('React-stand-in:', e);
  }
  return injectedCode;
}

function checkLifeCycleMethods(ProxyComponent, NextComponent) {
  try {
    var p1 = Object.getPrototypeOf(ProxyComponent.prototype);
    var p2 = NextComponent.prototype;
    _utils.reactLifeCycleMountMethods.forEach(function (key) {
      var d1 = Object.getOwnPropertyDescriptor(p1, key) || { value: p1[key] };
      var d2 = Object.getOwnPropertyDescriptor(p2, key) || { value: p2[key] };
      if (!(0, _utils.shallowStringsEqual)(d1, d2)) {
        _config2.default.logger.warn('React-stand-in:', 'You did update', ProxyComponent.name, 's lifecycle method', key, '. Unable to repeat');
      }
    });
  } catch (e) {
    // Ignore errors
  }
}

function inject(target, currentGeneration, injectedMembers) {
  if (target[_constants.GENERATION] !== currentGeneration) {
    var hasRegenerate = !!target[_constants.REGENERATE_METHOD];
    Object.keys(injectedMembers).forEach(function (key) {
      try {
        if (hasRegenerate) {
          target[_constants.REGENERATE_METHOD](key, '(function REACT_HOT_LOADER_SANDBOX () {\n          var _this = this; // common babel transpile\n          var _this2 = this; // common babel transpile          \n          return ' + injectedMembers[key] + ';\n          }).call(this)');
        } else {
          target[key] = injectedMembers[key];
        }
      } catch (e) {
        _config2.default.logger.warn('React-stand-in: Failed to regenerate method ', key, ' of class ', target);
        _config2.default.logger.warn('got error', e);
      }
    });

    target[_constants.GENERATION] = currentGeneration;
  }
}

exports.mergeComponents = mergeComponents;
exports.checkLifeCycleMethods = checkLifeCycleMethods;
exports.inject = inject;

/***/ }),

/***/ "./node_modules/react-stand-in/lib/transferStaticProps.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _shallowequal = __webpack_require__("./node_modules/shallowequal/index.js");

var _shallowequal2 = _interopRequireDefault(_shallowequal);

var _utils = __webpack_require__("./node_modules/react-stand-in/lib/utils.js");

var _constants = __webpack_require__("./node_modules/react-stand-in/lib/constants.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var RESERVED_STATICS = ['length', 'displayName', 'name', 'arguments', 'caller', 'prototype', 'toString', 'valueOf', _constants.PROXY_KEY, _constants.UNWRAP_PROXY];

function transferStaticProps(ProxyComponent, savedDescriptors, PreviousComponent, NextComponent) {
  Object.getOwnPropertyNames(ProxyComponent).forEach(function (key) {
    if (RESERVED_STATICS.indexOf(key) !== -1) {
      return;
    }

    var prevDescriptor = Object.getOwnPropertyDescriptor(ProxyComponent, key);
    var savedDescriptor = savedDescriptors[key];

    if (!(0, _shallowequal2.default)(prevDescriptor, savedDescriptor)) {
      (0, _utils.safeDefineProperty)(NextComponent, key, prevDescriptor);
    }
  });

  // Copy newly defined static methods and properties
  Object.getOwnPropertyNames(NextComponent).forEach(function (key) {
    if (RESERVED_STATICS.indexOf(key) !== -1) {
      return;
    }

    var prevDescriptor = PreviousComponent && Object.getOwnPropertyDescriptor(ProxyComponent, key);
    var savedDescriptor = savedDescriptors[key];

    // Skip redefined descriptors
    if (prevDescriptor && savedDescriptor && !(0, _shallowequal2.default)(savedDescriptor, prevDescriptor)) {
      (0, _utils.safeDefineProperty)(NextComponent, key, prevDescriptor);
      return;
    }

    if (prevDescriptor && !savedDescriptor) {
      (0, _utils.safeDefineProperty)(ProxyComponent, key, prevDescriptor);
      return;
    }

    var nextDescriptor = _extends({}, Object.getOwnPropertyDescriptor(NextComponent, key), {
      configurable: true
    });

    savedDescriptors[key] = nextDescriptor;
    (0, _utils.safeDefineProperty)(ProxyComponent, key, nextDescriptor);
  });

  // Remove static methods and properties that are no longer defined
  Object.getOwnPropertyNames(ProxyComponent).forEach(function (key) {
    if (RESERVED_STATICS.indexOf(key) !== -1) {
      return;
    }
    // Skip statics that exist on the next class
    if (NextComponent.hasOwnProperty(key)) {
      return;
    }
    // Skip non-configurable statics
    var proxyDescriptor = Object.getOwnPropertyDescriptor(ProxyComponent, key);
    if (proxyDescriptor && !proxyDescriptor.configurable) {
      return;
    }

    var prevDescriptor = PreviousComponent && Object.getOwnPropertyDescriptor(PreviousComponent, key);
    var savedDescriptor = savedDescriptors[key];

    // Skip redefined descriptors
    if (prevDescriptor && savedDescriptor && !(0, _shallowequal2.default)(savedDescriptor, prevDescriptor)) {
      return;
    }

    (0, _utils.safeDefineProperty)(ProxyComponent, key, {
      value: undefined
    });
  });

  return savedDescriptors;
}

exports.default = transferStaticProps;

/***/ }),

/***/ "./node_modules/react-stand-in/lib/utils.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.proxyClassCreator = exports.isReactComponentInstance = exports.doesSupportClasses = exports.identity = exports.reactLifeCycleMountMethods = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /* eslint-disable no-eval, func-names */


exports.getDisplayName = getDisplayName;
exports.isReactClass = isReactClass;
exports.safeReactConstructor = safeReactConstructor;
exports.isNativeFunction = isNativeFunction;
exports.getOwnKeys = getOwnKeys;
exports.shallowStringsEqual = shallowStringsEqual;
exports.deepPrototypeUpdate = deepPrototypeUpdate;
exports.safeDefineProperty = safeDefineProperty;

var _config = __webpack_require__("./node_modules/react-stand-in/lib/config.js");

var _config2 = _interopRequireDefault(_config);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getDisplayName(Component) {
  var displayName = Component.displayName || Component.name;
  return displayName && displayName !== 'ReactComponent' ? displayName : 'Unknown';
}

var reactLifeCycleMountMethods = exports.reactLifeCycleMountMethods = ['componentWillMount', 'componentDidMount'];

function isReactClass(Component) {
  return Component.prototype && (Component.prototype.isReactComponent || Component.prototype.componentWillMount || Component.prototype.componentWillUnmount || Component.prototype.componentDidMount || Component.prototype.componentDidUnmount || Component.prototype.render);
}

function safeReactConstructor(Component, lastInstance) {
  try {
    if (lastInstance) {
      return new Component(lastInstance.props, lastInstance.context);
    }
    return new Component({}, {});
  } catch (e) {
    // some components, like Redux connect could not be created without proper context
  }
  return null;
}

function isNativeFunction(fn) {
  return typeof fn === 'function' ? fn.toString().indexOf('[native code]') > 0 : false;
}

var identity = exports.identity = function identity(a) {
  return a;
};

var doesSupportClasses = exports.doesSupportClasses = function () {
  try {
    eval('class Test {}');
    return true;
  } catch (e) {
    return false;
  }
}();

var ES6ProxyComponentFactory = doesSupportClasses && eval('\n(function(InitialParent, postConstructionAction) {\n  return class ProxyComponent extends InitialParent {\n    constructor(props, context) {\n      super(props, context)\n      postConstructionAction.call(this)\n    }\n  }\n})\n');

var ES5ProxyComponentFactory = function ES5ProxyComponentFactory(InitialParent, postConstructionAction) {
  function ProxyComponent(props, context) {
    InitialParent.call(this, props, context);
    postConstructionAction.call(this);
  }
  ProxyComponent.prototype = Object.create(InitialParent.prototype);
  Object.setPrototypeOf(ProxyComponent, InitialParent);
  return ProxyComponent;
};

var isReactComponentInstance = exports.isReactComponentInstance = function isReactComponentInstance(el) {
  return el && (typeof el === 'undefined' ? 'undefined' : _typeof(el)) === 'object' && !el.type && el.render;
};

var proxyClassCreator = exports.proxyClassCreator = doesSupportClasses ? ES6ProxyComponentFactory : ES5ProxyComponentFactory;

function getOwnKeys(target) {
  return [].concat(Object.getOwnPropertyNames(target), Object.getOwnPropertySymbols(target));
}

function shallowStringsEqual(a, b) {
  for (var key in a) {
    if (String(a[key]) !== String(b[key])) {
      return false;
    }
  }
  return true;
}

function deepPrototypeUpdate(dest, source) {
  var deepDest = Object.getPrototypeOf(dest);
  var deepSrc = Object.getPrototypeOf(source);
  if (deepDest && deepSrc && deepSrc !== deepDest) {
    deepPrototypeUpdate(deepDest, deepSrc);
  }
  if (source.prototype && source.prototype !== dest.prototype) {
    dest.prototype = source.prototype;
  }
}

function safeDefineProperty(target, key, props) {
  try {
    Object.defineProperty(target, key, props);
  } catch (e) {
    _config2.default.logger.warn('Error while wrapping', key, ' -> ', e);
  }
}

/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime-module.js":
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// This method of obtaining a reference to the global object needs to be
// kept identical to the way it is obtained in runtime.js
var g = (function() { return this })() || Function("return this")();

// Use `getOwnPropertyNames` because not all browsers support calling
// `hasOwnProperty` on the global `self` object in a worker. See #183.
var hadRuntime = g.regeneratorRuntime &&
  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;

// Save the old regeneratorRuntime in case it needs to be restored later.
var oldRuntime = hadRuntime && g.regeneratorRuntime;

// Force reevalutation of runtime.js.
g.regeneratorRuntime = undefined;

module.exports = __webpack_require__("./node_modules/regenerator-runtime/runtime.js");

if (hadRuntime) {
  // Restore the original runtime.
  g.regeneratorRuntime = oldRuntime;
} else {
  // Remove the global property added by runtime.js.
  try {
    delete g.regeneratorRuntime;
  } catch(e) {
    g.regeneratorRuntime = undefined;
  }
}


/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/***/ (function(module, exports) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

!(function(global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
})(
  // In sloppy mode, unbound `this` refers to the global object, fallback to
  // Function constructor if we're in global strict mode. That is sadly a form
  // of indirect eval which violates Content Security Policy.
  (function() { return this })() || Function("return this")()
);


/***/ }),

/***/ "./node_modules/shallowequal/index.js":
/***/ (function(module, exports) {

module.exports = function shallowEqual(objA, objB, compare, compareContext) {

    var ret = compare ? compare.call(compareContext, objA, objB) : void 0;

    if(ret !== void 0) {
        return !!ret;
    }

    if(objA === objB) {
        return true;
    }

    if(typeof objA !== 'object' || !objA ||
       typeof objB !== 'object' || !objB) {
        return false;
    }

    var keysA = Object.keys(objA);
    var keysB = Object.keys(objB);

    if(keysA.length !== keysB.length) {
        return false;
    }

    var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);

    // Test for A's keys different from B.
    for(var idx = 0; idx < keysA.length; idx++) {

        var key = keysA[idx];

        if(!bHasOwnProperty(key)) {
            return false;
        }

        var valueA = objA[key];
        var valueB = objB[key];

        ret = compare ? compare.call(compareContext, valueA, valueB, key) : void 0;

        if(ret === false ||
           ret === void 0 && valueA !== valueB) {
            return false;
        }

    }

    return true;

};


/***/ }),

/***/ "./node_modules/simple-swizzle/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isArrayish = __webpack_require__("./node_modules/simple-swizzle/node_modules/is-arrayish/index.js");

var concat = Array.prototype.concat;
var slice = Array.prototype.slice;

var swizzle = module.exports = function swizzle(args) {
	var results = [];

	for (var i = 0, len = args.length; i < len; i++) {
		var arg = args[i];

		if (isArrayish(arg)) {
			// http://jsperf.com/javascript-array-concat-vs-push/98
			results = concat.call(results, slice.call(arg));
		} else {
			results.push(arg);
		}
	}

	return results;
};

swizzle.wrap = function (fn) {
	return function () {
		return fn(swizzle(arguments));
	};
};


/***/ }),

/***/ "./node_modules/simple-swizzle/node_modules/is-arrayish/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function isArrayish(obj) {
	if (!obj || typeof obj === 'string') {
		return false;
	}

	return obj instanceof Array || Array.isArray(obj) ||
		(obj.length >= 0 && (obj.splice instanceof Function ||
			(Object.getOwnPropertyDescriptor(obj, (obj.length - 1)) && obj.constructor.name !== 'String')));
};


/***/ }),

/***/ "./node_modules/socket.io-client/build/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Socket = exports.io = exports.Manager = exports.protocol = void 0;
const url_1 = __webpack_require__("./node_modules/socket.io-client/build/url.js");
const manager_1 = __webpack_require__("./node_modules/socket.io-client/build/manager.js");
const socket_1 = __webpack_require__("./node_modules/socket.io-client/build/socket.js");
Object.defineProperty(exports, "Socket", { enumerable: true, get: function () { return socket_1.Socket; } });
const debug = __webpack_require__("./node_modules/socket.io-client/node_modules/debug/src/browser.js")("socket.io-client");
/**
 * Module exports.
 */
module.exports = exports = lookup;
/**
 * Managers cache.
 */
const cache = (exports.managers = {});
function lookup(uri, opts) {
    if (typeof uri === "object") {
        opts = uri;
        uri = undefined;
    }
    opts = opts || {};
    const parsed = url_1.url(uri);
    const source = parsed.source;
    const id = parsed.id;
    const path = parsed.path;
    const sameNamespace = cache[id] && path in cache[id].nsps;
    const newConnection = opts.forceNew ||
        opts["force new connection"] ||
        false === opts.multiplex ||
        sameNamespace;
    let io;
    if (newConnection) {
        debug("ignoring socket cache for %s", source);
        io = new manager_1.Manager(source, opts);
    }
    else {
        if (!cache[id]) {
            debug("new io instance for %s", source);
            cache[id] = new manager_1.Manager(source, opts);
        }
        io = cache[id];
    }
    if (parsed.query && !opts.query) {
        opts.query = parsed.query;
    }
    return io.socket(parsed.path, opts);
}
exports.io = lookup;
/**
 * Protocol version.
 *
 * @public
 */
var socket_io_parser_1 = __webpack_require__("./node_modules/socket.io-parser/dist/index.js");
Object.defineProperty(exports, "protocol", { enumerable: true, get: function () { return socket_io_parser_1.protocol; } });
/**
 * `connect`.
 *
 * @param {String} uri
 * @public
 */
exports.connect = lookup;
/**
 * Expose constructors for standalone build.
 *
 * @public
 */
var manager_2 = __webpack_require__("./node_modules/socket.io-client/build/manager.js");
Object.defineProperty(exports, "Manager", { enumerable: true, get: function () { return manager_2.Manager; } });


/***/ }),

/***/ "./node_modules/socket.io-client/build/manager.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Manager = void 0;
const eio = __webpack_require__("./node_modules/engine.io-client/lib/index.js");
const socket_1 = __webpack_require__("./node_modules/socket.io-client/build/socket.js");
const Emitter = __webpack_require__("./node_modules/component-emitter/index.js");
const parser = __webpack_require__("./node_modules/socket.io-parser/dist/index.js");
const on_1 = __webpack_require__("./node_modules/socket.io-client/build/on.js");
const bind = __webpack_require__("./node_modules/component-bind/index.js");
const Backoff = __webpack_require__("./node_modules/backo2/index.js");
const debug = __webpack_require__("./node_modules/socket.io-client/node_modules/debug/src/browser.js")("socket.io-client:manager");
class Manager extends Emitter {
    constructor(uri, opts) {
        super();
        this.nsps = {};
        this.subs = [];
        this.connecting = [];
        if (uri && "object" === typeof uri) {
            opts = uri;
            uri = undefined;
        }
        opts = opts || {};
        opts.path = opts.path || "/socket.io";
        this.opts = opts;
        this.reconnection(opts.reconnection !== false);
        this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
        this.reconnectionDelay(opts.reconnectionDelay || 1000);
        this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
        this.randomizationFactor(opts.randomizationFactor || 0.5);
        this.backoff = new Backoff({
            min: this.reconnectionDelay(),
            max: this.reconnectionDelayMax(),
            jitter: this.randomizationFactor(),
        });
        this.timeout(null == opts.timeout ? 20000 : opts.timeout);
        this._readyState = "closed";
        this.uri = uri;
        const _parser = opts.parser || parser;
        this.encoder = new _parser.Encoder();
        this.decoder = new _parser.Decoder();
        this._autoConnect = opts.autoConnect !== false;
        if (this._autoConnect)
            this.open();
    }
    reconnection(v) {
        if (!arguments.length)
            return this._reconnection;
        this._reconnection = !!v;
        return this;
    }
    reconnectionAttempts(v) {
        if (v === undefined)
            return this._reconnectionAttempts;
        this._reconnectionAttempts = v;
        return this;
    }
    reconnectionDelay(v) {
        if (v === undefined)
            return this._reconnectionDelay;
        this._reconnectionDelay = v;
        this.backoff && this.backoff.setMin(v);
        return this;
    }
    randomizationFactor(v) {
        if (v === undefined)
            return this._randomizationFactor;
        this._randomizationFactor = v;
        this.backoff && this.backoff.setJitter(v);
        return this;
    }
    reconnectionDelayMax(v) {
        if (v === undefined)
            return this._reconnectionDelayMax;
        this._reconnectionDelayMax = v;
        this.backoff && this.backoff.setMax(v);
        return this;
    }
    timeout(v) {
        if (!arguments.length)
            return this._timeout;
        this._timeout = v;
        return this;
    }
    /**
     * Starts trying to reconnect if reconnection is enabled and we have not
     * started reconnecting yet
     *
     * @private
     */
    maybeReconnectOnOpen() {
        // Only try to reconnect if it's the first time we're connecting
        if (!this._reconnecting &&
            this._reconnection &&
            this.backoff.attempts === 0) {
            // keeps reconnection from firing twice for the same reconnection loop
            this.reconnect();
        }
    }
    /**
     * Sets the current transport `socket`.
     *
     * @param {Function} fn - optional, callback
     * @return {Manager} self
     * @public
     */
    open(fn) {
        debug("readyState %s", this._readyState);
        if (~this._readyState.indexOf("open"))
            return this;
        debug("opening %s", this.uri);
        this.engine = eio(this.uri, this.opts);
        const socket = this.engine;
        const self = this;
        this._readyState = "opening";
        this.skipReconnect = false;
        // emit `open`
        const openSub = on_1.on(socket, "open", function () {
            self.onopen();
            fn && fn();
        });
        // emit `error`
        const errorSub = on_1.on(socket, "error", (err) => {
            debug("error");
            self.cleanup();
            self._readyState = "closed";
            super.emit("error", err);
            if (fn) {
                fn(err);
            }
            else {
                // Only do this if there is no fn to handle the error
                self.maybeReconnectOnOpen();
            }
        });
        if (false !== this._timeout) {
            const timeout = this._timeout;
            debug("connect attempt will timeout after %d", timeout);
            if (timeout === 0) {
                openSub.destroy(); // prevents a race condition with the 'open' event
            }
            // set timer
            const timer = setTimeout(() => {
                debug("connect attempt timed out after %d", timeout);
                openSub.destroy();
                socket.close();
                socket.emit("error", new Error("timeout"));
            }, timeout);
            this.subs.push({
                destroy: function () {
                    clearTimeout(timer);
                },
            });
        }
        this.subs.push(openSub);
        this.subs.push(errorSub);
        return this;
    }
    /**
     * Alias for open()
     *
     * @return {Manager} self
     * @public
     */
    connect(fn) {
        return this.open(fn);
    }
    /**
     * Called upon transport open.
     *
     * @private
     */
    onopen() {
        debug("open");
        // clear old subs
        this.cleanup();
        // mark as open
        this._readyState = "open";
        super.emit("open");
        // add new subs
        const socket = this.engine;
        this.subs.push(on_1.on(socket, "data", bind(this, "ondata")));
        this.subs.push(on_1.on(socket, "ping", bind(this, "onping")));
        this.subs.push(on_1.on(socket, "error", bind(this, "onerror")));
        this.subs.push(on_1.on(socket, "close", bind(this, "onclose")));
        this.subs.push(on_1.on(this.decoder, "decoded", bind(this, "ondecoded")));
    }
    /**
     * Called upon a ping.
     *
     * @private
     */
    onping() {
        super.emit("ping");
    }
    /**
     * Called with data.
     *
     * @private
     */
    ondata(data) {
        this.decoder.add(data);
    }
    /**
     * Called when parser fully decodes a packet.
     *
     * @private
     */
    ondecoded(packet) {
        super.emit("packet", packet);
    }
    /**
     * Called upon socket error.
     *
     * @private
     */
    onerror(err) {
        debug("error", err);
        super.emit("error", err);
    }
    /**
     * Creates a new socket for the given `nsp`.
     *
     * @return {Socket}
     * @public
     */
    socket(nsp, opts) {
        let socket = this.nsps[nsp];
        if (!socket) {
            socket = new socket_1.Socket(this, nsp, opts);
            this.nsps[nsp] = socket;
            var self = this;
            socket.on("connecting", onConnecting);
            if (this._autoConnect) {
                // manually call here since connecting event is fired before listening
                onConnecting();
            }
        }
        function onConnecting() {
            if (!~self.connecting.indexOf(socket)) {
                self.connecting.push(socket);
            }
        }
        return socket;
    }
    /**
     * Called upon a socket close.
     *
     * @param {Socket} socket
     * @private
     */
    _destroy(socket) {
        const index = this.connecting.indexOf(socket);
        if (~index)
            this.connecting.splice(index, 1);
        if (this.connecting.length)
            return;
        this._close();
    }
    /**
     * Writes a packet.
     *
     * @param {Object} packet
     * @private
     */
    _packet(packet) {
        debug("writing packet %j", packet);
        if (packet.query && packet.type === 0)
            packet.nsp += "?" + packet.query;
        const encodedPackets = this.encoder.encode(packet);
        for (let i = 0; i < encodedPackets.length; i++) {
            this.engine.write(encodedPackets[i], packet.options);
        }
    }
    /**
     * Clean up transport subscriptions and packet buffer.
     *
     * @private
     */
    cleanup() {
        debug("cleanup");
        const subsLength = this.subs.length;
        for (let i = 0; i < subsLength; i++) {
            const sub = this.subs.shift();
            sub.destroy();
        }
        this.decoder.destroy();
    }
    /**
     * Close the current socket.
     *
     * @private
     */
    _close() {
        debug("disconnect");
        this.skipReconnect = true;
        this._reconnecting = false;
        if ("opening" === this._readyState) {
            // `onclose` will not fire because
            // an open event never happened
            this.cleanup();
        }
        this.backoff.reset();
        this._readyState = "closed";
        if (this.engine)
            this.engine.close();
    }
    /**
     * Alias for close()
     *
     * @private
     */
    disconnect() {
        return this._close();
    }
    /**
     * Called upon engine close.
     *
     * @private
     */
    onclose(reason) {
        debug("onclose");
        this.cleanup();
        this.backoff.reset();
        this._readyState = "closed";
        super.emit("close", reason);
        if (this._reconnection && !this.skipReconnect) {
            this.reconnect();
        }
    }
    /**
     * Attempt a reconnection.
     *
     * @private
     */
    reconnect() {
        if (this._reconnecting || this.skipReconnect)
            return this;
        const self = this;
        if (this.backoff.attempts >= this._reconnectionAttempts) {
            debug("reconnect failed");
            this.backoff.reset();
            super.emit("reconnect_failed");
            this._reconnecting = false;
        }
        else {
            const delay = this.backoff.duration();
            debug("will wait %dms before reconnect attempt", delay);
            this._reconnecting = true;
            const timer = setTimeout(() => {
                if (self.skipReconnect)
                    return;
                debug("attempting reconnect");
                super.emit("reconnect_attempt", self.backoff.attempts);
                // check again for the case socket closed in above events
                if (self.skipReconnect)
                    return;
                self.open((err) => {
                    if (err) {
                        debug("reconnect attempt error");
                        self._reconnecting = false;
                        self.reconnect();
                        super.emit("reconnect_error", err);
                    }
                    else {
                        debug("reconnect success");
                        self.onreconnect();
                    }
                });
            }, delay);
            this.subs.push({
                destroy: function () {
                    clearTimeout(timer);
                },
            });
        }
    }
    /**
     * Called upon successful reconnect.
     *
     * @private
     */
    onreconnect() {
        const attempt = this.backoff.attempts;
        this._reconnecting = false;
        this.backoff.reset();
        super.emit("reconnect", attempt);
    }
}
exports.Manager = Manager;


/***/ }),

/***/ "./node_modules/socket.io-client/build/on.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.on = void 0;
function on(obj, ev, fn) {
    obj.on(ev, fn);
    return {
        destroy: function () {
            obj.removeListener(ev, fn);
        },
    };
}
exports.on = on;


/***/ }),

/***/ "./node_modules/socket.io-client/build/socket.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Socket = void 0;
const socket_io_parser_1 = __webpack_require__("./node_modules/socket.io-parser/dist/index.js");
const Emitter = __webpack_require__("./node_modules/component-emitter/index.js");
const on_1 = __webpack_require__("./node_modules/socket.io-client/build/on.js");
const bind = __webpack_require__("./node_modules/component-bind/index.js");
const debug = __webpack_require__("./node_modules/socket.io-client/node_modules/debug/src/browser.js")("socket.io-client:socket");
/**
 * Internal events.
 * These events can't be emitted by the user.
 */
const RESERVED_EVENTS = {
    connect: 1,
    connect_error: 1,
    disconnect: 1,
    disconnecting: 1,
    // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener
    newListener: 1,
    removeListener: 1,
};
class Socket extends Emitter {
    /**
     * `Socket` constructor.
     *
     * @public
     */
    constructor(io, nsp, opts) {
        super();
        this.ids = 0;
        this.acks = {};
        this.receiveBuffer = [];
        this.sendBuffer = [];
        this.flags = {};
        this.io = io;
        this.nsp = nsp;
        this.ids = 0;
        this.acks = {};
        this.receiveBuffer = [];
        this.sendBuffer = [];
        this.connected = false;
        this.disconnected = true;
        this.flags = {};
        if (opts && opts.auth) {
            this.auth = opts.auth;
        }
        if (this.io._autoConnect)
            this.open();
    }
    /**
     * Subscribe to open, close and packet events
     *
     * @private
     */
    subEvents() {
        if (this.subs)
            return;
        const io = this.io;
        this.subs = [
            on_1.on(io, "open", bind(this, "onopen")),
            on_1.on(io, "packet", bind(this, "onpacket")),
            on_1.on(io, "close", bind(this, "onclose")),
        ];
    }
    /**
     * "Opens" the socket.
     *
     * @public
     */
    connect() {
        if (this.connected)
            return this;
        this.subEvents();
        if (!this.io._reconnecting)
            this.io.open(); // ensure open
        if ("open" === this.io._readyState)
            this.onopen();
        return this;
    }
    /**
     * Alias for connect()
     */
    open() {
        return this.connect();
    }
    /**
     * Sends a `message` event.
     *
     * @return {Socket} self
     * @public
     */
    send(...args) {
        args.unshift("message");
        this.emit.apply(this, args);
        return this;
    }
    /**
     * Override `emit`.
     * If the event is in `events`, it's emitted normally.
     *
     * @param {String} ev - event name
     * @return {Socket} self
     * @public
     */
    emit(ev, ...args) {
        if (RESERVED_EVENTS.hasOwnProperty(ev)) {
            throw new Error('"' + ev + '" is a reserved event name');
        }
        args.unshift(ev);
        const packet = {
            type: socket_io_parser_1.PacketType.EVENT,
            data: args,
        };
        packet.options = {};
        packet.options.compress = this.flags.compress !== false;
        // event ack callback
        if ("function" === typeof args[args.length - 1]) {
            debug("emitting packet with ack id %d", this.ids);
            this.acks[this.ids] = args.pop();
            packet.id = this.ids++;
        }
        const isTransportWritable = this.io.engine &&
            this.io.engine.transport &&
            this.io.engine.transport.writable;
        const discardPacket = this.flags.volatile && (!isTransportWritable || !this.connected);
        if (discardPacket) {
            debug("discard packet as the transport is not currently writable");
        }
        else if (this.connected) {
            this.packet(packet);
        }
        else {
            this.sendBuffer.push(packet);
        }
        this.flags = {};
        return this;
    }
    /**
     * Sends a packet.
     *
     * @param {Object} packet
     * @private
     */
    packet(packet) {
        packet.nsp = this.nsp;
        this.io._packet(packet);
    }
    /**
     * Called upon engine `open`.
     *
     * @private
     */
    onopen() {
        debug("transport is open - connecting");
        if (typeof this.auth == "function") {
            this.auth((data) => {
                this.packet({ type: socket_io_parser_1.PacketType.CONNECT, data });
            });
        }
        else {
            this.packet({ type: socket_io_parser_1.PacketType.CONNECT, data: this.auth });
        }
    }
    /**
     * Called upon engine `close`.
     *
     * @param {String} reason
     * @private
     */
    onclose(reason) {
        debug("close (%s)", reason);
        this.connected = false;
        this.disconnected = true;
        delete this.id;
        super.emit("disconnect", reason);
    }
    /**
     * Called with socket packet.
     *
     * @param {Object} packet
     * @private
     */
    onpacket(packet) {
        const sameNamespace = packet.nsp === this.nsp;
        if (!sameNamespace)
            return;
        switch (packet.type) {
            case socket_io_parser_1.PacketType.CONNECT:
                const id = packet.data.sid;
                this.onconnect(id);
                break;
            case socket_io_parser_1.PacketType.EVENT:
                this.onevent(packet);
                break;
            case socket_io_parser_1.PacketType.BINARY_EVENT:
                this.onevent(packet);
                break;
            case socket_io_parser_1.PacketType.ACK:
                this.onack(packet);
                break;
            case socket_io_parser_1.PacketType.BINARY_ACK:
                this.onack(packet);
                break;
            case socket_io_parser_1.PacketType.DISCONNECT:
                this.ondisconnect();
                break;
            case socket_io_parser_1.PacketType.CONNECT_ERROR:
                const err = new Error(packet.data.message);
                // @ts-ignore
                err.data = packet.data.data;
                super.emit("connect_error", err);
                break;
        }
    }
    /**
     * Called upon a server event.
     *
     * @param {Object} packet
     * @private
     */
    onevent(packet) {
        const args = packet.data || [];
        debug("emitting event %j", args);
        if (null != packet.id) {
            debug("attaching ack callback to event");
            args.push(this.ack(packet.id));
        }
        if (this.connected) {
            this.emitEvent(args);
        }
        else {
            this.receiveBuffer.push(args);
        }
    }
    emitEvent(args) {
        if (this._anyListeners && this._anyListeners.length) {
            const listeners = this._anyListeners.slice();
            for (const listener of listeners) {
                listener.apply(this, args);
            }
        }
        super.emit.apply(this, args);
    }
    /**
     * Produces an ack callback to emit with an event.
     *
     * @private
     */
    ack(id) {
        const self = this;
        let sent = false;
        return function (...args) {
            // prevent double callbacks
            if (sent)
                return;
            sent = true;
            debug("sending ack %j", args);
            self.packet({
                type: socket_io_parser_1.PacketType.ACK,
                id: id,
                data: args,
            });
        };
    }
    /**
     * Called upon a server acknowlegement.
     *
     * @param {Object} packet
     * @private
     */
    onack(packet) {
        const ack = this.acks[packet.id];
        if ("function" === typeof ack) {
            debug("calling ack %s with %j", packet.id, packet.data);
            ack.apply(this, packet.data);
            delete this.acks[packet.id];
        }
        else {
            debug("bad ack %s", packet.id);
        }
    }
    /**
     * Called upon server connect.
     *
     * @private
     */
    onconnect(id) {
        this.id = id;
        this.connected = true;
        this.disconnected = false;
        super.emit("connect");
        this.emitBuffered();
    }
    /**
     * Emit buffered events (received and emitted).
     *
     * @private
     */
    emitBuffered() {
        for (let i = 0; i < this.receiveBuffer.length; i++) {
            this.emitEvent(this.receiveBuffer[i]);
        }
        this.receiveBuffer = [];
        for (let i = 0; i < this.sendBuffer.length; i++) {
            this.packet(this.sendBuffer[i]);
        }
        this.sendBuffer = [];
    }
    /**
     * Called upon server disconnect.
     *
     * @private
     */
    ondisconnect() {
        debug("server disconnect (%s)", this.nsp);
        this.destroy();
        this.onclose("io server disconnect");
    }
    /**
     * Called upon forced client/server side disconnections,
     * this method ensures the manager stops tracking us and
     * that reconnections don't get triggered for this.
     *
     * @private
     */
    destroy() {
        if (this.subs) {
            // clean subscriptions to avoid reconnections
            for (let i = 0; i < this.subs.length; i++) {
                this.subs[i].destroy();
            }
            this.subs = null;
        }
        this.io._destroy(this);
    }
    /**
     * Disconnects the socket manually.
     *
     * @return {Socket} self
     * @public
     */
    disconnect() {
        if (this.connected) {
            debug("performing disconnect (%s)", this.nsp);
            this.packet({ type: socket_io_parser_1.PacketType.DISCONNECT });
        }
        // remove socket from pool
        this.destroy();
        if (this.connected) {
            // fire events
            this.onclose("io client disconnect");
        }
        return this;
    }
    /**
     * Alias for disconnect()
     *
     * @return {Socket} self
     * @public
     */
    close() {
        return this.disconnect();
    }
    /**
     * Sets the compress flag.
     *
     * @param {Boolean} compress - if `true`, compresses the sending data
     * @return {Socket} self
     * @public
     */
    compress(compress) {
        this.flags.compress = compress;
        return this;
    }
    /**
     * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
     * ready to send messages.
     *
     * @returns {Socket} self
     * @public
     */
    get volatile() {
        this.flags.volatile = true;
        return this;
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback.
     *
     * @param listener
     * @public
     */
    onAny(listener) {
        this._anyListeners = this._anyListeners || [];
        this._anyListeners.push(listener);
        return this;
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback. The listener is added to the beginning of the listeners array.
     *
     * @param listener
     * @public
     */
    prependAny(listener) {
        this._anyListeners = this._anyListeners || [];
        this._anyListeners.unshift(listener);
        return this;
    }
    /**
     * Removes the listener that will be fired when any event is emitted.
     *
     * @param listener
     * @public
     */
    offAny(listener) {
        if (!this._anyListeners) {
            return this;
        }
        if (listener) {
            const listeners = this._anyListeners;
            for (let i = 0; i < listeners.length; i++) {
                if (listener === listeners[i]) {
                    listeners.splice(i, 1);
                    return this;
                }
            }
        }
        else {
            this._anyListeners = [];
        }
        return this;
    }
    /**
     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
     * e.g. to remove listeners.
     *
     * @public
     */
    listenersAny() {
        return this._anyListeners || [];
    }
}
exports.Socket = Socket;


/***/ }),

/***/ "./node_modules/socket.io-client/build/url.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.url = void 0;
const parseuri = __webpack_require__("./node_modules/parseuri/index.js");
const debug = __webpack_require__("./node_modules/socket.io-client/node_modules/debug/src/browser.js")("socket.io-client:url");
/**
 * URL parser.
 *
 * @param {String} uri - url
 * @param {Object} loc - An object meant to mimic window.location.
 *                 Defaults to window.location.
 * @public
 */
function url(uri, loc) {
    let obj = uri;
    // default to window.location
    loc = loc || (typeof location !== "undefined" && location);
    if (null == uri)
        uri = loc.protocol + "//" + loc.host;
    // relative path support
    if ("string" === typeof uri) {
        if ("/" === uri.charAt(0)) {
            if ("/" === uri.charAt(1)) {
                uri = loc.protocol + uri;
            }
            else {
                uri = loc.host + uri;
            }
        }
        if (!/^(https?|wss?):\/\//.test(uri)) {
            debug("protocol-less url %s", uri);
            if ("undefined" !== typeof loc) {
                uri = loc.protocol + "//" + uri;
            }
            else {
                uri = "https://" + uri;
            }
        }
        // parse
        debug("parse %s", uri);
        obj = parseuri(uri);
    }
    // make sure we treat `localhost:80` and `localhost` equally
    if (!obj.port) {
        if (/^(http|ws)$/.test(obj.protocol)) {
            obj.port = "80";
        }
        else if (/^(http|ws)s$/.test(obj.protocol)) {
            obj.port = "443";
        }
    }
    obj.path = obj.path || "/";
    const ipv6 = obj.host.indexOf(":") !== -1;
    const host = ipv6 ? "[" + obj.host + "]" : obj.host;
    // define unique id
    obj.id = obj.protocol + "://" + host + ":" + obj.port;
    // define href
    obj.href =
        obj.protocol +
            "://" +
            host +
            (loc && loc.port === obj.port ? "" : ":" + obj.port);
    return obj;
}
exports.url = url;


/***/ }),

/***/ "./node_modules/socket.io-client/node_modules/debug/src/browser.js":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */
function log(...args) {
	// This hackery is required for IE8/9, where
	// the `console.log` function doesn't have 'apply'
	return typeof console === 'object' &&
		console.log &&
		console.log(...args);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug');
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = process.env.DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = __webpack_require__("./node_modules/socket.io-client/node_modules/debug/src/common.js")(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/socket.io-client/node_modules/debug/src/common.js":
/***/ (function(module, exports, __webpack_require__) {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = __webpack_require__("./node_modules/socket.io-client/node_modules/ms/index.js");

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* Active `debug` instances.
	*/
	createDebug.instances = [];

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return match;
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.enabled = createDebug.enabled(namespace);
		debug.useColors = createDebug.useColors();
		debug.color = selectColor(namespace);
		debug.destroy = destroy;
		debug.extend = extend;
		// Debug.formatArgs = formatArgs;
		// debug.rawLog = rawLog;

		// env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		createDebug.instances.push(debug);

		return debug;
	}

	function destroy() {
		const index = createDebug.instances.indexOf(this);
		if (index !== -1) {
			createDebug.instances.splice(index, 1);
			return true;
		}
		return false;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);

		createDebug.names = [];
		createDebug.skips = [];

		let i;
		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
		const len = split.length;

		for (i = 0; i < len; i++) {
			if (!split[i]) {
				// ignore empty strings
				continue;
			}

			namespaces = split[i].replace(/\*/g, '.*?');

			if (namespaces[0] === '-') {
				createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
			} else {
				createDebug.names.push(new RegExp('^' + namespaces + '$'));
			}
		}

		for (i = 0; i < createDebug.instances.length; i++) {
			const instance = createDebug.instances[i];
			instance.enabled = createDebug.enabled(instance.namespace);
		}
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names.map(toNamespace),
			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		if (name[name.length - 1] === '*') {
			return true;
		}

		let i;
		let len;

		for (i = 0, len = createDebug.skips.length; i < len; i++) {
			if (createDebug.skips[i].test(name)) {
				return false;
			}
		}

		for (i = 0, len = createDebug.names.length; i < len; i++) {
			if (createDebug.names[i].test(name)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/
	function toNamespace(regexp) {
		return regexp.toString()
			.substring(2, regexp.toString().length - 2)
			.replace(/\.\*\?$/, '*');
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

module.exports = setup;


/***/ }),

/***/ "./node_modules/socket.io-client/node_modules/ms/index.js":
/***/ (function(module, exports) {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}


/***/ }),

/***/ "./node_modules/socket.io-parser/dist/binary.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.reconstructPacket = exports.deconstructPacket = void 0;
const is_binary_1 = __webpack_require__("./node_modules/socket.io-parser/dist/is-binary.js");
/**
 * Replaces every Buffer | ArrayBuffer | Blob | File in packet with a numbered placeholder.
 *
 * @param {Object} packet - socket.io event packet
 * @return {Object} with deconstructed packet and list of buffers
 * @public
 */
function deconstructPacket(packet) {
    const buffers = [];
    const packetData = packet.data;
    const pack = packet;
    pack.data = _deconstructPacket(packetData, buffers);
    pack.attachments = buffers.length; // number of binary 'attachments'
    return { packet: pack, buffers: buffers };
}
exports.deconstructPacket = deconstructPacket;
function _deconstructPacket(data, buffers) {
    if (!data)
        return data;
    if (is_binary_1.isBinary(data)) {
        const placeholder = { _placeholder: true, num: buffers.length };
        buffers.push(data);
        return placeholder;
    }
    else if (Array.isArray(data)) {
        const newData = new Array(data.length);
        for (let i = 0; i < data.length; i++) {
            newData[i] = _deconstructPacket(data[i], buffers);
        }
        return newData;
    }
    else if (typeof data === "object" && !(data instanceof Date)) {
        const newData = {};
        for (const key in data) {
            if (data.hasOwnProperty(key)) {
                newData[key] = _deconstructPacket(data[key], buffers);
            }
        }
        return newData;
    }
    return data;
}
/**
 * Reconstructs a binary packet from its placeholder packet and buffers
 *
 * @param {Object} packet - event packet with placeholders
 * @param {Array} buffers - binary buffers to put in placeholder positions
 * @return {Object} reconstructed packet
 * @public
 */
function reconstructPacket(packet, buffers) {
    packet.data = _reconstructPacket(packet.data, buffers);
    packet.attachments = undefined; // no longer useful
    return packet;
}
exports.reconstructPacket = reconstructPacket;
function _reconstructPacket(data, buffers) {
    if (!data)
        return data;
    if (data && data._placeholder) {
        return buffers[data.num]; // appropriate buffer (should be natural order anyway)
    }
    else if (Array.isArray(data)) {
        for (let i = 0; i < data.length; i++) {
            data[i] = _reconstructPacket(data[i], buffers);
        }
    }
    else if (typeof data === "object") {
        for (const key in data) {
            if (data.hasOwnProperty(key)) {
                data[key] = _reconstructPacket(data[key], buffers);
            }
        }
    }
    return data;
}


/***/ }),

/***/ "./node_modules/socket.io-parser/dist/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Decoder = exports.Encoder = exports.PacketType = exports.protocol = void 0;
const Emitter = __webpack_require__("./node_modules/component-emitter/index.js");
const binary_1 = __webpack_require__("./node_modules/socket.io-parser/dist/binary.js");
const is_binary_1 = __webpack_require__("./node_modules/socket.io-parser/dist/is-binary.js");
const debug = __webpack_require__("./node_modules/socket.io-parser/node_modules/debug/src/browser.js")("socket.io-parser");
/**
 * Protocol version.
 *
 * @public
 */
exports.protocol = 5;
var PacketType;
(function (PacketType) {
    PacketType[PacketType["CONNECT"] = 0] = "CONNECT";
    PacketType[PacketType["DISCONNECT"] = 1] = "DISCONNECT";
    PacketType[PacketType["EVENT"] = 2] = "EVENT";
    PacketType[PacketType["ACK"] = 3] = "ACK";
    PacketType[PacketType["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
    PacketType[PacketType["BINARY_EVENT"] = 5] = "BINARY_EVENT";
    PacketType[PacketType["BINARY_ACK"] = 6] = "BINARY_ACK";
})(PacketType = exports.PacketType || (exports.PacketType = {}));
/**
 * A socket.io Encoder instance
 */
class Encoder {
    /**
     * Encode a packet as a single string if non-binary, or as a
     * buffer sequence, depending on packet type.
     *
     * @param {Object} obj - packet object
     */
    encode(obj) {
        debug("encoding packet %j", obj);
        if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
            if (is_binary_1.hasBinary(obj)) {
                obj.type =
                    obj.type === PacketType.EVENT
                        ? PacketType.BINARY_EVENT
                        : PacketType.BINARY_ACK;
                return this.encodeAsBinary(obj);
            }
        }
        return [this.encodeAsString(obj)];
    }
    /**
     * Encode packet as string.
     */
    encodeAsString(obj) {
        // first is type
        let str = "" + obj.type;
        // attachments if we have them
        if (obj.type === PacketType.BINARY_EVENT ||
            obj.type === PacketType.BINARY_ACK) {
            str += obj.attachments + "-";
        }
        // if we have a namespace other than `/`
        // we append it followed by a comma `,`
        if (obj.nsp && "/" !== obj.nsp) {
            str += obj.nsp + ",";
        }
        // immediately followed by the id
        if (null != obj.id) {
            str += obj.id;
        }
        // json data
        if (null != obj.data) {
            str += JSON.stringify(obj.data);
        }
        debug("encoded %j as %s", obj, str);
        return str;
    }
    /**
     * Encode packet as 'buffer sequence' by removing blobs, and
     * deconstructing packet into object with placeholders and
     * a list of buffers.
     */
    encodeAsBinary(obj) {
        const deconstruction = binary_1.deconstructPacket(obj);
        const pack = this.encodeAsString(deconstruction.packet);
        const buffers = deconstruction.buffers;
        buffers.unshift(pack); // add packet info to beginning of data list
        return buffers; // write all the buffers
    }
}
exports.Encoder = Encoder;
/**
 * A socket.io Decoder instance
 *
 * @return {Object} decoder
 */
class Decoder extends Emitter {
    constructor() {
        super();
    }
    /**
     * Decodes an encoded packet string into packet JSON.
     *
     * @param {String} obj - encoded packet
     */
    add(obj) {
        let packet;
        if (typeof obj === "string") {
            packet = this.decodeString(obj);
            if (packet.type === PacketType.BINARY_EVENT ||
                packet.type === PacketType.BINARY_ACK) {
                // binary packet's json
                this.reconstructor = new BinaryReconstructor(packet);
                // no attachments, labeled binary but no binary data to follow
                if (packet.attachments === 0) {
                    super.emit("decoded", packet);
                }
            }
            else {
                // non-binary full packet
                super.emit("decoded", packet);
            }
        }
        else if (is_binary_1.isBinary(obj) || obj.base64) {
            // raw binary data
            if (!this.reconstructor) {
                throw new Error("got binary data when not reconstructing a packet");
            }
            else {
                packet = this.reconstructor.takeBinaryData(obj);
                if (packet) {
                    // received final buffer
                    this.reconstructor = null;
                    super.emit("decoded", packet);
                }
            }
        }
        else {
            throw new Error("Unknown type: " + obj);
        }
    }
    /**
     * Decode a packet String (JSON data)
     *
     * @param {String} str
     * @return {Object} packet
     */
    decodeString(str) {
        let i = 0;
        // look up type
        const p = {
            type: Number(str.charAt(0)),
        };
        if (PacketType[p.type] === undefined) {
            throw new Error("unknown packet type " + p.type);
        }
        // look up attachments if type binary
        if (p.type === PacketType.BINARY_EVENT ||
            p.type === PacketType.BINARY_ACK) {
            const start = i + 1;
            while (str.charAt(++i) !== "-" && i != str.length) { }
            const buf = str.substring(start, i);
            if (buf != Number(buf) || str.charAt(i) !== "-") {
                throw new Error("Illegal attachments");
            }
            p.attachments = Number(buf);
        }
        // look up namespace (if any)
        if ("/" === str.charAt(i + 1)) {
            const start = i + 1;
            while (++i) {
                const c = str.charAt(i);
                if ("," === c)
                    break;
                if (i === str.length)
                    break;
            }
            p.nsp = str.substring(start, i);
        }
        else {
            p.nsp = "/";
        }
        // look up id
        const next = str.charAt(i + 1);
        if ("" !== next && Number(next) == next) {
            const start = i + 1;
            while (++i) {
                const c = str.charAt(i);
                if (null == c || Number(c) != c) {
                    --i;
                    break;
                }
                if (i === str.length)
                    break;
            }
            p.id = Number(str.substring(start, i + 1));
        }
        // look up json data
        if (str.charAt(++i)) {
            const payload = tryParse(str.substr(i));
            if (Decoder.isPayloadValid(p.type, payload)) {
                p.data = payload;
            }
            else {
                throw new Error("invalid payload");
            }
        }
        debug("decoded %s as %j", str, p);
        return p;
    }
    static isPayloadValid(type, payload) {
        switch (type) {
            case PacketType.CONNECT:
                return typeof payload === "object";
            case PacketType.DISCONNECT:
                return payload === undefined;
            case PacketType.CONNECT_ERROR:
                return typeof payload === "string" || typeof payload === "object";
            case PacketType.EVENT:
            case PacketType.BINARY_EVENT:
                return Array.isArray(payload) && typeof payload[0] === "string";
            case PacketType.ACK:
            case PacketType.BINARY_ACK:
                return Array.isArray(payload);
        }
    }
    /**
     * Deallocates a parser's resources
     */
    destroy() {
        if (this.reconstructor) {
            this.reconstructor.finishedReconstruction();
        }
    }
}
exports.Decoder = Decoder;
function tryParse(str) {
    try {
        return JSON.parse(str);
    }
    catch (e) {
        return false;
    }
}
/**
 * A manager of a binary event's 'buffer sequence'. Should
 * be constructed whenever a packet of type BINARY_EVENT is
 * decoded.
 *
 * @param {Object} packet
 * @return {BinaryReconstructor} initialized reconstructor
 */
class BinaryReconstructor {
    constructor(packet) {
        this.packet = packet;
        this.buffers = [];
        this.reconPack = packet;
    }
    /**
     * Method to be called when binary data received from connection
     * after a BINARY_EVENT packet.
     *
     * @param {Buffer | ArrayBuffer} binData - the raw binary data received
     * @return {null | Object} returns null if more binary data is expected or
     *   a reconstructed packet object if all buffers have been received.
     */
    takeBinaryData(binData) {
        this.buffers.push(binData);
        if (this.buffers.length === this.reconPack.attachments) {
            // done with buffer list
            const packet = binary_1.reconstructPacket(this.reconPack, this.buffers);
            this.finishedReconstruction();
            return packet;
        }
        return null;
    }
    /**
     * Cleans up binary packet reconstruction variables.
     */
    finishedReconstruction() {
        this.reconPack = null;
        this.buffers = [];
    }
}


/***/ }),

/***/ "./node_modules/socket.io-parser/dist/is-binary.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.hasBinary = exports.isBinary = void 0;
const withNativeArrayBuffer = typeof ArrayBuffer === "function";
const isView = (obj) => {
    return typeof ArrayBuffer.isView === "function"
        ? ArrayBuffer.isView(obj)
        : obj.buffer instanceof ArrayBuffer;
};
const toString = Object.prototype.toString;
const withNativeBlob = typeof Blob === "function" ||
    (typeof Blob !== "undefined" &&
        toString.call(Blob) === "[object BlobConstructor]");
const withNativeFile = typeof File === "function" ||
    (typeof File !== "undefined" &&
        toString.call(File) === "[object FileConstructor]");
/**
 * Returns true if obj is a Buffer, an ArrayBuffer, a Blob or a File.
 *
 * @private
 */
function isBinary(obj) {
    return ((withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj))) ||
        (withNativeBlob && obj instanceof Blob) ||
        (withNativeFile && obj instanceof File));
}
exports.isBinary = isBinary;
function hasBinary(obj, toJSON) {
    if (!obj || typeof obj !== "object") {
        return false;
    }
    if (Array.isArray(obj)) {
        for (let i = 0, l = obj.length; i < l; i++) {
            if (hasBinary(obj[i])) {
                return true;
            }
        }
        return false;
    }
    if (isBinary(obj)) {
        return true;
    }
    if (obj.toJSON &&
        typeof obj.toJSON === "function" &&
        arguments.length === 1) {
        return hasBinary(obj.toJSON(), true);
    }
    for (const key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
            return true;
        }
    }
    return false;
}
exports.hasBinary = hasBinary;


/***/ }),

/***/ "./node_modules/socket.io-parser/node_modules/debug/src/browser.js":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */
function log(...args) {
	// This hackery is required for IE8/9, where
	// the `console.log` function doesn't have 'apply'
	return typeof console === 'object' &&
		console.log &&
		console.log(...args);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug');
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = process.env.DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = __webpack_require__("./node_modules/socket.io-parser/node_modules/debug/src/common.js")(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/socket.io-parser/node_modules/debug/src/common.js":
/***/ (function(module, exports, __webpack_require__) {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = __webpack_require__("./node_modules/socket.io-parser/node_modules/ms/index.js");

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* Active `debug` instances.
	*/
	createDebug.instances = [];

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return match;
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.enabled = createDebug.enabled(namespace);
		debug.useColors = createDebug.useColors();
		debug.color = selectColor(namespace);
		debug.destroy = destroy;
		debug.extend = extend;
		// Debug.formatArgs = formatArgs;
		// debug.rawLog = rawLog;

		// env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		createDebug.instances.push(debug);

		return debug;
	}

	function destroy() {
		const index = createDebug.instances.indexOf(this);
		if (index !== -1) {
			createDebug.instances.splice(index, 1);
			return true;
		}
		return false;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);

		createDebug.names = [];
		createDebug.skips = [];

		let i;
		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
		const len = split.length;

		for (i = 0; i < len; i++) {
			if (!split[i]) {
				// ignore empty strings
				continue;
			}

			namespaces = split[i].replace(/\*/g, '.*?');

			if (namespaces[0] === '-') {
				createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
			} else {
				createDebug.names.push(new RegExp('^' + namespaces + '$'));
			}
		}

		for (i = 0; i < createDebug.instances.length; i++) {
			const instance = createDebug.instances[i];
			instance.enabled = createDebug.enabled(instance.namespace);
		}
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names.map(toNamespace),
			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		if (name[name.length - 1] === '*') {
			return true;
		}

		let i;
		let len;

		for (i = 0, len = createDebug.skips.length; i < len; i++) {
			if (createDebug.skips[i].test(name)) {
				return false;
			}
		}

		for (i = 0, len = createDebug.names.length; i < len; i++) {
			if (createDebug.names[i].test(name)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/
	function toNamespace(regexp) {
		return regexp.toString()
			.substring(2, regexp.toString().length - 2)
			.replace(/\.\*\?$/, '*');
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

module.exports = setup;


/***/ }),

/***/ "./node_modules/socket.io-parser/node_modules/ms/index.js":
/***/ (function(module, exports) {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}


/***/ }),

/***/ "./node_modules/string-hash/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function hash(str) {
  var hash = 5381,
      i    = str.length;

  while(i) {
    hash = (hash * 33) ^ str.charCodeAt(--i);
  }

  /* JavaScript does bitwise operations (like XOR, above) on 32-bit signed
   * integers. Since we want the results to be always positive, convert the
   * signed int to an unsigned by doing an unsigned bitshift. */
  return hash >>> 0;
}

module.exports = hash;


/***/ }),

/***/ "./node_modules/styled-jsx/dist/lib/stylesheet.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__("./node_modules/babel-runtime/helpers/classCallCheck.js");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__("./node_modules/babel-runtime/helpers/createClass.js");

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
Based on Glamor's sheet
https://github.com/threepointone/glamor/blob/667b480d31b3721a905021b26e1290ce92ca2879/src/sheet.js
*/

var isProd = process.env && "development" === 'production';
var isString = function isString(o) {
  return Object.prototype.toString.call(o) === '[object String]';
};

var StyleSheet = function () {
  function StyleSheet() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$name = _ref.name,
        name = _ref$name === undefined ? 'stylesheet' : _ref$name,
        _ref$optimizeForSpeed = _ref.optimizeForSpeed,
        optimizeForSpeed = _ref$optimizeForSpeed === undefined ? isProd : _ref$optimizeForSpeed,
        _ref$isBrowser = _ref.isBrowser,
        isBrowser = _ref$isBrowser === undefined ? typeof window !== 'undefined' : _ref$isBrowser;

    (0, _classCallCheck3.default)(this, StyleSheet);

    invariant(isString(name), '`name` must be a string');
    this._name = name;
    this._deletedRulePlaceholder = '#' + name + '-deleted-rule____{}';

    invariant(typeof optimizeForSpeed === 'boolean', '`optimizeForSpeed` must be a boolean');
    this._optimizeForSpeed = optimizeForSpeed;
    this._isBrowser = isBrowser;

    this._serverSheet = undefined;
    this._tags = [];
    this._injected = false;
    this._rulesCount = 0;
  }

  (0, _createClass3.default)(StyleSheet, [{
    key: 'setOptimizeForSpeed',
    value: function setOptimizeForSpeed(bool) {
      invariant(typeof bool === 'boolean', '`setOptimizeForSpeed` accepts a boolean');

      invariant(this._rulesCount === 0, 'optimizeForSpeed cannot be when rules have already been inserted');
      this.flush();
      this._optimizeForSpeed = bool;
      this.inject();
    }
  }, {
    key: 'isOptimizeForSpeed',
    value: function isOptimizeForSpeed() {
      return this._optimizeForSpeed;
    }
  }, {
    key: 'inject',
    value: function inject() {
      var _this = this;

      invariant(!this._injected, 'sheet already injected');
      this._injected = true;
      if (this._isBrowser && this._optimizeForSpeed) {
        this._tags[0] = this.makeStyleTag(this._name);
        this._optimizeForSpeed = 'insertRule' in this.getSheet();
        if (!this._optimizeForSpeed) {
          if (!isProd) {
            console.warn('StyleSheet: optimizeForSpeed mode not supported falling back to standard mode.'); // eslint-disable-line no-console
          }
          this.flush();
          this._injected = true;
        }
        return;
      }

      this._serverSheet = {
        cssRules: [],
        insertRule: function insertRule(rule, index) {
          if (typeof index === 'number') {
            _this._serverSheet.cssRules[index] = { cssText: rule };
          } else {
            _this._serverSheet.cssRules.push({ cssText: rule });
          }
          return index;
        },
        deleteRule: function deleteRule(index) {
          _this._serverSheet.cssRules[index] = null;
        }
      };
    }
  }, {
    key: 'getSheetForTag',
    value: function getSheetForTag(tag) {
      if (tag.sheet) {
        return tag.sheet;
      }

      // this weirdness brought to you by firefox
      for (var i = 0; i < document.styleSheets.length; i++) {
        if (document.styleSheets[i].ownerNode === tag) {
          return document.styleSheets[i];
        }
      }
    }
  }, {
    key: 'getSheet',
    value: function getSheet() {
      return this.getSheetForTag(this._tags[this._tags.length - 1]);
    }
  }, {
    key: 'insertRule',
    value: function insertRule(rule, index) {
      invariant(isString(rule), '`insertRule` accepts only strings');

      if (!this._isBrowser) {
        if (typeof index !== 'number') {
          index = this._serverSheet.cssRules.length;
        }
        this._serverSheet.insertRule(rule, index);
        return this._rulesCount++;
      }

      if (this._optimizeForSpeed) {
        var sheet = this.getSheet();
        if (typeof index !== 'number') {
          index = sheet.cssRules.length;
        }
        // this weirdness for perf, and chrome's weird bug
        // https://stackoverflow.com/questions/20007992/chrome-suddenly-stopped-accepting-insertrule
        try {
          sheet.insertRule(rule, index);
        } catch (err) {
          if (!isProd) {
            console.warn('StyleSheet: illegal rule: \n\n' + rule + '\n\nSee https://stackoverflow.com/q/20007992 for more info'); // eslint-disable-line no-console
          }
          return -1;
        }
      } else {
        var insertionPoint = this._tags[index];
        this._tags.push(this.makeStyleTag(this._name, rule, insertionPoint));
      }

      return this._rulesCount++;
    }
  }, {
    key: 'replaceRule',
    value: function replaceRule(index, rule) {
      if (this._optimizeForSpeed || !this._isBrowser) {
        var sheet = this._isBrowser ? this.getSheet() : this._serverSheet;
        if (!rule.trim()) {
          rule = this._deletedRulePlaceholder;
        }

        if (!sheet.cssRules[index]) {
          // @TBD Should we throw an error?
          return index;
        }

        sheet.deleteRule(index);

        try {
          sheet.insertRule(rule, index);
        } catch (err) {
          if (!isProd) {
            console.warn('StyleSheet: illegal rule: \n\n' + rule + '\n\nSee https://stackoverflow.com/q/20007992 for more info'); // eslint-disable-line no-console
          }
          // In order to preserve the indices we insert a deleteRulePlaceholder
          sheet.insertRule(this._deletedRulePlaceholder, index);
        }
      } else {
        var tag = this._tags[index];
        invariant(tag, 'old rule at index `' + index + '` not found');
        tag.textContent = rule;
      }
      return index;
    }
  }, {
    key: 'deleteRule',
    value: function deleteRule(index) {
      if (!this._isBrowser) {
        this._serverSheet.deleteRule(index);
        return;
      }

      if (this._optimizeForSpeed) {
        this.replaceRule(index, '');
      } else {
        var tag = this._tags[index];
        invariant(tag, 'rule at index `' + index + '` not found');
        tag.parentNode.removeChild(tag);
        this._tags[index] = null;
      }
    }
  }, {
    key: 'flush',
    value: function flush() {
      this._injected = false;
      this._rulesCount = 0;
      if (this._isBrowser) {
        this._tags.forEach(function (tag) {
          return tag && tag.parentNode.removeChild(tag);
        });
        this._tags = [];
      } else {
        // simpler on server
        this._serverSheet.cssRules = [];
      }
    }
  }, {
    key: 'cssRules',
    value: function cssRules() {
      var _this2 = this;

      if (!this._isBrowser) {
        return this._serverSheet.cssRules;
      }
      return this._tags.reduce(function (rules, tag) {
        if (tag) {
          rules = rules.concat(_this2.getSheetForTag(tag).cssRules.map(function (rule) {
            return rule.cssText === _this2._deletedRulePlaceholder ? null : rule;
          }));
        } else {
          rules.push(null);
        }
        return rules;
      }, []);
    }
  }, {
    key: 'makeStyleTag',
    value: function makeStyleTag(name, cssString, relativeToTag) {
      if (cssString) {
        invariant(isString(cssString), 'makeStyleTag acceps only strings as second parameter');
      }
      var tag = document.createElement('style');
      tag.type = 'text/css';
      tag.setAttribute('data-' + name, '');
      if (cssString) {
        tag.appendChild(document.createTextNode(cssString));
      }
      var head = document.head || document.getElementsByTagName('head')[0];
      if (relativeToTag) {
        head.insertBefore(tag, relativeToTag);
      } else {
        head.appendChild(tag);
      }
      return tag;
    }
  }, {
    key: 'length',
    get: function get() {
      return this._rulesCount;
    }
  }]);
  return StyleSheet;
}();

exports.default = StyleSheet;


function invariant(condition, message) {
  if (!condition) {
    throw new Error('StyleSheet: ' + message + '.');
  }
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/styled-jsx/dist/style.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _map = __webpack_require__("./node_modules/babel-runtime/core-js/map.js");

var _map2 = _interopRequireDefault(_map);

var _slicedToArray2 = __webpack_require__("./node_modules/babel-runtime/helpers/slicedToArray.js");

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _getPrototypeOf = __webpack_require__("./node_modules/babel-runtime/core-js/object/get-prototype-of.js");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = __webpack_require__("./node_modules/babel-runtime/helpers/classCallCheck.js");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__("./node_modules/babel-runtime/helpers/createClass.js");

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __webpack_require__("./node_modules/babel-runtime/helpers/possibleConstructorReturn.js");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__("./node_modules/babel-runtime/helpers/inherits.js");

var _inherits3 = _interopRequireDefault(_inherits2);

exports.flush = flush;

var _react = __webpack_require__("./node_modules/react/cjs/react.development.js");

var _stylesheetRegistry = __webpack_require__("./node_modules/styled-jsx/dist/stylesheet-registry.js");

var _stylesheetRegistry2 = _interopRequireDefault(_stylesheetRegistry);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var styleSheetRegistry = new _stylesheetRegistry2.default();

var JSXStyle = function (_Component) {
  (0, _inherits3.default)(JSXStyle, _Component);

  function JSXStyle() {
    (0, _classCallCheck3.default)(this, JSXStyle);
    return (0, _possibleConstructorReturn3.default)(this, (JSXStyle.__proto__ || (0, _getPrototypeOf2.default)(JSXStyle)).apply(this, arguments));
  }

  (0, _createClass3.default)(JSXStyle, [{
    key: 'componentWillMount',
    value: function componentWillMount() {
      styleSheetRegistry.add(this.props);
    }
  }, {
    key: 'shouldComponentUpdate',
    value: function shouldComponentUpdate(nextProps) {
      return this.props.css !== nextProps.css;
    }

    // To avoid FOUC, we process new changes
    // on `componentWillUpdate` rather than `componentDidUpdate`.

  }, {
    key: 'componentWillUpdate',
    value: function componentWillUpdate(nextProps) {
      styleSheetRegistry.update(this.props, nextProps);
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      styleSheetRegistry.remove(this.props);
    }
  }, {
    key: 'render',
    value: function render() {
      return null;
    }
  }], [{
    key: 'dynamic',
    value: function dynamic(info) {
      return info.map(function (tagInfo) {
        var _tagInfo = (0, _slicedToArray3.default)(tagInfo, 2),
            baseId = _tagInfo[0],
            props = _tagInfo[1];

        return styleSheetRegistry.computeId(baseId, props);
      }).join(' ');
    }
  }]);
  return JSXStyle;
}(_react.Component);

exports.default = JSXStyle;
function flush() {
  var cssRules = styleSheetRegistry.cssRules();
  styleSheetRegistry.flush();
  return new _map2.default(cssRules);
}

/***/ }),

/***/ "./node_modules/styled-jsx/dist/stylesheet-registry.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _keys = __webpack_require__("./node_modules/babel-runtime/core-js/object/keys.js");

var _keys2 = _interopRequireDefault(_keys);

var _classCallCheck2 = __webpack_require__("./node_modules/babel-runtime/helpers/classCallCheck.js");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__("./node_modules/babel-runtime/helpers/createClass.js");

var _createClass3 = _interopRequireDefault(_createClass2);

var _stringHash = __webpack_require__("./node_modules/string-hash/index.js");

var _stringHash2 = _interopRequireDefault(_stringHash);

var _stylesheet = __webpack_require__("./node_modules/styled-jsx/dist/lib/stylesheet.js");

var _stylesheet2 = _interopRequireDefault(_stylesheet);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var StyleSheetRegistry = function () {
  function StyleSheetRegistry() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$styleSheet = _ref.styleSheet,
        styleSheet = _ref$styleSheet === undefined ? null : _ref$styleSheet,
        _ref$optimizeForSpeed = _ref.optimizeForSpeed,
        optimizeForSpeed = _ref$optimizeForSpeed === undefined ? false : _ref$optimizeForSpeed,
        _ref$isBrowser = _ref.isBrowser,
        isBrowser = _ref$isBrowser === undefined ? typeof window !== 'undefined' : _ref$isBrowser;

    (0, _classCallCheck3.default)(this, StyleSheetRegistry);

    this._sheet = styleSheet || new _stylesheet2.default({
      name: 'styled-jsx',
      optimizeForSpeed: optimizeForSpeed
    });
    this._sheet.inject();
    this._isBrowser = isBrowser;

    this._fromServer = undefined;
    this._indices = {};
    this._instancesCounts = {};

    this.computeId = this.createComputeId();
    this.computeSelector = this.createComputeSelector();
  }

  (0, _createClass3.default)(StyleSheetRegistry, [{
    key: 'add',
    value: function add(props) {
      var _this = this;

      if (undefined === this._optimizeForSpeed) {
        this._optimizeForSpeed = Array.isArray(props.css);
        this._sheet.setOptimizeForSpeed(this._optimizeForSpeed);
        this._optimizeForSpeed = this._sheet.isOptimizeForSpeed();
      }

      if (this._isBrowser && !this._fromServer) {
        this._fromServer = this.selectFromServer();
        this._instancesCounts = (0, _keys2.default)(this._fromServer).reduce(function (acc, tagName) {
          acc[tagName] = 0;
          return acc;
        }, {});
      }

      var _getIdAndRules = this.getIdAndRules(props),
          styleId = _getIdAndRules.styleId,
          rules = _getIdAndRules.rules;

      // Deduping: just increase the instances count.


      if (styleId in this._instancesCounts) {
        this._instancesCounts[styleId] += 1;
        return;
      }

      var indices = rules.map(function (rule) {
        return _this._sheet.insertRule(rule);
      })
      // Filter out invalid rules
      .filter(function (index) {
        return index !== -1;
      });

      if (indices.length > 0) {
        this._indices[styleId] = indices;
        this._instancesCounts[styleId] = 1;
      }
    }
  }, {
    key: 'remove',
    value: function remove(props) {
      var _this2 = this;

      var _getIdAndRules2 = this.getIdAndRules(props),
          styleId = _getIdAndRules2.styleId;

      invariant(styleId in this._instancesCounts, 'styleId: `' + styleId + '` not found');
      this._instancesCounts[styleId] -= 1;

      if (this._instancesCounts[styleId] < 1) {
        var tagFromServer = this._fromServer && this._fromServer[styleId];
        if (tagFromServer) {
          tagFromServer.parentNode.removeChild(tagFromServer);
          delete this._fromServer[styleId];
        } else {
          this._indices[styleId].forEach(function (index) {
            return _this2._sheet.deleteRule(index);
          });
          delete this._indices[styleId];
        }
        delete this._instancesCounts[styleId];
      }
    }
  }, {
    key: 'update',
    value: function update(props, nextProps) {
      this.add(nextProps);
      this.remove(props);
    }
  }, {
    key: 'flush',
    value: function flush() {
      this._sheet.flush();
      this._sheet.inject();
      this._fromServer = undefined;
      this._indices = {};
      this._instancesCounts = {};

      this.computeId = this.createComputeId();
      this.computeSelector = this.createComputeSelector();
    }
  }, {
    key: 'cssRules',
    value: function cssRules() {
      var _this3 = this;

      var fromServer = this._fromServer ? (0, _keys2.default)(this._fromServer).map(function (styleId) {
        return [styleId, _this3._fromServer[styleId]];
      }) : [];
      var cssRules = this._sheet.cssRules();

      return fromServer.concat((0, _keys2.default)(this._indices).map(function (styleId) {
        return [styleId, _this3._indices[styleId].map(function (index) {
          return cssRules[index].cssText;
        }).join('\n')];
      }));
    }

    /**
     * createComputeId
     *
     * Creates a function to compute and memoize a jsx id from a basedId and optionally props.
     */

  }, {
    key: 'createComputeId',
    value: function createComputeId() {
      var cache = {};
      return function (baseId, props) {
        if (!props) {
          return 'jsx-' + baseId;
        }
        var propsToString = String(props);
        var key = baseId + propsToString;
        // return `jsx-${hashString(`${baseId}-${propsToString}`)}`
        if (!cache[key]) {
          cache[key] = 'jsx-' + (0, _stringHash2.default)(baseId + '-' + propsToString);
        }
        return cache[key];
      };
    }

    /**
     * createComputeSelector
     *
     * Creates a function to compute and memoize dynamic selectors.
     */

  }, {
    key: 'createComputeSelector',
    value: function createComputeSelector() {
      var selectoPlaceholderRegexp = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : /__jsx-style-dynamic-selector/g;

      var cache = {};
      return function (id, css) {
        var idcss = id + css;
        if (!cache[idcss]) {
          cache[idcss] = css.replace(selectoPlaceholderRegexp, id);
        }
        return cache[idcss];
      };
    }
  }, {
    key: 'getIdAndRules',
    value: function getIdAndRules(props) {
      var _this4 = this;

      if (props.dynamic) {
        var styleId = this.computeId(props.styleId, props.dynamic);
        return {
          styleId: styleId,
          rules: Array.isArray(props.css) ? props.css.map(function (rule) {
            return _this4.computeSelector(styleId, rule);
          }) : [this.computeSelector(styleId, props.css)]
        };
      }

      return {
        styleId: this.computeId(props.styleId),
        rules: Array.isArray(props.css) ? props.css : [props.css]
      };
    }

    /**
     * selectFromServer
     *
     * Collects style tags from the document with id __jsx-XXX
     */

  }, {
    key: 'selectFromServer',
    value: function selectFromServer() {
      var elements = Array.prototype.slice.call(document.querySelectorAll('[id^="__jsx-"]'));

      return elements.reduce(function (acc, element) {
        var id = element.id.slice(2);
        acc[id] = element;
        return acc;
      }, {});
    }
  }]);
  return StyleSheetRegistry;
}();

exports.default = StyleSheetRegistry;


function invariant(condition, message) {
  if (!condition) {
    throw new Error('StyleSheetRegistry: ' + message + '.');
  }
}

/***/ }),

/***/ "./node_modules/styled-jsx/style.js":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__("./node_modules/styled-jsx/dist/style.js")


/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./node_modules/webpack/buildin/harmony-module.js":
/***/ (function(module, exports) {

module.exports = function(originalModule) {
	if(!originalModule.webpackPolyfill) {
		var module = Object.create(originalModule);
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		Object.defineProperty(module, "exports", {
			enumerable: true,
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./node_modules/yeast/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split('')
  , length = 64
  , map = {}
  , seed = 0
  , i = 0
  , prev;

/**
 * Return a string representing the specified number.
 *
 * @param {Number} num The number to convert.
 * @returns {String} The string representation of the number.
 * @api public
 */
function encode(num) {
  var encoded = '';

  do {
    encoded = alphabet[num % length] + encoded;
    num = Math.floor(num / length);
  } while (num > 0);

  return encoded;
}

/**
 * Return the integer value specified by the given string.
 *
 * @param {String} str The string to convert.
 * @returns {Number} The integer value represented by the string.
 * @api public
 */
function decode(str) {
  var decoded = 0;

  for (i = 0; i < str.length; i++) {
    decoded = decoded * length + map[str.charAt(i)];
  }

  return decoded;
}

/**
 * Yeast: A tiny growing id generator.
 *
 * @returns {String} A unique id.
 * @api public
 */
function yeast() {
  var now = encode(+new Date());

  if (now !== prev) return seed = 0, prev = now;
  return now +'.'+ encode(seed++);
}

//
// Map each character to its index.
//
for (; i < length; i++) map[alphabet[i]] = i;

//
// Expose the `yeast`, `encode` and `decode` functions.
//
yeast.encode = encode;
yeast.decode = decode;
module.exports = yeast;


/***/ }),

/***/ "./pages/index.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_styled_jsx_style__ = __webpack_require__("./node_modules/styled-jsx/style.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_styled_jsx_style___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_styled_jsx_style__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react__ = __webpack_require__("./node_modules/react/cjs/react.development.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_immutable__ = __webpack_require__("./node_modules/immutable/dist/immutable.es.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_prop_types__ = __webpack_require__("./node_modules/prop-types/index.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_prop_types__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_next_head__ = __webpack_require__("./node_modules/next/head.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_next_head___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_next_head__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_color__ = __webpack_require__("./node_modules/color/index.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_color___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_color__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_react_input_range__ = __webpack_require__("./node_modules/react-input-range/lib/js/index.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_react_input_range___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_react_input_range__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__input_range_style__ = __webpack_require__("./input-range-style.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__svg_loupe_svg__ = __webpack_require__("./svg/loupe.svg");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__svg_remove_svg__ = __webpack_require__("./svg/remove.svg");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__svg_reload_svg__ = __webpack_require__("./svg/reload.svg");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__svg_return_svg__ = __webpack_require__("./svg/return.svg");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__sudoku__ = __webpack_require__("./sudoku.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__colors__ = __webpack_require__("./colors.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__components_tool_tip__ = __webpack_require__("./components/tool-tip.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15_socket_io_client__ = __webpack_require__("./node_modules/socket.io-client/build/index.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15_socket_io_client___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_15_socket_io_client__);
var _jsxFileName = '/Users/lichenma/Projects/SuDuoku/SuDuoku/pages/index.js';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();



(function () {
  var enterModule = __webpack_require__("./node_modules/react-hot-loader/patch.js").enterModule;

  enterModule && enterModule(module);
})();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/* eslint-disable jsx-a11y/accessible-emoji */







// eslint-disable-next-line import/no-extraneous-dependencies














var Description = 'Discover the next evolution of Sudoku with amazing graphics, animations, and user-friendly features. Enjoy a Sudoku experience like you never have before with customizable game generation, cell highlighting, intuitive controls and more!';
var cellWidth = 2.5;

var LightBlue100 = '#B3E5FC';
var LightBlue200 = '#81D4FA';
var LightBlue300 = '#4FC3F7';
var Indigo700 = '#303F9F';
var DeepOrange200 = '#FFAB91';
var DeepOrange600 = '#F4511E';
var ControlNumberColor = Indigo700;

// eslint-disable-next-line no-lone-blocks
{/* language=CSS */}
var CellStyle = new String('.cell{height:' + cellWidth + 'em;width:' + cellWidth + 'em;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;font-size:1.1em;font-weight:bold;-webkit-transition:background-color .3s ease-in-out;transition:background-color .3s ease-in-out;}.cell:nth-child(3n+3):not(:last-child){border-right:2px solid black;}.cell:not(:last-child){border-right:1px solid black;}.note-number{font-size:.6em;width:33%;height:33%;box-sizing:border-box;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhZ2VzL2luZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQW9DcUIsQUFHMkMsQUFXVCxBQUdBLEFBR2QsZUFDTCxVQUNDLElBUGYsQUFHQSxPQUswQixFQW5CZSxvQkFvQnhCLGlCQW5CQSx5REFvQk0saUJBbkJKLHlEQUNJLG1CQW1CSSwwRUFsQkEseUJBbUIzQiwwRUFsQm9CLGdCQUNDLGlCQUMyQixnR0FDaEQiLCJmaWxlIjoicGFnZXMvaW5kZXguanMiLCJzb3VyY2VSb290IjoiL1VzZXJzL2xpY2hlbm1hL1Byb2plY3RzL1N1RHVva3UvU3VEdW9rdSIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIGpzeC1hMTF5L2FjY2Vzc2libGUtZW1vamkgKi9cbmltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFNldCwgTGlzdCwgZnJvbUpTIH0gZnJvbSAnaW1tdXRhYmxlJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgTmV4dEhlYWQgZnJvbSAnbmV4dC9oZWFkJztcbmltcG9ydCBDb2xvciBmcm9tICdjb2xvcic7XG5pbXBvcnQgSW5wdXRSYW5nZSBmcm9tICdyZWFjdC1pbnB1dC1yYW5nZSc7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tZXh0cmFuZW91cy1kZXBlbmRlbmNpZXNcbmltcG9ydCBjc3MgZnJvbSAnc3R5bGVkLWpzeC9jc3MnO1xuXG5pbXBvcnQgUmFuZ2VTdHlsZSBmcm9tICcuLi9pbnB1dC1yYW5nZS1zdHlsZSc7XG5pbXBvcnQgTG91cGVJY29uIGZyb20gJy4uL3N2Zy9sb3VwZS5zdmcnO1xuaW1wb3J0IFJlbW92ZUljb24gZnJvbSAnLi4vc3ZnL3JlbW92ZS5zdmcnO1xuaW1wb3J0IFJlbG9hZEljb24gZnJvbSAnLi4vc3ZnL3JlbG9hZC5zdmcnO1xuaW1wb3J0IFJldHVybkljb24gZnJvbSAnLi4vc3ZnL3JldHVybi5zdmcnO1xuXG5pbXBvcnQgeyBtYWtlUHV6emxlLCBwbHVjaywgaXNQZWVyIGFzIGFyZUNvb3JkaW5hdGVQZWVycywgcmFuZ2UgfSBmcm9tICcuLi9zdWRva3UnO1xuaW1wb3J0IHsgYmFja0dyb3VuZEJsdWUgfSBmcm9tICcuLi9jb2xvcnMnO1xuaW1wb3J0IFRpcCBmcm9tICcuLi9jb21wb25lbnRzL3Rvb2wtdGlwJztcblxuaW1wb3J0IGlvIGZyb20gJ3NvY2tldC5pby1jbGllbnQnXG5cbmNvbnN0IERlc2NyaXB0aW9uID0gJ0Rpc2NvdmVyIHRoZSBuZXh0IGV2b2x1dGlvbiBvZiBTdWRva3Ugd2l0aCBhbWF6aW5nIGdyYXBoaWNzLCBhbmltYXRpb25zLCBhbmQgdXNlci1mcmllbmRseSBmZWF0dXJlcy4gRW5qb3kgYSBTdWRva3UgZXhwZXJpZW5jZSBsaWtlIHlvdSBuZXZlciBoYXZlIGJlZm9yZSB3aXRoIGN1c3RvbWl6YWJsZSBnYW1lIGdlbmVyYXRpb24sIGNlbGwgaGlnaGxpZ2h0aW5nLCBpbnR1aXRpdmUgY29udHJvbHMgYW5kIG1vcmUhJztcbmNvbnN0IGNlbGxXaWR0aCA9IDIuNTtcblxuY29uc3QgTGlnaHRCbHVlMTAwID0gJyNCM0U1RkMnO1xuY29uc3QgTGlnaHRCbHVlMjAwID0gJyM4MUQ0RkEnO1xuY29uc3QgTGlnaHRCbHVlMzAwID0gJyM0RkMzRjcnO1xuY29uc3QgSW5kaWdvNzAwID0gJyMzMDNGOUYnO1xuY29uc3QgRGVlcE9yYW5nZTIwMCA9ICcjRkZBQjkxJztcbmNvbnN0IERlZXBPcmFuZ2U2MDAgPSAnI0Y0NTExRSc7XG5jb25zdCBDb250cm9sTnVtYmVyQ29sb3IgPSBJbmRpZ283MDA7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sb25lLWJsb2Nrc1xueyAvKiBsYW5ndWFnZT1DU1MgKi8gfVxuY29uc3QgQ2VsbFN0eWxlID0gY3NzYFxuLmNlbGwge1xuICAgIGhlaWdodDogJHtjZWxsV2lkdGh9ZW07XG4gICAgd2lkdGg6ICR7Y2VsbFdpZHRofWVtO1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC13cmFwOiB3cmFwO1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgZm9udC1zaXplOiAxLjFlbTtcbiAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICB0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kLWNvbG9yIC4zcyBlYXNlLWluLW91dDtcbn1cbi5jZWxsOm50aC1jaGlsZCgzbiszKTpub3QoOmxhc3QtY2hpbGQpIHtcbiAgICBib3JkZXItcmlnaHQ6IDJweCBzb2xpZCBibGFjaztcbn1cbi5jZWxsOm5vdCg6bGFzdC1jaGlsZCkge1xuICAgIGJvcmRlci1yaWdodDogMXB4IHNvbGlkIGJsYWNrO1xufVxuLm5vdGUtbnVtYmVyIHtcbiAgICBmb250LXNpemU6IC42ZW07XG4gICAgd2lkdGg6IDMzJTtcbiAgICBoZWlnaHQ6IDMzJTtcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbn1cbmA7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sb25lLWJsb2Nrc1xueyAvKiBsYW5ndWFnZT1DU1MgKi8gfVxuY29uc3QgQWN0aW9uc1N0eWxlID0gY3NzYFxuLmFjdGlvbnMge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgbWF4LXdpZHRoOiA0MDBweDtcbiAgICBtYXJnaW4tdG9wOiAuNWVtO1xuICAgIHBhZGRpbmc6IDAgLjZlbTtcbn1cbi5hY3Rpb24ge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xufVxuLmFjdGlvbiA6Z2xvYmFsKHN2Zykge1xuICAgIHdpZHRoOiAyLjVlbTtcbiAgICBtYXJnaW4tYm90dG9tOiAuMmVtO1xufVxuLnJlZG8gOmdsb2JhbChzdmcpIHtcbiAgICB0cmFuc2Zvcm06IHNjYWxlWCgtMSk7XG59XG5gO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbG9uZS1ibG9ja3NcbnsgLyogbGFuZ3VhZ2U9Q1NTICovIH1cbmNvbnN0IENvbnRyb2xTdHlsZSA9IGNzc2Bcbi5jb250cm9sIHtcbiAgICBwYWRkaW5nOiAwIDJlbTtcbiAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgZGlzcGxheTogaW5saW5lLWZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBmbGV4LXdyYXA6IHdyYXA7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgZm9udC1mYW1pbHk6ICdTcGVjaWFsIEVsaXRlJywgY3Vyc2l2ZTtcbiAgICB0cmFuc2l0aW9uOiBmaWx0ZXIgLjVzIGVhc2UtaW4tb3V0O1xuICAgIHdpZHRoOiAxMDAlO1xufVxuYDtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxvbmUtYmxvY2tzXG57IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG5jb25zdCBOdW1iZXJDb250cm9sU3R5bGUgPSBjc3NgXG4ubnVtYmVyIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGZvbnQtc2l6ZTogMmVtO1xuICAgIG1hcmdpbjogLjFlbTtcbiAgICB3aWR0aDogMS41ZW07XG4gICAgaGVpZ2h0OiAxLjVlbTtcbiAgICBjb2xvcjogJHtDb250cm9sTnVtYmVyQ29sb3J9O1xuICAgIGJveC1zaGFkb3c6IDAgMXB4IDJweCByZ2JhKDAsMCwwLDAuMTYpLCAwIDFweCAycHggcmdiYSgwLDAsMCwwLjIzKTtcbiAgICBib3JkZXItcmFkaXVzOiA1MCU7XG59XG4ubnVtYmVyID4gZGl2IHtcbiAgICBtYXJnaW4tdG9wOiAuM2VtO1xufVxuYDtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxvbmUtYmxvY2tzXG57IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG5jb25zdCBQdXp6bGVTdHlsZSA9IGNzc2Bcbi5wdXp6bGUge1xuICAgIG1hcmdpbi10b3A6IC41ZW07XG4gICAgd2lkdGg6ICR7Y2VsbFdpZHRoICogOX1lbTtcbiAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgYm94LXNoYWRvdzogMCAzcHggNnB4IHJnYmEoMCwwLDAsMC4xNiksIDAgM3B4IDZweCByZ2JhKDAsMCwwLDAuMjMpO1xufVxuLnJvdyB7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGZsZXg6IDA7XG4gICAgd2lkdGg6ICR7Y2VsbFdpZHRoICogOX1lbTtcbn1cbi5yb3c6bm90KDpsYXN0LWNoaWxkKSB7XG4gICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkIGJsYWNrO1xufVxuLnJvdzpudGgtY2hpbGQoM24rMyk6bm90KDpsYXN0LWNoaWxkKSB7XG4gICAgYm9yZGVyLWJvdHRvbTogMnB4IHNvbGlkIGJsYWNrICFpbXBvcnRhbnQ7XG59XG5gO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbG9uZS1ibG9ja3NcbnsgLyogbGFuZ3VhZ2U9Q1NTICovIH1cbmNvbnN0IENpcmN1bHVhclByb2dyZXNzU3R5bGUgPSBjc3NgXG4uY2lyY3VsYXItcHJvZ3Jlc3Mge1xuICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB0b3A6IDA7XG4gICAgbGVmdDogMDtcbiAgICB0cmFuc2l0aW9uOiBmaWx0ZXIgLjRzIGVhc2UtaW4tb3V0O1xufVxuXG4uY2lyY2xlLWJnIHtcbiAgICBmaWxsOiBub25lO1xuICAgIHN0cm9rZTogI2VlZTtcbiAgICBzdHJva2Utd2lkdGg6IDMuODtcbn1cblxuLmNpcmNsZSB7XG4gICAgc3Ryb2tlOiAke0NvbnRyb2xOdW1iZXJDb2xvcn07XG4gICAgdHJhbnNpdGlvbjogc3Ryb2tlLWRhc2hhcnJheSAuNHMgZWFzZS1pbi1vdXQ7XG4gICAgZmlsbDogbm9uZTtcbiAgICBzdHJva2Utd2lkdGg6IDIuODtcbiAgICBzdHJva2UtbGluZWNhcDogcm91bmQ7XG59XG5gO1xuXG5jb25zdCBDaXJjdWxhclBhdGhEID0gJ00xOCAyLjA4NDUgYSAxNS45MTU1IDE1LjkxNTUgMCAwIDEgMCAzMS44MzEgYSAxNS45MTU1IDE1LjkxNTUgMCAwIDEgMCAtMzEuODMxJztcblxuZnVuY3Rpb24gZ2V0QmFja0dyb3VuZENvbG9yKHtcbiAgY29uZmxpY3QsIGlzUGVlciwgc2FtZVZhbHVlLCBpc1NlbGVjdGVkLFxufSkge1xuICBpZiAoY29uZmxpY3QgJiYgaXNQZWVyICYmIHNhbWVWYWx1ZSkge1xuICAgIHJldHVybiBEZWVwT3JhbmdlMjAwO1xuICB9IGVsc2UgaWYgKHNhbWVWYWx1ZSkge1xuICAgIHJldHVybiBMaWdodEJsdWUzMDA7XG4gIH0gZWxzZSBpZiAoaXNTZWxlY3RlZCkge1xuICAgIHJldHVybiBMaWdodEJsdWUyMDA7XG4gIH0gZWxzZSBpZiAoaXNQZWVyKSB7XG4gICAgcmV0dXJuIExpZ2h0Qmx1ZTEwMDtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldEZvbnRDb2xvcih7IHZhbHVlLCBjb25mbGljdCwgcHJlZmlsbGVkIH0pIHtcbiAgaWYgKGNvbmZsaWN0ICYmICFwcmVmaWxsZWQpIHtcbiAgICByZXR1cm4gRGVlcE9yYW5nZTYwMDtcbiAgfSBlbHNlIGlmICghcHJlZmlsbGVkICYmIHZhbHVlKSB7XG4gICAgcmV0dXJuIENvbnRyb2xOdW1iZXJDb2xvcjtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmNsYXNzIEdlbmVyYXRpb25VSSBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuXG4gICAgdGhpcy5zdGF0ZSA9IHsgdmFsdWU6IDMwIH07XG4gIH1cblxuICBnZW5lcmF0ZUdhbWUgPSAoKSA9PiB7XG4gICAgdGhpcy5wcm9wcy5nZW5lcmF0ZUdhbWUodGhpcy5zdGF0ZS52YWx1ZSk7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ2VuZXJhdGlvblwiPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvcHlcIj5TdGFydCB3aXRoIHt0aGlzLnN0YXRlLnZhbHVlfSBjZWxscyBwcmVmaWxsZWQ8L2Rpdj5cbiAgICAgICAgPElucHV0UmFuZ2VcbiAgICAgICAgICBtYXhWYWx1ZT17ODF9XG4gICAgICAgICAgbWluVmFsdWU9ezE3fVxuICAgICAgICAgIHZhbHVlPXt0aGlzLnN0YXRlLnZhbHVlfVxuICAgICAgICAgIG9uQ2hhbmdlPXt2YWx1ZSA9PiB0aGlzLnNldFN0YXRlKHsgdmFsdWUgfSl9XG4gICAgICAgIC8+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYnV0dG9uXCIgb25DbGljaz17dGhpcy5nZW5lcmF0ZUdhbWV9PlBsYXkgU3Vkb2t1PC9kaXY+XG4gICAgICAgIHsgLyogbGFuZ3VhZ2U9Q1NTICovIH1cbiAgICAgICAgPHN0eWxlIGpzeD57YFxuICAgICAgICAgICAgLmNvcHkge1xuICAgICAgICAgICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICAgICAgICAgICAgICBmb250LXNpemU6IDEuM2VtO1xuICAgICAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IC41ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAuZ2VuZXJhdGlvbiB7XG4gICAgICAgICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgICAgICAgICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6Z2xvYmFsKC5pbnB1dC1yYW5nZSkge1xuICAgICAgICAgICAgICAgIHdpZHRoOiA4MCU7XG4gICAgICAgICAgICAgICAgbWF4LXdpZHRoOiA1MDBweDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC5idXR0b24ge1xuICAgICAgICAgICAgICBtYXJnaW4tdG9wOiAuNWVtO1xuICAgICAgICAgICAgICBib3JkZXItcmFkaXVzOiAuMjVlbTtcbiAgICAgICAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgICAgICAgICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICAgICAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xuICAgICAgICAgICAgICBjb2xvcjogI2ZmZjtcbiAgICAgICAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gICAgICAgICAgICAgIHRyYW5zaXRpb246IGFsbCAuMjVzO1xuICAgICAgICAgICAgICBwYWRkaW5nOiA1cHggMTBweDtcbiAgICAgICAgICAgICAgZm9udC1zaXplOiAxLjRlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC5idXR0b246YWN0aXZlIHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoMHB4LCA1cHgpO1xuICAgICAgICAgICAgICBib3gtc2hhZG93OiAwIDFweCAwIDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC5idXR0b24ge1xuICAgICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAke2JhY2tHcm91bmRCbHVlfTtcbiAgICAgICAgICAgICAgYm94LXNoYWRvdzogMCAycHggNHB4IDAgJHtDb2xvcihiYWNrR3JvdW5kQmx1ZSkuZGFya2VuKDAuNSkuaHNsKCkuc3RyaW5nKCl9O1xuICAgICAgICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAuYnV0dG9uOmhvdmVyIHtcbiAgICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogJHtDb2xvcihiYWNrR3JvdW5kQmx1ZSkubGlnaHRlbigwLjIpLmhzbCgpLnN0cmluZygpfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgYH1cbiAgICAgICAgPC9zdHlsZT5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cbn1cblxuR2VuZXJhdGlvblVJLnByb3BUeXBlcyA9IHtcbiAgZ2VuZXJhdGVHYW1lOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxufTtcblxuY29uc3QgTnVtYmVyQ29udHJvbCA9ICh7IG51bWJlciwgb25DbGljaywgY29tcGxldGlvblBlcmNlbnRhZ2UgfSkgPT4gKFxuICA8ZGl2XG4gICAga2V5PXtudW1iZXJ9XG4gICAgY2xhc3NOYW1lPVwibnVtYmVyXCJcbiAgICBvbkNsaWNrPXtvbkNsaWNrfVxuICA+XG4gICAgPGRpdj57bnVtYmVyfTwvZGl2PlxuICAgIDxDaXJjbHVsYXJQcm9ncmVzcyBwZXJjZW50PXtjb21wbGV0aW9uUGVyY2VudGFnZX0gLz5cbiAgICA8c3R5bGUganN4PntOdW1iZXJDb250cm9sU3R5bGV9PC9zdHlsZT5cbiAgPC9kaXY+XG4pO1xuXG5OdW1iZXJDb250cm9sLnByb3BUeXBlcyA9IHtcbiAgbnVtYmVyOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIG9uQ2xpY2s6IFByb3BUeXBlcy5mdW5jLFxuICBjb21wbGV0aW9uUGVyY2VudGFnZTogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxufTtcblxuTnVtYmVyQ29udHJvbC5kZWZhdWx0UHJvcHMgPSB7XG4gIG9uQ2xpY2s6IG51bGwsXG59O1xuXG5jb25zdCBDZWxsID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHtcbiAgICB2YWx1ZSwgb25DbGljaywgaXNQZWVyLCBpc1NlbGVjdGVkLCBzYW1lVmFsdWUsIHByZWZpbGxlZCwgbm90ZXMsIGNvbmZsaWN0LFxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IGJhY2tncm91bmRDb2xvciA9IGdldEJhY2tHcm91bmRDb2xvcih7XG4gICAgY29uZmxpY3QsIGlzUGVlciwgc2FtZVZhbHVlLCBpc1NlbGVjdGVkLFxuICB9KTtcbiAgY29uc3QgZm9udENvbG9yID0gZ2V0Rm9udENvbG9yKHsgY29uZmxpY3QsIHByZWZpbGxlZCwgdmFsdWUgfSk7XG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJjZWxsXCIgb25DbGljaz17b25DbGlja30+XG4gICAgICB7XG4gICAgICAgIG5vdGVzID9cbiAgICAgICAgICByYW5nZSg5KS5tYXAoaSA9PlxuICAgICAgICAgICAgKFxuICAgICAgICAgICAgICA8ZGl2IGtleT17aX0gY2xhc3NOYW1lPVwibm90ZS1udW1iZXJcIj5cbiAgICAgICAgICAgICAgICB7bm90ZXMuaGFzKGkgKyAxKSAmJiAoaSArIDEpfVxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICkpIDpcbiAgICAgICAgICB2YWx1ZSAmJiB2YWx1ZVxuICAgICAgfVxuICAgICAgey8qIGxhbmd1YWdlPUNTUyAqL31cbiAgICAgIDxzdHlsZSBqc3g+e0NlbGxTdHlsZX08L3N0eWxlPlxuICAgICAgPHN0eWxlIGpzeD57YFxuICAgICAgICAgICAgICAgIC5jZWxsIHtcbiAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogJHtiYWNrZ3JvdW5kQ29sb3IgfHwgJ2luaXRpYWwnfTtcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6ICR7Zm9udENvbG9yIHx8ICdpbml0aWFsJ307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgYH1cbiAgICAgIDwvc3R5bGU+XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5DZWxsLnByb3BUeXBlcyA9IHtcbiAgLy8gY3VycmVudCBudW1iZXIgdmFsdWVcbiAgdmFsdWU6IFByb3BUeXBlcy5udW1iZXIsXG4gIC8vIGNlbGwgY2xpY2sgaGFuZGxlclxuICBvbkNsaWNrOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAvLyBpZiB0aGUgY2VsbCBpcyBhIHBlZXIgb2YgdGhlIHNlbGVjdGVkIGNlbGxcbiAgaXNQZWVyOiBQcm9wVHlwZXMuYm9vbC5pc1JlcXVpcmVkLFxuICAvLyBpZiB0aGUgY2VsbCBpcyBzZWxlY3RlZCBieSB0aGUgdXNlclxuICBpc1NlbGVjdGVkOiBQcm9wVHlwZXMuYm9vbC5pc1JlcXVpcmVkLFxuICAvLyBjdXJyZW50IGNlbGwgaGFzIHRoZSBzYW1lIHZhbHVlIGlmIHRoZSB1c2VyIHNlbGVjdGVkIGNlbGxcbiAgc2FtZVZhbHVlOiBQcm9wVHlwZXMuYm9vbC5pc1JlcXVpcmVkLFxuICAvLyBpZiB0aGlzIHdhcyBwcmVmaWxsZWQgYXMgYSBwYXJ0IG9mIHRoZSBwdXp6bGVcbiAgcHJlZmlsbGVkOiBQcm9wVHlwZXMuYm9vbC5pc1JlcXVpcmVkLFxuICAvLyBjdXJyZW50IG5vdGVzIHRha2VuIG9uIHRoZSBjZWxsXG4gIG5vdGVzOiBQcm9wVHlwZXMuaW5zdGFuY2VPZihTZXQpLFxuICAvLyBpZiB0aGUgY3VycmVudCBjZWxsIGRvZXMgbm90IHNhdGlzZnkgdGhlIGdhbWUgY29uc3RyYWludFxuICBjb25mbGljdDogUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZCxcbn07XG5cbkNlbGwuZGVmYXVsdFByb3BzID0ge1xuICBub3RlczogbnVsbCxcbiAgdmFsdWU6IG51bGwsXG59O1xuXG5jb25zdCBDaXJjbHVsYXJQcm9ncmVzcyA9ICh7IHBlcmNlbnQgfSkgPT4gKFxuICA8c3ZnIHZpZXdCb3g9XCIwIDAgMzYgMzZcIiBjbGFzc05hbWU9XCJjaXJjdWxhci1wcm9ncmVzc1wiPlxuICAgIDxwYXRoXG4gICAgICBjbGFzc05hbWU9XCJjaXJjbGUtYmdcIlxuICAgICAgZD17Q2lyY3VsYXJQYXRoRH1cbiAgICAvPlxuICAgIDxwYXRoXG4gICAgICBjbGFzc05hbWU9XCJjaXJjbGVcIlxuICAgICAgc3Ryb2tlRGFzaGFycmF5PXtgJHtwZXJjZW50ICogMTAwfSwgMTAwYH1cbiAgICAgIGQ9e0NpcmN1bGFyUGF0aER9XG4gICAgLz5cbiAgICB7IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG4gICAgPHN0eWxlIGpzeD57Q2lyY3VsdWFyUHJvZ3Jlc3NTdHlsZX08L3N0eWxlPlxuICA8L3N2Zz5cbik7XG5cbkNpcmNsdWxhclByb2dyZXNzLnByb3BUeXBlcyA9IHtcbiAgcGVyY2VudDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxufTtcblxuZnVuY3Rpb24gZ2V0Q2xpY2tIYW5kbGVyKG9uQ2xpY2ssIG9uRG91YmxlQ2xpY2ssIGRlbGF5ID0gMjUwKSB7XG4gIGxldCB0aW1lb3V0SUQgPSBudWxsO1xuICByZXR1cm4gKGV2ZW50KSA9PiB7XG4gICAgaWYgKCF0aW1lb3V0SUQpIHtcbiAgICAgIHRpbWVvdXRJRCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBvbkNsaWNrKGV2ZW50KTtcbiAgICAgICAgdGltZW91dElEID0gbnVsbDtcbiAgICAgIH0sIGRlbGF5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGltZW91dElEID0gY2xlYXJUaW1lb3V0KHRpbWVvdXRJRCk7XG4gICAgICBvbkRvdWJsZUNsaWNrKGV2ZW50KTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogbWFrZSBzaXplIDkgYXJyYXkgb2YgMHNcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZnVuY3Rpb24gbWFrZUNvdW50T2JqZWN0KCkge1xuICBjb25zdCBjb3VudE9iaiA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpICs9IDEpIGNvdW50T2JqLnB1c2goMCk7XG4gIHJldHVybiBjb3VudE9iajtcbn1cblxuLyoqXG4gKiBnaXZlbiBhIDJEIGFycmF5IG9mIG51bWJlcnMgYXMgdGhlIGluaXRpYWwgcHV6emxlLCBnZW5lcmF0ZSB0aGUgaW5pdGlhbCBnYW1lIHN0YXRlXG4gKiBAcGFyYW0gcHV6emxlXG4gKiBAcmV0dXJucyB7YW55fVxuICovXG5mdW5jdGlvbiBtYWtlQm9hcmQoeyBwdXp6bGUgfSkge1xuICAvLyBjcmVhdGUgaW5pdGlhbCBjb3VudCBvYmplY3QgdG8ga2VlcCB0cmFjayBvZiBjb25mbGljdHMgcGVyIG51bWJlciB2YWx1ZVxuICBjb25zdCByb3dzID0gQXJyYXkuZnJvbShBcnJheSg5KS5rZXlzKCkpLm1hcCgoKSA9PiBtYWtlQ291bnRPYmplY3QoKSk7XG4gIGNvbnN0IGNvbHVtbnMgPSBBcnJheS5mcm9tKEFycmF5KDkpLmtleXMoKSkubWFwKCgpID0+IG1ha2VDb3VudE9iamVjdCgpKTtcbiAgY29uc3Qgc3F1YXJlcyA9IEFycmF5LmZyb20oQXJyYXkoOSkua2V5cygpKS5tYXAoKCkgPT4gbWFrZUNvdW50T2JqZWN0KCkpO1xuICBjb25zdCByZXN1bHQgPSBwdXp6bGUubWFwKChyb3csIGkpID0+IChcbiAgICByb3cubWFwKChjZWxsLCBqKSA9PiB7XG4gICAgICBpZiAoY2VsbCkge1xuICAgICAgICByb3dzW2ldW2NlbGxdICs9IDE7XG4gICAgICAgIGNvbHVtbnNbal1bY2VsbF0gKz0gMTtcbiAgICAgICAgc3F1YXJlc1soKE1hdGguZmxvb3IoaSAvIDMpKSAqIDMpICsgTWF0aC5mbG9vcihqIC8gMyldW2NlbGxdICs9IDE7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogcHV6emxlW2ldW2pdID4gMCA/IHB1enpsZVtpXVtqXSA6IG51bGwsXG4gICAgICAgIHByZWZpbGxlZDogISFwdXp6bGVbaV1bal0sXG4gICAgICB9O1xuICAgIH0pXG4gICkpO1xuICByZXR1cm4gZnJvbUpTKHsgcHV6emxlOiByZXN1bHQsIHNlbGVjdGVkOiBmYWxzZSwgY2hvaWNlczogeyByb3dzLCBjb2x1bW5zLCBzcXVhcmVzIH0gfSk7XG59XG5cbi8qKlxuICogZ2l2ZSB0aGUgY29vcmRpbmF0ZSB1cGRhdGUgdGhlIGN1cnJlbnQgYm9hcmQgd2l0aCBhIG51bWJlciBjaG9pY2VcbiAqIEBwYXJhbSB4XG4gKiBAcGFyYW0geVxuICogQHBhcmFtIG51bWJlclxuICogQHBhcmFtIGZpbGwgd2hldGhlciB0byBzZXQgb3IgdW5zZXRcbiAqIEBwYXJhbSBib2FyZCB0aGUgaW1tdXRhYmxlIGJvYXJkIGdpdmVuIHRvIGNoYW5nZVxuICovXG5mdW5jdGlvbiB1cGRhdGVCb2FyZFdpdGhOdW1iZXIoe1xuICB4LCB5LCBudW1iZXIsIGZpbGwgPSB0cnVlLCBib2FyZCxcbn0pIHtcbiAgbGV0IGNlbGwgPSBib2FyZC5nZXQoJ3B1enpsZScpLmdldEluKFt4LCB5XSk7XG4gIC8vIGRlbGV0ZSBpdHMgbm90ZXNcbiAgY2VsbCA9IGNlbGwuZGVsZXRlKCdub3RlcycpO1xuICAvLyBzZXQgb3IgdW5zZXQgaXRzIHZhbHVlIGRlcGVuZGluZyBvbiBgZmlsbGBcbiAgY2VsbCA9IGZpbGwgPyBjZWxsLnNldCgndmFsdWUnLCBudW1iZXIpIDogY2VsbC5kZWxldGUoJ3ZhbHVlJyk7XG4gIGNvbnN0IGluY3JlbWVudCA9IGZpbGwgPyAxIDogLTE7XG4gIC8vIHVwZGF0ZSB0aGUgY3VycmVudCBncm91cCBjaG9pY2VzXG4gIGNvbnN0IHJvd1BhdGggPSBbJ2Nob2ljZXMnLCAncm93cycsIHgsIG51bWJlcl07XG4gIGNvbnN0IGNvbHVtblBhdGggPSBbJ2Nob2ljZXMnLCAnY29sdW1ucycsIHksIG51bWJlcl07XG4gIGNvbnN0IHNxdWFyZVBhdGggPSBbJ2Nob2ljZXMnLCAnc3F1YXJlcycsXG4gICAgKChNYXRoLmZsb29yKHggLyAzKSkgKiAzKSArIE1hdGguZmxvb3IoeSAvIDMpLCBudW1iZXJdO1xuICByZXR1cm4gYm9hcmQuc2V0SW4ocm93UGF0aCwgYm9hcmQuZ2V0SW4ocm93UGF0aCkgKyBpbmNyZW1lbnQpXG4gICAgLnNldEluKGNvbHVtblBhdGgsIGJvYXJkLmdldEluKGNvbHVtblBhdGgpICsgaW5jcmVtZW50KVxuICAgIC5zZXRJbihzcXVhcmVQYXRoLCBib2FyZC5nZXRJbihzcXVhcmVQYXRoKSArIGluY3JlbWVudClcbiAgICAuc2V0SW4oWydwdXp6bGUnLCB4LCB5XSwgY2VsbCk7XG59XG5cbmZ1bmN0aW9uIGdldE51bWJlck9mR3JvdXBzQXNzaWduZWRGb3JOdW1iZXIobnVtYmVyLCBncm91cHMpIHtcbiAgcmV0dXJuIGdyb3Vwcy5yZWR1Y2UoKGFjY3VtdWxhdG9yLCByb3cpID0+XG4gICAgYWNjdW11bGF0b3IgKyAocm93LmdldChudW1iZXIpID4gMCA/IDEgOiAwKSwgMCk7XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3Qvbm8tbXVsdGktY29tcFxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW5kZXggZXh0ZW5kcyBDb21wb25lbnQge1xuICBzdGF0ZSA9IHt9O1xuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgIGlmICgnc2VydmljZVdvcmtlcicgaW4gbmF2aWdhdG9yKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICAgIG5hdmlnYXRvci5zZXJ2aWNlV29ya2VyXG4gICAgICAgIC5yZWdpc3RlcignL3NlcnZpY2Utd29ya2VyLmpzJylcbiAgICAgICAgLnRoZW4oKHJlZykgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdTZXJ2aWNlV29ya2VyIHNjb3BlOiAnLCByZWcuc2NvcGUpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdzZXJ2aWNlIHdvcmtlciByZWdpc3RyYXRpb24gc3VjY2Vzc2Z1bCcpO1xuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgIGNvbnNvbGUud2Fybignc2VydmljZSB3b3JrZXIgcmVnaXN0cmF0aW9uIGZhaWxlZCcsIGVyci5tZXNzYWdlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICBcbiAgICBmZXRjaCgnL2FwaS9zb2NrZXRpbycpLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgY29uc3Qgc29ja2V0ID0gaW8oKVxuXG4gICAgICBzb2NrZXQub24oJ2Nvbm5lY3QnLCAoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdjb25uZWN0JylcbiAgICAgICAgc29ja2V0LmVtaXQoJ2hlbGxvJylcbiAgICAgIH0pXG5cbiAgICAgIHNvY2tldC5vbignaGVsbG8nLCBkYXRhID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ2hlbGxvJywgZGF0YSlcbiAgICAgIH0pXG5cbiAgICAgIHNvY2tldC5vbignYSB1c2VyIGNvbm5lY3RlZCcsICgpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ2EgdXNlciBjb25uZWN0ZWQnKVxuICAgICAgfSlcblxuICAgICAgc29ja2V0Lm9uKCdkaXNjb25uZWN0JywgKCkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZygnZGlzY29ubmVjdCcpXG4gICAgICB9KVxuICAgIH0pXG4gICBcbiAgfVxuICBnZXRTZWxlY3RlZENlbGwoKSB7XG4gICAgY29uc3QgeyBib2FyZCB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBzZWxlY3RlZCA9IGJvYXJkLmdldCgnc2VsZWN0ZWQnKTtcbiAgICByZXR1cm4gc2VsZWN0ZWQgJiYgYm9hcmQuZ2V0KCdwdXp6bGUnKS5nZXRJbihbc2VsZWN0ZWQueCwgc2VsZWN0ZWQueV0pO1xuICB9XG5cbiAgLy8gZ2V0IHRoZSBtaW4gYmV0d2VlbiBpdHMgY29tcGxldGlvbiBpbiByb3dzLCBjb2x1bW5zIGFuZCBzcXVhcmVzLlxuICBnZXROdW1iZXJWYWx1ZUNvdW50KG51bWJlcikge1xuICAgIGNvbnN0IHJvd3MgPSB0aGlzLnN0YXRlLmJvYXJkLmdldEluKFsnY2hvaWNlcycsICdyb3dzJ10pO1xuICAgIGNvbnN0IGNvbHVtbnMgPSB0aGlzLnN0YXRlLmJvYXJkLmdldEluKFsnY2hvaWNlcycsICdjb2x1bW5zJ10pO1xuICAgIGNvbnN0IHNxdWFyZXMgPSB0aGlzLnN0YXRlLmJvYXJkLmdldEluKFsnY2hvaWNlcycsICdzcXVhcmVzJ10pO1xuICAgIHJldHVybiBNYXRoLm1pbihcbiAgICAgIGdldE51bWJlck9mR3JvdXBzQXNzaWduZWRGb3JOdW1iZXIobnVtYmVyLCBzcXVhcmVzKSxcbiAgICAgIE1hdGgubWluKFxuICAgICAgICBnZXROdW1iZXJPZkdyb3Vwc0Fzc2lnbmVkRm9yTnVtYmVyKG51bWJlciwgcm93cyksXG4gICAgICAgIGdldE51bWJlck9mR3JvdXBzQXNzaWduZWRGb3JOdW1iZXIobnVtYmVyLCBjb2x1bW5zKSxcbiAgICAgICksXG4gICAgKTtcbiAgfVxuXG4gIGdlbmVyYXRlR2FtZSA9IChmaW5hbENvdW50ID0gMjApID0+IHtcbiAgICAvLyBnZXQgYSBmaWxsZWQgcHV6emxlIGdlbmVyYXRlZFxuICAgIGNvbnN0IHNvbHV0aW9uID0gbWFrZVB1enpsZSgpO1xuICAgIC8vIHBsdWNrIHZhbHVlcyBmcm9tIGNlbGxzIHRvIGNyZWF0ZSB0aGUgZ2FtZVxuICAgIGNvbnN0IHsgcHV6emxlIH0gPSBwbHVjayhzb2x1dGlvbiwgZmluYWxDb3VudCk7XG4gICAgLy8gaW5pdGlhbGl6ZSB0aGUgYm9hcmQgd2l0aCBjaG9pY2UgY291bnRzXG4gICAgY29uc3QgYm9hcmQgPSBtYWtlQm9hcmQoeyBwdXp6bGUgfSk7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBib2FyZCwgaGlzdG9yeTogTGlzdC5vZihib2FyZCksIGhpc3RvcnlPZmZTZXQ6IDAsIHNvbHV0aW9uLFxuICAgIH0pO1xuICB9XG5cbiAgYWRkTnVtYmVyQXNOb3RlID0gKG51bWJlcikgPT4ge1xuICAgIGxldCB7IGJvYXJkIH0gPSB0aGlzLnN0YXRlO1xuICAgIGxldCBzZWxlY3RlZENlbGwgPSB0aGlzLmdldFNlbGVjdGVkQ2VsbCgpO1xuICAgIGlmICghc2VsZWN0ZWRDZWxsKSByZXR1cm47XG4gICAgY29uc3QgcHJlZmlsbGVkID0gc2VsZWN0ZWRDZWxsLmdldCgncHJlZmlsbGVkJyk7XG4gICAgaWYgKHByZWZpbGxlZCkgcmV0dXJuO1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gYm9hcmQuZ2V0KCdzZWxlY3RlZCcpO1xuICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHNlbGVjdGVkQ2VsbC5nZXQoJ3ZhbHVlJyk7XG4gICAgaWYgKGN1cnJlbnRWYWx1ZSkge1xuICAgICAgYm9hcmQgPSB1cGRhdGVCb2FyZFdpdGhOdW1iZXIoe1xuICAgICAgICB4LCB5LCBudW1iZXI6IGN1cnJlbnRWYWx1ZSwgZmlsbDogZmFsc2UsIGJvYXJkOiB0aGlzLnN0YXRlLmJvYXJkLFxuICAgICAgfSk7XG4gICAgfVxuICAgIGxldCBub3RlcyA9IHNlbGVjdGVkQ2VsbC5nZXQoJ25vdGVzJykgfHwgU2V0KCk7XG4gICAgaWYgKG5vdGVzLmhhcyhudW1iZXIpKSB7XG4gICAgICBub3RlcyA9IG5vdGVzLmRlbGV0ZShudW1iZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub3RlcyA9IG5vdGVzLmFkZChudW1iZXIpO1xuICAgIH1cbiAgICBzZWxlY3RlZENlbGwgPSBzZWxlY3RlZENlbGwuc2V0KCdub3RlcycsIG5vdGVzKTtcbiAgICBzZWxlY3RlZENlbGwgPSBzZWxlY3RlZENlbGwuZGVsZXRlKCd2YWx1ZScpO1xuICAgIGJvYXJkID0gYm9hcmQuc2V0SW4oWydwdXp6bGUnLCB4LCB5XSwgc2VsZWN0ZWRDZWxsKTtcbiAgICB0aGlzLnVwZGF0ZUJvYXJkKGJvYXJkKTtcbiAgfTtcblxuICB1cGRhdGVCb2FyZCA9IChuZXdCb2FyZCkgPT4ge1xuICAgIGxldCB7IGhpc3RvcnkgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgeyBoaXN0b3J5T2ZmU2V0IH0gPSB0aGlzLnN0YXRlO1xuICAgIC8vIGFueXRoaW5nIGJlZm9yZSBjdXJyZW50IHN0ZXAgaXMgc3RpbGwgaW4gaGlzdG9yeVxuICAgIGhpc3RvcnkgPSBoaXN0b3J5LnNsaWNlKDAsIGhpc3RvcnlPZmZTZXQgKyAxKTtcbiAgICAvLyBhZGQgaXRzZWxmIG9udG8gdGhlIGhpc3RvcnlcbiAgICBoaXN0b3J5ID0gaGlzdG9yeS5wdXNoKG5ld0JvYXJkKTtcbiAgICAvLyB1cGRhdGUgdGhlIGdhbWVcbiAgICB0aGlzLnNldFN0YXRlKHsgYm9hcmQ6IG5ld0JvYXJkLCBoaXN0b3J5LCBoaXN0b3J5T2ZmU2V0OiBoaXN0b3J5LnNpemUgLSAxIH0pO1xuICB9O1xuXG4gIGNhblVuZG8gPSAoKSA9PiB0aGlzLnN0YXRlLmhpc3RvcnlPZmZTZXQgPiAwXG5cbiAgcmVkbyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGhpc3RvcnkgfSA9IHRoaXMuc3RhdGU7XG4gICAgbGV0IHsgaGlzdG9yeU9mZlNldCB9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAoaGlzdG9yeS5zaXplKSB7XG4gICAgICBoaXN0b3J5T2ZmU2V0ID0gTWF0aC5taW4oaGlzdG9yeS5zaXplIC0gMSwgaGlzdG9yeU9mZlNldCArIDEpO1xuICAgICAgY29uc3QgYm9hcmQgPSBoaXN0b3J5LmdldChoaXN0b3J5T2ZmU2V0KTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBib2FyZCwgaGlzdG9yeU9mZlNldCB9KTtcbiAgICB9XG4gIH07XG5cbiAgdW5kbyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGhpc3RvcnkgfSA9IHRoaXMuc3RhdGU7XG4gICAgbGV0IHsgaGlzdG9yeU9mZlNldCwgYm9hcmQgfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKGhpc3Rvcnkuc2l6ZSkge1xuICAgICAgaGlzdG9yeU9mZlNldCA9IE1hdGgubWF4KDAsIGhpc3RvcnlPZmZTZXQgLSAxKTtcbiAgICAgIGJvYXJkID0gaGlzdG9yeS5nZXQoaGlzdG9yeU9mZlNldCk7XG4gICAgICB0aGlzLnNldFN0YXRlKHsgYm9hcmQsIGhpc3RvcnlPZmZTZXQsIGhpc3RvcnkgfSk7XG4gICAgfVxuICB9O1xuXG4gIGVyYXNlU2VsZWN0ZWQgPSAoKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0ZWRDZWxsID0gdGhpcy5nZXRTZWxlY3RlZENlbGwoKTtcbiAgICBpZiAoIXNlbGVjdGVkQ2VsbCkgcmV0dXJuO1xuICAgIHRoaXMuZmlsbE51bWJlcihmYWxzZSk7XG4gIH1cblxuICBmaWxsU2VsZWN0ZWRXaXRoU29sdXRpb24gPSAoKSA9PiB7XG4gICAgY29uc3QgeyBib2FyZCwgc29sdXRpb24gfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3Qgc2VsZWN0ZWRDZWxsID0gdGhpcy5nZXRTZWxlY3RlZENlbGwoKTtcbiAgICBpZiAoIXNlbGVjdGVkQ2VsbCkgcmV0dXJuO1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gYm9hcmQuZ2V0KCdzZWxlY3RlZCcpO1xuICAgIHRoaXMuZmlsbE51bWJlcihzb2x1dGlvblt4XVt5XSk7XG4gIH1cblxuXG4gIC8vIGZpbGwgY3VycmVudGx5IHNlbGVjdGVkIGNlbGwgd2l0aCBudW1iZXJcbiAgZmlsbE51bWJlciA9IChudW1iZXIpID0+IHtcbiAgICBsZXQgeyBib2FyZCB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBzZWxlY3RlZENlbGwgPSB0aGlzLmdldFNlbGVjdGVkQ2VsbCgpO1xuICAgIC8vIG5vLW9wIGlmIG5vdGhpbmcgaXMgc2VsZWN0ZWRcbiAgICBpZiAoIXNlbGVjdGVkQ2VsbCkgcmV0dXJuO1xuICAgIGNvbnN0IHByZWZpbGxlZCA9IHNlbGVjdGVkQ2VsbC5nZXQoJ3ByZWZpbGxlZCcpO1xuICAgIC8vIG5vLW9wIGlmIGl0IGlzIHJlZmlsbGVkXG4gICAgaWYgKHByZWZpbGxlZCkgcmV0dXJuO1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gYm9hcmQuZ2V0KCdzZWxlY3RlZCcpO1xuICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHNlbGVjdGVkQ2VsbC5nZXQoJ3ZhbHVlJyk7XG4gICAgLy8gcmVtb3ZlIHRoZSBjdXJyZW50IHZhbHVlIGFuZCB1cGRhdGUgdGhlIGdhbWUgc3RhdGVcbiAgICBpZiAoY3VycmVudFZhbHVlKSB7XG4gICAgICBib2FyZCA9IHVwZGF0ZUJvYXJkV2l0aE51bWJlcih7XG4gICAgICAgIHgsIHksIG51bWJlcjogY3VycmVudFZhbHVlLCBmaWxsOiBmYWxzZSwgYm9hcmQ6IHRoaXMuc3RhdGUuYm9hcmQsXG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gdXBkYXRlIHRvIG5ldyBudW1iZXIgaWYgYW55XG4gICAgY29uc3Qgc2V0TnVtYmVyID0gY3VycmVudFZhbHVlICE9PSBudW1iZXIgJiYgbnVtYmVyO1xuICAgIGlmIChzZXROdW1iZXIpIHtcbiAgICAgIGJvYXJkID0gdXBkYXRlQm9hcmRXaXRoTnVtYmVyKHtcbiAgICAgICAgeCwgeSwgbnVtYmVyLCBmaWxsOiB0cnVlLCBib2FyZCxcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZUJvYXJkKGJvYXJkKTtcbiAgfTtcblxuICBzZWxlY3RDZWxsID0gKHgsIHkpID0+IHtcbiAgICBsZXQgeyBib2FyZCB9ID0gdGhpcy5zdGF0ZTtcbiAgICBib2FyZCA9IGJvYXJkLnNldCgnc2VsZWN0ZWQnLCB7IHgsIHkgfSk7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IGJvYXJkIH0pO1xuICB9O1xuXG4gIGlzQ29uZmxpY3QoaSwgaikge1xuICAgIGNvbnN0IHsgdmFsdWUgfSA9IHRoaXMuc3RhdGUuYm9hcmQuZ2V0SW4oWydwdXp6bGUnLCBpLCBqXSkudG9KU09OKCk7XG4gICAgaWYgKCF2YWx1ZSkgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IHJvd0NvbmZsaWN0ID1cbiAgICAgIHRoaXMuc3RhdGUuYm9hcmQuZ2V0SW4oWydjaG9pY2VzJywgJ3Jvd3MnLCBpLCB2YWx1ZV0pID4gMTtcbiAgICBjb25zdCBjb2x1bW5Db25mbGljdCA9XG4gICAgICB0aGlzLnN0YXRlLmJvYXJkLmdldEluKFsnY2hvaWNlcycsICdjb2x1bW5zJywgaiwgdmFsdWVdKSA+IDE7XG4gICAgY29uc3Qgc3F1YXJlQ29uZmxpY3QgPVxuICAgICAgdGhpcy5zdGF0ZS5ib2FyZC5nZXRJbihbJ2Nob2ljZXMnLCAnc3F1YXJlcycsXG4gICAgICAgICgoTWF0aC5mbG9vcihpIC8gMykpICogMykgKyBNYXRoLmZsb29yKGogLyAzKSwgdmFsdWVdKSA+IDE7XG4gICAgcmV0dXJuIHJvd0NvbmZsaWN0IHx8IGNvbHVtbkNvbmZsaWN0IHx8IHNxdWFyZUNvbmZsaWN0O1xuICB9XG5cbiAgcmVuZGVyQ2VsbChjZWxsLCB4LCB5KSB7XG4gICAgY29uc3QgeyBib2FyZCB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBzZWxlY3RlZCA9IHRoaXMuZ2V0U2VsZWN0ZWRDZWxsKCk7XG4gICAgY29uc3QgeyB2YWx1ZSwgcHJlZmlsbGVkLCBub3RlcyB9ID0gY2VsbC50b0pTT04oKTtcbiAgICBjb25zdCBjb25mbGljdCA9IHRoaXMuaXNDb25mbGljdCh4LCB5KTtcbiAgICBjb25zdCBwZWVyID0gYXJlQ29vcmRpbmF0ZVBlZXJzKHsgeCwgeSB9LCBib2FyZC5nZXQoJ3NlbGVjdGVkJykpO1xuICAgIGNvbnN0IHNhbWVWYWx1ZSA9ICEhKHNlbGVjdGVkICYmIHNlbGVjdGVkLmdldCgndmFsdWUnKVxuICAgICAgJiYgdmFsdWUgPT09IHNlbGVjdGVkLmdldCgndmFsdWUnKSk7XG5cbiAgICBjb25zdCBpc1NlbGVjdGVkID0gY2VsbCA9PT0gc2VsZWN0ZWQ7XG4gICAgcmV0dXJuICg8Q2VsbFxuICAgICAgcHJlZmlsbGVkPXtwcmVmaWxsZWR9XG4gICAgICBub3Rlcz17bm90ZXN9XG4gICAgICBzYW1lVmFsdWU9e3NhbWVWYWx1ZX1cbiAgICAgIGlzU2VsZWN0ZWQ9e2lzU2VsZWN0ZWR9XG4gICAgICBpc1BlZXI9e3BlZXJ9XG4gICAgICB2YWx1ZT17dmFsdWV9XG4gICAgICBvbkNsaWNrPXsoKSA9PiB7IHRoaXMuc2VsZWN0Q2VsbCh4LCB5KTsgfX1cbiAgICAgIGtleT17eX1cbiAgICAgIHg9e3h9XG4gICAgICB5PXt5fVxuICAgICAgY29uZmxpY3Q9e2NvbmZsaWN0fVxuICAgIC8+KTtcbiAgfVxuXG4gIHJlbmRlck51bWJlckNvbnRyb2woKSB7XG4gICAgY29uc3Qgc2VsZWN0ZWRDZWxsID0gdGhpcy5nZXRTZWxlY3RlZENlbGwoKTtcbiAgICBjb25zdCBwcmVmaWxsZWQgPSBzZWxlY3RlZENlbGwgJiYgc2VsZWN0ZWRDZWxsLmdldCgncHJlZmlsbGVkJyk7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29udHJvbFwiPlxuICAgICAgICB7cmFuZ2UoOSkubWFwKChpKSA9PiB7XG4gICAgICAgICAgY29uc3QgbnVtYmVyID0gaSArIDE7XG4gICAgICAgICAgLy8gaGFuZGxlcyBiaW5kaW5nIHNpbmdsZSBjbGljayBhbmQgZG91YmxlIGNsaWNrIGNhbGxiYWNrc1xuICAgICAgICAgIGNvbnN0IGNsaWNrSGFuZGxlID0gZ2V0Q2xpY2tIYW5kbGVyKFxuICAgICAgICAgICAgKCkgPT4geyB0aGlzLmZpbGxOdW1iZXIobnVtYmVyKTsgfSxcbiAgICAgICAgICAgICgpID0+IHsgdGhpcy5hZGROdW1iZXJBc05vdGUobnVtYmVyKTsgfSxcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8TnVtYmVyQ29udHJvbFxuICAgICAgICAgICAgICBrZXk9e251bWJlcn1cbiAgICAgICAgICAgICAgbnVtYmVyPXtudW1iZXJ9XG4gICAgICAgICAgICAgIG9uQ2xpY2s9eyFwcmVmaWxsZWQgPyBjbGlja0hhbmRsZSA6IHVuZGVmaW5lZH1cbiAgICAgICAgICAgICAgY29tcGxldGlvblBlcmNlbnRhZ2U9e3RoaXMuZ2V0TnVtYmVyVmFsdWVDb3VudChudW1iZXIpIC8gOX1cbiAgICAgICAgICAgIC8+KTtcbiAgICAgICAgfSl9XG4gICAgICAgIDxzdHlsZSBqc3g+e0NvbnRyb2xTdHlsZX08L3N0eWxlPlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxuXG4gIHJlbmRlckFjdGlvbnMoKSB7XG4gICAgY29uc3QgeyBoaXN0b3J5IH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IHNlbGVjdGVkQ2VsbCA9IHRoaXMuZ2V0U2VsZWN0ZWRDZWxsKCk7XG4gICAgY29uc3QgcHJlZmlsbGVkID0gc2VsZWN0ZWRDZWxsICYmIHNlbGVjdGVkQ2VsbC5nZXQoJ3ByZWZpbGxlZCcpO1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImFjdGlvbnNcIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJhY3Rpb25cIiBvbkNsaWNrPXtoaXN0b3J5LnNpemUgPyB0aGlzLnVuZG8gOiBudWxsfT5cbiAgICAgICAgICA8UmVsb2FkSWNvbiAvPlVuZG9cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWN0aW9uIHJlZG9cIiBvbkNsaWNrPXtoaXN0b3J5LnNpemUgPyB0aGlzLnJlZG8gOiBudWxsfT5cbiAgICAgICAgICA8UmVsb2FkSWNvbiAvPlJlZG9cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWN0aW9uXCIgb25DbGljaz17IXByZWZpbGxlZCA/IHRoaXMuZXJhc2VTZWxlY3RlZCA6IG51bGx9PlxuICAgICAgICAgIDxSZW1vdmVJY29uIC8+RXJhc2VcbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXZcbiAgICAgICAgICBjbGFzc05hbWU9XCJhY3Rpb25cIlxuICAgICAgICAgIG9uQ2xpY2s9eyFwcmVmaWxsZWQgP1xuICAgICAgICAgIHRoaXMuZmlsbFNlbGVjdGVkV2l0aFNvbHV0aW9uIDogbnVsbH1cbiAgICAgICAgPlxuICAgICAgICAgIDxMb3VwZUljb24gLz5IaW50XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8c3R5bGUganN4PntBY3Rpb25zU3R5bGV9PC9zdHlsZT5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cblxuICByZW5kZXJQdXp6bGUoKSB7XG4gICAgY29uc3QgeyBib2FyZCB9ID0gdGhpcy5zdGF0ZTtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJwdXp6bGVcIj5cbiAgICAgICAge2JvYXJkLmdldCgncHV6emxlJykubWFwKChyb3csIGkpID0+IChcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3Qvbm8tYXJyYXktaW5kZXgta2V5XG4gICAgICAgICAgPGRpdiBrZXk9e2l9IGNsYXNzTmFtZT1cInJvd1wiPlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICByb3cubWFwKChjZWxsLCBqKSA9PiB0aGlzLnJlbmRlckNlbGwoY2VsbCwgaSwgaikpLnRvQXJyYXkoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICApKS50b0FycmF5KCl9XG4gICAgICAgIDxzdHlsZSBqc3g+e1B1enpsZVN0eWxlfTwvc3R5bGU+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG5cbiAgcmVuZGVyQ29udHJvbHMoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29udHJvbHNcIj5cbiAgICAgICAge3RoaXMucmVuZGVyTnVtYmVyQ29udHJvbCgpfVxuICAgICAgICB7dGhpcy5yZW5kZXJBY3Rpb25zKCl9XG4gICAgICAgIHsgLyogbGFuZ3VhZ2U9Q1NTICovIH1cbiAgICAgICAgPHN0eWxlIGpzeD57YFxuICAgICAgICAgICAgLmNvbnRyb2xzIHtcbiAgICAgICAgICAgICAgICBtYXJnaW4tdG9wOiAuM2VtO1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgICAgICAgZmxleC13cmFwOiB3cmFwO1xuICAgICAgICAgICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICAgICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICAgICAgICAgIHBhZGRpbmc6IC41ZW0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgYH1cbiAgICAgICAgPC9zdHlsZT5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cblxuICByZW5kZXJHZW5lcmF0aW9uVUkoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxHZW5lcmF0aW9uVUkgZ2VuZXJhdGVHYW1lPXt0aGlzLmdlbmVyYXRlR2FtZX0gLz5cbiAgICApO1xuICB9XG5cbiAgcmVuZGVySGVhZGVyKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImhlYWRlclwiPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm5ldy1nYW1lXCIgb25DbGljaz17KCkgPT4gdGhpcy5zZXRTdGF0ZSh7IGJvYXJkOiBmYWxzZSB9KX0+XG4gICAgICAgICAgPFJldHVybkljb24gLz5cbiAgICAgICAgICA8ZGl2Pk5ldyBHYW1lPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8VGlwIC8+XG4gICAgICAgIHsgLyogbGFuZ3VhZ2U9Q1NTICovIH1cbiAgICAgICAgPHN0eWxlIGpzeD57YFxuICAgICAgICAgICAgLmhlYWRlciB7XG4gICAgICAgICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gICAgICAgICAgICAgICAgbWF4LXdpZHRoOiA1MDBweDtcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiAwIDAuNWVtO1xuICAgICAgICAgICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAubmV3LWdhbWUge1xuICAgICAgICAgICAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICAgICAgICAgICAgICBtYXJnaW4tdG9wOiAuMmVtO1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6IGlubGluZS1mbGV4O1xuICAgICAgICAgICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgICAgICAgICAgcGFkZGluZzogLjJlbSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLm5ldy1nYW1lIDpnbG9iYWwoc3ZnKSB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxZW07XG4gICAgICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogLjNlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgYH1cbiAgICAgICAgPC9zdHlsZT5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBib2FyZCB9ID0gdGhpcy5zdGF0ZTtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJib2R5XCI+XG4gICAgICAgIDxOZXh0SGVhZD5cbiAgICAgICAgICA8dGl0bGU+U3Vkb2t1IEV2b2x2ZWQ8L3RpdGxlPlxuICAgICAgICAgIDxtZXRhIG5hbWU9XCJ2aWV3cG9ydFwiIGNvbnRlbnQ9XCJpbml0aWFsLXNjYWxlPTEuMCwgd2lkdGg9ZGV2aWNlLXdpZHRoXCIgLz5cbiAgICAgICAgICA8bWV0YSBuYW1lPVwiZGVzY3JpcHRpb25cIiBjb250ZW50PXtEZXNjcmlwdGlvbn0gLz5cbiAgICAgICAgICA8bGluayBocmVmPVwiaHR0cHM6Ly9mb250cy5nb29nbGVhcGlzLmNvbS9jc3M/ZmFtaWx5PVNwZWNpYWwrRWxpdGVcIiByZWw9XCJzdHlsZXNoZWV0XCIgLz5cbiAgICAgICAgICA8bWV0YSBwcm9wZXJ0eT1cIm9nOnVybFwiIGNvbnRlbnQ9XCJodHRwczovL3N1ZG9rdS5zaXRpYW5saXUuY29tL1wiIC8+XG4gICAgICAgICAgPG1ldGEgcHJvcGVydHk9XCJvZzp0aXRsZVwiIGNvbnRlbnQ9XCJTdWRva3UgRXZvbHZlZFwiIC8+XG4gICAgICAgICAgPG1ldGEgcHJvcGVydHk9XCJvZzp0eXBlXCIgY29udGVudD1cIndlYnNpdGVcIiAvPlxuICAgICAgICAgIDxtZXRhIHByb3BlcnR5PVwib2c6ZGVzY3JpcHRpb25cIiBjb250ZW50PXtEZXNjcmlwdGlvbn0gLz5cbiAgICAgICAgICA8bWV0YSBwcm9wZXJ0eT1cIm9nOmltYWdlXCIgY29udGVudD1cImh0dHBzOi8vc3Vkb2t1LnNpdGlhbmxpdS5jb20vc3RhdGljL29nLWltYWdlLnBuZ1wiIC8+XG4gICAgICAgIDwvTmV4dEhlYWQ+XG4gICAgICAgIHshYm9hcmQgJiYgdGhpcy5yZW5kZXJHZW5lcmF0aW9uVUkoKX1cbiAgICAgICAge2JvYXJkICYmIHRoaXMucmVuZGVySGVhZGVyKCl9XG4gICAgICAgIHtib2FyZCAmJiB0aGlzLnJlbmRlclB1enpsZSgpfVxuICAgICAgICB7Ym9hcmQgJiYgdGhpcy5yZW5kZXJDb250cm9scygpfVxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInJvb3RlclwiPlxuICAgICAgICAgIE1hZGUgd2l0aCA8c3Bhbj7inaTvuI88L3NwYW4+77iPIEJ5IDxhIGhyZWY9XCJodHRwczovL3d3dy5zaXRpYW5saXUuY29tL1wiPlNpdGlhbiBMaXU8L2E+IHwgPGEgaHJlZj1cImh0dHBzOi8vbWVkaXVtLmNvbS9Ac2l0aWFubGl1XzU3NjgwL2J1aWxkaW5nLWEtc3Vkb2t1LWdhbWUtaW4tcmVhY3QtY2E2NjM5MTU3MTJcIj5CbG9nIFBvc3Q8L2E+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICB7IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG4gICAgICAgIDxzdHlsZSBqc3g+e2BcbiAgICAgICAgICAgIDpnbG9iYWwoYm9keSksIC5ib2R5IHtcbiAgICAgICAgICAgICAgICBmb250LWZhbWlseTogJ1NwZWNpYWwgRWxpdGUnLCBjdXJzaXZlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLmJvZHkge1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICAgICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICAgICAgICAgIGhlaWdodDogMTAwdmg7XG4gICAgICAgICAgICAgICAgd2lkdGg6IDEwMHZ3O1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEBtZWRpYSAobWluLXdpZHRoOiA4MDBweCkgYW5kIChtaW4taGVpZ2h0OiA5MzBweCl7XG4gICAgICAgICAgICAgICAgOmdsb2JhbCguaGVhZGVyLCAucHV6emxlLCAuY29udHJvbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9udC1zaXplOiAxLjVlbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBAbWVkaWEgKG1heC13aWR0aDogODAwcHgpIGFuZCAobWluLXdpZHRoOiA2MDBweCl7XG4gICAgICAgICAgICAgICAgOmdsb2JhbCguaGVhZGVyLCAucHV6emxlLCAuY29udHJvbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9udC1zaXplOiAxLjJlbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBAbWVkaWEgKG1heC1oZWlnaHQ6IDkzMHB4KSBhbmQgKG1pbi1oZWlnaHQ6IDgwMHB4KSBhbmQgKG1pbi13aWR0aDogNjAwcHgpe1xuICAgICAgICAgICAgICAgIDpnbG9iYWwoLmhlYWRlciwgLnB1enpsZSwgLmNvbnRyb2xzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvbnQtc2l6ZTogMS4yZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQG1lZGlhIChtYXgtaGVpZ2h0OiA4MDBweCkgYW5kIChtaW4taGVpZ2h0OiA2MDBweCkgYW5kIChtaW4td2lkdGg6IDM3MHB4KXtcbiAgICAgICAgICAgICAgICA6Z2xvYmFsKC5oZWFkZXIsIC5wdXp6bGUsIC5jb250cm9scykge1xuICAgICAgICAgICAgICAgICAgICBmb250LXNpemU6IDFlbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBAbWVkaWEgKG1heC13aWR0aDogMzcwcHgpe1xuICAgICAgICAgICAgICAgIDpnbG9iYWwoLmhlYWRlciwgLnB1enpsZSwgLmNvbnRyb2xzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvbnQtc2l6ZTogLjhlbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBAbWVkaWEgKG1heC1oZWlnaHQ6IDYwMHB4KXtcbiAgICAgICAgICAgICAgICA6Z2xvYmFsKC5oZWFkZXIsIC5wdXp6bGUsIC5jb250cm9scykge1xuICAgICAgICAgICAgICAgICAgICBmb250LXNpemU6IC44ZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOmdsb2JhbChib2R5KSB7XG4gICAgICAgICAgICAgICAgbWFyZ2luOiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLnJvb3RlciB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgICAgICAgICAgIGJvdHRvbTogMDtcbiAgICAgICAgICAgICAgICBmb250LXNpemU6IC44ZW07XG4gICAgICAgICAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgICAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICBgfVxuICAgICAgICA8L3N0eWxlPlxuICAgICAgICA8c3R5bGUganN4IGdsb2JhbD57UmFuZ2VTdHlsZX08L3N0eWxlPlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufVxuIl19 */\n/*@ sourceURL=pages/index.js */');

// eslint-disable-next-line no-lone-blocks
CellStyle.__hash = '861130757';
CellStyle.__scoped = '.cell.jsx-3895838756{height:' + cellWidth + 'em;width:' + cellWidth + 'em;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;font-size:1.1em;font-weight:bold;-webkit-transition:background-color .3s ease-in-out;transition:background-color .3s ease-in-out;}.cell.jsx-3895838756:nth-child(3n+3):not(:last-child){border-right:2px solid black;}.cell.jsx-3895838756:not(:last-child){border-right:1px solid black;}.note-number.jsx-3895838756{font-size:.6em;width:33%;height:33%;box-sizing:border-box;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhZ2VzL2luZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQW9DcUIsQUFHMkMsQUFXVCxBQUdBLEFBR2QsZUFDTCxVQUNDLElBUGYsQUFHQSxPQUswQixFQW5CZSxvQkFvQnhCLGlCQW5CQSx5REFvQk0saUJBbkJKLHlEQUNJLG1CQW1CSSwwRUFsQkEseUJBbUIzQiwwRUFsQm9CLGdCQUNDLGlCQUMyQixnR0FDaEQiLCJmaWxlIjoicGFnZXMvaW5kZXguanMiLCJzb3VyY2VSb290IjoiL1VzZXJzL2xpY2hlbm1hL1Byb2plY3RzL1N1RHVva3UvU3VEdW9rdSIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIGpzeC1hMTF5L2FjY2Vzc2libGUtZW1vamkgKi9cbmltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFNldCwgTGlzdCwgZnJvbUpTIH0gZnJvbSAnaW1tdXRhYmxlJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgTmV4dEhlYWQgZnJvbSAnbmV4dC9oZWFkJztcbmltcG9ydCBDb2xvciBmcm9tICdjb2xvcic7XG5pbXBvcnQgSW5wdXRSYW5nZSBmcm9tICdyZWFjdC1pbnB1dC1yYW5nZSc7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tZXh0cmFuZW91cy1kZXBlbmRlbmNpZXNcbmltcG9ydCBjc3MgZnJvbSAnc3R5bGVkLWpzeC9jc3MnO1xuXG5pbXBvcnQgUmFuZ2VTdHlsZSBmcm9tICcuLi9pbnB1dC1yYW5nZS1zdHlsZSc7XG5pbXBvcnQgTG91cGVJY29uIGZyb20gJy4uL3N2Zy9sb3VwZS5zdmcnO1xuaW1wb3J0IFJlbW92ZUljb24gZnJvbSAnLi4vc3ZnL3JlbW92ZS5zdmcnO1xuaW1wb3J0IFJlbG9hZEljb24gZnJvbSAnLi4vc3ZnL3JlbG9hZC5zdmcnO1xuaW1wb3J0IFJldHVybkljb24gZnJvbSAnLi4vc3ZnL3JldHVybi5zdmcnO1xuXG5pbXBvcnQgeyBtYWtlUHV6emxlLCBwbHVjaywgaXNQZWVyIGFzIGFyZUNvb3JkaW5hdGVQZWVycywgcmFuZ2UgfSBmcm9tICcuLi9zdWRva3UnO1xuaW1wb3J0IHsgYmFja0dyb3VuZEJsdWUgfSBmcm9tICcuLi9jb2xvcnMnO1xuaW1wb3J0IFRpcCBmcm9tICcuLi9jb21wb25lbnRzL3Rvb2wtdGlwJztcblxuaW1wb3J0IGlvIGZyb20gJ3NvY2tldC5pby1jbGllbnQnXG5cbmNvbnN0IERlc2NyaXB0aW9uID0gJ0Rpc2NvdmVyIHRoZSBuZXh0IGV2b2x1dGlvbiBvZiBTdWRva3Ugd2l0aCBhbWF6aW5nIGdyYXBoaWNzLCBhbmltYXRpb25zLCBhbmQgdXNlci1mcmllbmRseSBmZWF0dXJlcy4gRW5qb3kgYSBTdWRva3UgZXhwZXJpZW5jZSBsaWtlIHlvdSBuZXZlciBoYXZlIGJlZm9yZSB3aXRoIGN1c3RvbWl6YWJsZSBnYW1lIGdlbmVyYXRpb24sIGNlbGwgaGlnaGxpZ2h0aW5nLCBpbnR1aXRpdmUgY29udHJvbHMgYW5kIG1vcmUhJztcbmNvbnN0IGNlbGxXaWR0aCA9IDIuNTtcblxuY29uc3QgTGlnaHRCbHVlMTAwID0gJyNCM0U1RkMnO1xuY29uc3QgTGlnaHRCbHVlMjAwID0gJyM4MUQ0RkEnO1xuY29uc3QgTGlnaHRCbHVlMzAwID0gJyM0RkMzRjcnO1xuY29uc3QgSW5kaWdvNzAwID0gJyMzMDNGOUYnO1xuY29uc3QgRGVlcE9yYW5nZTIwMCA9ICcjRkZBQjkxJztcbmNvbnN0IERlZXBPcmFuZ2U2MDAgPSAnI0Y0NTExRSc7XG5jb25zdCBDb250cm9sTnVtYmVyQ29sb3IgPSBJbmRpZ283MDA7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sb25lLWJsb2Nrc1xueyAvKiBsYW5ndWFnZT1DU1MgKi8gfVxuY29uc3QgQ2VsbFN0eWxlID0gY3NzYFxuLmNlbGwge1xuICAgIGhlaWdodDogJHtjZWxsV2lkdGh9ZW07XG4gICAgd2lkdGg6ICR7Y2VsbFdpZHRofWVtO1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC13cmFwOiB3cmFwO1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgZm9udC1zaXplOiAxLjFlbTtcbiAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICB0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kLWNvbG9yIC4zcyBlYXNlLWluLW91dDtcbn1cbi5jZWxsOm50aC1jaGlsZCgzbiszKTpub3QoOmxhc3QtY2hpbGQpIHtcbiAgICBib3JkZXItcmlnaHQ6IDJweCBzb2xpZCBibGFjaztcbn1cbi5jZWxsOm5vdCg6bGFzdC1jaGlsZCkge1xuICAgIGJvcmRlci1yaWdodDogMXB4IHNvbGlkIGJsYWNrO1xufVxuLm5vdGUtbnVtYmVyIHtcbiAgICBmb250LXNpemU6IC42ZW07XG4gICAgd2lkdGg6IDMzJTtcbiAgICBoZWlnaHQ6IDMzJTtcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbn1cbmA7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sb25lLWJsb2Nrc1xueyAvKiBsYW5ndWFnZT1DU1MgKi8gfVxuY29uc3QgQWN0aW9uc1N0eWxlID0gY3NzYFxuLmFjdGlvbnMge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgbWF4LXdpZHRoOiA0MDBweDtcbiAgICBtYXJnaW4tdG9wOiAuNWVtO1xuICAgIHBhZGRpbmc6IDAgLjZlbTtcbn1cbi5hY3Rpb24ge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xufVxuLmFjdGlvbiA6Z2xvYmFsKHN2Zykge1xuICAgIHdpZHRoOiAyLjVlbTtcbiAgICBtYXJnaW4tYm90dG9tOiAuMmVtO1xufVxuLnJlZG8gOmdsb2JhbChzdmcpIHtcbiAgICB0cmFuc2Zvcm06IHNjYWxlWCgtMSk7XG59XG5gO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbG9uZS1ibG9ja3NcbnsgLyogbGFuZ3VhZ2U9Q1NTICovIH1cbmNvbnN0IENvbnRyb2xTdHlsZSA9IGNzc2Bcbi5jb250cm9sIHtcbiAgICBwYWRkaW5nOiAwIDJlbTtcbiAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgZGlzcGxheTogaW5saW5lLWZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBmbGV4LXdyYXA6IHdyYXA7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgZm9udC1mYW1pbHk6ICdTcGVjaWFsIEVsaXRlJywgY3Vyc2l2ZTtcbiAgICB0cmFuc2l0aW9uOiBmaWx0ZXIgLjVzIGVhc2UtaW4tb3V0O1xuICAgIHdpZHRoOiAxMDAlO1xufVxuYDtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxvbmUtYmxvY2tzXG57IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG5jb25zdCBOdW1iZXJDb250cm9sU3R5bGUgPSBjc3NgXG4ubnVtYmVyIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGZvbnQtc2l6ZTogMmVtO1xuICAgIG1hcmdpbjogLjFlbTtcbiAgICB3aWR0aDogMS41ZW07XG4gICAgaGVpZ2h0OiAxLjVlbTtcbiAgICBjb2xvcjogJHtDb250cm9sTnVtYmVyQ29sb3J9O1xuICAgIGJveC1zaGFkb3c6IDAgMXB4IDJweCByZ2JhKDAsMCwwLDAuMTYpLCAwIDFweCAycHggcmdiYSgwLDAsMCwwLjIzKTtcbiAgICBib3JkZXItcmFkaXVzOiA1MCU7XG59XG4ubnVtYmVyID4gZGl2IHtcbiAgICBtYXJnaW4tdG9wOiAuM2VtO1xufVxuYDtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxvbmUtYmxvY2tzXG57IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG5jb25zdCBQdXp6bGVTdHlsZSA9IGNzc2Bcbi5wdXp6bGUge1xuICAgIG1hcmdpbi10b3A6IC41ZW07XG4gICAgd2lkdGg6ICR7Y2VsbFdpZHRoICogOX1lbTtcbiAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgYm94LXNoYWRvdzogMCAzcHggNnB4IHJnYmEoMCwwLDAsMC4xNiksIDAgM3B4IDZweCByZ2JhKDAsMCwwLDAuMjMpO1xufVxuLnJvdyB7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGZsZXg6IDA7XG4gICAgd2lkdGg6ICR7Y2VsbFdpZHRoICogOX1lbTtcbn1cbi5yb3c6bm90KDpsYXN0LWNoaWxkKSB7XG4gICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkIGJsYWNrO1xufVxuLnJvdzpudGgtY2hpbGQoM24rMyk6bm90KDpsYXN0LWNoaWxkKSB7XG4gICAgYm9yZGVyLWJvdHRvbTogMnB4IHNvbGlkIGJsYWNrICFpbXBvcnRhbnQ7XG59XG5gO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbG9uZS1ibG9ja3NcbnsgLyogbGFuZ3VhZ2U9Q1NTICovIH1cbmNvbnN0IENpcmN1bHVhclByb2dyZXNzU3R5bGUgPSBjc3NgXG4uY2lyY3VsYXItcHJvZ3Jlc3Mge1xuICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB0b3A6IDA7XG4gICAgbGVmdDogMDtcbiAgICB0cmFuc2l0aW9uOiBmaWx0ZXIgLjRzIGVhc2UtaW4tb3V0O1xufVxuXG4uY2lyY2xlLWJnIHtcbiAgICBmaWxsOiBub25lO1xuICAgIHN0cm9rZTogI2VlZTtcbiAgICBzdHJva2Utd2lkdGg6IDMuODtcbn1cblxuLmNpcmNsZSB7XG4gICAgc3Ryb2tlOiAke0NvbnRyb2xOdW1iZXJDb2xvcn07XG4gICAgdHJhbnNpdGlvbjogc3Ryb2tlLWRhc2hhcnJheSAuNHMgZWFzZS1pbi1vdXQ7XG4gICAgZmlsbDogbm9uZTtcbiAgICBzdHJva2Utd2lkdGg6IDIuODtcbiAgICBzdHJva2UtbGluZWNhcDogcm91bmQ7XG59XG5gO1xuXG5jb25zdCBDaXJjdWxhclBhdGhEID0gJ00xOCAyLjA4NDUgYSAxNS45MTU1IDE1LjkxNTUgMCAwIDEgMCAzMS44MzEgYSAxNS45MTU1IDE1LjkxNTUgMCAwIDEgMCAtMzEuODMxJztcblxuZnVuY3Rpb24gZ2V0QmFja0dyb3VuZENvbG9yKHtcbiAgY29uZmxpY3QsIGlzUGVlciwgc2FtZVZhbHVlLCBpc1NlbGVjdGVkLFxufSkge1xuICBpZiAoY29uZmxpY3QgJiYgaXNQZWVyICYmIHNhbWVWYWx1ZSkge1xuICAgIHJldHVybiBEZWVwT3JhbmdlMjAwO1xuICB9IGVsc2UgaWYgKHNhbWVWYWx1ZSkge1xuICAgIHJldHVybiBMaWdodEJsdWUzMDA7XG4gIH0gZWxzZSBpZiAoaXNTZWxlY3RlZCkge1xuICAgIHJldHVybiBMaWdodEJsdWUyMDA7XG4gIH0gZWxzZSBpZiAoaXNQZWVyKSB7XG4gICAgcmV0dXJuIExpZ2h0Qmx1ZTEwMDtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldEZvbnRDb2xvcih7IHZhbHVlLCBjb25mbGljdCwgcHJlZmlsbGVkIH0pIHtcbiAgaWYgKGNvbmZsaWN0ICYmICFwcmVmaWxsZWQpIHtcbiAgICByZXR1cm4gRGVlcE9yYW5nZTYwMDtcbiAgfSBlbHNlIGlmICghcHJlZmlsbGVkICYmIHZhbHVlKSB7XG4gICAgcmV0dXJuIENvbnRyb2xOdW1iZXJDb2xvcjtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmNsYXNzIEdlbmVyYXRpb25VSSBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuXG4gICAgdGhpcy5zdGF0ZSA9IHsgdmFsdWU6IDMwIH07XG4gIH1cblxuICBnZW5lcmF0ZUdhbWUgPSAoKSA9PiB7XG4gICAgdGhpcy5wcm9wcy5nZW5lcmF0ZUdhbWUodGhpcy5zdGF0ZS52YWx1ZSk7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ2VuZXJhdGlvblwiPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvcHlcIj5TdGFydCB3aXRoIHt0aGlzLnN0YXRlLnZhbHVlfSBjZWxscyBwcmVmaWxsZWQ8L2Rpdj5cbiAgICAgICAgPElucHV0UmFuZ2VcbiAgICAgICAgICBtYXhWYWx1ZT17ODF9XG4gICAgICAgICAgbWluVmFsdWU9ezE3fVxuICAgICAgICAgIHZhbHVlPXt0aGlzLnN0YXRlLnZhbHVlfVxuICAgICAgICAgIG9uQ2hhbmdlPXt2YWx1ZSA9PiB0aGlzLnNldFN0YXRlKHsgdmFsdWUgfSl9XG4gICAgICAgIC8+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYnV0dG9uXCIgb25DbGljaz17dGhpcy5nZW5lcmF0ZUdhbWV9PlBsYXkgU3Vkb2t1PC9kaXY+XG4gICAgICAgIHsgLyogbGFuZ3VhZ2U9Q1NTICovIH1cbiAgICAgICAgPHN0eWxlIGpzeD57YFxuICAgICAgICAgICAgLmNvcHkge1xuICAgICAgICAgICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICAgICAgICAgICAgICBmb250LXNpemU6IDEuM2VtO1xuICAgICAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IC41ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAuZ2VuZXJhdGlvbiB7XG4gICAgICAgICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgICAgICAgICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6Z2xvYmFsKC5pbnB1dC1yYW5nZSkge1xuICAgICAgICAgICAgICAgIHdpZHRoOiA4MCU7XG4gICAgICAgICAgICAgICAgbWF4LXdpZHRoOiA1MDBweDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC5idXR0b24ge1xuICAgICAgICAgICAgICBtYXJnaW4tdG9wOiAuNWVtO1xuICAgICAgICAgICAgICBib3JkZXItcmFkaXVzOiAuMjVlbTtcbiAgICAgICAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgICAgICAgICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICAgICAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xuICAgICAgICAgICAgICBjb2xvcjogI2ZmZjtcbiAgICAgICAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gICAgICAgICAgICAgIHRyYW5zaXRpb246IGFsbCAuMjVzO1xuICAgICAgICAgICAgICBwYWRkaW5nOiA1cHggMTBweDtcbiAgICAgICAgICAgICAgZm9udC1zaXplOiAxLjRlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC5idXR0b246YWN0aXZlIHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoMHB4LCA1cHgpO1xuICAgICAgICAgICAgICBib3gtc2hhZG93OiAwIDFweCAwIDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC5idXR0b24ge1xuICAgICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAke2JhY2tHcm91bmRCbHVlfTtcbiAgICAgICAgICAgICAgYm94LXNoYWRvdzogMCAycHggNHB4IDAgJHtDb2xvcihiYWNrR3JvdW5kQmx1ZSkuZGFya2VuKDAuNSkuaHNsKCkuc3RyaW5nKCl9O1xuICAgICAgICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAuYnV0dG9uOmhvdmVyIHtcbiAgICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogJHtDb2xvcihiYWNrR3JvdW5kQmx1ZSkubGlnaHRlbigwLjIpLmhzbCgpLnN0cmluZygpfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgYH1cbiAgICAgICAgPC9zdHlsZT5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cbn1cblxuR2VuZXJhdGlvblVJLnByb3BUeXBlcyA9IHtcbiAgZ2VuZXJhdGVHYW1lOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxufTtcblxuY29uc3QgTnVtYmVyQ29udHJvbCA9ICh7IG51bWJlciwgb25DbGljaywgY29tcGxldGlvblBlcmNlbnRhZ2UgfSkgPT4gKFxuICA8ZGl2XG4gICAga2V5PXtudW1iZXJ9XG4gICAgY2xhc3NOYW1lPVwibnVtYmVyXCJcbiAgICBvbkNsaWNrPXtvbkNsaWNrfVxuICA+XG4gICAgPGRpdj57bnVtYmVyfTwvZGl2PlxuICAgIDxDaXJjbHVsYXJQcm9ncmVzcyBwZXJjZW50PXtjb21wbGV0aW9uUGVyY2VudGFnZX0gLz5cbiAgICA8c3R5bGUganN4PntOdW1iZXJDb250cm9sU3R5bGV9PC9zdHlsZT5cbiAgPC9kaXY+XG4pO1xuXG5OdW1iZXJDb250cm9sLnByb3BUeXBlcyA9IHtcbiAgbnVtYmVyOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIG9uQ2xpY2s6IFByb3BUeXBlcy5mdW5jLFxuICBjb21wbGV0aW9uUGVyY2VudGFnZTogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxufTtcblxuTnVtYmVyQ29udHJvbC5kZWZhdWx0UHJvcHMgPSB7XG4gIG9uQ2xpY2s6IG51bGwsXG59O1xuXG5jb25zdCBDZWxsID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHtcbiAgICB2YWx1ZSwgb25DbGljaywgaXNQZWVyLCBpc1NlbGVjdGVkLCBzYW1lVmFsdWUsIHByZWZpbGxlZCwgbm90ZXMsIGNvbmZsaWN0LFxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IGJhY2tncm91bmRDb2xvciA9IGdldEJhY2tHcm91bmRDb2xvcih7XG4gICAgY29uZmxpY3QsIGlzUGVlciwgc2FtZVZhbHVlLCBpc1NlbGVjdGVkLFxuICB9KTtcbiAgY29uc3QgZm9udENvbG9yID0gZ2V0Rm9udENvbG9yKHsgY29uZmxpY3QsIHByZWZpbGxlZCwgdmFsdWUgfSk7XG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJjZWxsXCIgb25DbGljaz17b25DbGlja30+XG4gICAgICB7XG4gICAgICAgIG5vdGVzID9cbiAgICAgICAgICByYW5nZSg5KS5tYXAoaSA9PlxuICAgICAgICAgICAgKFxuICAgICAgICAgICAgICA8ZGl2IGtleT17aX0gY2xhc3NOYW1lPVwibm90ZS1udW1iZXJcIj5cbiAgICAgICAgICAgICAgICB7bm90ZXMuaGFzKGkgKyAxKSAmJiAoaSArIDEpfVxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICkpIDpcbiAgICAgICAgICB2YWx1ZSAmJiB2YWx1ZVxuICAgICAgfVxuICAgICAgey8qIGxhbmd1YWdlPUNTUyAqL31cbiAgICAgIDxzdHlsZSBqc3g+e0NlbGxTdHlsZX08L3N0eWxlPlxuICAgICAgPHN0eWxlIGpzeD57YFxuICAgICAgICAgICAgICAgIC5jZWxsIHtcbiAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogJHtiYWNrZ3JvdW5kQ29sb3IgfHwgJ2luaXRpYWwnfTtcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6ICR7Zm9udENvbG9yIHx8ICdpbml0aWFsJ307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgYH1cbiAgICAgIDwvc3R5bGU+XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5DZWxsLnByb3BUeXBlcyA9IHtcbiAgLy8gY3VycmVudCBudW1iZXIgdmFsdWVcbiAgdmFsdWU6IFByb3BUeXBlcy5udW1iZXIsXG4gIC8vIGNlbGwgY2xpY2sgaGFuZGxlclxuICBvbkNsaWNrOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAvLyBpZiB0aGUgY2VsbCBpcyBhIHBlZXIgb2YgdGhlIHNlbGVjdGVkIGNlbGxcbiAgaXNQZWVyOiBQcm9wVHlwZXMuYm9vbC5pc1JlcXVpcmVkLFxuICAvLyBpZiB0aGUgY2VsbCBpcyBzZWxlY3RlZCBieSB0aGUgdXNlclxuICBpc1NlbGVjdGVkOiBQcm9wVHlwZXMuYm9vbC5pc1JlcXVpcmVkLFxuICAvLyBjdXJyZW50IGNlbGwgaGFzIHRoZSBzYW1lIHZhbHVlIGlmIHRoZSB1c2VyIHNlbGVjdGVkIGNlbGxcbiAgc2FtZVZhbHVlOiBQcm9wVHlwZXMuYm9vbC5pc1JlcXVpcmVkLFxuICAvLyBpZiB0aGlzIHdhcyBwcmVmaWxsZWQgYXMgYSBwYXJ0IG9mIHRoZSBwdXp6bGVcbiAgcHJlZmlsbGVkOiBQcm9wVHlwZXMuYm9vbC5pc1JlcXVpcmVkLFxuICAvLyBjdXJyZW50IG5vdGVzIHRha2VuIG9uIHRoZSBjZWxsXG4gIG5vdGVzOiBQcm9wVHlwZXMuaW5zdGFuY2VPZihTZXQpLFxuICAvLyBpZiB0aGUgY3VycmVudCBjZWxsIGRvZXMgbm90IHNhdGlzZnkgdGhlIGdhbWUgY29uc3RyYWludFxuICBjb25mbGljdDogUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZCxcbn07XG5cbkNlbGwuZGVmYXVsdFByb3BzID0ge1xuICBub3RlczogbnVsbCxcbiAgdmFsdWU6IG51bGwsXG59O1xuXG5jb25zdCBDaXJjbHVsYXJQcm9ncmVzcyA9ICh7IHBlcmNlbnQgfSkgPT4gKFxuICA8c3ZnIHZpZXdCb3g9XCIwIDAgMzYgMzZcIiBjbGFzc05hbWU9XCJjaXJjdWxhci1wcm9ncmVzc1wiPlxuICAgIDxwYXRoXG4gICAgICBjbGFzc05hbWU9XCJjaXJjbGUtYmdcIlxuICAgICAgZD17Q2lyY3VsYXJQYXRoRH1cbiAgICAvPlxuICAgIDxwYXRoXG4gICAgICBjbGFzc05hbWU9XCJjaXJjbGVcIlxuICAgICAgc3Ryb2tlRGFzaGFycmF5PXtgJHtwZXJjZW50ICogMTAwfSwgMTAwYH1cbiAgICAgIGQ9e0NpcmN1bGFyUGF0aER9XG4gICAgLz5cbiAgICB7IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG4gICAgPHN0eWxlIGpzeD57Q2lyY3VsdWFyUHJvZ3Jlc3NTdHlsZX08L3N0eWxlPlxuICA8L3N2Zz5cbik7XG5cbkNpcmNsdWxhclByb2dyZXNzLnByb3BUeXBlcyA9IHtcbiAgcGVyY2VudDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxufTtcblxuZnVuY3Rpb24gZ2V0Q2xpY2tIYW5kbGVyKG9uQ2xpY2ssIG9uRG91YmxlQ2xpY2ssIGRlbGF5ID0gMjUwKSB7XG4gIGxldCB0aW1lb3V0SUQgPSBudWxsO1xuICByZXR1cm4gKGV2ZW50KSA9PiB7XG4gICAgaWYgKCF0aW1lb3V0SUQpIHtcbiAgICAgIHRpbWVvdXRJRCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBvbkNsaWNrKGV2ZW50KTtcbiAgICAgICAgdGltZW91dElEID0gbnVsbDtcbiAgICAgIH0sIGRlbGF5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGltZW91dElEID0gY2xlYXJUaW1lb3V0KHRpbWVvdXRJRCk7XG4gICAgICBvbkRvdWJsZUNsaWNrKGV2ZW50KTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogbWFrZSBzaXplIDkgYXJyYXkgb2YgMHNcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZnVuY3Rpb24gbWFrZUNvdW50T2JqZWN0KCkge1xuICBjb25zdCBjb3VudE9iaiA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpICs9IDEpIGNvdW50T2JqLnB1c2goMCk7XG4gIHJldHVybiBjb3VudE9iajtcbn1cblxuLyoqXG4gKiBnaXZlbiBhIDJEIGFycmF5IG9mIG51bWJlcnMgYXMgdGhlIGluaXRpYWwgcHV6emxlLCBnZW5lcmF0ZSB0aGUgaW5pdGlhbCBnYW1lIHN0YXRlXG4gKiBAcGFyYW0gcHV6emxlXG4gKiBAcmV0dXJucyB7YW55fVxuICovXG5mdW5jdGlvbiBtYWtlQm9hcmQoeyBwdXp6bGUgfSkge1xuICAvLyBjcmVhdGUgaW5pdGlhbCBjb3VudCBvYmplY3QgdG8ga2VlcCB0cmFjayBvZiBjb25mbGljdHMgcGVyIG51bWJlciB2YWx1ZVxuICBjb25zdCByb3dzID0gQXJyYXkuZnJvbShBcnJheSg5KS5rZXlzKCkpLm1hcCgoKSA9PiBtYWtlQ291bnRPYmplY3QoKSk7XG4gIGNvbnN0IGNvbHVtbnMgPSBBcnJheS5mcm9tKEFycmF5KDkpLmtleXMoKSkubWFwKCgpID0+IG1ha2VDb3VudE9iamVjdCgpKTtcbiAgY29uc3Qgc3F1YXJlcyA9IEFycmF5LmZyb20oQXJyYXkoOSkua2V5cygpKS5tYXAoKCkgPT4gbWFrZUNvdW50T2JqZWN0KCkpO1xuICBjb25zdCByZXN1bHQgPSBwdXp6bGUubWFwKChyb3csIGkpID0+IChcbiAgICByb3cubWFwKChjZWxsLCBqKSA9PiB7XG4gICAgICBpZiAoY2VsbCkge1xuICAgICAgICByb3dzW2ldW2NlbGxdICs9IDE7XG4gICAgICAgIGNvbHVtbnNbal1bY2VsbF0gKz0gMTtcbiAgICAgICAgc3F1YXJlc1soKE1hdGguZmxvb3IoaSAvIDMpKSAqIDMpICsgTWF0aC5mbG9vcihqIC8gMyldW2NlbGxdICs9IDE7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogcHV6emxlW2ldW2pdID4gMCA/IHB1enpsZVtpXVtqXSA6IG51bGwsXG4gICAgICAgIHByZWZpbGxlZDogISFwdXp6bGVbaV1bal0sXG4gICAgICB9O1xuICAgIH0pXG4gICkpO1xuICByZXR1cm4gZnJvbUpTKHsgcHV6emxlOiByZXN1bHQsIHNlbGVjdGVkOiBmYWxzZSwgY2hvaWNlczogeyByb3dzLCBjb2x1bW5zLCBzcXVhcmVzIH0gfSk7XG59XG5cbi8qKlxuICogZ2l2ZSB0aGUgY29vcmRpbmF0ZSB1cGRhdGUgdGhlIGN1cnJlbnQgYm9hcmQgd2l0aCBhIG51bWJlciBjaG9pY2VcbiAqIEBwYXJhbSB4XG4gKiBAcGFyYW0geVxuICogQHBhcmFtIG51bWJlclxuICogQHBhcmFtIGZpbGwgd2hldGhlciB0byBzZXQgb3IgdW5zZXRcbiAqIEBwYXJhbSBib2FyZCB0aGUgaW1tdXRhYmxlIGJvYXJkIGdpdmVuIHRvIGNoYW5nZVxuICovXG5mdW5jdGlvbiB1cGRhdGVCb2FyZFdpdGhOdW1iZXIoe1xuICB4LCB5LCBudW1iZXIsIGZpbGwgPSB0cnVlLCBib2FyZCxcbn0pIHtcbiAgbGV0IGNlbGwgPSBib2FyZC5nZXQoJ3B1enpsZScpLmdldEluKFt4LCB5XSk7XG4gIC8vIGRlbGV0ZSBpdHMgbm90ZXNcbiAgY2VsbCA9IGNlbGwuZGVsZXRlKCdub3RlcycpO1xuICAvLyBzZXQgb3IgdW5zZXQgaXRzIHZhbHVlIGRlcGVuZGluZyBvbiBgZmlsbGBcbiAgY2VsbCA9IGZpbGwgPyBjZWxsLnNldCgndmFsdWUnLCBudW1iZXIpIDogY2VsbC5kZWxldGUoJ3ZhbHVlJyk7XG4gIGNvbnN0IGluY3JlbWVudCA9IGZpbGwgPyAxIDogLTE7XG4gIC8vIHVwZGF0ZSB0aGUgY3VycmVudCBncm91cCBjaG9pY2VzXG4gIGNvbnN0IHJvd1BhdGggPSBbJ2Nob2ljZXMnLCAncm93cycsIHgsIG51bWJlcl07XG4gIGNvbnN0IGNvbHVtblBhdGggPSBbJ2Nob2ljZXMnLCAnY29sdW1ucycsIHksIG51bWJlcl07XG4gIGNvbnN0IHNxdWFyZVBhdGggPSBbJ2Nob2ljZXMnLCAnc3F1YXJlcycsXG4gICAgKChNYXRoLmZsb29yKHggLyAzKSkgKiAzKSArIE1hdGguZmxvb3IoeSAvIDMpLCBudW1iZXJdO1xuICByZXR1cm4gYm9hcmQuc2V0SW4ocm93UGF0aCwgYm9hcmQuZ2V0SW4ocm93UGF0aCkgKyBpbmNyZW1lbnQpXG4gICAgLnNldEluKGNvbHVtblBhdGgsIGJvYXJkLmdldEluKGNvbHVtblBhdGgpICsgaW5jcmVtZW50KVxuICAgIC5zZXRJbihzcXVhcmVQYXRoLCBib2FyZC5nZXRJbihzcXVhcmVQYXRoKSArIGluY3JlbWVudClcbiAgICAuc2V0SW4oWydwdXp6bGUnLCB4LCB5XSwgY2VsbCk7XG59XG5cbmZ1bmN0aW9uIGdldE51bWJlck9mR3JvdXBzQXNzaWduZWRGb3JOdW1iZXIobnVtYmVyLCBncm91cHMpIHtcbiAgcmV0dXJuIGdyb3Vwcy5yZWR1Y2UoKGFjY3VtdWxhdG9yLCByb3cpID0+XG4gICAgYWNjdW11bGF0b3IgKyAocm93LmdldChudW1iZXIpID4gMCA/IDEgOiAwKSwgMCk7XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3Qvbm8tbXVsdGktY29tcFxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW5kZXggZXh0ZW5kcyBDb21wb25lbnQge1xuICBzdGF0ZSA9IHt9O1xuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgIGlmICgnc2VydmljZVdvcmtlcicgaW4gbmF2aWdhdG9yKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICAgIG5hdmlnYXRvci5zZXJ2aWNlV29ya2VyXG4gICAgICAgIC5yZWdpc3RlcignL3NlcnZpY2Utd29ya2VyLmpzJylcbiAgICAgICAgLnRoZW4oKHJlZykgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdTZXJ2aWNlV29ya2VyIHNjb3BlOiAnLCByZWcuc2NvcGUpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdzZXJ2aWNlIHdvcmtlciByZWdpc3RyYXRpb24gc3VjY2Vzc2Z1bCcpO1xuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgIGNvbnNvbGUud2Fybignc2VydmljZSB3b3JrZXIgcmVnaXN0cmF0aW9uIGZhaWxlZCcsIGVyci5tZXNzYWdlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICBcbiAgICBmZXRjaCgnL2FwaS9zb2NrZXRpbycpLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgY29uc3Qgc29ja2V0ID0gaW8oKVxuXG4gICAgICBzb2NrZXQub24oJ2Nvbm5lY3QnLCAoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdjb25uZWN0JylcbiAgICAgICAgc29ja2V0LmVtaXQoJ2hlbGxvJylcbiAgICAgIH0pXG5cbiAgICAgIHNvY2tldC5vbignaGVsbG8nLCBkYXRhID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ2hlbGxvJywgZGF0YSlcbiAgICAgIH0pXG5cbiAgICAgIHNvY2tldC5vbignYSB1c2VyIGNvbm5lY3RlZCcsICgpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ2EgdXNlciBjb25uZWN0ZWQnKVxuICAgICAgfSlcblxuICAgICAgc29ja2V0Lm9uKCdkaXNjb25uZWN0JywgKCkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZygnZGlzY29ubmVjdCcpXG4gICAgICB9KVxuICAgIH0pXG4gICBcbiAgfVxuICBnZXRTZWxlY3RlZENlbGwoKSB7XG4gICAgY29uc3QgeyBib2FyZCB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBzZWxlY3RlZCA9IGJvYXJkLmdldCgnc2VsZWN0ZWQnKTtcbiAgICByZXR1cm4gc2VsZWN0ZWQgJiYgYm9hcmQuZ2V0KCdwdXp6bGUnKS5nZXRJbihbc2VsZWN0ZWQueCwgc2VsZWN0ZWQueV0pO1xuICB9XG5cbiAgLy8gZ2V0IHRoZSBtaW4gYmV0d2VlbiBpdHMgY29tcGxldGlvbiBpbiByb3dzLCBjb2x1bW5zIGFuZCBzcXVhcmVzLlxuICBnZXROdW1iZXJWYWx1ZUNvdW50KG51bWJlcikge1xuICAgIGNvbnN0IHJvd3MgPSB0aGlzLnN0YXRlLmJvYXJkLmdldEluKFsnY2hvaWNlcycsICdyb3dzJ10pO1xuICAgIGNvbnN0IGNvbHVtbnMgPSB0aGlzLnN0YXRlLmJvYXJkLmdldEluKFsnY2hvaWNlcycsICdjb2x1bW5zJ10pO1xuICAgIGNvbnN0IHNxdWFyZXMgPSB0aGlzLnN0YXRlLmJvYXJkLmdldEluKFsnY2hvaWNlcycsICdzcXVhcmVzJ10pO1xuICAgIHJldHVybiBNYXRoLm1pbihcbiAgICAgIGdldE51bWJlck9mR3JvdXBzQXNzaWduZWRGb3JOdW1iZXIobnVtYmVyLCBzcXVhcmVzKSxcbiAgICAgIE1hdGgubWluKFxuICAgICAgICBnZXROdW1iZXJPZkdyb3Vwc0Fzc2lnbmVkRm9yTnVtYmVyKG51bWJlciwgcm93cyksXG4gICAgICAgIGdldE51bWJlck9mR3JvdXBzQXNzaWduZWRGb3JOdW1iZXIobnVtYmVyLCBjb2x1bW5zKSxcbiAgICAgICksXG4gICAgKTtcbiAgfVxuXG4gIGdlbmVyYXRlR2FtZSA9IChmaW5hbENvdW50ID0gMjApID0+IHtcbiAgICAvLyBnZXQgYSBmaWxsZWQgcHV6emxlIGdlbmVyYXRlZFxuICAgIGNvbnN0IHNvbHV0aW9uID0gbWFrZVB1enpsZSgpO1xuICAgIC8vIHBsdWNrIHZhbHVlcyBmcm9tIGNlbGxzIHRvIGNyZWF0ZSB0aGUgZ2FtZVxuICAgIGNvbnN0IHsgcHV6emxlIH0gPSBwbHVjayhzb2x1dGlvbiwgZmluYWxDb3VudCk7XG4gICAgLy8gaW5pdGlhbGl6ZSB0aGUgYm9hcmQgd2l0aCBjaG9pY2UgY291bnRzXG4gICAgY29uc3QgYm9hcmQgPSBtYWtlQm9hcmQoeyBwdXp6bGUgfSk7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBib2FyZCwgaGlzdG9yeTogTGlzdC5vZihib2FyZCksIGhpc3RvcnlPZmZTZXQ6IDAsIHNvbHV0aW9uLFxuICAgIH0pO1xuICB9XG5cbiAgYWRkTnVtYmVyQXNOb3RlID0gKG51bWJlcikgPT4ge1xuICAgIGxldCB7IGJvYXJkIH0gPSB0aGlzLnN0YXRlO1xuICAgIGxldCBzZWxlY3RlZENlbGwgPSB0aGlzLmdldFNlbGVjdGVkQ2VsbCgpO1xuICAgIGlmICghc2VsZWN0ZWRDZWxsKSByZXR1cm47XG4gICAgY29uc3QgcHJlZmlsbGVkID0gc2VsZWN0ZWRDZWxsLmdldCgncHJlZmlsbGVkJyk7XG4gICAgaWYgKHByZWZpbGxlZCkgcmV0dXJuO1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gYm9hcmQuZ2V0KCdzZWxlY3RlZCcpO1xuICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHNlbGVjdGVkQ2VsbC5nZXQoJ3ZhbHVlJyk7XG4gICAgaWYgKGN1cnJlbnRWYWx1ZSkge1xuICAgICAgYm9hcmQgPSB1cGRhdGVCb2FyZFdpdGhOdW1iZXIoe1xuICAgICAgICB4LCB5LCBudW1iZXI6IGN1cnJlbnRWYWx1ZSwgZmlsbDogZmFsc2UsIGJvYXJkOiB0aGlzLnN0YXRlLmJvYXJkLFxuICAgICAgfSk7XG4gICAgfVxuICAgIGxldCBub3RlcyA9IHNlbGVjdGVkQ2VsbC5nZXQoJ25vdGVzJykgfHwgU2V0KCk7XG4gICAgaWYgKG5vdGVzLmhhcyhudW1iZXIpKSB7XG4gICAgICBub3RlcyA9IG5vdGVzLmRlbGV0ZShudW1iZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub3RlcyA9IG5vdGVzLmFkZChudW1iZXIpO1xuICAgIH1cbiAgICBzZWxlY3RlZENlbGwgPSBzZWxlY3RlZENlbGwuc2V0KCdub3RlcycsIG5vdGVzKTtcbiAgICBzZWxlY3RlZENlbGwgPSBzZWxlY3RlZENlbGwuZGVsZXRlKCd2YWx1ZScpO1xuICAgIGJvYXJkID0gYm9hcmQuc2V0SW4oWydwdXp6bGUnLCB4LCB5XSwgc2VsZWN0ZWRDZWxsKTtcbiAgICB0aGlzLnVwZGF0ZUJvYXJkKGJvYXJkKTtcbiAgfTtcblxuICB1cGRhdGVCb2FyZCA9IChuZXdCb2FyZCkgPT4ge1xuICAgIGxldCB7IGhpc3RvcnkgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgeyBoaXN0b3J5T2ZmU2V0IH0gPSB0aGlzLnN0YXRlO1xuICAgIC8vIGFueXRoaW5nIGJlZm9yZSBjdXJyZW50IHN0ZXAgaXMgc3RpbGwgaW4gaGlzdG9yeVxuICAgIGhpc3RvcnkgPSBoaXN0b3J5LnNsaWNlKDAsIGhpc3RvcnlPZmZTZXQgKyAxKTtcbiAgICAvLyBhZGQgaXRzZWxmIG9udG8gdGhlIGhpc3RvcnlcbiAgICBoaXN0b3J5ID0gaGlzdG9yeS5wdXNoKG5ld0JvYXJkKTtcbiAgICAvLyB1cGRhdGUgdGhlIGdhbWVcbiAgICB0aGlzLnNldFN0YXRlKHsgYm9hcmQ6IG5ld0JvYXJkLCBoaXN0b3J5LCBoaXN0b3J5T2ZmU2V0OiBoaXN0b3J5LnNpemUgLSAxIH0pO1xuICB9O1xuXG4gIGNhblVuZG8gPSAoKSA9PiB0aGlzLnN0YXRlLmhpc3RvcnlPZmZTZXQgPiAwXG5cbiAgcmVkbyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGhpc3RvcnkgfSA9IHRoaXMuc3RhdGU7XG4gICAgbGV0IHsgaGlzdG9yeU9mZlNldCB9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAoaGlzdG9yeS5zaXplKSB7XG4gICAgICBoaXN0b3J5T2ZmU2V0ID0gTWF0aC5taW4oaGlzdG9yeS5zaXplIC0gMSwgaGlzdG9yeU9mZlNldCArIDEpO1xuICAgICAgY29uc3QgYm9hcmQgPSBoaXN0b3J5LmdldChoaXN0b3J5T2ZmU2V0KTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBib2FyZCwgaGlzdG9yeU9mZlNldCB9KTtcbiAgICB9XG4gIH07XG5cbiAgdW5kbyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGhpc3RvcnkgfSA9IHRoaXMuc3RhdGU7XG4gICAgbGV0IHsgaGlzdG9yeU9mZlNldCwgYm9hcmQgfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKGhpc3Rvcnkuc2l6ZSkge1xuICAgICAgaGlzdG9yeU9mZlNldCA9IE1hdGgubWF4KDAsIGhpc3RvcnlPZmZTZXQgLSAxKTtcbiAgICAgIGJvYXJkID0gaGlzdG9yeS5nZXQoaGlzdG9yeU9mZlNldCk7XG4gICAgICB0aGlzLnNldFN0YXRlKHsgYm9hcmQsIGhpc3RvcnlPZmZTZXQsIGhpc3RvcnkgfSk7XG4gICAgfVxuICB9O1xuXG4gIGVyYXNlU2VsZWN0ZWQgPSAoKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0ZWRDZWxsID0gdGhpcy5nZXRTZWxlY3RlZENlbGwoKTtcbiAgICBpZiAoIXNlbGVjdGVkQ2VsbCkgcmV0dXJuO1xuICAgIHRoaXMuZmlsbE51bWJlcihmYWxzZSk7XG4gIH1cblxuICBmaWxsU2VsZWN0ZWRXaXRoU29sdXRpb24gPSAoKSA9PiB7XG4gICAgY29uc3QgeyBib2FyZCwgc29sdXRpb24gfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3Qgc2VsZWN0ZWRDZWxsID0gdGhpcy5nZXRTZWxlY3RlZENlbGwoKTtcbiAgICBpZiAoIXNlbGVjdGVkQ2VsbCkgcmV0dXJuO1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gYm9hcmQuZ2V0KCdzZWxlY3RlZCcpO1xuICAgIHRoaXMuZmlsbE51bWJlcihzb2x1dGlvblt4XVt5XSk7XG4gIH1cblxuXG4gIC8vIGZpbGwgY3VycmVudGx5IHNlbGVjdGVkIGNlbGwgd2l0aCBudW1iZXJcbiAgZmlsbE51bWJlciA9IChudW1iZXIpID0+IHtcbiAgICBsZXQgeyBib2FyZCB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBzZWxlY3RlZENlbGwgPSB0aGlzLmdldFNlbGVjdGVkQ2VsbCgpO1xuICAgIC8vIG5vLW9wIGlmIG5vdGhpbmcgaXMgc2VsZWN0ZWRcbiAgICBpZiAoIXNlbGVjdGVkQ2VsbCkgcmV0dXJuO1xuICAgIGNvbnN0IHByZWZpbGxlZCA9IHNlbGVjdGVkQ2VsbC5nZXQoJ3ByZWZpbGxlZCcpO1xuICAgIC8vIG5vLW9wIGlmIGl0IGlzIHJlZmlsbGVkXG4gICAgaWYgKHByZWZpbGxlZCkgcmV0dXJuO1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gYm9hcmQuZ2V0KCdzZWxlY3RlZCcpO1xuICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHNlbGVjdGVkQ2VsbC5nZXQoJ3ZhbHVlJyk7XG4gICAgLy8gcmVtb3ZlIHRoZSBjdXJyZW50IHZhbHVlIGFuZCB1cGRhdGUgdGhlIGdhbWUgc3RhdGVcbiAgICBpZiAoY3VycmVudFZhbHVlKSB7XG4gICAgICBib2FyZCA9IHVwZGF0ZUJvYXJkV2l0aE51bWJlcih7XG4gICAgICAgIHgsIHksIG51bWJlcjogY3VycmVudFZhbHVlLCBmaWxsOiBmYWxzZSwgYm9hcmQ6IHRoaXMuc3RhdGUuYm9hcmQsXG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gdXBkYXRlIHRvIG5ldyBudW1iZXIgaWYgYW55XG4gICAgY29uc3Qgc2V0TnVtYmVyID0gY3VycmVudFZhbHVlICE9PSBudW1iZXIgJiYgbnVtYmVyO1xuICAgIGlmIChzZXROdW1iZXIpIHtcbiAgICAgIGJvYXJkID0gdXBkYXRlQm9hcmRXaXRoTnVtYmVyKHtcbiAgICAgICAgeCwgeSwgbnVtYmVyLCBmaWxsOiB0cnVlLCBib2FyZCxcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZUJvYXJkKGJvYXJkKTtcbiAgfTtcblxuICBzZWxlY3RDZWxsID0gKHgsIHkpID0+IHtcbiAgICBsZXQgeyBib2FyZCB9ID0gdGhpcy5zdGF0ZTtcbiAgICBib2FyZCA9IGJvYXJkLnNldCgnc2VsZWN0ZWQnLCB7IHgsIHkgfSk7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IGJvYXJkIH0pO1xuICB9O1xuXG4gIGlzQ29uZmxpY3QoaSwgaikge1xuICAgIGNvbnN0IHsgdmFsdWUgfSA9IHRoaXMuc3RhdGUuYm9hcmQuZ2V0SW4oWydwdXp6bGUnLCBpLCBqXSkudG9KU09OKCk7XG4gICAgaWYgKCF2YWx1ZSkgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IHJvd0NvbmZsaWN0ID1cbiAgICAgIHRoaXMuc3RhdGUuYm9hcmQuZ2V0SW4oWydjaG9pY2VzJywgJ3Jvd3MnLCBpLCB2YWx1ZV0pID4gMTtcbiAgICBjb25zdCBjb2x1bW5Db25mbGljdCA9XG4gICAgICB0aGlzLnN0YXRlLmJvYXJkLmdldEluKFsnY2hvaWNlcycsICdjb2x1bW5zJywgaiwgdmFsdWVdKSA+IDE7XG4gICAgY29uc3Qgc3F1YXJlQ29uZmxpY3QgPVxuICAgICAgdGhpcy5zdGF0ZS5ib2FyZC5nZXRJbihbJ2Nob2ljZXMnLCAnc3F1YXJlcycsXG4gICAgICAgICgoTWF0aC5mbG9vcihpIC8gMykpICogMykgKyBNYXRoLmZsb29yKGogLyAzKSwgdmFsdWVdKSA+IDE7XG4gICAgcmV0dXJuIHJvd0NvbmZsaWN0IHx8IGNvbHVtbkNvbmZsaWN0IHx8IHNxdWFyZUNvbmZsaWN0O1xuICB9XG5cbiAgcmVuZGVyQ2VsbChjZWxsLCB4LCB5KSB7XG4gICAgY29uc3QgeyBib2FyZCB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBzZWxlY3RlZCA9IHRoaXMuZ2V0U2VsZWN0ZWRDZWxsKCk7XG4gICAgY29uc3QgeyB2YWx1ZSwgcHJlZmlsbGVkLCBub3RlcyB9ID0gY2VsbC50b0pTT04oKTtcbiAgICBjb25zdCBjb25mbGljdCA9IHRoaXMuaXNDb25mbGljdCh4LCB5KTtcbiAgICBjb25zdCBwZWVyID0gYXJlQ29vcmRpbmF0ZVBlZXJzKHsgeCwgeSB9LCBib2FyZC5nZXQoJ3NlbGVjdGVkJykpO1xuICAgIGNvbnN0IHNhbWVWYWx1ZSA9ICEhKHNlbGVjdGVkICYmIHNlbGVjdGVkLmdldCgndmFsdWUnKVxuICAgICAgJiYgdmFsdWUgPT09IHNlbGVjdGVkLmdldCgndmFsdWUnKSk7XG5cbiAgICBjb25zdCBpc1NlbGVjdGVkID0gY2VsbCA9PT0gc2VsZWN0ZWQ7XG4gICAgcmV0dXJuICg8Q2VsbFxuICAgICAgcHJlZmlsbGVkPXtwcmVmaWxsZWR9XG4gICAgICBub3Rlcz17bm90ZXN9XG4gICAgICBzYW1lVmFsdWU9e3NhbWVWYWx1ZX1cbiAgICAgIGlzU2VsZWN0ZWQ9e2lzU2VsZWN0ZWR9XG4gICAgICBpc1BlZXI9e3BlZXJ9XG4gICAgICB2YWx1ZT17dmFsdWV9XG4gICAgICBvbkNsaWNrPXsoKSA9PiB7IHRoaXMuc2VsZWN0Q2VsbCh4LCB5KTsgfX1cbiAgICAgIGtleT17eX1cbiAgICAgIHg9e3h9XG4gICAgICB5PXt5fVxuICAgICAgY29uZmxpY3Q9e2NvbmZsaWN0fVxuICAgIC8+KTtcbiAgfVxuXG4gIHJlbmRlck51bWJlckNvbnRyb2woKSB7XG4gICAgY29uc3Qgc2VsZWN0ZWRDZWxsID0gdGhpcy5nZXRTZWxlY3RlZENlbGwoKTtcbiAgICBjb25zdCBwcmVmaWxsZWQgPSBzZWxlY3RlZENlbGwgJiYgc2VsZWN0ZWRDZWxsLmdldCgncHJlZmlsbGVkJyk7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29udHJvbFwiPlxuICAgICAgICB7cmFuZ2UoOSkubWFwKChpKSA9PiB7XG4gICAgICAgICAgY29uc3QgbnVtYmVyID0gaSArIDE7XG4gICAgICAgICAgLy8gaGFuZGxlcyBiaW5kaW5nIHNpbmdsZSBjbGljayBhbmQgZG91YmxlIGNsaWNrIGNhbGxiYWNrc1xuICAgICAgICAgIGNvbnN0IGNsaWNrSGFuZGxlID0gZ2V0Q2xpY2tIYW5kbGVyKFxuICAgICAgICAgICAgKCkgPT4geyB0aGlzLmZpbGxOdW1iZXIobnVtYmVyKTsgfSxcbiAgICAgICAgICAgICgpID0+IHsgdGhpcy5hZGROdW1iZXJBc05vdGUobnVtYmVyKTsgfSxcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8TnVtYmVyQ29udHJvbFxuICAgICAgICAgICAgICBrZXk9e251bWJlcn1cbiAgICAgICAgICAgICAgbnVtYmVyPXtudW1iZXJ9XG4gICAgICAgICAgICAgIG9uQ2xpY2s9eyFwcmVmaWxsZWQgPyBjbGlja0hhbmRsZSA6IHVuZGVmaW5lZH1cbiAgICAgICAgICAgICAgY29tcGxldGlvblBlcmNlbnRhZ2U9e3RoaXMuZ2V0TnVtYmVyVmFsdWVDb3VudChudW1iZXIpIC8gOX1cbiAgICAgICAgICAgIC8+KTtcbiAgICAgICAgfSl9XG4gICAgICAgIDxzdHlsZSBqc3g+e0NvbnRyb2xTdHlsZX08L3N0eWxlPlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxuXG4gIHJlbmRlckFjdGlvbnMoKSB7XG4gICAgY29uc3QgeyBoaXN0b3J5IH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IHNlbGVjdGVkQ2VsbCA9IHRoaXMuZ2V0U2VsZWN0ZWRDZWxsKCk7XG4gICAgY29uc3QgcHJlZmlsbGVkID0gc2VsZWN0ZWRDZWxsICYmIHNlbGVjdGVkQ2VsbC5nZXQoJ3ByZWZpbGxlZCcpO1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImFjdGlvbnNcIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJhY3Rpb25cIiBvbkNsaWNrPXtoaXN0b3J5LnNpemUgPyB0aGlzLnVuZG8gOiBudWxsfT5cbiAgICAgICAgICA8UmVsb2FkSWNvbiAvPlVuZG9cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWN0aW9uIHJlZG9cIiBvbkNsaWNrPXtoaXN0b3J5LnNpemUgPyB0aGlzLnJlZG8gOiBudWxsfT5cbiAgICAgICAgICA8UmVsb2FkSWNvbiAvPlJlZG9cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWN0aW9uXCIgb25DbGljaz17IXByZWZpbGxlZCA/IHRoaXMuZXJhc2VTZWxlY3RlZCA6IG51bGx9PlxuICAgICAgICAgIDxSZW1vdmVJY29uIC8+RXJhc2VcbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXZcbiAgICAgICAgICBjbGFzc05hbWU9XCJhY3Rpb25cIlxuICAgICAgICAgIG9uQ2xpY2s9eyFwcmVmaWxsZWQgP1xuICAgICAgICAgIHRoaXMuZmlsbFNlbGVjdGVkV2l0aFNvbHV0aW9uIDogbnVsbH1cbiAgICAgICAgPlxuICAgICAgICAgIDxMb3VwZUljb24gLz5IaW50XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8c3R5bGUganN4PntBY3Rpb25zU3R5bGV9PC9zdHlsZT5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cblxuICByZW5kZXJQdXp6bGUoKSB7XG4gICAgY29uc3QgeyBib2FyZCB9ID0gdGhpcy5zdGF0ZTtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJwdXp6bGVcIj5cbiAgICAgICAge2JvYXJkLmdldCgncHV6emxlJykubWFwKChyb3csIGkpID0+IChcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3Qvbm8tYXJyYXktaW5kZXgta2V5XG4gICAgICAgICAgPGRpdiBrZXk9e2l9IGNsYXNzTmFtZT1cInJvd1wiPlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICByb3cubWFwKChjZWxsLCBqKSA9PiB0aGlzLnJlbmRlckNlbGwoY2VsbCwgaSwgaikpLnRvQXJyYXkoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICApKS50b0FycmF5KCl9XG4gICAgICAgIDxzdHlsZSBqc3g+e1B1enpsZVN0eWxlfTwvc3R5bGU+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG5cbiAgcmVuZGVyQ29udHJvbHMoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29udHJvbHNcIj5cbiAgICAgICAge3RoaXMucmVuZGVyTnVtYmVyQ29udHJvbCgpfVxuICAgICAgICB7dGhpcy5yZW5kZXJBY3Rpb25zKCl9XG4gICAgICAgIHsgLyogbGFuZ3VhZ2U9Q1NTICovIH1cbiAgICAgICAgPHN0eWxlIGpzeD57YFxuICAgICAgICAgICAgLmNvbnRyb2xzIHtcbiAgICAgICAgICAgICAgICBtYXJnaW4tdG9wOiAuM2VtO1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgICAgICAgZmxleC13cmFwOiB3cmFwO1xuICAgICAgICAgICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICAgICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICAgICAgICAgIHBhZGRpbmc6IC41ZW0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgYH1cbiAgICAgICAgPC9zdHlsZT5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cblxuICByZW5kZXJHZW5lcmF0aW9uVUkoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxHZW5lcmF0aW9uVUkgZ2VuZXJhdGVHYW1lPXt0aGlzLmdlbmVyYXRlR2FtZX0gLz5cbiAgICApO1xuICB9XG5cbiAgcmVuZGVySGVhZGVyKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImhlYWRlclwiPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm5ldy1nYW1lXCIgb25DbGljaz17KCkgPT4gdGhpcy5zZXRTdGF0ZSh7IGJvYXJkOiBmYWxzZSB9KX0+XG4gICAgICAgICAgPFJldHVybkljb24gLz5cbiAgICAgICAgICA8ZGl2Pk5ldyBHYW1lPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8VGlwIC8+XG4gICAgICAgIHsgLyogbGFuZ3VhZ2U9Q1NTICovIH1cbiAgICAgICAgPHN0eWxlIGpzeD57YFxuICAgICAgICAgICAgLmhlYWRlciB7XG4gICAgICAgICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gICAgICAgICAgICAgICAgbWF4LXdpZHRoOiA1MDBweDtcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiAwIDAuNWVtO1xuICAgICAgICAgICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAubmV3LWdhbWUge1xuICAgICAgICAgICAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICAgICAgICAgICAgICBtYXJnaW4tdG9wOiAuMmVtO1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6IGlubGluZS1mbGV4O1xuICAgICAgICAgICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgICAgICAgICAgcGFkZGluZzogLjJlbSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLm5ldy1nYW1lIDpnbG9iYWwoc3ZnKSB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxZW07XG4gICAgICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogLjNlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgYH1cbiAgICAgICAgPC9zdHlsZT5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBib2FyZCB9ID0gdGhpcy5zdGF0ZTtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJib2R5XCI+XG4gICAgICAgIDxOZXh0SGVhZD5cbiAgICAgICAgICA8dGl0bGU+U3Vkb2t1IEV2b2x2ZWQ8L3RpdGxlPlxuICAgICAgICAgIDxtZXRhIG5hbWU9XCJ2aWV3cG9ydFwiIGNvbnRlbnQ9XCJpbml0aWFsLXNjYWxlPTEuMCwgd2lkdGg9ZGV2aWNlLXdpZHRoXCIgLz5cbiAgICAgICAgICA8bWV0YSBuYW1lPVwiZGVzY3JpcHRpb25cIiBjb250ZW50PXtEZXNjcmlwdGlvbn0gLz5cbiAgICAgICAgICA8bGluayBocmVmPVwiaHR0cHM6Ly9mb250cy5nb29nbGVhcGlzLmNvbS9jc3M/ZmFtaWx5PVNwZWNpYWwrRWxpdGVcIiByZWw9XCJzdHlsZXNoZWV0XCIgLz5cbiAgICAgICAgICA8bWV0YSBwcm9wZXJ0eT1cIm9nOnVybFwiIGNvbnRlbnQ9XCJodHRwczovL3N1ZG9rdS5zaXRpYW5saXUuY29tL1wiIC8+XG4gICAgICAgICAgPG1ldGEgcHJvcGVydHk9XCJvZzp0aXRsZVwiIGNvbnRlbnQ9XCJTdWRva3UgRXZvbHZlZFwiIC8+XG4gICAgICAgICAgPG1ldGEgcHJvcGVydHk9XCJvZzp0eXBlXCIgY29udGVudD1cIndlYnNpdGVcIiAvPlxuICAgICAgICAgIDxtZXRhIHByb3BlcnR5PVwib2c6ZGVzY3JpcHRpb25cIiBjb250ZW50PXtEZXNjcmlwdGlvbn0gLz5cbiAgICAgICAgICA8bWV0YSBwcm9wZXJ0eT1cIm9nOmltYWdlXCIgY29udGVudD1cImh0dHBzOi8vc3Vkb2t1LnNpdGlhbmxpdS5jb20vc3RhdGljL29nLWltYWdlLnBuZ1wiIC8+XG4gICAgICAgIDwvTmV4dEhlYWQ+XG4gICAgICAgIHshYm9hcmQgJiYgdGhpcy5yZW5kZXJHZW5lcmF0aW9uVUkoKX1cbiAgICAgICAge2JvYXJkICYmIHRoaXMucmVuZGVySGVhZGVyKCl9XG4gICAgICAgIHtib2FyZCAmJiB0aGlzLnJlbmRlclB1enpsZSgpfVxuICAgICAgICB7Ym9hcmQgJiYgdGhpcy5yZW5kZXJDb250cm9scygpfVxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInJvb3RlclwiPlxuICAgICAgICAgIE1hZGUgd2l0aCA8c3Bhbj7inaTvuI88L3NwYW4+77iPIEJ5IDxhIGhyZWY9XCJodHRwczovL3d3dy5zaXRpYW5saXUuY29tL1wiPlNpdGlhbiBMaXU8L2E+IHwgPGEgaHJlZj1cImh0dHBzOi8vbWVkaXVtLmNvbS9Ac2l0aWFubGl1XzU3NjgwL2J1aWxkaW5nLWEtc3Vkb2t1LWdhbWUtaW4tcmVhY3QtY2E2NjM5MTU3MTJcIj5CbG9nIFBvc3Q8L2E+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICB7IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG4gICAgICAgIDxzdHlsZSBqc3g+e2BcbiAgICAgICAgICAgIDpnbG9iYWwoYm9keSksIC5ib2R5IHtcbiAgICAgICAgICAgICAgICBmb250LWZhbWlseTogJ1NwZWNpYWwgRWxpdGUnLCBjdXJzaXZlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLmJvZHkge1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICAgICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICAgICAgICAgIGhlaWdodDogMTAwdmg7XG4gICAgICAgICAgICAgICAgd2lkdGg6IDEwMHZ3O1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEBtZWRpYSAobWluLXdpZHRoOiA4MDBweCkgYW5kIChtaW4taGVpZ2h0OiA5MzBweCl7XG4gICAgICAgICAgICAgICAgOmdsb2JhbCguaGVhZGVyLCAucHV6emxlLCAuY29udHJvbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9udC1zaXplOiAxLjVlbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBAbWVkaWEgKG1heC13aWR0aDogODAwcHgpIGFuZCAobWluLXdpZHRoOiA2MDBweCl7XG4gICAgICAgICAgICAgICAgOmdsb2JhbCguaGVhZGVyLCAucHV6emxlLCAuY29udHJvbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9udC1zaXplOiAxLjJlbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBAbWVkaWEgKG1heC1oZWlnaHQ6IDkzMHB4KSBhbmQgKG1pbi1oZWlnaHQ6IDgwMHB4KSBhbmQgKG1pbi13aWR0aDogNjAwcHgpe1xuICAgICAgICAgICAgICAgIDpnbG9iYWwoLmhlYWRlciwgLnB1enpsZSwgLmNvbnRyb2xzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvbnQtc2l6ZTogMS4yZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQG1lZGlhIChtYXgtaGVpZ2h0OiA4MDBweCkgYW5kIChtaW4taGVpZ2h0OiA2MDBweCkgYW5kIChtaW4td2lkdGg6IDM3MHB4KXtcbiAgICAgICAgICAgICAgICA6Z2xvYmFsKC5oZWFkZXIsIC5wdXp6bGUsIC5jb250cm9scykge1xuICAgICAgICAgICAgICAgICAgICBmb250LXNpemU6IDFlbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBAbWVkaWEgKG1heC13aWR0aDogMzcwcHgpe1xuICAgICAgICAgICAgICAgIDpnbG9iYWwoLmhlYWRlciwgLnB1enpsZSwgLmNvbnRyb2xzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvbnQtc2l6ZTogLjhlbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBAbWVkaWEgKG1heC1oZWlnaHQ6IDYwMHB4KXtcbiAgICAgICAgICAgICAgICA6Z2xvYmFsKC5oZWFkZXIsIC5wdXp6bGUsIC5jb250cm9scykge1xuICAgICAgICAgICAgICAgICAgICBmb250LXNpemU6IC44ZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOmdsb2JhbChib2R5KSB7XG4gICAgICAgICAgICAgICAgbWFyZ2luOiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLnJvb3RlciB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgICAgICAgICAgIGJvdHRvbTogMDtcbiAgICAgICAgICAgICAgICBmb250LXNpemU6IC44ZW07XG4gICAgICAgICAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgICAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICBgfVxuICAgICAgICA8L3N0eWxlPlxuICAgICAgICA8c3R5bGUganN4IGdsb2JhbD57UmFuZ2VTdHlsZX08L3N0eWxlPlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufVxuIl19 */\n/*@ sourceURL=pages/index.js */';
CellStyle.__scopedHash = '3895838756';
{/* language=CSS */}
var ActionsStyle = new String('.actions{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;width:100%;max-width:400px;margin-top:.5em;padding:0 .6em;}.action{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;}.action svg{width:2.5em;margin-bottom:.2em;}.redo svg{-webkit-transform:scaleX(-1);-ms-transform:scaleX(-1);transform:scaleX(-1);}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhZ2VzL2luZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQW1Fd0IsQUFHa0IsQUFTQSxBQUtELEFBSVMsWUFIRixtQkFDdkIsMkNBZnVCLEFBU0EsQ0FTdkIsNEZBakJrQyxBQVNSLDhFQUMxQixxQ0FUZSxXQUNLLGdCQUNBLGdCQUNELGVBQ25CIiwiZmlsZSI6InBhZ2VzL2luZGV4LmpzIiwic291cmNlUm9vdCI6Ii9Vc2Vycy9saWNoZW5tYS9Qcm9qZWN0cy9TdUR1b2t1L1N1RHVva3UiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBqc3gtYTExeS9hY2Nlc3NpYmxlLWVtb2ppICovXG5pbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50LCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBTZXQsIExpc3QsIGZyb21KUyB9IGZyb20gJ2ltbXV0YWJsZSc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IE5leHRIZWFkIGZyb20gJ25leHQvaGVhZCc7XG5pbXBvcnQgQ29sb3IgZnJvbSAnY29sb3InO1xuaW1wb3J0IElucHV0UmFuZ2UgZnJvbSAncmVhY3QtaW5wdXQtcmFuZ2UnO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLWV4dHJhbmVvdXMtZGVwZW5kZW5jaWVzXG5pbXBvcnQgY3NzIGZyb20gJ3N0eWxlZC1qc3gvY3NzJztcblxuaW1wb3J0IFJhbmdlU3R5bGUgZnJvbSAnLi4vaW5wdXQtcmFuZ2Utc3R5bGUnO1xuaW1wb3J0IExvdXBlSWNvbiBmcm9tICcuLi9zdmcvbG91cGUuc3ZnJztcbmltcG9ydCBSZW1vdmVJY29uIGZyb20gJy4uL3N2Zy9yZW1vdmUuc3ZnJztcbmltcG9ydCBSZWxvYWRJY29uIGZyb20gJy4uL3N2Zy9yZWxvYWQuc3ZnJztcbmltcG9ydCBSZXR1cm5JY29uIGZyb20gJy4uL3N2Zy9yZXR1cm4uc3ZnJztcblxuaW1wb3J0IHsgbWFrZVB1enpsZSwgcGx1Y2ssIGlzUGVlciBhcyBhcmVDb29yZGluYXRlUGVlcnMsIHJhbmdlIH0gZnJvbSAnLi4vc3Vkb2t1JztcbmltcG9ydCB7IGJhY2tHcm91bmRCbHVlIH0gZnJvbSAnLi4vY29sb3JzJztcbmltcG9ydCBUaXAgZnJvbSAnLi4vY29tcG9uZW50cy90b29sLXRpcCc7XG5cbmltcG9ydCBpbyBmcm9tICdzb2NrZXQuaW8tY2xpZW50J1xuXG5jb25zdCBEZXNjcmlwdGlvbiA9ICdEaXNjb3ZlciB0aGUgbmV4dCBldm9sdXRpb24gb2YgU3Vkb2t1IHdpdGggYW1hemluZyBncmFwaGljcywgYW5pbWF0aW9ucywgYW5kIHVzZXItZnJpZW5kbHkgZmVhdHVyZXMuIEVuam95IGEgU3Vkb2t1IGV4cGVyaWVuY2UgbGlrZSB5b3UgbmV2ZXIgaGF2ZSBiZWZvcmUgd2l0aCBjdXN0b21pemFibGUgZ2FtZSBnZW5lcmF0aW9uLCBjZWxsIGhpZ2hsaWdodGluZywgaW50dWl0aXZlIGNvbnRyb2xzIGFuZCBtb3JlISc7XG5jb25zdCBjZWxsV2lkdGggPSAyLjU7XG5cbmNvbnN0IExpZ2h0Qmx1ZTEwMCA9ICcjQjNFNUZDJztcbmNvbnN0IExpZ2h0Qmx1ZTIwMCA9ICcjODFENEZBJztcbmNvbnN0IExpZ2h0Qmx1ZTMwMCA9ICcjNEZDM0Y3JztcbmNvbnN0IEluZGlnbzcwMCA9ICcjMzAzRjlGJztcbmNvbnN0IERlZXBPcmFuZ2UyMDAgPSAnI0ZGQUI5MSc7XG5jb25zdCBEZWVwT3JhbmdlNjAwID0gJyNGNDUxMUUnO1xuY29uc3QgQ29udHJvbE51bWJlckNvbG9yID0gSW5kaWdvNzAwO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbG9uZS1ibG9ja3NcbnsgLyogbGFuZ3VhZ2U9Q1NTICovIH1cbmNvbnN0IENlbGxTdHlsZSA9IGNzc2Bcbi5jZWxsIHtcbiAgICBoZWlnaHQ6ICR7Y2VsbFdpZHRofWVtO1xuICAgIHdpZHRoOiAke2NlbGxXaWR0aH1lbTtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtd3JhcDogd3JhcDtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgIGZvbnQtc2l6ZTogMS4xZW07XG4gICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgdHJhbnNpdGlvbjogYmFja2dyb3VuZC1jb2xvciAuM3MgZWFzZS1pbi1vdXQ7XG59XG4uY2VsbDpudGgtY2hpbGQoM24rMyk6bm90KDpsYXN0LWNoaWxkKSB7XG4gICAgYm9yZGVyLXJpZ2h0OiAycHggc29saWQgYmxhY2s7XG59XG4uY2VsbDpub3QoOmxhc3QtY2hpbGQpIHtcbiAgICBib3JkZXItcmlnaHQ6IDFweCBzb2xpZCBibGFjaztcbn1cbi5ub3RlLW51bWJlciB7XG4gICAgZm9udC1zaXplOiAuNmVtO1xuICAgIHdpZHRoOiAzMyU7XG4gICAgaGVpZ2h0OiAzMyU7XG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG59XG5gO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbG9uZS1ibG9ja3NcbnsgLyogbGFuZ3VhZ2U9Q1NTICovIH1cbmNvbnN0IEFjdGlvbnNTdHlsZSA9IGNzc2Bcbi5hY3Rpb25zIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIG1heC13aWR0aDogNDAwcHg7XG4gICAgbWFyZ2luLXRvcDogLjVlbTtcbiAgICBwYWRkaW5nOiAwIC42ZW07XG59XG4uYWN0aW9uIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbn1cbi5hY3Rpb24gOmdsb2JhbChzdmcpIHtcbiAgICB3aWR0aDogMi41ZW07XG4gICAgbWFyZ2luLWJvdHRvbTogLjJlbTtcbn1cbi5yZWRvIDpnbG9iYWwoc3ZnKSB7XG4gICAgdHJhbnNmb3JtOiBzY2FsZVgoLTEpO1xufVxuYDtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxvbmUtYmxvY2tzXG57IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG5jb25zdCBDb250cm9sU3R5bGUgPSBjc3NgXG4uY29udHJvbCB7XG4gICAgcGFkZGluZzogMCAyZW07XG4gICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIGRpc3BsYXk6IGlubGluZS1mbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgZmxleC13cmFwOiB3cmFwO1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgIGZvbnQtZmFtaWx5OiAnU3BlY2lhbCBFbGl0ZScsIGN1cnNpdmU7XG4gICAgdHJhbnNpdGlvbjogZmlsdGVyIC41cyBlYXNlLWluLW91dDtcbiAgICB3aWR0aDogMTAwJTtcbn1cbmA7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sb25lLWJsb2Nrc1xueyAvKiBsYW5ndWFnZT1DU1MgKi8gfVxuY29uc3QgTnVtYmVyQ29udHJvbFN0eWxlID0gY3NzYFxuLm51bWJlciB7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBmb250LXNpemU6IDJlbTtcbiAgICBtYXJnaW46IC4xZW07XG4gICAgd2lkdGg6IDEuNWVtO1xuICAgIGhlaWdodDogMS41ZW07XG4gICAgY29sb3I6ICR7Q29udHJvbE51bWJlckNvbG9yfTtcbiAgICBib3gtc2hhZG93OiAwIDFweCAycHggcmdiYSgwLDAsMCwwLjE2KSwgMCAxcHggMnB4IHJnYmEoMCwwLDAsMC4yMyk7XG4gICAgYm9yZGVyLXJhZGl1czogNTAlO1xufVxuLm51bWJlciA+IGRpdiB7XG4gICAgbWFyZ2luLXRvcDogLjNlbTtcbn1cbmA7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sb25lLWJsb2Nrc1xueyAvKiBsYW5ndWFnZT1DU1MgKi8gfVxuY29uc3QgUHV6emxlU3R5bGUgPSBjc3NgXG4ucHV6emxlIHtcbiAgICBtYXJnaW4tdG9wOiAuNWVtO1xuICAgIHdpZHRoOiAke2NlbGxXaWR0aCAqIDl9ZW07XG4gICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIGJveC1zaGFkb3c6IDAgM3B4IDZweCByZ2JhKDAsMCwwLDAuMTYpLCAwIDNweCA2cHggcmdiYSgwLDAsMCwwLjIzKTtcbn1cbi5yb3cge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBmbGV4OiAwO1xuICAgIHdpZHRoOiAke2NlbGxXaWR0aCAqIDl9ZW07XG59XG4ucm93Om5vdCg6bGFzdC1jaGlsZCkge1xuICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCBibGFjaztcbn1cbi5yb3c6bnRoLWNoaWxkKDNuKzMpOm5vdCg6bGFzdC1jaGlsZCkge1xuICAgIGJvcmRlci1ib3R0b206IDJweCBzb2xpZCBibGFjayAhaW1wb3J0YW50O1xufVxuYDtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxvbmUtYmxvY2tzXG57IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG5jb25zdCBDaXJjdWx1YXJQcm9ncmVzc1N0eWxlID0gY3NzYFxuLmNpcmN1bGFyLXByb2dyZXNzIHtcbiAgICBkaXNwbGF5OiBibG9jaztcbiAgICB3aWR0aDogMTAwJTtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgdG9wOiAwO1xuICAgIGxlZnQ6IDA7XG4gICAgdHJhbnNpdGlvbjogZmlsdGVyIC40cyBlYXNlLWluLW91dDtcbn1cblxuLmNpcmNsZS1iZyB7XG4gICAgZmlsbDogbm9uZTtcbiAgICBzdHJva2U6ICNlZWU7XG4gICAgc3Ryb2tlLXdpZHRoOiAzLjg7XG59XG5cbi5jaXJjbGUge1xuICAgIHN0cm9rZTogJHtDb250cm9sTnVtYmVyQ29sb3J9O1xuICAgIHRyYW5zaXRpb246IHN0cm9rZS1kYXNoYXJyYXkgLjRzIGVhc2UtaW4tb3V0O1xuICAgIGZpbGw6IG5vbmU7XG4gICAgc3Ryb2tlLXdpZHRoOiAyLjg7XG4gICAgc3Ryb2tlLWxpbmVjYXA6IHJvdW5kO1xufVxuYDtcblxuY29uc3QgQ2lyY3VsYXJQYXRoRCA9ICdNMTggMi4wODQ1IGEgMTUuOTE1NSAxNS45MTU1IDAgMCAxIDAgMzEuODMxIGEgMTUuOTE1NSAxNS45MTU1IDAgMCAxIDAgLTMxLjgzMSc7XG5cbmZ1bmN0aW9uIGdldEJhY2tHcm91bmRDb2xvcih7XG4gIGNvbmZsaWN0LCBpc1BlZXIsIHNhbWVWYWx1ZSwgaXNTZWxlY3RlZCxcbn0pIHtcbiAgaWYgKGNvbmZsaWN0ICYmIGlzUGVlciAmJiBzYW1lVmFsdWUpIHtcbiAgICByZXR1cm4gRGVlcE9yYW5nZTIwMDtcbiAgfSBlbHNlIGlmIChzYW1lVmFsdWUpIHtcbiAgICByZXR1cm4gTGlnaHRCbHVlMzAwO1xuICB9IGVsc2UgaWYgKGlzU2VsZWN0ZWQpIHtcbiAgICByZXR1cm4gTGlnaHRCbHVlMjAwO1xuICB9IGVsc2UgaWYgKGlzUGVlcikge1xuICAgIHJldHVybiBMaWdodEJsdWUxMDA7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRGb250Q29sb3IoeyB2YWx1ZSwgY29uZmxpY3QsIHByZWZpbGxlZCB9KSB7XG4gIGlmIChjb25mbGljdCAmJiAhcHJlZmlsbGVkKSB7XG4gICAgcmV0dXJuIERlZXBPcmFuZ2U2MDA7XG4gIH0gZWxzZSBpZiAoIXByZWZpbGxlZCAmJiB2YWx1ZSkge1xuICAgIHJldHVybiBDb250cm9sTnVtYmVyQ29sb3I7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5jbGFzcyBHZW5lcmF0aW9uVUkgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcblxuICAgIHRoaXMuc3RhdGUgPSB7IHZhbHVlOiAzMCB9O1xuICB9XG5cbiAgZ2VuZXJhdGVHYW1lID0gKCkgPT4ge1xuICAgIHRoaXMucHJvcHMuZ2VuZXJhdGVHYW1lKHRoaXMuc3RhdGUudmFsdWUpO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImdlbmVyYXRpb25cIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb3B5XCI+U3RhcnQgd2l0aCB7dGhpcy5zdGF0ZS52YWx1ZX0gY2VsbHMgcHJlZmlsbGVkPC9kaXY+XG4gICAgICAgIDxJbnB1dFJhbmdlXG4gICAgICAgICAgbWF4VmFsdWU9ezgxfVxuICAgICAgICAgIG1pblZhbHVlPXsxN31cbiAgICAgICAgICB2YWx1ZT17dGhpcy5zdGF0ZS52YWx1ZX1cbiAgICAgICAgICBvbkNoYW5nZT17dmFsdWUgPT4gdGhpcy5zZXRTdGF0ZSh7IHZhbHVlIH0pfVxuICAgICAgICAvPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImJ1dHRvblwiIG9uQ2xpY2s9e3RoaXMuZ2VuZXJhdGVHYW1lfT5QbGF5IFN1ZG9rdTwvZGl2PlxuICAgICAgICB7IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG4gICAgICAgIDxzdHlsZSBqc3g+e2BcbiAgICAgICAgICAgIC5jb3B5IHtcbiAgICAgICAgICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgICAgICAgICAgICAgZm9udC1zaXplOiAxLjNlbTtcbiAgICAgICAgICAgICAgICBtYXJnaW4tYm90dG9tOiAuNWVtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLmdlbmVyYXRpb24ge1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgICAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgICAgICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOmdsb2JhbCguaW5wdXQtcmFuZ2UpIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogODAlO1xuICAgICAgICAgICAgICAgIG1heC13aWR0aDogNTAwcHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAuYnV0dG9uIHtcbiAgICAgICAgICAgICAgbWFyZ2luLXRvcDogLjVlbTtcbiAgICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogLjI1ZW07XG4gICAgICAgICAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICAgICAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICAgICAgICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcbiAgICAgICAgICAgICAgY29sb3I6ICNmZmY7XG4gICAgICAgICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgICAgICAgICAgICB0cmFuc2l0aW9uOiBhbGwgLjI1cztcbiAgICAgICAgICAgICAgcGFkZGluZzogNXB4IDEwcHg7XG4gICAgICAgICAgICAgIGZvbnQtc2l6ZTogMS40ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAuYnV0dG9uOmFjdGl2ZSB7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKDBweCwgNXB4KTtcbiAgICAgICAgICAgICAgYm94LXNoYWRvdzogMCAxcHggMCAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAuYnV0dG9uIHtcbiAgICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogJHtiYWNrR3JvdW5kQmx1ZX07XG4gICAgICAgICAgICAgIGJveC1zaGFkb3c6IDAgMnB4IDRweCAwICR7Q29sb3IoYmFja0dyb3VuZEJsdWUpLmRhcmtlbigwLjUpLmhzbCgpLnN0cmluZygpfTtcbiAgICAgICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLmJ1dHRvbjpob3ZlciB7XG4gICAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6ICR7Q29sb3IoYmFja0dyb3VuZEJsdWUpLmxpZ2h0ZW4oMC4yKS5oc2woKS5zdHJpbmcoKX07XG4gICAgICAgICAgICB9XG4gICAgICAgIGB9XG4gICAgICAgIDwvc3R5bGU+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG59XG5cbkdlbmVyYXRpb25VSS5wcm9wVHlwZXMgPSB7XG4gIGdlbmVyYXRlR2FtZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbn07XG5cbmNvbnN0IE51bWJlckNvbnRyb2wgPSAoeyBudW1iZXIsIG9uQ2xpY2ssIGNvbXBsZXRpb25QZXJjZW50YWdlIH0pID0+IChcbiAgPGRpdlxuICAgIGtleT17bnVtYmVyfVxuICAgIGNsYXNzTmFtZT1cIm51bWJlclwiXG4gICAgb25DbGljaz17b25DbGlja31cbiAgPlxuICAgIDxkaXY+e251bWJlcn08L2Rpdj5cbiAgICA8Q2lyY2x1bGFyUHJvZ3Jlc3MgcGVyY2VudD17Y29tcGxldGlvblBlcmNlbnRhZ2V9IC8+XG4gICAgPHN0eWxlIGpzeD57TnVtYmVyQ29udHJvbFN0eWxlfTwvc3R5bGU+XG4gIDwvZGl2PlxuKTtcblxuTnVtYmVyQ29udHJvbC5wcm9wVHlwZXMgPSB7XG4gIG51bWJlcjogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICBvbkNsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgY29tcGxldGlvblBlcmNlbnRhZ2U6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbn07XG5cbk51bWJlckNvbnRyb2wuZGVmYXVsdFByb3BzID0ge1xuICBvbkNsaWNrOiBudWxsLFxufTtcblxuY29uc3QgQ2VsbCA9IChwcm9wcykgPT4ge1xuICBjb25zdCB7XG4gICAgdmFsdWUsIG9uQ2xpY2ssIGlzUGVlciwgaXNTZWxlY3RlZCwgc2FtZVZhbHVlLCBwcmVmaWxsZWQsIG5vdGVzLCBjb25mbGljdCxcbiAgfSA9IHByb3BzO1xuICBjb25zdCBiYWNrZ3JvdW5kQ29sb3IgPSBnZXRCYWNrR3JvdW5kQ29sb3Ioe1xuICAgIGNvbmZsaWN0LCBpc1BlZXIsIHNhbWVWYWx1ZSwgaXNTZWxlY3RlZCxcbiAgfSk7XG4gIGNvbnN0IGZvbnRDb2xvciA9IGdldEZvbnRDb2xvcih7IGNvbmZsaWN0LCBwcmVmaWxsZWQsIHZhbHVlIH0pO1xuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwiY2VsbFwiIG9uQ2xpY2s9e29uQ2xpY2t9PlxuICAgICAge1xuICAgICAgICBub3RlcyA/XG4gICAgICAgICAgcmFuZ2UoOSkubWFwKGkgPT5cbiAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgPGRpdiBrZXk9e2l9IGNsYXNzTmFtZT1cIm5vdGUtbnVtYmVyXCI+XG4gICAgICAgICAgICAgICAge25vdGVzLmhhcyhpICsgMSkgJiYgKGkgKyAxKX1cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICApKSA6XG4gICAgICAgICAgdmFsdWUgJiYgdmFsdWVcbiAgICAgIH1cbiAgICAgIHsvKiBsYW5ndWFnZT1DU1MgKi99XG4gICAgICA8c3R5bGUganN4PntDZWxsU3R5bGV9PC9zdHlsZT5cbiAgICAgIDxzdHlsZSBqc3g+e2BcbiAgICAgICAgICAgICAgICAuY2VsbCB7XG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6ICR7YmFja2dyb3VuZENvbG9yIHx8ICdpbml0aWFsJ307XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiAke2ZvbnRDb2xvciB8fCAnaW5pdGlhbCd9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGB9XG4gICAgICA8L3N0eWxlPlxuICAgIDwvZGl2PlxuICApO1xufTtcblxuQ2VsbC5wcm9wVHlwZXMgPSB7XG4gIC8vIGN1cnJlbnQgbnVtYmVyIHZhbHVlXG4gIHZhbHVlOiBQcm9wVHlwZXMubnVtYmVyLFxuICAvLyBjZWxsIGNsaWNrIGhhbmRsZXJcbiAgb25DbGljazogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgLy8gaWYgdGhlIGNlbGwgaXMgYSBwZWVyIG9mIHRoZSBzZWxlY3RlZCBjZWxsXG4gIGlzUGVlcjogUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZCxcbiAgLy8gaWYgdGhlIGNlbGwgaXMgc2VsZWN0ZWQgYnkgdGhlIHVzZXJcbiAgaXNTZWxlY3RlZDogUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZCxcbiAgLy8gY3VycmVudCBjZWxsIGhhcyB0aGUgc2FtZSB2YWx1ZSBpZiB0aGUgdXNlciBzZWxlY3RlZCBjZWxsXG4gIHNhbWVWYWx1ZTogUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZCxcbiAgLy8gaWYgdGhpcyB3YXMgcHJlZmlsbGVkIGFzIGEgcGFydCBvZiB0aGUgcHV6emxlXG4gIHByZWZpbGxlZDogUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZCxcbiAgLy8gY3VycmVudCBub3RlcyB0YWtlbiBvbiB0aGUgY2VsbFxuICBub3RlczogUHJvcFR5cGVzLmluc3RhbmNlT2YoU2V0KSxcbiAgLy8gaWYgdGhlIGN1cnJlbnQgY2VsbCBkb2VzIG5vdCBzYXRpc2Z5IHRoZSBnYW1lIGNvbnN0cmFpbnRcbiAgY29uZmxpY3Q6IFByb3BUeXBlcy5ib29sLmlzUmVxdWlyZWQsXG59O1xuXG5DZWxsLmRlZmF1bHRQcm9wcyA9IHtcbiAgbm90ZXM6IG51bGwsXG4gIHZhbHVlOiBudWxsLFxufTtcblxuY29uc3QgQ2lyY2x1bGFyUHJvZ3Jlc3MgPSAoeyBwZXJjZW50IH0pID0+IChcbiAgPHN2ZyB2aWV3Qm94PVwiMCAwIDM2IDM2XCIgY2xhc3NOYW1lPVwiY2lyY3VsYXItcHJvZ3Jlc3NcIj5cbiAgICA8cGF0aFxuICAgICAgY2xhc3NOYW1lPVwiY2lyY2xlLWJnXCJcbiAgICAgIGQ9e0NpcmN1bGFyUGF0aER9XG4gICAgLz5cbiAgICA8cGF0aFxuICAgICAgY2xhc3NOYW1lPVwiY2lyY2xlXCJcbiAgICAgIHN0cm9rZURhc2hhcnJheT17YCR7cGVyY2VudCAqIDEwMH0sIDEwMGB9XG4gICAgICBkPXtDaXJjdWxhclBhdGhEfVxuICAgIC8+XG4gICAgeyAvKiBsYW5ndWFnZT1DU1MgKi8gfVxuICAgIDxzdHlsZSBqc3g+e0NpcmN1bHVhclByb2dyZXNzU3R5bGV9PC9zdHlsZT5cbiAgPC9zdmc+XG4pO1xuXG5DaXJjbHVsYXJQcm9ncmVzcy5wcm9wVHlwZXMgPSB7XG4gIHBlcmNlbnQ6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbn07XG5cbmZ1bmN0aW9uIGdldENsaWNrSGFuZGxlcihvbkNsaWNrLCBvbkRvdWJsZUNsaWNrLCBkZWxheSA9IDI1MCkge1xuICBsZXQgdGltZW91dElEID0gbnVsbDtcbiAgcmV0dXJuIChldmVudCkgPT4ge1xuICAgIGlmICghdGltZW91dElEKSB7XG4gICAgICB0aW1lb3V0SUQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgb25DbGljayhldmVudCk7XG4gICAgICAgIHRpbWVvdXRJRCA9IG51bGw7XG4gICAgICB9LCBkZWxheSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpbWVvdXRJRCA9IGNsZWFyVGltZW91dCh0aW1lb3V0SUQpO1xuICAgICAgb25Eb3VibGVDbGljayhldmVudCk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIG1ha2Ugc2l6ZSA5IGFycmF5IG9mIDBzXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIG1ha2VDb3VudE9iamVjdCgpIHtcbiAgY29uc3QgY291bnRPYmogPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSArPSAxKSBjb3VudE9iai5wdXNoKDApO1xuICByZXR1cm4gY291bnRPYmo7XG59XG5cbi8qKlxuICogZ2l2ZW4gYSAyRCBhcnJheSBvZiBudW1iZXJzIGFzIHRoZSBpbml0aWFsIHB1enpsZSwgZ2VuZXJhdGUgdGhlIGluaXRpYWwgZ2FtZSBzdGF0ZVxuICogQHBhcmFtIHB1enpsZVxuICogQHJldHVybnMge2FueX1cbiAqL1xuZnVuY3Rpb24gbWFrZUJvYXJkKHsgcHV6emxlIH0pIHtcbiAgLy8gY3JlYXRlIGluaXRpYWwgY291bnQgb2JqZWN0IHRvIGtlZXAgdHJhY2sgb2YgY29uZmxpY3RzIHBlciBudW1iZXIgdmFsdWVcbiAgY29uc3Qgcm93cyA9IEFycmF5LmZyb20oQXJyYXkoOSkua2V5cygpKS5tYXAoKCkgPT4gbWFrZUNvdW50T2JqZWN0KCkpO1xuICBjb25zdCBjb2x1bW5zID0gQXJyYXkuZnJvbShBcnJheSg5KS5rZXlzKCkpLm1hcCgoKSA9PiBtYWtlQ291bnRPYmplY3QoKSk7XG4gIGNvbnN0IHNxdWFyZXMgPSBBcnJheS5mcm9tKEFycmF5KDkpLmtleXMoKSkubWFwKCgpID0+IG1ha2VDb3VudE9iamVjdCgpKTtcbiAgY29uc3QgcmVzdWx0ID0gcHV6emxlLm1hcCgocm93LCBpKSA9PiAoXG4gICAgcm93Lm1hcCgoY2VsbCwgaikgPT4ge1xuICAgICAgaWYgKGNlbGwpIHtcbiAgICAgICAgcm93c1tpXVtjZWxsXSArPSAxO1xuICAgICAgICBjb2x1bW5zW2pdW2NlbGxdICs9IDE7XG4gICAgICAgIHNxdWFyZXNbKChNYXRoLmZsb29yKGkgLyAzKSkgKiAzKSArIE1hdGguZmxvb3IoaiAvIDMpXVtjZWxsXSArPSAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHB1enpsZVtpXVtqXSA+IDAgPyBwdXp6bGVbaV1bal0gOiBudWxsLFxuICAgICAgICBwcmVmaWxsZWQ6ICEhcHV6emxlW2ldW2pdLFxuICAgICAgfTtcbiAgICB9KVxuICApKTtcbiAgcmV0dXJuIGZyb21KUyh7IHB1enpsZTogcmVzdWx0LCBzZWxlY3RlZDogZmFsc2UsIGNob2ljZXM6IHsgcm93cywgY29sdW1ucywgc3F1YXJlcyB9IH0pO1xufVxuXG4vKipcbiAqIGdpdmUgdGhlIGNvb3JkaW5hdGUgdXBkYXRlIHRoZSBjdXJyZW50IGJvYXJkIHdpdGggYSBudW1iZXIgY2hvaWNlXG4gKiBAcGFyYW0geFxuICogQHBhcmFtIHlcbiAqIEBwYXJhbSBudW1iZXJcbiAqIEBwYXJhbSBmaWxsIHdoZXRoZXIgdG8gc2V0IG9yIHVuc2V0XG4gKiBAcGFyYW0gYm9hcmQgdGhlIGltbXV0YWJsZSBib2FyZCBnaXZlbiB0byBjaGFuZ2VcbiAqL1xuZnVuY3Rpb24gdXBkYXRlQm9hcmRXaXRoTnVtYmVyKHtcbiAgeCwgeSwgbnVtYmVyLCBmaWxsID0gdHJ1ZSwgYm9hcmQsXG59KSB7XG4gIGxldCBjZWxsID0gYm9hcmQuZ2V0KCdwdXp6bGUnKS5nZXRJbihbeCwgeV0pO1xuICAvLyBkZWxldGUgaXRzIG5vdGVzXG4gIGNlbGwgPSBjZWxsLmRlbGV0ZSgnbm90ZXMnKTtcbiAgLy8gc2V0IG9yIHVuc2V0IGl0cyB2YWx1ZSBkZXBlbmRpbmcgb24gYGZpbGxgXG4gIGNlbGwgPSBmaWxsID8gY2VsbC5zZXQoJ3ZhbHVlJywgbnVtYmVyKSA6IGNlbGwuZGVsZXRlKCd2YWx1ZScpO1xuICBjb25zdCBpbmNyZW1lbnQgPSBmaWxsID8gMSA6IC0xO1xuICAvLyB1cGRhdGUgdGhlIGN1cnJlbnQgZ3JvdXAgY2hvaWNlc1xuICBjb25zdCByb3dQYXRoID0gWydjaG9pY2VzJywgJ3Jvd3MnLCB4LCBudW1iZXJdO1xuICBjb25zdCBjb2x1bW5QYXRoID0gWydjaG9pY2VzJywgJ2NvbHVtbnMnLCB5LCBudW1iZXJdO1xuICBjb25zdCBzcXVhcmVQYXRoID0gWydjaG9pY2VzJywgJ3NxdWFyZXMnLFxuICAgICgoTWF0aC5mbG9vcih4IC8gMykpICogMykgKyBNYXRoLmZsb29yKHkgLyAzKSwgbnVtYmVyXTtcbiAgcmV0dXJuIGJvYXJkLnNldEluKHJvd1BhdGgsIGJvYXJkLmdldEluKHJvd1BhdGgpICsgaW5jcmVtZW50KVxuICAgIC5zZXRJbihjb2x1bW5QYXRoLCBib2FyZC5nZXRJbihjb2x1bW5QYXRoKSArIGluY3JlbWVudClcbiAgICAuc2V0SW4oc3F1YXJlUGF0aCwgYm9hcmQuZ2V0SW4oc3F1YXJlUGF0aCkgKyBpbmNyZW1lbnQpXG4gICAgLnNldEluKFsncHV6emxlJywgeCwgeV0sIGNlbGwpO1xufVxuXG5mdW5jdGlvbiBnZXROdW1iZXJPZkdyb3Vwc0Fzc2lnbmVkRm9yTnVtYmVyKG51bWJlciwgZ3JvdXBzKSB7XG4gIHJldHVybiBncm91cHMucmVkdWNlKChhY2N1bXVsYXRvciwgcm93KSA9PlxuICAgIGFjY3VtdWxhdG9yICsgKHJvdy5nZXQobnVtYmVyKSA+IDAgPyAxIDogMCksIDApO1xufVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L25vLW11bHRpLWNvbXBcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEluZGV4IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgc3RhdGUgPSB7fTtcblxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICBpZiAoJ3NlcnZpY2VXb3JrZXInIGluIG5hdmlnYXRvcikge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICAgICBuYXZpZ2F0b3Iuc2VydmljZVdvcmtlclxuICAgICAgICAucmVnaXN0ZXIoJy9zZXJ2aWNlLXdvcmtlci5qcycpXG4gICAgICAgIC50aGVuKChyZWcpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnU2VydmljZVdvcmtlciBzY29wZTogJywgcmVnLnNjb3BlKTtcbiAgICAgICAgICBjb25zb2xlLmxvZygnc2VydmljZSB3b3JrZXIgcmVnaXN0cmF0aW9uIHN1Y2Nlc3NmdWwnKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ3NlcnZpY2Ugd29ya2VyIHJlZ2lzdHJhdGlvbiBmYWlsZWQnLCBlcnIubWVzc2FnZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgXG4gICAgZmV0Y2goJy9hcGkvc29ja2V0aW8nKS5maW5hbGx5KCgpID0+IHtcbiAgICAgIGNvbnN0IHNvY2tldCA9IGlvKClcblxuICAgICAgc29ja2V0Lm9uKCdjb25uZWN0JywgKCkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZygnY29ubmVjdCcpXG4gICAgICAgIHNvY2tldC5lbWl0KCdoZWxsbycpXG4gICAgICB9KVxuXG4gICAgICBzb2NrZXQub24oJ2hlbGxvJywgZGF0YSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdoZWxsbycsIGRhdGEpXG4gICAgICB9KVxuXG4gICAgICBzb2NrZXQub24oJ2EgdXNlciBjb25uZWN0ZWQnLCAoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdhIHVzZXIgY29ubmVjdGVkJylcbiAgICAgIH0pXG5cbiAgICAgIHNvY2tldC5vbignZGlzY29ubmVjdCcsICgpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ2Rpc2Nvbm5lY3QnKVxuICAgICAgfSlcbiAgICB9KVxuICAgXG4gIH1cbiAgZ2V0U2VsZWN0ZWRDZWxsKCkge1xuICAgIGNvbnN0IHsgYm9hcmQgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3Qgc2VsZWN0ZWQgPSBib2FyZC5nZXQoJ3NlbGVjdGVkJyk7XG4gICAgcmV0dXJuIHNlbGVjdGVkICYmIGJvYXJkLmdldCgncHV6emxlJykuZ2V0SW4oW3NlbGVjdGVkLngsIHNlbGVjdGVkLnldKTtcbiAgfVxuXG4gIC8vIGdldCB0aGUgbWluIGJldHdlZW4gaXRzIGNvbXBsZXRpb24gaW4gcm93cywgY29sdW1ucyBhbmQgc3F1YXJlcy5cbiAgZ2V0TnVtYmVyVmFsdWVDb3VudChudW1iZXIpIHtcbiAgICBjb25zdCByb3dzID0gdGhpcy5zdGF0ZS5ib2FyZC5nZXRJbihbJ2Nob2ljZXMnLCAncm93cyddKTtcbiAgICBjb25zdCBjb2x1bW5zID0gdGhpcy5zdGF0ZS5ib2FyZC5nZXRJbihbJ2Nob2ljZXMnLCAnY29sdW1ucyddKTtcbiAgICBjb25zdCBzcXVhcmVzID0gdGhpcy5zdGF0ZS5ib2FyZC5nZXRJbihbJ2Nob2ljZXMnLCAnc3F1YXJlcyddKTtcbiAgICByZXR1cm4gTWF0aC5taW4oXG4gICAgICBnZXROdW1iZXJPZkdyb3Vwc0Fzc2lnbmVkRm9yTnVtYmVyKG51bWJlciwgc3F1YXJlcyksXG4gICAgICBNYXRoLm1pbihcbiAgICAgICAgZ2V0TnVtYmVyT2ZHcm91cHNBc3NpZ25lZEZvck51bWJlcihudW1iZXIsIHJvd3MpLFxuICAgICAgICBnZXROdW1iZXJPZkdyb3Vwc0Fzc2lnbmVkRm9yTnVtYmVyKG51bWJlciwgY29sdW1ucyksXG4gICAgICApLFxuICAgICk7XG4gIH1cblxuICBnZW5lcmF0ZUdhbWUgPSAoZmluYWxDb3VudCA9IDIwKSA9PiB7XG4gICAgLy8gZ2V0IGEgZmlsbGVkIHB1enpsZSBnZW5lcmF0ZWRcbiAgICBjb25zdCBzb2x1dGlvbiA9IG1ha2VQdXp6bGUoKTtcbiAgICAvLyBwbHVjayB2YWx1ZXMgZnJvbSBjZWxscyB0byBjcmVhdGUgdGhlIGdhbWVcbiAgICBjb25zdCB7IHB1enpsZSB9ID0gcGx1Y2soc29sdXRpb24sIGZpbmFsQ291bnQpO1xuICAgIC8vIGluaXRpYWxpemUgdGhlIGJvYXJkIHdpdGggY2hvaWNlIGNvdW50c1xuICAgIGNvbnN0IGJvYXJkID0gbWFrZUJvYXJkKHsgcHV6emxlIH0pO1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgYm9hcmQsIGhpc3Rvcnk6IExpc3Qub2YoYm9hcmQpLCBoaXN0b3J5T2ZmU2V0OiAwLCBzb2x1dGlvbixcbiAgICB9KTtcbiAgfVxuXG4gIGFkZE51bWJlckFzTm90ZSA9IChudW1iZXIpID0+IHtcbiAgICBsZXQgeyBib2FyZCB9ID0gdGhpcy5zdGF0ZTtcbiAgICBsZXQgc2VsZWN0ZWRDZWxsID0gdGhpcy5nZXRTZWxlY3RlZENlbGwoKTtcbiAgICBpZiAoIXNlbGVjdGVkQ2VsbCkgcmV0dXJuO1xuICAgIGNvbnN0IHByZWZpbGxlZCA9IHNlbGVjdGVkQ2VsbC5nZXQoJ3ByZWZpbGxlZCcpO1xuICAgIGlmIChwcmVmaWxsZWQpIHJldHVybjtcbiAgICBjb25zdCB7IHgsIHkgfSA9IGJvYXJkLmdldCgnc2VsZWN0ZWQnKTtcbiAgICBjb25zdCBjdXJyZW50VmFsdWUgPSBzZWxlY3RlZENlbGwuZ2V0KCd2YWx1ZScpO1xuICAgIGlmIChjdXJyZW50VmFsdWUpIHtcbiAgICAgIGJvYXJkID0gdXBkYXRlQm9hcmRXaXRoTnVtYmVyKHtcbiAgICAgICAgeCwgeSwgbnVtYmVyOiBjdXJyZW50VmFsdWUsIGZpbGw6IGZhbHNlLCBib2FyZDogdGhpcy5zdGF0ZS5ib2FyZCxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBsZXQgbm90ZXMgPSBzZWxlY3RlZENlbGwuZ2V0KCdub3RlcycpIHx8IFNldCgpO1xuICAgIGlmIChub3Rlcy5oYXMobnVtYmVyKSkge1xuICAgICAgbm90ZXMgPSBub3Rlcy5kZWxldGUobnVtYmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm90ZXMgPSBub3Rlcy5hZGQobnVtYmVyKTtcbiAgICB9XG4gICAgc2VsZWN0ZWRDZWxsID0gc2VsZWN0ZWRDZWxsLnNldCgnbm90ZXMnLCBub3Rlcyk7XG4gICAgc2VsZWN0ZWRDZWxsID0gc2VsZWN0ZWRDZWxsLmRlbGV0ZSgndmFsdWUnKTtcbiAgICBib2FyZCA9IGJvYXJkLnNldEluKFsncHV6emxlJywgeCwgeV0sIHNlbGVjdGVkQ2VsbCk7XG4gICAgdGhpcy51cGRhdGVCb2FyZChib2FyZCk7XG4gIH07XG5cbiAgdXBkYXRlQm9hcmQgPSAobmV3Qm9hcmQpID0+IHtcbiAgICBsZXQgeyBoaXN0b3J5IH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IHsgaGlzdG9yeU9mZlNldCB9ID0gdGhpcy5zdGF0ZTtcbiAgICAvLyBhbnl0aGluZyBiZWZvcmUgY3VycmVudCBzdGVwIGlzIHN0aWxsIGluIGhpc3RvcnlcbiAgICBoaXN0b3J5ID0gaGlzdG9yeS5zbGljZSgwLCBoaXN0b3J5T2ZmU2V0ICsgMSk7XG4gICAgLy8gYWRkIGl0c2VsZiBvbnRvIHRoZSBoaXN0b3J5XG4gICAgaGlzdG9yeSA9IGhpc3RvcnkucHVzaChuZXdCb2FyZCk7XG4gICAgLy8gdXBkYXRlIHRoZSBnYW1lXG4gICAgdGhpcy5zZXRTdGF0ZSh7IGJvYXJkOiBuZXdCb2FyZCwgaGlzdG9yeSwgaGlzdG9yeU9mZlNldDogaGlzdG9yeS5zaXplIC0gMSB9KTtcbiAgfTtcblxuICBjYW5VbmRvID0gKCkgPT4gdGhpcy5zdGF0ZS5oaXN0b3J5T2ZmU2V0ID4gMFxuXG4gIHJlZG8gPSAoKSA9PiB7XG4gICAgY29uc3QgeyBoaXN0b3J5IH0gPSB0aGlzLnN0YXRlO1xuICAgIGxldCB7IGhpc3RvcnlPZmZTZXQgfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKGhpc3Rvcnkuc2l6ZSkge1xuICAgICAgaGlzdG9yeU9mZlNldCA9IE1hdGgubWluKGhpc3Rvcnkuc2l6ZSAtIDEsIGhpc3RvcnlPZmZTZXQgKyAxKTtcbiAgICAgIGNvbnN0IGJvYXJkID0gaGlzdG9yeS5nZXQoaGlzdG9yeU9mZlNldCk7XG4gICAgICB0aGlzLnNldFN0YXRlKHsgYm9hcmQsIGhpc3RvcnlPZmZTZXQgfSk7XG4gICAgfVxuICB9O1xuXG4gIHVuZG8gPSAoKSA9PiB7XG4gICAgY29uc3QgeyBoaXN0b3J5IH0gPSB0aGlzLnN0YXRlO1xuICAgIGxldCB7IGhpc3RvcnlPZmZTZXQsIGJvYXJkIH0gPSB0aGlzLnN0YXRlO1xuICAgIGlmIChoaXN0b3J5LnNpemUpIHtcbiAgICAgIGhpc3RvcnlPZmZTZXQgPSBNYXRoLm1heCgwLCBoaXN0b3J5T2ZmU2V0IC0gMSk7XG4gICAgICBib2FyZCA9IGhpc3RvcnkuZ2V0KGhpc3RvcnlPZmZTZXQpO1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IGJvYXJkLCBoaXN0b3J5T2ZmU2V0LCBoaXN0b3J5IH0pO1xuICAgIH1cbiAgfTtcblxuICBlcmFzZVNlbGVjdGVkID0gKCkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGVkQ2VsbCA9IHRoaXMuZ2V0U2VsZWN0ZWRDZWxsKCk7XG4gICAgaWYgKCFzZWxlY3RlZENlbGwpIHJldHVybjtcbiAgICB0aGlzLmZpbGxOdW1iZXIoZmFsc2UpO1xuICB9XG5cbiAgZmlsbFNlbGVjdGVkV2l0aFNvbHV0aW9uID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgYm9hcmQsIHNvbHV0aW9uIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IHNlbGVjdGVkQ2VsbCA9IHRoaXMuZ2V0U2VsZWN0ZWRDZWxsKCk7XG4gICAgaWYgKCFzZWxlY3RlZENlbGwpIHJldHVybjtcbiAgICBjb25zdCB7IHgsIHkgfSA9IGJvYXJkLmdldCgnc2VsZWN0ZWQnKTtcbiAgICB0aGlzLmZpbGxOdW1iZXIoc29sdXRpb25beF1beV0pO1xuICB9XG5cblxuICAvLyBmaWxsIGN1cnJlbnRseSBzZWxlY3RlZCBjZWxsIHdpdGggbnVtYmVyXG4gIGZpbGxOdW1iZXIgPSAobnVtYmVyKSA9PiB7XG4gICAgbGV0IHsgYm9hcmQgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3Qgc2VsZWN0ZWRDZWxsID0gdGhpcy5nZXRTZWxlY3RlZENlbGwoKTtcbiAgICAvLyBuby1vcCBpZiBub3RoaW5nIGlzIHNlbGVjdGVkXG4gICAgaWYgKCFzZWxlY3RlZENlbGwpIHJldHVybjtcbiAgICBjb25zdCBwcmVmaWxsZWQgPSBzZWxlY3RlZENlbGwuZ2V0KCdwcmVmaWxsZWQnKTtcbiAgICAvLyBuby1vcCBpZiBpdCBpcyByZWZpbGxlZFxuICAgIGlmIChwcmVmaWxsZWQpIHJldHVybjtcbiAgICBjb25zdCB7IHgsIHkgfSA9IGJvYXJkLmdldCgnc2VsZWN0ZWQnKTtcbiAgICBjb25zdCBjdXJyZW50VmFsdWUgPSBzZWxlY3RlZENlbGwuZ2V0KCd2YWx1ZScpO1xuICAgIC8vIHJlbW92ZSB0aGUgY3VycmVudCB2YWx1ZSBhbmQgdXBkYXRlIHRoZSBnYW1lIHN0YXRlXG4gICAgaWYgKGN1cnJlbnRWYWx1ZSkge1xuICAgICAgYm9hcmQgPSB1cGRhdGVCb2FyZFdpdGhOdW1iZXIoe1xuICAgICAgICB4LCB5LCBudW1iZXI6IGN1cnJlbnRWYWx1ZSwgZmlsbDogZmFsc2UsIGJvYXJkOiB0aGlzLnN0YXRlLmJvYXJkLFxuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIHVwZGF0ZSB0byBuZXcgbnVtYmVyIGlmIGFueVxuICAgIGNvbnN0IHNldE51bWJlciA9IGN1cnJlbnRWYWx1ZSAhPT0gbnVtYmVyICYmIG51bWJlcjtcbiAgICBpZiAoc2V0TnVtYmVyKSB7XG4gICAgICBib2FyZCA9IHVwZGF0ZUJvYXJkV2l0aE51bWJlcih7XG4gICAgICAgIHgsIHksIG51bWJlciwgZmlsbDogdHJ1ZSwgYm9hcmQsXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVCb2FyZChib2FyZCk7XG4gIH07XG5cbiAgc2VsZWN0Q2VsbCA9ICh4LCB5KSA9PiB7XG4gICAgbGV0IHsgYm9hcmQgfSA9IHRoaXMuc3RhdGU7XG4gICAgYm9hcmQgPSBib2FyZC5zZXQoJ3NlbGVjdGVkJywgeyB4LCB5IH0pO1xuICAgIHRoaXMuc2V0U3RhdGUoeyBib2FyZCB9KTtcbiAgfTtcblxuICBpc0NvbmZsaWN0KGksIGopIHtcbiAgICBjb25zdCB7IHZhbHVlIH0gPSB0aGlzLnN0YXRlLmJvYXJkLmdldEluKFsncHV6emxlJywgaSwgal0pLnRvSlNPTigpO1xuICAgIGlmICghdmFsdWUpIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCByb3dDb25mbGljdCA9XG4gICAgICB0aGlzLnN0YXRlLmJvYXJkLmdldEluKFsnY2hvaWNlcycsICdyb3dzJywgaSwgdmFsdWVdKSA+IDE7XG4gICAgY29uc3QgY29sdW1uQ29uZmxpY3QgPVxuICAgICAgdGhpcy5zdGF0ZS5ib2FyZC5nZXRJbihbJ2Nob2ljZXMnLCAnY29sdW1ucycsIGosIHZhbHVlXSkgPiAxO1xuICAgIGNvbnN0IHNxdWFyZUNvbmZsaWN0ID1cbiAgICAgIHRoaXMuc3RhdGUuYm9hcmQuZ2V0SW4oWydjaG9pY2VzJywgJ3NxdWFyZXMnLFxuICAgICAgICAoKE1hdGguZmxvb3IoaSAvIDMpKSAqIDMpICsgTWF0aC5mbG9vcihqIC8gMyksIHZhbHVlXSkgPiAxO1xuICAgIHJldHVybiByb3dDb25mbGljdCB8fCBjb2x1bW5Db25mbGljdCB8fCBzcXVhcmVDb25mbGljdDtcbiAgfVxuXG4gIHJlbmRlckNlbGwoY2VsbCwgeCwgeSkge1xuICAgIGNvbnN0IHsgYm9hcmQgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3Qgc2VsZWN0ZWQgPSB0aGlzLmdldFNlbGVjdGVkQ2VsbCgpO1xuICAgIGNvbnN0IHsgdmFsdWUsIHByZWZpbGxlZCwgbm90ZXMgfSA9IGNlbGwudG9KU09OKCk7XG4gICAgY29uc3QgY29uZmxpY3QgPSB0aGlzLmlzQ29uZmxpY3QoeCwgeSk7XG4gICAgY29uc3QgcGVlciA9IGFyZUNvb3JkaW5hdGVQZWVycyh7IHgsIHkgfSwgYm9hcmQuZ2V0KCdzZWxlY3RlZCcpKTtcbiAgICBjb25zdCBzYW1lVmFsdWUgPSAhIShzZWxlY3RlZCAmJiBzZWxlY3RlZC5nZXQoJ3ZhbHVlJylcbiAgICAgICYmIHZhbHVlID09PSBzZWxlY3RlZC5nZXQoJ3ZhbHVlJykpO1xuXG4gICAgY29uc3QgaXNTZWxlY3RlZCA9IGNlbGwgPT09IHNlbGVjdGVkO1xuICAgIHJldHVybiAoPENlbGxcbiAgICAgIHByZWZpbGxlZD17cHJlZmlsbGVkfVxuICAgICAgbm90ZXM9e25vdGVzfVxuICAgICAgc2FtZVZhbHVlPXtzYW1lVmFsdWV9XG4gICAgICBpc1NlbGVjdGVkPXtpc1NlbGVjdGVkfVxuICAgICAgaXNQZWVyPXtwZWVyfVxuICAgICAgdmFsdWU9e3ZhbHVlfVxuICAgICAgb25DbGljaz17KCkgPT4geyB0aGlzLnNlbGVjdENlbGwoeCwgeSk7IH19XG4gICAgICBrZXk9e3l9XG4gICAgICB4PXt4fVxuICAgICAgeT17eX1cbiAgICAgIGNvbmZsaWN0PXtjb25mbGljdH1cbiAgICAvPik7XG4gIH1cblxuICByZW5kZXJOdW1iZXJDb250cm9sKCkge1xuICAgIGNvbnN0IHNlbGVjdGVkQ2VsbCA9IHRoaXMuZ2V0U2VsZWN0ZWRDZWxsKCk7XG4gICAgY29uc3QgcHJlZmlsbGVkID0gc2VsZWN0ZWRDZWxsICYmIHNlbGVjdGVkQ2VsbC5nZXQoJ3ByZWZpbGxlZCcpO1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRyb2xcIj5cbiAgICAgICAge3JhbmdlKDkpLm1hcCgoaSkgPT4ge1xuICAgICAgICAgIGNvbnN0IG51bWJlciA9IGkgKyAxO1xuICAgICAgICAgIC8vIGhhbmRsZXMgYmluZGluZyBzaW5nbGUgY2xpY2sgYW5kIGRvdWJsZSBjbGljayBjYWxsYmFja3NcbiAgICAgICAgICBjb25zdCBjbGlja0hhbmRsZSA9IGdldENsaWNrSGFuZGxlcihcbiAgICAgICAgICAgICgpID0+IHsgdGhpcy5maWxsTnVtYmVyKG51bWJlcik7IH0sXG4gICAgICAgICAgICAoKSA9PiB7IHRoaXMuYWRkTnVtYmVyQXNOb3RlKG51bWJlcik7IH0sXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPE51bWJlckNvbnRyb2xcbiAgICAgICAgICAgICAga2V5PXtudW1iZXJ9XG4gICAgICAgICAgICAgIG51bWJlcj17bnVtYmVyfVxuICAgICAgICAgICAgICBvbkNsaWNrPXshcHJlZmlsbGVkID8gY2xpY2tIYW5kbGUgOiB1bmRlZmluZWR9XG4gICAgICAgICAgICAgIGNvbXBsZXRpb25QZXJjZW50YWdlPXt0aGlzLmdldE51bWJlclZhbHVlQ291bnQobnVtYmVyKSAvIDl9XG4gICAgICAgICAgICAvPik7XG4gICAgICAgIH0pfVxuICAgICAgICA8c3R5bGUganN4PntDb250cm9sU3R5bGV9PC9zdHlsZT5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cblxuICByZW5kZXJBY3Rpb25zKCkge1xuICAgIGNvbnN0IHsgaGlzdG9yeSB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBzZWxlY3RlZENlbGwgPSB0aGlzLmdldFNlbGVjdGVkQ2VsbCgpO1xuICAgIGNvbnN0IHByZWZpbGxlZCA9IHNlbGVjdGVkQ2VsbCAmJiBzZWxlY3RlZENlbGwuZ2V0KCdwcmVmaWxsZWQnKTtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJhY3Rpb25zXCI+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWN0aW9uXCIgb25DbGljaz17aGlzdG9yeS5zaXplID8gdGhpcy51bmRvIDogbnVsbH0+XG4gICAgICAgICAgPFJlbG9hZEljb24gLz5VbmRvXG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImFjdGlvbiByZWRvXCIgb25DbGljaz17aGlzdG9yeS5zaXplID8gdGhpcy5yZWRvIDogbnVsbH0+XG4gICAgICAgICAgPFJlbG9hZEljb24gLz5SZWRvXG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImFjdGlvblwiIG9uQ2xpY2s9eyFwcmVmaWxsZWQgPyB0aGlzLmVyYXNlU2VsZWN0ZWQgOiBudWxsfT5cbiAgICAgICAgICA8UmVtb3ZlSWNvbiAvPkVyYXNlXG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2XG4gICAgICAgICAgY2xhc3NOYW1lPVwiYWN0aW9uXCJcbiAgICAgICAgICBvbkNsaWNrPXshcHJlZmlsbGVkID9cbiAgICAgICAgICB0aGlzLmZpbGxTZWxlY3RlZFdpdGhTb2x1dGlvbiA6IG51bGx9XG4gICAgICAgID5cbiAgICAgICAgICA8TG91cGVJY29uIC8+SGludFxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPHN0eWxlIGpzeD57QWN0aW9uc1N0eWxlfTwvc3R5bGU+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG5cbiAgcmVuZGVyUHV6emxlKCkge1xuICAgIGNvbnN0IHsgYm9hcmQgfSA9IHRoaXMuc3RhdGU7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwicHV6emxlXCI+XG4gICAgICAgIHtib2FyZC5nZXQoJ3B1enpsZScpLm1hcCgocm93LCBpKSA9PiAoXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L25vLWFycmF5LWluZGV4LWtleVxuICAgICAgICAgIDxkaXYga2V5PXtpfSBjbGFzc05hbWU9XCJyb3dcIj5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcm93Lm1hcCgoY2VsbCwgaikgPT4gdGhpcy5yZW5kZXJDZWxsKGNlbGwsIGksIGopKS50b0FycmF5KClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKSkudG9BcnJheSgpfVxuICAgICAgICA8c3R5bGUganN4PntQdXp6bGVTdHlsZX08L3N0eWxlPlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxuXG4gIHJlbmRlckNvbnRyb2xzKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRyb2xzXCI+XG4gICAgICAgIHt0aGlzLnJlbmRlck51bWJlckNvbnRyb2woKX1cbiAgICAgICAge3RoaXMucmVuZGVyQWN0aW9ucygpfVxuICAgICAgICB7IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG4gICAgICAgIDxzdHlsZSBqc3g+e2BcbiAgICAgICAgICAgIC5jb250cm9scyB7XG4gICAgICAgICAgICAgICAgbWFyZ2luLXRvcDogLjNlbTtcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICAgICAgICAgIGZsZXgtd3JhcDogd3JhcDtcbiAgICAgICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiAuNWVtIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIGB9XG4gICAgICAgIDwvc3R5bGU+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG5cbiAgcmVuZGVyR2VuZXJhdGlvblVJKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8R2VuZXJhdGlvblVJIGdlbmVyYXRlR2FtZT17dGhpcy5nZW5lcmF0ZUdhbWV9IC8+XG4gICAgKTtcbiAgfVxuXG4gIHJlbmRlckhlYWRlcigpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJoZWFkZXJcIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJuZXctZ2FtZVwiIG9uQ2xpY2s9eygpID0+IHRoaXMuc2V0U3RhdGUoeyBib2FyZDogZmFsc2UgfSl9PlxuICAgICAgICAgIDxSZXR1cm5JY29uIC8+XG4gICAgICAgICAgPGRpdj5OZXcgR2FtZTwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPFRpcCAvPlxuICAgICAgICB7IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG4gICAgICAgIDxzdHlsZSBqc3g+e2BcbiAgICAgICAgICAgIC5oZWFkZXIge1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgICAgICAgICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICAgICAgICAgICAgICAgIG1heC13aWR0aDogNTAwcHg7XG4gICAgICAgICAgICAgICAgcGFkZGluZzogMCAwLjVlbTtcbiAgICAgICAgICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLm5ldy1nYW1lIHtcbiAgICAgICAgICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICAgICAgICAgICAgbWFyZ2luLXRvcDogLjJlbTtcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiBpbmxpbmUtZmxleDtcbiAgICAgICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICAgICAgICAgIHBhZGRpbmc6IC4yZW0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC5uZXctZ2FtZSA6Z2xvYmFsKHN2Zykge1xuICAgICAgICAgICAgICAgIGhlaWdodDogMWVtO1xuICAgICAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IC4zZW07XG4gICAgICAgICAgICB9XG4gICAgICAgIGB9XG4gICAgICAgIDwvc3R5bGU+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgYm9hcmQgfSA9IHRoaXMuc3RhdGU7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYm9keVwiPlxuICAgICAgICA8TmV4dEhlYWQ+XG4gICAgICAgICAgPHRpdGxlPlN1ZG9rdSBFdm9sdmVkPC90aXRsZT5cbiAgICAgICAgICA8bWV0YSBuYW1lPVwidmlld3BvcnRcIiBjb250ZW50PVwiaW5pdGlhbC1zY2FsZT0xLjAsIHdpZHRoPWRldmljZS13aWR0aFwiIC8+XG4gICAgICAgICAgPG1ldGEgbmFtZT1cImRlc2NyaXB0aW9uXCIgY29udGVudD17RGVzY3JpcHRpb259IC8+XG4gICAgICAgICAgPGxpbmsgaHJlZj1cImh0dHBzOi8vZm9udHMuZ29vZ2xlYXBpcy5jb20vY3NzP2ZhbWlseT1TcGVjaWFsK0VsaXRlXCIgcmVsPVwic3R5bGVzaGVldFwiIC8+XG4gICAgICAgICAgPG1ldGEgcHJvcGVydHk9XCJvZzp1cmxcIiBjb250ZW50PVwiaHR0cHM6Ly9zdWRva3Uuc2l0aWFubGl1LmNvbS9cIiAvPlxuICAgICAgICAgIDxtZXRhIHByb3BlcnR5PVwib2c6dGl0bGVcIiBjb250ZW50PVwiU3Vkb2t1IEV2b2x2ZWRcIiAvPlxuICAgICAgICAgIDxtZXRhIHByb3BlcnR5PVwib2c6dHlwZVwiIGNvbnRlbnQ9XCJ3ZWJzaXRlXCIgLz5cbiAgICAgICAgICA8bWV0YSBwcm9wZXJ0eT1cIm9nOmRlc2NyaXB0aW9uXCIgY29udGVudD17RGVzY3JpcHRpb259IC8+XG4gICAgICAgICAgPG1ldGEgcHJvcGVydHk9XCJvZzppbWFnZVwiIGNvbnRlbnQ9XCJodHRwczovL3N1ZG9rdS5zaXRpYW5saXUuY29tL3N0YXRpYy9vZy1pbWFnZS5wbmdcIiAvPlxuICAgICAgICA8L05leHRIZWFkPlxuICAgICAgICB7IWJvYXJkICYmIHRoaXMucmVuZGVyR2VuZXJhdGlvblVJKCl9XG4gICAgICAgIHtib2FyZCAmJiB0aGlzLnJlbmRlckhlYWRlcigpfVxuICAgICAgICB7Ym9hcmQgJiYgdGhpcy5yZW5kZXJQdXp6bGUoKX1cbiAgICAgICAge2JvYXJkICYmIHRoaXMucmVuZGVyQ29udHJvbHMoKX1cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJyb290ZXJcIj5cbiAgICAgICAgICBNYWRlIHdpdGggPHNwYW4+4p2k77iPPC9zcGFuPu+4jyBCeSA8YSBocmVmPVwiaHR0cHM6Ly93d3cuc2l0aWFubGl1LmNvbS9cIj5TaXRpYW4gTGl1PC9hPiB8IDxhIGhyZWY9XCJodHRwczovL21lZGl1bS5jb20vQHNpdGlhbmxpdV81NzY4MC9idWlsZGluZy1hLXN1ZG9rdS1nYW1lLWluLXJlYWN0LWNhNjYzOTE1NzEyXCI+QmxvZyBQb3N0PC9hPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgeyAvKiBsYW5ndWFnZT1DU1MgKi8gfVxuICAgICAgICA8c3R5bGUganN4PntgXG4gICAgICAgICAgICA6Z2xvYmFsKGJvZHkpLCAuYm9keSB7XG4gICAgICAgICAgICAgICAgZm9udC1mYW1pbHk6ICdTcGVjaWFsIEVsaXRlJywgY3Vyc2l2ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC5ib2R5IHtcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICAgICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgICAgICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDEwMHZoO1xuICAgICAgICAgICAgICAgIHdpZHRoOiAxMDB2dztcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBAbWVkaWEgKG1pbi13aWR0aDogODAwcHgpIGFuZCAobWluLWhlaWdodDogOTMwcHgpe1xuICAgICAgICAgICAgICAgIDpnbG9iYWwoLmhlYWRlciwgLnB1enpsZSwgLmNvbnRyb2xzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvbnQtc2l6ZTogMS41ZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQG1lZGlhIChtYXgtd2lkdGg6IDgwMHB4KSBhbmQgKG1pbi13aWR0aDogNjAwcHgpe1xuICAgICAgICAgICAgICAgIDpnbG9iYWwoLmhlYWRlciwgLnB1enpsZSwgLmNvbnRyb2xzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvbnQtc2l6ZTogMS4yZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQG1lZGlhIChtYXgtaGVpZ2h0OiA5MzBweCkgYW5kIChtaW4taGVpZ2h0OiA4MDBweCkgYW5kIChtaW4td2lkdGg6IDYwMHB4KXtcbiAgICAgICAgICAgICAgICA6Z2xvYmFsKC5oZWFkZXIsIC5wdXp6bGUsIC5jb250cm9scykge1xuICAgICAgICAgICAgICAgICAgICBmb250LXNpemU6IDEuMmVtO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEBtZWRpYSAobWF4LWhlaWdodDogODAwcHgpIGFuZCAobWluLWhlaWdodDogNjAwcHgpIGFuZCAobWluLXdpZHRoOiAzNzBweCl7XG4gICAgICAgICAgICAgICAgOmdsb2JhbCguaGVhZGVyLCAucHV6emxlLCAuY29udHJvbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9udC1zaXplOiAxZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQG1lZGlhIChtYXgtd2lkdGg6IDM3MHB4KXtcbiAgICAgICAgICAgICAgICA6Z2xvYmFsKC5oZWFkZXIsIC5wdXp6bGUsIC5jb250cm9scykge1xuICAgICAgICAgICAgICAgICAgICBmb250LXNpemU6IC44ZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQG1lZGlhIChtYXgtaGVpZ2h0OiA2MDBweCl7XG4gICAgICAgICAgICAgICAgOmdsb2JhbCguaGVhZGVyLCAucHV6emxlLCAuY29udHJvbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9udC1zaXplOiAuOGVtO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDpnbG9iYWwoYm9keSkge1xuICAgICAgICAgICAgICAgIG1hcmdpbjogMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC5yb290ZXIge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICAgICAgICAgICAgICBib3R0b206IDA7XG4gICAgICAgICAgICAgICAgZm9udC1zaXplOiAuOGVtO1xuICAgICAgICAgICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICAgICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgYH1cbiAgICAgICAgPC9zdHlsZT5cbiAgICAgICAgPHN0eWxlIGpzeCBnbG9iYWw+e1JhbmdlU3R5bGV9PC9zdHlsZT5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cbn1cbiJdfQ== */\n/*@ sourceURL=pages/index.js */');

// eslint-disable-next-line no-lone-blocks
ActionsStyle.__hash = '3577854778';
ActionsStyle.__scoped = '.actions.jsx-183028603{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;width:100%;max-width:400px;margin-top:.5em;padding:0 .6em;}.action.jsx-183028603{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;}.action.jsx-183028603 svg{width:2.5em;margin-bottom:.2em;}.redo.jsx-183028603 svg{-webkit-transform:scaleX(-1);-ms-transform:scaleX(-1);transform:scaleX(-1);}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhZ2VzL2luZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQW1Fd0IsQUFHa0IsQUFTQSxBQUtELEFBSVMsWUFIRixtQkFDdkIsMkNBZnVCLEFBU0EsQ0FTdkIsNEZBakJrQyxBQVNSLDhFQUMxQixxQ0FUZSxXQUNLLGdCQUNBLGdCQUNELGVBQ25CIiwiZmlsZSI6InBhZ2VzL2luZGV4LmpzIiwic291cmNlUm9vdCI6Ii9Vc2Vycy9saWNoZW5tYS9Qcm9qZWN0cy9TdUR1b2t1L1N1RHVva3UiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBqc3gtYTExeS9hY2Nlc3NpYmxlLWVtb2ppICovXG5pbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50LCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBTZXQsIExpc3QsIGZyb21KUyB9IGZyb20gJ2ltbXV0YWJsZSc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IE5leHRIZWFkIGZyb20gJ25leHQvaGVhZCc7XG5pbXBvcnQgQ29sb3IgZnJvbSAnY29sb3InO1xuaW1wb3J0IElucHV0UmFuZ2UgZnJvbSAncmVhY3QtaW5wdXQtcmFuZ2UnO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLWV4dHJhbmVvdXMtZGVwZW5kZW5jaWVzXG5pbXBvcnQgY3NzIGZyb20gJ3N0eWxlZC1qc3gvY3NzJztcblxuaW1wb3J0IFJhbmdlU3R5bGUgZnJvbSAnLi4vaW5wdXQtcmFuZ2Utc3R5bGUnO1xuaW1wb3J0IExvdXBlSWNvbiBmcm9tICcuLi9zdmcvbG91cGUuc3ZnJztcbmltcG9ydCBSZW1vdmVJY29uIGZyb20gJy4uL3N2Zy9yZW1vdmUuc3ZnJztcbmltcG9ydCBSZWxvYWRJY29uIGZyb20gJy4uL3N2Zy9yZWxvYWQuc3ZnJztcbmltcG9ydCBSZXR1cm5JY29uIGZyb20gJy4uL3N2Zy9yZXR1cm4uc3ZnJztcblxuaW1wb3J0IHsgbWFrZVB1enpsZSwgcGx1Y2ssIGlzUGVlciBhcyBhcmVDb29yZGluYXRlUGVlcnMsIHJhbmdlIH0gZnJvbSAnLi4vc3Vkb2t1JztcbmltcG9ydCB7IGJhY2tHcm91bmRCbHVlIH0gZnJvbSAnLi4vY29sb3JzJztcbmltcG9ydCBUaXAgZnJvbSAnLi4vY29tcG9uZW50cy90b29sLXRpcCc7XG5cbmltcG9ydCBpbyBmcm9tICdzb2NrZXQuaW8tY2xpZW50J1xuXG5jb25zdCBEZXNjcmlwdGlvbiA9ICdEaXNjb3ZlciB0aGUgbmV4dCBldm9sdXRpb24gb2YgU3Vkb2t1IHdpdGggYW1hemluZyBncmFwaGljcywgYW5pbWF0aW9ucywgYW5kIHVzZXItZnJpZW5kbHkgZmVhdHVyZXMuIEVuam95IGEgU3Vkb2t1IGV4cGVyaWVuY2UgbGlrZSB5b3UgbmV2ZXIgaGF2ZSBiZWZvcmUgd2l0aCBjdXN0b21pemFibGUgZ2FtZSBnZW5lcmF0aW9uLCBjZWxsIGhpZ2hsaWdodGluZywgaW50dWl0aXZlIGNvbnRyb2xzIGFuZCBtb3JlISc7XG5jb25zdCBjZWxsV2lkdGggPSAyLjU7XG5cbmNvbnN0IExpZ2h0Qmx1ZTEwMCA9ICcjQjNFNUZDJztcbmNvbnN0IExpZ2h0Qmx1ZTIwMCA9ICcjODFENEZBJztcbmNvbnN0IExpZ2h0Qmx1ZTMwMCA9ICcjNEZDM0Y3JztcbmNvbnN0IEluZGlnbzcwMCA9ICcjMzAzRjlGJztcbmNvbnN0IERlZXBPcmFuZ2UyMDAgPSAnI0ZGQUI5MSc7XG5jb25zdCBEZWVwT3JhbmdlNjAwID0gJyNGNDUxMUUnO1xuY29uc3QgQ29udHJvbE51bWJlckNvbG9yID0gSW5kaWdvNzAwO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbG9uZS1ibG9ja3NcbnsgLyogbGFuZ3VhZ2U9Q1NTICovIH1cbmNvbnN0IENlbGxTdHlsZSA9IGNzc2Bcbi5jZWxsIHtcbiAgICBoZWlnaHQ6ICR7Y2VsbFdpZHRofWVtO1xuICAgIHdpZHRoOiAke2NlbGxXaWR0aH1lbTtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtd3JhcDogd3JhcDtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgIGZvbnQtc2l6ZTogMS4xZW07XG4gICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgdHJhbnNpdGlvbjogYmFja2dyb3VuZC1jb2xvciAuM3MgZWFzZS1pbi1vdXQ7XG59XG4uY2VsbDpudGgtY2hpbGQoM24rMyk6bm90KDpsYXN0LWNoaWxkKSB7XG4gICAgYm9yZGVyLXJpZ2h0OiAycHggc29saWQgYmxhY2s7XG59XG4uY2VsbDpub3QoOmxhc3QtY2hpbGQpIHtcbiAgICBib3JkZXItcmlnaHQ6IDFweCBzb2xpZCBibGFjaztcbn1cbi5ub3RlLW51bWJlciB7XG4gICAgZm9udC1zaXplOiAuNmVtO1xuICAgIHdpZHRoOiAzMyU7XG4gICAgaGVpZ2h0OiAzMyU7XG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG59XG5gO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbG9uZS1ibG9ja3NcbnsgLyogbGFuZ3VhZ2U9Q1NTICovIH1cbmNvbnN0IEFjdGlvbnNTdHlsZSA9IGNzc2Bcbi5hY3Rpb25zIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIG1heC13aWR0aDogNDAwcHg7XG4gICAgbWFyZ2luLXRvcDogLjVlbTtcbiAgICBwYWRkaW5nOiAwIC42ZW07XG59XG4uYWN0aW9uIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbn1cbi5hY3Rpb24gOmdsb2JhbChzdmcpIHtcbiAgICB3aWR0aDogMi41ZW07XG4gICAgbWFyZ2luLWJvdHRvbTogLjJlbTtcbn1cbi5yZWRvIDpnbG9iYWwoc3ZnKSB7XG4gICAgdHJhbnNmb3JtOiBzY2FsZVgoLTEpO1xufVxuYDtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxvbmUtYmxvY2tzXG57IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG5jb25zdCBDb250cm9sU3R5bGUgPSBjc3NgXG4uY29udHJvbCB7XG4gICAgcGFkZGluZzogMCAyZW07XG4gICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIGRpc3BsYXk6IGlubGluZS1mbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgZmxleC13cmFwOiB3cmFwO1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgIGZvbnQtZmFtaWx5OiAnU3BlY2lhbCBFbGl0ZScsIGN1cnNpdmU7XG4gICAgdHJhbnNpdGlvbjogZmlsdGVyIC41cyBlYXNlLWluLW91dDtcbiAgICB3aWR0aDogMTAwJTtcbn1cbmA7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sb25lLWJsb2Nrc1xueyAvKiBsYW5ndWFnZT1DU1MgKi8gfVxuY29uc3QgTnVtYmVyQ29udHJvbFN0eWxlID0gY3NzYFxuLm51bWJlciB7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBmb250LXNpemU6IDJlbTtcbiAgICBtYXJnaW46IC4xZW07XG4gICAgd2lkdGg6IDEuNWVtO1xuICAgIGhlaWdodDogMS41ZW07XG4gICAgY29sb3I6ICR7Q29udHJvbE51bWJlckNvbG9yfTtcbiAgICBib3gtc2hhZG93OiAwIDFweCAycHggcmdiYSgwLDAsMCwwLjE2KSwgMCAxcHggMnB4IHJnYmEoMCwwLDAsMC4yMyk7XG4gICAgYm9yZGVyLXJhZGl1czogNTAlO1xufVxuLm51bWJlciA+IGRpdiB7XG4gICAgbWFyZ2luLXRvcDogLjNlbTtcbn1cbmA7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sb25lLWJsb2Nrc1xueyAvKiBsYW5ndWFnZT1DU1MgKi8gfVxuY29uc3QgUHV6emxlU3R5bGUgPSBjc3NgXG4ucHV6emxlIHtcbiAgICBtYXJnaW4tdG9wOiAuNWVtO1xuICAgIHdpZHRoOiAke2NlbGxXaWR0aCAqIDl9ZW07XG4gICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIGJveC1zaGFkb3c6IDAgM3B4IDZweCByZ2JhKDAsMCwwLDAuMTYpLCAwIDNweCA2cHggcmdiYSgwLDAsMCwwLjIzKTtcbn1cbi5yb3cge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBmbGV4OiAwO1xuICAgIHdpZHRoOiAke2NlbGxXaWR0aCAqIDl9ZW07XG59XG4ucm93Om5vdCg6bGFzdC1jaGlsZCkge1xuICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCBibGFjaztcbn1cbi5yb3c6bnRoLWNoaWxkKDNuKzMpOm5vdCg6bGFzdC1jaGlsZCkge1xuICAgIGJvcmRlci1ib3R0b206IDJweCBzb2xpZCBibGFjayAhaW1wb3J0YW50O1xufVxuYDtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxvbmUtYmxvY2tzXG57IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG5jb25zdCBDaXJjdWx1YXJQcm9ncmVzc1N0eWxlID0gY3NzYFxuLmNpcmN1bGFyLXByb2dyZXNzIHtcbiAgICBkaXNwbGF5OiBibG9jaztcbiAgICB3aWR0aDogMTAwJTtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgdG9wOiAwO1xuICAgIGxlZnQ6IDA7XG4gICAgdHJhbnNpdGlvbjogZmlsdGVyIC40cyBlYXNlLWluLW91dDtcbn1cblxuLmNpcmNsZS1iZyB7XG4gICAgZmlsbDogbm9uZTtcbiAgICBzdHJva2U6ICNlZWU7XG4gICAgc3Ryb2tlLXdpZHRoOiAzLjg7XG59XG5cbi5jaXJjbGUge1xuICAgIHN0cm9rZTogJHtDb250cm9sTnVtYmVyQ29sb3J9O1xuICAgIHRyYW5zaXRpb246IHN0cm9rZS1kYXNoYXJyYXkgLjRzIGVhc2UtaW4tb3V0O1xuICAgIGZpbGw6IG5vbmU7XG4gICAgc3Ryb2tlLXdpZHRoOiAyLjg7XG4gICAgc3Ryb2tlLWxpbmVjYXA6IHJvdW5kO1xufVxuYDtcblxuY29uc3QgQ2lyY3VsYXJQYXRoRCA9ICdNMTggMi4wODQ1IGEgMTUuOTE1NSAxNS45MTU1IDAgMCAxIDAgMzEuODMxIGEgMTUuOTE1NSAxNS45MTU1IDAgMCAxIDAgLTMxLjgzMSc7XG5cbmZ1bmN0aW9uIGdldEJhY2tHcm91bmRDb2xvcih7XG4gIGNvbmZsaWN0LCBpc1BlZXIsIHNhbWVWYWx1ZSwgaXNTZWxlY3RlZCxcbn0pIHtcbiAgaWYgKGNvbmZsaWN0ICYmIGlzUGVlciAmJiBzYW1lVmFsdWUpIHtcbiAgICByZXR1cm4gRGVlcE9yYW5nZTIwMDtcbiAgfSBlbHNlIGlmIChzYW1lVmFsdWUpIHtcbiAgICByZXR1cm4gTGlnaHRCbHVlMzAwO1xuICB9IGVsc2UgaWYgKGlzU2VsZWN0ZWQpIHtcbiAgICByZXR1cm4gTGlnaHRCbHVlMjAwO1xuICB9IGVsc2UgaWYgKGlzUGVlcikge1xuICAgIHJldHVybiBMaWdodEJsdWUxMDA7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRGb250Q29sb3IoeyB2YWx1ZSwgY29uZmxpY3QsIHByZWZpbGxlZCB9KSB7XG4gIGlmIChjb25mbGljdCAmJiAhcHJlZmlsbGVkKSB7XG4gICAgcmV0dXJuIERlZXBPcmFuZ2U2MDA7XG4gIH0gZWxzZSBpZiAoIXByZWZpbGxlZCAmJiB2YWx1ZSkge1xuICAgIHJldHVybiBDb250cm9sTnVtYmVyQ29sb3I7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5jbGFzcyBHZW5lcmF0aW9uVUkgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcblxuICAgIHRoaXMuc3RhdGUgPSB7IHZhbHVlOiAzMCB9O1xuICB9XG5cbiAgZ2VuZXJhdGVHYW1lID0gKCkgPT4ge1xuICAgIHRoaXMucHJvcHMuZ2VuZXJhdGVHYW1lKHRoaXMuc3RhdGUudmFsdWUpO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImdlbmVyYXRpb25cIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb3B5XCI+U3RhcnQgd2l0aCB7dGhpcy5zdGF0ZS52YWx1ZX0gY2VsbHMgcHJlZmlsbGVkPC9kaXY+XG4gICAgICAgIDxJbnB1dFJhbmdlXG4gICAgICAgICAgbWF4VmFsdWU9ezgxfVxuICAgICAgICAgIG1pblZhbHVlPXsxN31cbiAgICAgICAgICB2YWx1ZT17dGhpcy5zdGF0ZS52YWx1ZX1cbiAgICAgICAgICBvbkNoYW5nZT17dmFsdWUgPT4gdGhpcy5zZXRTdGF0ZSh7IHZhbHVlIH0pfVxuICAgICAgICAvPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImJ1dHRvblwiIG9uQ2xpY2s9e3RoaXMuZ2VuZXJhdGVHYW1lfT5QbGF5IFN1ZG9rdTwvZGl2PlxuICAgICAgICB7IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG4gICAgICAgIDxzdHlsZSBqc3g+e2BcbiAgICAgICAgICAgIC5jb3B5IHtcbiAgICAgICAgICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgICAgICAgICAgICAgZm9udC1zaXplOiAxLjNlbTtcbiAgICAgICAgICAgICAgICBtYXJnaW4tYm90dG9tOiAuNWVtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLmdlbmVyYXRpb24ge1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgICAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgICAgICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOmdsb2JhbCguaW5wdXQtcmFuZ2UpIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogODAlO1xuICAgICAgICAgICAgICAgIG1heC13aWR0aDogNTAwcHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAuYnV0dG9uIHtcbiAgICAgICAgICAgICAgbWFyZ2luLXRvcDogLjVlbTtcbiAgICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogLjI1ZW07XG4gICAgICAgICAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICAgICAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICAgICAgICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcbiAgICAgICAgICAgICAgY29sb3I6ICNmZmY7XG4gICAgICAgICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgICAgICAgICAgICB0cmFuc2l0aW9uOiBhbGwgLjI1cztcbiAgICAgICAgICAgICAgcGFkZGluZzogNXB4IDEwcHg7XG4gICAgICAgICAgICAgIGZvbnQtc2l6ZTogMS40ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAuYnV0dG9uOmFjdGl2ZSB7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKDBweCwgNXB4KTtcbiAgICAgICAgICAgICAgYm94LXNoYWRvdzogMCAxcHggMCAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAuYnV0dG9uIHtcbiAgICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogJHtiYWNrR3JvdW5kQmx1ZX07XG4gICAgICAgICAgICAgIGJveC1zaGFkb3c6IDAgMnB4IDRweCAwICR7Q29sb3IoYmFja0dyb3VuZEJsdWUpLmRhcmtlbigwLjUpLmhzbCgpLnN0cmluZygpfTtcbiAgICAgICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLmJ1dHRvbjpob3ZlciB7XG4gICAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6ICR7Q29sb3IoYmFja0dyb3VuZEJsdWUpLmxpZ2h0ZW4oMC4yKS5oc2woKS5zdHJpbmcoKX07XG4gICAgICAgICAgICB9XG4gICAgICAgIGB9XG4gICAgICAgIDwvc3R5bGU+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG59XG5cbkdlbmVyYXRpb25VSS5wcm9wVHlwZXMgPSB7XG4gIGdlbmVyYXRlR2FtZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbn07XG5cbmNvbnN0IE51bWJlckNvbnRyb2wgPSAoeyBudW1iZXIsIG9uQ2xpY2ssIGNvbXBsZXRpb25QZXJjZW50YWdlIH0pID0+IChcbiAgPGRpdlxuICAgIGtleT17bnVtYmVyfVxuICAgIGNsYXNzTmFtZT1cIm51bWJlclwiXG4gICAgb25DbGljaz17b25DbGlja31cbiAgPlxuICAgIDxkaXY+e251bWJlcn08L2Rpdj5cbiAgICA8Q2lyY2x1bGFyUHJvZ3Jlc3MgcGVyY2VudD17Y29tcGxldGlvblBlcmNlbnRhZ2V9IC8+XG4gICAgPHN0eWxlIGpzeD57TnVtYmVyQ29udHJvbFN0eWxlfTwvc3R5bGU+XG4gIDwvZGl2PlxuKTtcblxuTnVtYmVyQ29udHJvbC5wcm9wVHlwZXMgPSB7XG4gIG51bWJlcjogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICBvbkNsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgY29tcGxldGlvblBlcmNlbnRhZ2U6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbn07XG5cbk51bWJlckNvbnRyb2wuZGVmYXVsdFByb3BzID0ge1xuICBvbkNsaWNrOiBudWxsLFxufTtcblxuY29uc3QgQ2VsbCA9IChwcm9wcykgPT4ge1xuICBjb25zdCB7XG4gICAgdmFsdWUsIG9uQ2xpY2ssIGlzUGVlciwgaXNTZWxlY3RlZCwgc2FtZVZhbHVlLCBwcmVmaWxsZWQsIG5vdGVzLCBjb25mbGljdCxcbiAgfSA9IHByb3BzO1xuICBjb25zdCBiYWNrZ3JvdW5kQ29sb3IgPSBnZXRCYWNrR3JvdW5kQ29sb3Ioe1xuICAgIGNvbmZsaWN0LCBpc1BlZXIsIHNhbWVWYWx1ZSwgaXNTZWxlY3RlZCxcbiAgfSk7XG4gIGNvbnN0IGZvbnRDb2xvciA9IGdldEZvbnRDb2xvcih7IGNvbmZsaWN0LCBwcmVmaWxsZWQsIHZhbHVlIH0pO1xuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwiY2VsbFwiIG9uQ2xpY2s9e29uQ2xpY2t9PlxuICAgICAge1xuICAgICAgICBub3RlcyA/XG4gICAgICAgICAgcmFuZ2UoOSkubWFwKGkgPT5cbiAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgPGRpdiBrZXk9e2l9IGNsYXNzTmFtZT1cIm5vdGUtbnVtYmVyXCI+XG4gICAgICAgICAgICAgICAge25vdGVzLmhhcyhpICsgMSkgJiYgKGkgKyAxKX1cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICApKSA6XG4gICAgICAgICAgdmFsdWUgJiYgdmFsdWVcbiAgICAgIH1cbiAgICAgIHsvKiBsYW5ndWFnZT1DU1MgKi99XG4gICAgICA8c3R5bGUganN4PntDZWxsU3R5bGV9PC9zdHlsZT5cbiAgICAgIDxzdHlsZSBqc3g+e2BcbiAgICAgICAgICAgICAgICAuY2VsbCB7XG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6ICR7YmFja2dyb3VuZENvbG9yIHx8ICdpbml0aWFsJ307XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiAke2ZvbnRDb2xvciB8fCAnaW5pdGlhbCd9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGB9XG4gICAgICA8L3N0eWxlPlxuICAgIDwvZGl2PlxuICApO1xufTtcblxuQ2VsbC5wcm9wVHlwZXMgPSB7XG4gIC8vIGN1cnJlbnQgbnVtYmVyIHZhbHVlXG4gIHZhbHVlOiBQcm9wVHlwZXMubnVtYmVyLFxuICAvLyBjZWxsIGNsaWNrIGhhbmRsZXJcbiAgb25DbGljazogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgLy8gaWYgdGhlIGNlbGwgaXMgYSBwZWVyIG9mIHRoZSBzZWxlY3RlZCBjZWxsXG4gIGlzUGVlcjogUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZCxcbiAgLy8gaWYgdGhlIGNlbGwgaXMgc2VsZWN0ZWQgYnkgdGhlIHVzZXJcbiAgaXNTZWxlY3RlZDogUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZCxcbiAgLy8gY3VycmVudCBjZWxsIGhhcyB0aGUgc2FtZSB2YWx1ZSBpZiB0aGUgdXNlciBzZWxlY3RlZCBjZWxsXG4gIHNhbWVWYWx1ZTogUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZCxcbiAgLy8gaWYgdGhpcyB3YXMgcHJlZmlsbGVkIGFzIGEgcGFydCBvZiB0aGUgcHV6emxlXG4gIHByZWZpbGxlZDogUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZCxcbiAgLy8gY3VycmVudCBub3RlcyB0YWtlbiBvbiB0aGUgY2VsbFxuICBub3RlczogUHJvcFR5cGVzLmluc3RhbmNlT2YoU2V0KSxcbiAgLy8gaWYgdGhlIGN1cnJlbnQgY2VsbCBkb2VzIG5vdCBzYXRpc2Z5IHRoZSBnYW1lIGNvbnN0cmFpbnRcbiAgY29uZmxpY3Q6IFByb3BUeXBlcy5ib29sLmlzUmVxdWlyZWQsXG59O1xuXG5DZWxsLmRlZmF1bHRQcm9wcyA9IHtcbiAgbm90ZXM6IG51bGwsXG4gIHZhbHVlOiBudWxsLFxufTtcblxuY29uc3QgQ2lyY2x1bGFyUHJvZ3Jlc3MgPSAoeyBwZXJjZW50IH0pID0+IChcbiAgPHN2ZyB2aWV3Qm94PVwiMCAwIDM2IDM2XCIgY2xhc3NOYW1lPVwiY2lyY3VsYXItcHJvZ3Jlc3NcIj5cbiAgICA8cGF0aFxuICAgICAgY2xhc3NOYW1lPVwiY2lyY2xlLWJnXCJcbiAgICAgIGQ9e0NpcmN1bGFyUGF0aER9XG4gICAgLz5cbiAgICA8cGF0aFxuICAgICAgY2xhc3NOYW1lPVwiY2lyY2xlXCJcbiAgICAgIHN0cm9rZURhc2hhcnJheT17YCR7cGVyY2VudCAqIDEwMH0sIDEwMGB9XG4gICAgICBkPXtDaXJjdWxhclBhdGhEfVxuICAgIC8+XG4gICAgeyAvKiBsYW5ndWFnZT1DU1MgKi8gfVxuICAgIDxzdHlsZSBqc3g+e0NpcmN1bHVhclByb2dyZXNzU3R5bGV9PC9zdHlsZT5cbiAgPC9zdmc+XG4pO1xuXG5DaXJjbHVsYXJQcm9ncmVzcy5wcm9wVHlwZXMgPSB7XG4gIHBlcmNlbnQ6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbn07XG5cbmZ1bmN0aW9uIGdldENsaWNrSGFuZGxlcihvbkNsaWNrLCBvbkRvdWJsZUNsaWNrLCBkZWxheSA9IDI1MCkge1xuICBsZXQgdGltZW91dElEID0gbnVsbDtcbiAgcmV0dXJuIChldmVudCkgPT4ge1xuICAgIGlmICghdGltZW91dElEKSB7XG4gICAgICB0aW1lb3V0SUQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgb25DbGljayhldmVudCk7XG4gICAgICAgIHRpbWVvdXRJRCA9IG51bGw7XG4gICAgICB9LCBkZWxheSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpbWVvdXRJRCA9IGNsZWFyVGltZW91dCh0aW1lb3V0SUQpO1xuICAgICAgb25Eb3VibGVDbGljayhldmVudCk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIG1ha2Ugc2l6ZSA5IGFycmF5IG9mIDBzXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIG1ha2VDb3VudE9iamVjdCgpIHtcbiAgY29uc3QgY291bnRPYmogPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSArPSAxKSBjb3VudE9iai5wdXNoKDApO1xuICByZXR1cm4gY291bnRPYmo7XG59XG5cbi8qKlxuICogZ2l2ZW4gYSAyRCBhcnJheSBvZiBudW1iZXJzIGFzIHRoZSBpbml0aWFsIHB1enpsZSwgZ2VuZXJhdGUgdGhlIGluaXRpYWwgZ2FtZSBzdGF0ZVxuICogQHBhcmFtIHB1enpsZVxuICogQHJldHVybnMge2FueX1cbiAqL1xuZnVuY3Rpb24gbWFrZUJvYXJkKHsgcHV6emxlIH0pIHtcbiAgLy8gY3JlYXRlIGluaXRpYWwgY291bnQgb2JqZWN0IHRvIGtlZXAgdHJhY2sgb2YgY29uZmxpY3RzIHBlciBudW1iZXIgdmFsdWVcbiAgY29uc3Qgcm93cyA9IEFycmF5LmZyb20oQXJyYXkoOSkua2V5cygpKS5tYXAoKCkgPT4gbWFrZUNvdW50T2JqZWN0KCkpO1xuICBjb25zdCBjb2x1bW5zID0gQXJyYXkuZnJvbShBcnJheSg5KS5rZXlzKCkpLm1hcCgoKSA9PiBtYWtlQ291bnRPYmplY3QoKSk7XG4gIGNvbnN0IHNxdWFyZXMgPSBBcnJheS5mcm9tKEFycmF5KDkpLmtleXMoKSkubWFwKCgpID0+IG1ha2VDb3VudE9iamVjdCgpKTtcbiAgY29uc3QgcmVzdWx0ID0gcHV6emxlLm1hcCgocm93LCBpKSA9PiAoXG4gICAgcm93Lm1hcCgoY2VsbCwgaikgPT4ge1xuICAgICAgaWYgKGNlbGwpIHtcbiAgICAgICAgcm93c1tpXVtjZWxsXSArPSAxO1xuICAgICAgICBjb2x1bW5zW2pdW2NlbGxdICs9IDE7XG4gICAgICAgIHNxdWFyZXNbKChNYXRoLmZsb29yKGkgLyAzKSkgKiAzKSArIE1hdGguZmxvb3IoaiAvIDMpXVtjZWxsXSArPSAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHB1enpsZVtpXVtqXSA+IDAgPyBwdXp6bGVbaV1bal0gOiBudWxsLFxuICAgICAgICBwcmVmaWxsZWQ6ICEhcHV6emxlW2ldW2pdLFxuICAgICAgfTtcbiAgICB9KVxuICApKTtcbiAgcmV0dXJuIGZyb21KUyh7IHB1enpsZTogcmVzdWx0LCBzZWxlY3RlZDogZmFsc2UsIGNob2ljZXM6IHsgcm93cywgY29sdW1ucywgc3F1YXJlcyB9IH0pO1xufVxuXG4vKipcbiAqIGdpdmUgdGhlIGNvb3JkaW5hdGUgdXBkYXRlIHRoZSBjdXJyZW50IGJvYXJkIHdpdGggYSBudW1iZXIgY2hvaWNlXG4gKiBAcGFyYW0geFxuICogQHBhcmFtIHlcbiAqIEBwYXJhbSBudW1iZXJcbiAqIEBwYXJhbSBmaWxsIHdoZXRoZXIgdG8gc2V0IG9yIHVuc2V0XG4gKiBAcGFyYW0gYm9hcmQgdGhlIGltbXV0YWJsZSBib2FyZCBnaXZlbiB0byBjaGFuZ2VcbiAqL1xuZnVuY3Rpb24gdXBkYXRlQm9hcmRXaXRoTnVtYmVyKHtcbiAgeCwgeSwgbnVtYmVyLCBmaWxsID0gdHJ1ZSwgYm9hcmQsXG59KSB7XG4gIGxldCBjZWxsID0gYm9hcmQuZ2V0KCdwdXp6bGUnKS5nZXRJbihbeCwgeV0pO1xuICAvLyBkZWxldGUgaXRzIG5vdGVzXG4gIGNlbGwgPSBjZWxsLmRlbGV0ZSgnbm90ZXMnKTtcbiAgLy8gc2V0IG9yIHVuc2V0IGl0cyB2YWx1ZSBkZXBlbmRpbmcgb24gYGZpbGxgXG4gIGNlbGwgPSBmaWxsID8gY2VsbC5zZXQoJ3ZhbHVlJywgbnVtYmVyKSA6IGNlbGwuZGVsZXRlKCd2YWx1ZScpO1xuICBjb25zdCBpbmNyZW1lbnQgPSBmaWxsID8gMSA6IC0xO1xuICAvLyB1cGRhdGUgdGhlIGN1cnJlbnQgZ3JvdXAgY2hvaWNlc1xuICBjb25zdCByb3dQYXRoID0gWydjaG9pY2VzJywgJ3Jvd3MnLCB4LCBudW1iZXJdO1xuICBjb25zdCBjb2x1bW5QYXRoID0gWydjaG9pY2VzJywgJ2NvbHVtbnMnLCB5LCBudW1iZXJdO1xuICBjb25zdCBzcXVhcmVQYXRoID0gWydjaG9pY2VzJywgJ3NxdWFyZXMnLFxuICAgICgoTWF0aC5mbG9vcih4IC8gMykpICogMykgKyBNYXRoLmZsb29yKHkgLyAzKSwgbnVtYmVyXTtcbiAgcmV0dXJuIGJvYXJkLnNldEluKHJvd1BhdGgsIGJvYXJkLmdldEluKHJvd1BhdGgpICsgaW5jcmVtZW50KVxuICAgIC5zZXRJbihjb2x1bW5QYXRoLCBib2FyZC5nZXRJbihjb2x1bW5QYXRoKSArIGluY3JlbWVudClcbiAgICAuc2V0SW4oc3F1YXJlUGF0aCwgYm9hcmQuZ2V0SW4oc3F1YXJlUGF0aCkgKyBpbmNyZW1lbnQpXG4gICAgLnNldEluKFsncHV6emxlJywgeCwgeV0sIGNlbGwpO1xufVxuXG5mdW5jdGlvbiBnZXROdW1iZXJPZkdyb3Vwc0Fzc2lnbmVkRm9yTnVtYmVyKG51bWJlciwgZ3JvdXBzKSB7XG4gIHJldHVybiBncm91cHMucmVkdWNlKChhY2N1bXVsYXRvciwgcm93KSA9PlxuICAgIGFjY3VtdWxhdG9yICsgKHJvdy5nZXQobnVtYmVyKSA+IDAgPyAxIDogMCksIDApO1xufVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L25vLW11bHRpLWNvbXBcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEluZGV4IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgc3RhdGUgPSB7fTtcblxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICBpZiAoJ3NlcnZpY2VXb3JrZXInIGluIG5hdmlnYXRvcikge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICAgICBuYXZpZ2F0b3Iuc2VydmljZVdvcmtlclxuICAgICAgICAucmVnaXN0ZXIoJy9zZXJ2aWNlLXdvcmtlci5qcycpXG4gICAgICAgIC50aGVuKChyZWcpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnU2VydmljZVdvcmtlciBzY29wZTogJywgcmVnLnNjb3BlKTtcbiAgICAgICAgICBjb25zb2xlLmxvZygnc2VydmljZSB3b3JrZXIgcmVnaXN0cmF0aW9uIHN1Y2Nlc3NmdWwnKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ3NlcnZpY2Ugd29ya2VyIHJlZ2lzdHJhdGlvbiBmYWlsZWQnLCBlcnIubWVzc2FnZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgXG4gICAgZmV0Y2goJy9hcGkvc29ja2V0aW8nKS5maW5hbGx5KCgpID0+IHtcbiAgICAgIGNvbnN0IHNvY2tldCA9IGlvKClcblxuICAgICAgc29ja2V0Lm9uKCdjb25uZWN0JywgKCkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZygnY29ubmVjdCcpXG4gICAgICAgIHNvY2tldC5lbWl0KCdoZWxsbycpXG4gICAgICB9KVxuXG4gICAgICBzb2NrZXQub24oJ2hlbGxvJywgZGF0YSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdoZWxsbycsIGRhdGEpXG4gICAgICB9KVxuXG4gICAgICBzb2NrZXQub24oJ2EgdXNlciBjb25uZWN0ZWQnLCAoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdhIHVzZXIgY29ubmVjdGVkJylcbiAgICAgIH0pXG5cbiAgICAgIHNvY2tldC5vbignZGlzY29ubmVjdCcsICgpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ2Rpc2Nvbm5lY3QnKVxuICAgICAgfSlcbiAgICB9KVxuICAgXG4gIH1cbiAgZ2V0U2VsZWN0ZWRDZWxsKCkge1xuICAgIGNvbnN0IHsgYm9hcmQgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3Qgc2VsZWN0ZWQgPSBib2FyZC5nZXQoJ3NlbGVjdGVkJyk7XG4gICAgcmV0dXJuIHNlbGVjdGVkICYmIGJvYXJkLmdldCgncHV6emxlJykuZ2V0SW4oW3NlbGVjdGVkLngsIHNlbGVjdGVkLnldKTtcbiAgfVxuXG4gIC8vIGdldCB0aGUgbWluIGJldHdlZW4gaXRzIGNvbXBsZXRpb24gaW4gcm93cywgY29sdW1ucyBhbmQgc3F1YXJlcy5cbiAgZ2V0TnVtYmVyVmFsdWVDb3VudChudW1iZXIpIHtcbiAgICBjb25zdCByb3dzID0gdGhpcy5zdGF0ZS5ib2FyZC5nZXRJbihbJ2Nob2ljZXMnLCAncm93cyddKTtcbiAgICBjb25zdCBjb2x1bW5zID0gdGhpcy5zdGF0ZS5ib2FyZC5nZXRJbihbJ2Nob2ljZXMnLCAnY29sdW1ucyddKTtcbiAgICBjb25zdCBzcXVhcmVzID0gdGhpcy5zdGF0ZS5ib2FyZC5nZXRJbihbJ2Nob2ljZXMnLCAnc3F1YXJlcyddKTtcbiAgICByZXR1cm4gTWF0aC5taW4oXG4gICAgICBnZXROdW1iZXJPZkdyb3Vwc0Fzc2lnbmVkRm9yTnVtYmVyKG51bWJlciwgc3F1YXJlcyksXG4gICAgICBNYXRoLm1pbihcbiAgICAgICAgZ2V0TnVtYmVyT2ZHcm91cHNBc3NpZ25lZEZvck51bWJlcihudW1iZXIsIHJvd3MpLFxuICAgICAgICBnZXROdW1iZXJPZkdyb3Vwc0Fzc2lnbmVkRm9yTnVtYmVyKG51bWJlciwgY29sdW1ucyksXG4gICAgICApLFxuICAgICk7XG4gIH1cblxuICBnZW5lcmF0ZUdhbWUgPSAoZmluYWxDb3VudCA9IDIwKSA9PiB7XG4gICAgLy8gZ2V0IGEgZmlsbGVkIHB1enpsZSBnZW5lcmF0ZWRcbiAgICBjb25zdCBzb2x1dGlvbiA9IG1ha2VQdXp6bGUoKTtcbiAgICAvLyBwbHVjayB2YWx1ZXMgZnJvbSBjZWxscyB0byBjcmVhdGUgdGhlIGdhbWVcbiAgICBjb25zdCB7IHB1enpsZSB9ID0gcGx1Y2soc29sdXRpb24sIGZpbmFsQ291bnQpO1xuICAgIC8vIGluaXRpYWxpemUgdGhlIGJvYXJkIHdpdGggY2hvaWNlIGNvdW50c1xuICAgIGNvbnN0IGJvYXJkID0gbWFrZUJvYXJkKHsgcHV6emxlIH0pO1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgYm9hcmQsIGhpc3Rvcnk6IExpc3Qub2YoYm9hcmQpLCBoaXN0b3J5T2ZmU2V0OiAwLCBzb2x1dGlvbixcbiAgICB9KTtcbiAgfVxuXG4gIGFkZE51bWJlckFzTm90ZSA9IChudW1iZXIpID0+IHtcbiAgICBsZXQgeyBib2FyZCB9ID0gdGhpcy5zdGF0ZTtcbiAgICBsZXQgc2VsZWN0ZWRDZWxsID0gdGhpcy5nZXRTZWxlY3RlZENlbGwoKTtcbiAgICBpZiAoIXNlbGVjdGVkQ2VsbCkgcmV0dXJuO1xuICAgIGNvbnN0IHByZWZpbGxlZCA9IHNlbGVjdGVkQ2VsbC5nZXQoJ3ByZWZpbGxlZCcpO1xuICAgIGlmIChwcmVmaWxsZWQpIHJldHVybjtcbiAgICBjb25zdCB7IHgsIHkgfSA9IGJvYXJkLmdldCgnc2VsZWN0ZWQnKTtcbiAgICBjb25zdCBjdXJyZW50VmFsdWUgPSBzZWxlY3RlZENlbGwuZ2V0KCd2YWx1ZScpO1xuICAgIGlmIChjdXJyZW50VmFsdWUpIHtcbiAgICAgIGJvYXJkID0gdXBkYXRlQm9hcmRXaXRoTnVtYmVyKHtcbiAgICAgICAgeCwgeSwgbnVtYmVyOiBjdXJyZW50VmFsdWUsIGZpbGw6IGZhbHNlLCBib2FyZDogdGhpcy5zdGF0ZS5ib2FyZCxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBsZXQgbm90ZXMgPSBzZWxlY3RlZENlbGwuZ2V0KCdub3RlcycpIHx8IFNldCgpO1xuICAgIGlmIChub3Rlcy5oYXMobnVtYmVyKSkge1xuICAgICAgbm90ZXMgPSBub3Rlcy5kZWxldGUobnVtYmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm90ZXMgPSBub3Rlcy5hZGQobnVtYmVyKTtcbiAgICB9XG4gICAgc2VsZWN0ZWRDZWxsID0gc2VsZWN0ZWRDZWxsLnNldCgnbm90ZXMnLCBub3Rlcyk7XG4gICAgc2VsZWN0ZWRDZWxsID0gc2VsZWN0ZWRDZWxsLmRlbGV0ZSgndmFsdWUnKTtcbiAgICBib2FyZCA9IGJvYXJkLnNldEluKFsncHV6emxlJywgeCwgeV0sIHNlbGVjdGVkQ2VsbCk7XG4gICAgdGhpcy51cGRhdGVCb2FyZChib2FyZCk7XG4gIH07XG5cbiAgdXBkYXRlQm9hcmQgPSAobmV3Qm9hcmQpID0+IHtcbiAgICBsZXQgeyBoaXN0b3J5IH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IHsgaGlzdG9yeU9mZlNldCB9ID0gdGhpcy5zdGF0ZTtcbiAgICAvLyBhbnl0aGluZyBiZWZvcmUgY3VycmVudCBzdGVwIGlzIHN0aWxsIGluIGhpc3RvcnlcbiAgICBoaXN0b3J5ID0gaGlzdG9yeS5zbGljZSgwLCBoaXN0b3J5T2ZmU2V0ICsgMSk7XG4gICAgLy8gYWRkIGl0c2VsZiBvbnRvIHRoZSBoaXN0b3J5XG4gICAgaGlzdG9yeSA9IGhpc3RvcnkucHVzaChuZXdCb2FyZCk7XG4gICAgLy8gdXBkYXRlIHRoZSBnYW1lXG4gICAgdGhpcy5zZXRTdGF0ZSh7IGJvYXJkOiBuZXdCb2FyZCwgaGlzdG9yeSwgaGlzdG9yeU9mZlNldDogaGlzdG9yeS5zaXplIC0gMSB9KTtcbiAgfTtcblxuICBjYW5VbmRvID0gKCkgPT4gdGhpcy5zdGF0ZS5oaXN0b3J5T2ZmU2V0ID4gMFxuXG4gIHJlZG8gPSAoKSA9PiB7XG4gICAgY29uc3QgeyBoaXN0b3J5IH0gPSB0aGlzLnN0YXRlO1xuICAgIGxldCB7IGhpc3RvcnlPZmZTZXQgfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKGhpc3Rvcnkuc2l6ZSkge1xuICAgICAgaGlzdG9yeU9mZlNldCA9IE1hdGgubWluKGhpc3Rvcnkuc2l6ZSAtIDEsIGhpc3RvcnlPZmZTZXQgKyAxKTtcbiAgICAgIGNvbnN0IGJvYXJkID0gaGlzdG9yeS5nZXQoaGlzdG9yeU9mZlNldCk7XG4gICAgICB0aGlzLnNldFN0YXRlKHsgYm9hcmQsIGhpc3RvcnlPZmZTZXQgfSk7XG4gICAgfVxuICB9O1xuXG4gIHVuZG8gPSAoKSA9PiB7XG4gICAgY29uc3QgeyBoaXN0b3J5IH0gPSB0aGlzLnN0YXRlO1xuICAgIGxldCB7IGhpc3RvcnlPZmZTZXQsIGJvYXJkIH0gPSB0aGlzLnN0YXRlO1xuICAgIGlmIChoaXN0b3J5LnNpemUpIHtcbiAgICAgIGhpc3RvcnlPZmZTZXQgPSBNYXRoLm1heCgwLCBoaXN0b3J5T2ZmU2V0IC0gMSk7XG4gICAgICBib2FyZCA9IGhpc3RvcnkuZ2V0KGhpc3RvcnlPZmZTZXQpO1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IGJvYXJkLCBoaXN0b3J5T2ZmU2V0LCBoaXN0b3J5IH0pO1xuICAgIH1cbiAgfTtcblxuICBlcmFzZVNlbGVjdGVkID0gKCkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGVkQ2VsbCA9IHRoaXMuZ2V0U2VsZWN0ZWRDZWxsKCk7XG4gICAgaWYgKCFzZWxlY3RlZENlbGwpIHJldHVybjtcbiAgICB0aGlzLmZpbGxOdW1iZXIoZmFsc2UpO1xuICB9XG5cbiAgZmlsbFNlbGVjdGVkV2l0aFNvbHV0aW9uID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgYm9hcmQsIHNvbHV0aW9uIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IHNlbGVjdGVkQ2VsbCA9IHRoaXMuZ2V0U2VsZWN0ZWRDZWxsKCk7XG4gICAgaWYgKCFzZWxlY3RlZENlbGwpIHJldHVybjtcbiAgICBjb25zdCB7IHgsIHkgfSA9IGJvYXJkLmdldCgnc2VsZWN0ZWQnKTtcbiAgICB0aGlzLmZpbGxOdW1iZXIoc29sdXRpb25beF1beV0pO1xuICB9XG5cblxuICAvLyBmaWxsIGN1cnJlbnRseSBzZWxlY3RlZCBjZWxsIHdpdGggbnVtYmVyXG4gIGZpbGxOdW1iZXIgPSAobnVtYmVyKSA9PiB7XG4gICAgbGV0IHsgYm9hcmQgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3Qgc2VsZWN0ZWRDZWxsID0gdGhpcy5nZXRTZWxlY3RlZENlbGwoKTtcbiAgICAvLyBuby1vcCBpZiBub3RoaW5nIGlzIHNlbGVjdGVkXG4gICAgaWYgKCFzZWxlY3RlZENlbGwpIHJldHVybjtcbiAgICBjb25zdCBwcmVmaWxsZWQgPSBzZWxlY3RlZENlbGwuZ2V0KCdwcmVmaWxsZWQnKTtcbiAgICAvLyBuby1vcCBpZiBpdCBpcyByZWZpbGxlZFxuICAgIGlmIChwcmVmaWxsZWQpIHJldHVybjtcbiAgICBjb25zdCB7IHgsIHkgfSA9IGJvYXJkLmdldCgnc2VsZWN0ZWQnKTtcbiAgICBjb25zdCBjdXJyZW50VmFsdWUgPSBzZWxlY3RlZENlbGwuZ2V0KCd2YWx1ZScpO1xuICAgIC8vIHJlbW92ZSB0aGUgY3VycmVudCB2YWx1ZSBhbmQgdXBkYXRlIHRoZSBnYW1lIHN0YXRlXG4gICAgaWYgKGN1cnJlbnRWYWx1ZSkge1xuICAgICAgYm9hcmQgPSB1cGRhdGVCb2FyZFdpdGhOdW1iZXIoe1xuICAgICAgICB4LCB5LCBudW1iZXI6IGN1cnJlbnRWYWx1ZSwgZmlsbDogZmFsc2UsIGJvYXJkOiB0aGlzLnN0YXRlLmJvYXJkLFxuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIHVwZGF0ZSB0byBuZXcgbnVtYmVyIGlmIGFueVxuICAgIGNvbnN0IHNldE51bWJlciA9IGN1cnJlbnRWYWx1ZSAhPT0gbnVtYmVyICYmIG51bWJlcjtcbiAgICBpZiAoc2V0TnVtYmVyKSB7XG4gICAgICBib2FyZCA9IHVwZGF0ZUJvYXJkV2l0aE51bWJlcih7XG4gICAgICAgIHgsIHksIG51bWJlciwgZmlsbDogdHJ1ZSwgYm9hcmQsXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVCb2FyZChib2FyZCk7XG4gIH07XG5cbiAgc2VsZWN0Q2VsbCA9ICh4LCB5KSA9PiB7XG4gICAgbGV0IHsgYm9hcmQgfSA9IHRoaXMuc3RhdGU7XG4gICAgYm9hcmQgPSBib2FyZC5zZXQoJ3NlbGVjdGVkJywgeyB4LCB5IH0pO1xuICAgIHRoaXMuc2V0U3RhdGUoeyBib2FyZCB9KTtcbiAgfTtcblxuICBpc0NvbmZsaWN0KGksIGopIHtcbiAgICBjb25zdCB7IHZhbHVlIH0gPSB0aGlzLnN0YXRlLmJvYXJkLmdldEluKFsncHV6emxlJywgaSwgal0pLnRvSlNPTigpO1xuICAgIGlmICghdmFsdWUpIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCByb3dDb25mbGljdCA9XG4gICAgICB0aGlzLnN0YXRlLmJvYXJkLmdldEluKFsnY2hvaWNlcycsICdyb3dzJywgaSwgdmFsdWVdKSA+IDE7XG4gICAgY29uc3QgY29sdW1uQ29uZmxpY3QgPVxuICAgICAgdGhpcy5zdGF0ZS5ib2FyZC5nZXRJbihbJ2Nob2ljZXMnLCAnY29sdW1ucycsIGosIHZhbHVlXSkgPiAxO1xuICAgIGNvbnN0IHNxdWFyZUNvbmZsaWN0ID1cbiAgICAgIHRoaXMuc3RhdGUuYm9hcmQuZ2V0SW4oWydjaG9pY2VzJywgJ3NxdWFyZXMnLFxuICAgICAgICAoKE1hdGguZmxvb3IoaSAvIDMpKSAqIDMpICsgTWF0aC5mbG9vcihqIC8gMyksIHZhbHVlXSkgPiAxO1xuICAgIHJldHVybiByb3dDb25mbGljdCB8fCBjb2x1bW5Db25mbGljdCB8fCBzcXVhcmVDb25mbGljdDtcbiAgfVxuXG4gIHJlbmRlckNlbGwoY2VsbCwgeCwgeSkge1xuICAgIGNvbnN0IHsgYm9hcmQgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3Qgc2VsZWN0ZWQgPSB0aGlzLmdldFNlbGVjdGVkQ2VsbCgpO1xuICAgIGNvbnN0IHsgdmFsdWUsIHByZWZpbGxlZCwgbm90ZXMgfSA9IGNlbGwudG9KU09OKCk7XG4gICAgY29uc3QgY29uZmxpY3QgPSB0aGlzLmlzQ29uZmxpY3QoeCwgeSk7XG4gICAgY29uc3QgcGVlciA9IGFyZUNvb3JkaW5hdGVQZWVycyh7IHgsIHkgfSwgYm9hcmQuZ2V0KCdzZWxlY3RlZCcpKTtcbiAgICBjb25zdCBzYW1lVmFsdWUgPSAhIShzZWxlY3RlZCAmJiBzZWxlY3RlZC5nZXQoJ3ZhbHVlJylcbiAgICAgICYmIHZhbHVlID09PSBzZWxlY3RlZC5nZXQoJ3ZhbHVlJykpO1xuXG4gICAgY29uc3QgaXNTZWxlY3RlZCA9IGNlbGwgPT09IHNlbGVjdGVkO1xuICAgIHJldHVybiAoPENlbGxcbiAgICAgIHByZWZpbGxlZD17cHJlZmlsbGVkfVxuICAgICAgbm90ZXM9e25vdGVzfVxuICAgICAgc2FtZVZhbHVlPXtzYW1lVmFsdWV9XG4gICAgICBpc1NlbGVjdGVkPXtpc1NlbGVjdGVkfVxuICAgICAgaXNQZWVyPXtwZWVyfVxuICAgICAgdmFsdWU9e3ZhbHVlfVxuICAgICAgb25DbGljaz17KCkgPT4geyB0aGlzLnNlbGVjdENlbGwoeCwgeSk7IH19XG4gICAgICBrZXk9e3l9XG4gICAgICB4PXt4fVxuICAgICAgeT17eX1cbiAgICAgIGNvbmZsaWN0PXtjb25mbGljdH1cbiAgICAvPik7XG4gIH1cblxuICByZW5kZXJOdW1iZXJDb250cm9sKCkge1xuICAgIGNvbnN0IHNlbGVjdGVkQ2VsbCA9IHRoaXMuZ2V0U2VsZWN0ZWRDZWxsKCk7XG4gICAgY29uc3QgcHJlZmlsbGVkID0gc2VsZWN0ZWRDZWxsICYmIHNlbGVjdGVkQ2VsbC5nZXQoJ3ByZWZpbGxlZCcpO1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRyb2xcIj5cbiAgICAgICAge3JhbmdlKDkpLm1hcCgoaSkgPT4ge1xuICAgICAgICAgIGNvbnN0IG51bWJlciA9IGkgKyAxO1xuICAgICAgICAgIC8vIGhhbmRsZXMgYmluZGluZyBzaW5nbGUgY2xpY2sgYW5kIGRvdWJsZSBjbGljayBjYWxsYmFja3NcbiAgICAgICAgICBjb25zdCBjbGlja0hhbmRsZSA9IGdldENsaWNrSGFuZGxlcihcbiAgICAgICAgICAgICgpID0+IHsgdGhpcy5maWxsTnVtYmVyKG51bWJlcik7IH0sXG4gICAgICAgICAgICAoKSA9PiB7IHRoaXMuYWRkTnVtYmVyQXNOb3RlKG51bWJlcik7IH0sXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPE51bWJlckNvbnRyb2xcbiAgICAgICAgICAgICAga2V5PXtudW1iZXJ9XG4gICAgICAgICAgICAgIG51bWJlcj17bnVtYmVyfVxuICAgICAgICAgICAgICBvbkNsaWNrPXshcHJlZmlsbGVkID8gY2xpY2tIYW5kbGUgOiB1bmRlZmluZWR9XG4gICAgICAgICAgICAgIGNvbXBsZXRpb25QZXJjZW50YWdlPXt0aGlzLmdldE51bWJlclZhbHVlQ291bnQobnVtYmVyKSAvIDl9XG4gICAgICAgICAgICAvPik7XG4gICAgICAgIH0pfVxuICAgICAgICA8c3R5bGUganN4PntDb250cm9sU3R5bGV9PC9zdHlsZT5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cblxuICByZW5kZXJBY3Rpb25zKCkge1xuICAgIGNvbnN0IHsgaGlzdG9yeSB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBzZWxlY3RlZENlbGwgPSB0aGlzLmdldFNlbGVjdGVkQ2VsbCgpO1xuICAgIGNvbnN0IHByZWZpbGxlZCA9IHNlbGVjdGVkQ2VsbCAmJiBzZWxlY3RlZENlbGwuZ2V0KCdwcmVmaWxsZWQnKTtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJhY3Rpb25zXCI+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWN0aW9uXCIgb25DbGljaz17aGlzdG9yeS5zaXplID8gdGhpcy51bmRvIDogbnVsbH0+XG4gICAgICAgICAgPFJlbG9hZEljb24gLz5VbmRvXG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImFjdGlvbiByZWRvXCIgb25DbGljaz17aGlzdG9yeS5zaXplID8gdGhpcy5yZWRvIDogbnVsbH0+XG4gICAgICAgICAgPFJlbG9hZEljb24gLz5SZWRvXG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImFjdGlvblwiIG9uQ2xpY2s9eyFwcmVmaWxsZWQgPyB0aGlzLmVyYXNlU2VsZWN0ZWQgOiBudWxsfT5cbiAgICAgICAgICA8UmVtb3ZlSWNvbiAvPkVyYXNlXG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2XG4gICAgICAgICAgY2xhc3NOYW1lPVwiYWN0aW9uXCJcbiAgICAgICAgICBvbkNsaWNrPXshcHJlZmlsbGVkID9cbiAgICAgICAgICB0aGlzLmZpbGxTZWxlY3RlZFdpdGhTb2x1dGlvbiA6IG51bGx9XG4gICAgICAgID5cbiAgICAgICAgICA8TG91cGVJY29uIC8+SGludFxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPHN0eWxlIGpzeD57QWN0aW9uc1N0eWxlfTwvc3R5bGU+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG5cbiAgcmVuZGVyUHV6emxlKCkge1xuICAgIGNvbnN0IHsgYm9hcmQgfSA9IHRoaXMuc3RhdGU7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwicHV6emxlXCI+XG4gICAgICAgIHtib2FyZC5nZXQoJ3B1enpsZScpLm1hcCgocm93LCBpKSA9PiAoXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L25vLWFycmF5LWluZGV4LWtleVxuICAgICAgICAgIDxkaXYga2V5PXtpfSBjbGFzc05hbWU9XCJyb3dcIj5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcm93Lm1hcCgoY2VsbCwgaikgPT4gdGhpcy5yZW5kZXJDZWxsKGNlbGwsIGksIGopKS50b0FycmF5KClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKSkudG9BcnJheSgpfVxuICAgICAgICA8c3R5bGUganN4PntQdXp6bGVTdHlsZX08L3N0eWxlPlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxuXG4gIHJlbmRlckNvbnRyb2xzKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRyb2xzXCI+XG4gICAgICAgIHt0aGlzLnJlbmRlck51bWJlckNvbnRyb2woKX1cbiAgICAgICAge3RoaXMucmVuZGVyQWN0aW9ucygpfVxuICAgICAgICB7IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG4gICAgICAgIDxzdHlsZSBqc3g+e2BcbiAgICAgICAgICAgIC5jb250cm9scyB7XG4gICAgICAgICAgICAgICAgbWFyZ2luLXRvcDogLjNlbTtcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICAgICAgICAgIGZsZXgtd3JhcDogd3JhcDtcbiAgICAgICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiAuNWVtIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIGB9XG4gICAgICAgIDwvc3R5bGU+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG5cbiAgcmVuZGVyR2VuZXJhdGlvblVJKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8R2VuZXJhdGlvblVJIGdlbmVyYXRlR2FtZT17dGhpcy5nZW5lcmF0ZUdhbWV9IC8+XG4gICAgKTtcbiAgfVxuXG4gIHJlbmRlckhlYWRlcigpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJoZWFkZXJcIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJuZXctZ2FtZVwiIG9uQ2xpY2s9eygpID0+IHRoaXMuc2V0U3RhdGUoeyBib2FyZDogZmFsc2UgfSl9PlxuICAgICAgICAgIDxSZXR1cm5JY29uIC8+XG4gICAgICAgICAgPGRpdj5OZXcgR2FtZTwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPFRpcCAvPlxuICAgICAgICB7IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG4gICAgICAgIDxzdHlsZSBqc3g+e2BcbiAgICAgICAgICAgIC5oZWFkZXIge1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgICAgICAgICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICAgICAgICAgICAgICAgIG1heC13aWR0aDogNTAwcHg7XG4gICAgICAgICAgICAgICAgcGFkZGluZzogMCAwLjVlbTtcbiAgICAgICAgICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLm5ldy1nYW1lIHtcbiAgICAgICAgICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICAgICAgICAgICAgbWFyZ2luLXRvcDogLjJlbTtcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiBpbmxpbmUtZmxleDtcbiAgICAgICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICAgICAgICAgIHBhZGRpbmc6IC4yZW0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC5uZXctZ2FtZSA6Z2xvYmFsKHN2Zykge1xuICAgICAgICAgICAgICAgIGhlaWdodDogMWVtO1xuICAgICAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IC4zZW07XG4gICAgICAgICAgICB9XG4gICAgICAgIGB9XG4gICAgICAgIDwvc3R5bGU+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgYm9hcmQgfSA9IHRoaXMuc3RhdGU7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYm9keVwiPlxuICAgICAgICA8TmV4dEhlYWQ+XG4gICAgICAgICAgPHRpdGxlPlN1ZG9rdSBFdm9sdmVkPC90aXRsZT5cbiAgICAgICAgICA8bWV0YSBuYW1lPVwidmlld3BvcnRcIiBjb250ZW50PVwiaW5pdGlhbC1zY2FsZT0xLjAsIHdpZHRoPWRldmljZS13aWR0aFwiIC8+XG4gICAgICAgICAgPG1ldGEgbmFtZT1cImRlc2NyaXB0aW9uXCIgY29udGVudD17RGVzY3JpcHRpb259IC8+XG4gICAgICAgICAgPGxpbmsgaHJlZj1cImh0dHBzOi8vZm9udHMuZ29vZ2xlYXBpcy5jb20vY3NzP2ZhbWlseT1TcGVjaWFsK0VsaXRlXCIgcmVsPVwic3R5bGVzaGVldFwiIC8+XG4gICAgICAgICAgPG1ldGEgcHJvcGVydHk9XCJvZzp1cmxcIiBjb250ZW50PVwiaHR0cHM6Ly9zdWRva3Uuc2l0aWFubGl1LmNvbS9cIiAvPlxuICAgICAgICAgIDxtZXRhIHByb3BlcnR5PVwib2c6dGl0bGVcIiBjb250ZW50PVwiU3Vkb2t1IEV2b2x2ZWRcIiAvPlxuICAgICAgICAgIDxtZXRhIHByb3BlcnR5PVwib2c6dHlwZVwiIGNvbnRlbnQ9XCJ3ZWJzaXRlXCIgLz5cbiAgICAgICAgICA8bWV0YSBwcm9wZXJ0eT1cIm9nOmRlc2NyaXB0aW9uXCIgY29udGVudD17RGVzY3JpcHRpb259IC8+XG4gICAgICAgICAgPG1ldGEgcHJvcGVydHk9XCJvZzppbWFnZVwiIGNvbnRlbnQ9XCJodHRwczovL3N1ZG9rdS5zaXRpYW5saXUuY29tL3N0YXRpYy9vZy1pbWFnZS5wbmdcIiAvPlxuICAgICAgICA8L05leHRIZWFkPlxuICAgICAgICB7IWJvYXJkICYmIHRoaXMucmVuZGVyR2VuZXJhdGlvblVJKCl9XG4gICAgICAgIHtib2FyZCAmJiB0aGlzLnJlbmRlckhlYWRlcigpfVxuICAgICAgICB7Ym9hcmQgJiYgdGhpcy5yZW5kZXJQdXp6bGUoKX1cbiAgICAgICAge2JvYXJkICYmIHRoaXMucmVuZGVyQ29udHJvbHMoKX1cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJyb290ZXJcIj5cbiAgICAgICAgICBNYWRlIHdpdGggPHNwYW4+4p2k77iPPC9zcGFuPu+4jyBCeSA8YSBocmVmPVwiaHR0cHM6Ly93d3cuc2l0aWFubGl1LmNvbS9cIj5TaXRpYW4gTGl1PC9hPiB8IDxhIGhyZWY9XCJodHRwczovL21lZGl1bS5jb20vQHNpdGlhbmxpdV81NzY4MC9idWlsZGluZy1hLXN1ZG9rdS1nYW1lLWluLXJlYWN0LWNhNjYzOTE1NzEyXCI+QmxvZyBQb3N0PC9hPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgeyAvKiBsYW5ndWFnZT1DU1MgKi8gfVxuICAgICAgICA8c3R5bGUganN4PntgXG4gICAgICAgICAgICA6Z2xvYmFsKGJvZHkpLCAuYm9keSB7XG4gICAgICAgICAgICAgICAgZm9udC1mYW1pbHk6ICdTcGVjaWFsIEVsaXRlJywgY3Vyc2l2ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC5ib2R5IHtcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICAgICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgICAgICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDEwMHZoO1xuICAgICAgICAgICAgICAgIHdpZHRoOiAxMDB2dztcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBAbWVkaWEgKG1pbi13aWR0aDogODAwcHgpIGFuZCAobWluLWhlaWdodDogOTMwcHgpe1xuICAgICAgICAgICAgICAgIDpnbG9iYWwoLmhlYWRlciwgLnB1enpsZSwgLmNvbnRyb2xzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvbnQtc2l6ZTogMS41ZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQG1lZGlhIChtYXgtd2lkdGg6IDgwMHB4KSBhbmQgKG1pbi13aWR0aDogNjAwcHgpe1xuICAgICAgICAgICAgICAgIDpnbG9iYWwoLmhlYWRlciwgLnB1enpsZSwgLmNvbnRyb2xzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvbnQtc2l6ZTogMS4yZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQG1lZGlhIChtYXgtaGVpZ2h0OiA5MzBweCkgYW5kIChtaW4taGVpZ2h0OiA4MDBweCkgYW5kIChtaW4td2lkdGg6IDYwMHB4KXtcbiAgICAgICAgICAgICAgICA6Z2xvYmFsKC5oZWFkZXIsIC5wdXp6bGUsIC5jb250cm9scykge1xuICAgICAgICAgICAgICAgICAgICBmb250LXNpemU6IDEuMmVtO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEBtZWRpYSAobWF4LWhlaWdodDogODAwcHgpIGFuZCAobWluLWhlaWdodDogNjAwcHgpIGFuZCAobWluLXdpZHRoOiAzNzBweCl7XG4gICAgICAgICAgICAgICAgOmdsb2JhbCguaGVhZGVyLCAucHV6emxlLCAuY29udHJvbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9udC1zaXplOiAxZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQG1lZGlhIChtYXgtd2lkdGg6IDM3MHB4KXtcbiAgICAgICAgICAgICAgICA6Z2xvYmFsKC5oZWFkZXIsIC5wdXp6bGUsIC5jb250cm9scykge1xuICAgICAgICAgICAgICAgICAgICBmb250LXNpemU6IC44ZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQG1lZGlhIChtYXgtaGVpZ2h0OiA2MDBweCl7XG4gICAgICAgICAgICAgICAgOmdsb2JhbCguaGVhZGVyLCAucHV6emxlLCAuY29udHJvbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9udC1zaXplOiAuOGVtO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDpnbG9iYWwoYm9keSkge1xuICAgICAgICAgICAgICAgIG1hcmdpbjogMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC5yb290ZXIge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICAgICAgICAgICAgICBib3R0b206IDA7XG4gICAgICAgICAgICAgICAgZm9udC1zaXplOiAuOGVtO1xuICAgICAgICAgICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICAgICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgYH1cbiAgICAgICAgPC9zdHlsZT5cbiAgICAgICAgPHN0eWxlIGpzeCBnbG9iYWw+e1JhbmdlU3R5bGV9PC9zdHlsZT5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cbn1cbiJdfQ== */\n/*@ sourceURL=pages/index.js */';
ActionsStyle.__scopedHash = '183028603';
{/* language=CSS */}
var ControlStyle = new String('.control{padding:0 2em;cursor:pointer;display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;font-family:\'Special Elite\',cursive;-webkit-transition:filter .5s ease-in-out;transition:filter .5s ease-in-out;width:100%;}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhZ2VzL2luZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQTZGd0IsQUFHbUIsY0FDQyxlQUNLLHNHQUNELDZGQUNKLHlEQUNRLG1HQUNjLG9DQUNILDRFQUN2QixXQUNmIiwiZmlsZSI6InBhZ2VzL2luZGV4LmpzIiwic291cmNlUm9vdCI6Ii9Vc2Vycy9saWNoZW5tYS9Qcm9qZWN0cy9TdUR1b2t1L1N1RHVva3UiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBqc3gtYTExeS9hY2Nlc3NpYmxlLWVtb2ppICovXG5pbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50LCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBTZXQsIExpc3QsIGZyb21KUyB9IGZyb20gJ2ltbXV0YWJsZSc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IE5leHRIZWFkIGZyb20gJ25leHQvaGVhZCc7XG5pbXBvcnQgQ29sb3IgZnJvbSAnY29sb3InO1xuaW1wb3J0IElucHV0UmFuZ2UgZnJvbSAncmVhY3QtaW5wdXQtcmFuZ2UnO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLWV4dHJhbmVvdXMtZGVwZW5kZW5jaWVzXG5pbXBvcnQgY3NzIGZyb20gJ3N0eWxlZC1qc3gvY3NzJztcblxuaW1wb3J0IFJhbmdlU3R5bGUgZnJvbSAnLi4vaW5wdXQtcmFuZ2Utc3R5bGUnO1xuaW1wb3J0IExvdXBlSWNvbiBmcm9tICcuLi9zdmcvbG91cGUuc3ZnJztcbmltcG9ydCBSZW1vdmVJY29uIGZyb20gJy4uL3N2Zy9yZW1vdmUuc3ZnJztcbmltcG9ydCBSZWxvYWRJY29uIGZyb20gJy4uL3N2Zy9yZWxvYWQuc3ZnJztcbmltcG9ydCBSZXR1cm5JY29uIGZyb20gJy4uL3N2Zy9yZXR1cm4uc3ZnJztcblxuaW1wb3J0IHsgbWFrZVB1enpsZSwgcGx1Y2ssIGlzUGVlciBhcyBhcmVDb29yZGluYXRlUGVlcnMsIHJhbmdlIH0gZnJvbSAnLi4vc3Vkb2t1JztcbmltcG9ydCB7IGJhY2tHcm91bmRCbHVlIH0gZnJvbSAnLi4vY29sb3JzJztcbmltcG9ydCBUaXAgZnJvbSAnLi4vY29tcG9uZW50cy90b29sLXRpcCc7XG5cbmltcG9ydCBpbyBmcm9tICdzb2NrZXQuaW8tY2xpZW50J1xuXG5jb25zdCBEZXNjcmlwdGlvbiA9ICdEaXNjb3ZlciB0aGUgbmV4dCBldm9sdXRpb24gb2YgU3Vkb2t1IHdpdGggYW1hemluZyBncmFwaGljcywgYW5pbWF0aW9ucywgYW5kIHVzZXItZnJpZW5kbHkgZmVhdHVyZXMuIEVuam95IGEgU3Vkb2t1IGV4cGVyaWVuY2UgbGlrZSB5b3UgbmV2ZXIgaGF2ZSBiZWZvcmUgd2l0aCBjdXN0b21pemFibGUgZ2FtZSBnZW5lcmF0aW9uLCBjZWxsIGhpZ2hsaWdodGluZywgaW50dWl0aXZlIGNvbnRyb2xzIGFuZCBtb3JlISc7XG5jb25zdCBjZWxsV2lkdGggPSAyLjU7XG5cbmNvbnN0IExpZ2h0Qmx1ZTEwMCA9ICcjQjNFNUZDJztcbmNvbnN0IExpZ2h0Qmx1ZTIwMCA9ICcjODFENEZBJztcbmNvbnN0IExpZ2h0Qmx1ZTMwMCA9ICcjNEZDM0Y3JztcbmNvbnN0IEluZGlnbzcwMCA9ICcjMzAzRjlGJztcbmNvbnN0IERlZXBPcmFuZ2UyMDAgPSAnI0ZGQUI5MSc7XG5jb25zdCBEZWVwT3JhbmdlNjAwID0gJyNGNDUxMUUnO1xuY29uc3QgQ29udHJvbE51bWJlckNvbG9yID0gSW5kaWdvNzAwO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbG9uZS1ibG9ja3NcbnsgLyogbGFuZ3VhZ2U9Q1NTICovIH1cbmNvbnN0IENlbGxTdHlsZSA9IGNzc2Bcbi5jZWxsIHtcbiAgICBoZWlnaHQ6ICR7Y2VsbFdpZHRofWVtO1xuICAgIHdpZHRoOiAke2NlbGxXaWR0aH1lbTtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtd3JhcDogd3JhcDtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgIGZvbnQtc2l6ZTogMS4xZW07XG4gICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgdHJhbnNpdGlvbjogYmFja2dyb3VuZC1jb2xvciAuM3MgZWFzZS1pbi1vdXQ7XG59XG4uY2VsbDpudGgtY2hpbGQoM24rMyk6bm90KDpsYXN0LWNoaWxkKSB7XG4gICAgYm9yZGVyLXJpZ2h0OiAycHggc29saWQgYmxhY2s7XG59XG4uY2VsbDpub3QoOmxhc3QtY2hpbGQpIHtcbiAgICBib3JkZXItcmlnaHQ6IDFweCBzb2xpZCBibGFjaztcbn1cbi5ub3RlLW51bWJlciB7XG4gICAgZm9udC1zaXplOiAuNmVtO1xuICAgIHdpZHRoOiAzMyU7XG4gICAgaGVpZ2h0OiAzMyU7XG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG59XG5gO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbG9uZS1ibG9ja3NcbnsgLyogbGFuZ3VhZ2U9Q1NTICovIH1cbmNvbnN0IEFjdGlvbnNTdHlsZSA9IGNzc2Bcbi5hY3Rpb25zIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIG1heC13aWR0aDogNDAwcHg7XG4gICAgbWFyZ2luLXRvcDogLjVlbTtcbiAgICBwYWRkaW5nOiAwIC42ZW07XG59XG4uYWN0aW9uIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbn1cbi5hY3Rpb24gOmdsb2JhbChzdmcpIHtcbiAgICB3aWR0aDogMi41ZW07XG4gICAgbWFyZ2luLWJvdHRvbTogLjJlbTtcbn1cbi5yZWRvIDpnbG9iYWwoc3ZnKSB7XG4gICAgdHJhbnNmb3JtOiBzY2FsZVgoLTEpO1xufVxuYDtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxvbmUtYmxvY2tzXG57IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG5jb25zdCBDb250cm9sU3R5bGUgPSBjc3NgXG4uY29udHJvbCB7XG4gICAgcGFkZGluZzogMCAyZW07XG4gICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIGRpc3BsYXk6IGlubGluZS1mbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgZmxleC13cmFwOiB3cmFwO1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgIGZvbnQtZmFtaWx5OiAnU3BlY2lhbCBFbGl0ZScsIGN1cnNpdmU7XG4gICAgdHJhbnNpdGlvbjogZmlsdGVyIC41cyBlYXNlLWluLW91dDtcbiAgICB3aWR0aDogMTAwJTtcbn1cbmA7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sb25lLWJsb2Nrc1xueyAvKiBsYW5ndWFnZT1DU1MgKi8gfVxuY29uc3QgTnVtYmVyQ29udHJvbFN0eWxlID0gY3NzYFxuLm51bWJlciB7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBmb250LXNpemU6IDJlbTtcbiAgICBtYXJnaW46IC4xZW07XG4gICAgd2lkdGg6IDEuNWVtO1xuICAgIGhlaWdodDogMS41ZW07XG4gICAgY29sb3I6ICR7Q29udHJvbE51bWJlckNvbG9yfTtcbiAgICBib3gtc2hhZG93OiAwIDFweCAycHggcmdiYSgwLDAsMCwwLjE2KSwgMCAxcHggMnB4IHJnYmEoMCwwLDAsMC4yMyk7XG4gICAgYm9yZGVyLXJhZGl1czogNTAlO1xufVxuLm51bWJlciA+IGRpdiB7XG4gICAgbWFyZ2luLXRvcDogLjNlbTtcbn1cbmA7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sb25lLWJsb2Nrc1xueyAvKiBsYW5ndWFnZT1DU1MgKi8gfVxuY29uc3QgUHV6emxlU3R5bGUgPSBjc3NgXG4ucHV6emxlIHtcbiAgICBtYXJnaW4tdG9wOiAuNWVtO1xuICAgIHdpZHRoOiAke2NlbGxXaWR0aCAqIDl9ZW07XG4gICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIGJveC1zaGFkb3c6IDAgM3B4IDZweCByZ2JhKDAsMCwwLDAuMTYpLCAwIDNweCA2cHggcmdiYSgwLDAsMCwwLjIzKTtcbn1cbi5yb3cge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBmbGV4OiAwO1xuICAgIHdpZHRoOiAke2NlbGxXaWR0aCAqIDl9ZW07XG59XG4ucm93Om5vdCg6bGFzdC1jaGlsZCkge1xuICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCBibGFjaztcbn1cbi5yb3c6bnRoLWNoaWxkKDNuKzMpOm5vdCg6bGFzdC1jaGlsZCkge1xuICAgIGJvcmRlci1ib3R0b206IDJweCBzb2xpZCBibGFjayAhaW1wb3J0YW50O1xufVxuYDtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxvbmUtYmxvY2tzXG57IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG5jb25zdCBDaXJjdWx1YXJQcm9ncmVzc1N0eWxlID0gY3NzYFxuLmNpcmN1bGFyLXByb2dyZXNzIHtcbiAgICBkaXNwbGF5OiBibG9jaztcbiAgICB3aWR0aDogMTAwJTtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgdG9wOiAwO1xuICAgIGxlZnQ6IDA7XG4gICAgdHJhbnNpdGlvbjogZmlsdGVyIC40cyBlYXNlLWluLW91dDtcbn1cblxuLmNpcmNsZS1iZyB7XG4gICAgZmlsbDogbm9uZTtcbiAgICBzdHJva2U6ICNlZWU7XG4gICAgc3Ryb2tlLXdpZHRoOiAzLjg7XG59XG5cbi5jaXJjbGUge1xuICAgIHN0cm9rZTogJHtDb250cm9sTnVtYmVyQ29sb3J9O1xuICAgIHRyYW5zaXRpb246IHN0cm9rZS1kYXNoYXJyYXkgLjRzIGVhc2UtaW4tb3V0O1xuICAgIGZpbGw6IG5vbmU7XG4gICAgc3Ryb2tlLXdpZHRoOiAyLjg7XG4gICAgc3Ryb2tlLWxpbmVjYXA6IHJvdW5kO1xufVxuYDtcblxuY29uc3QgQ2lyY3VsYXJQYXRoRCA9ICdNMTggMi4wODQ1IGEgMTUuOTE1NSAxNS45MTU1IDAgMCAxIDAgMzEuODMxIGEgMTUuOTE1NSAxNS45MTU1IDAgMCAxIDAgLTMxLjgzMSc7XG5cbmZ1bmN0aW9uIGdldEJhY2tHcm91bmRDb2xvcih7XG4gIGNvbmZsaWN0LCBpc1BlZXIsIHNhbWVWYWx1ZSwgaXNTZWxlY3RlZCxcbn0pIHtcbiAgaWYgKGNvbmZsaWN0ICYmIGlzUGVlciAmJiBzYW1lVmFsdWUpIHtcbiAgICByZXR1cm4gRGVlcE9yYW5nZTIwMDtcbiAgfSBlbHNlIGlmIChzYW1lVmFsdWUpIHtcbiAgICByZXR1cm4gTGlnaHRCbHVlMzAwO1xuICB9IGVsc2UgaWYgKGlzU2VsZWN0ZWQpIHtcbiAgICByZXR1cm4gTGlnaHRCbHVlMjAwO1xuICB9IGVsc2UgaWYgKGlzUGVlcikge1xuICAgIHJldHVybiBMaWdodEJsdWUxMDA7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRGb250Q29sb3IoeyB2YWx1ZSwgY29uZmxpY3QsIHByZWZpbGxlZCB9KSB7XG4gIGlmIChjb25mbGljdCAmJiAhcHJlZmlsbGVkKSB7XG4gICAgcmV0dXJuIERlZXBPcmFuZ2U2MDA7XG4gIH0gZWxzZSBpZiAoIXByZWZpbGxlZCAmJiB2YWx1ZSkge1xuICAgIHJldHVybiBDb250cm9sTnVtYmVyQ29sb3I7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5jbGFzcyBHZW5lcmF0aW9uVUkgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcblxuICAgIHRoaXMuc3RhdGUgPSB7IHZhbHVlOiAzMCB9O1xuICB9XG5cbiAgZ2VuZXJhdGVHYW1lID0gKCkgPT4ge1xuICAgIHRoaXMucHJvcHMuZ2VuZXJhdGVHYW1lKHRoaXMuc3RhdGUudmFsdWUpO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImdlbmVyYXRpb25cIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb3B5XCI+U3RhcnQgd2l0aCB7dGhpcy5zdGF0ZS52YWx1ZX0gY2VsbHMgcHJlZmlsbGVkPC9kaXY+XG4gICAgICAgIDxJbnB1dFJhbmdlXG4gICAgICAgICAgbWF4VmFsdWU9ezgxfVxuICAgICAgICAgIG1pblZhbHVlPXsxN31cbiAgICAgICAgICB2YWx1ZT17dGhpcy5zdGF0ZS52YWx1ZX1cbiAgICAgICAgICBvbkNoYW5nZT17dmFsdWUgPT4gdGhpcy5zZXRTdGF0ZSh7IHZhbHVlIH0pfVxuICAgICAgICAvPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImJ1dHRvblwiIG9uQ2xpY2s9e3RoaXMuZ2VuZXJhdGVHYW1lfT5QbGF5IFN1ZG9rdTwvZGl2PlxuICAgICAgICB7IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG4gICAgICAgIDxzdHlsZSBqc3g+e2BcbiAgICAgICAgICAgIC5jb3B5IHtcbiAgICAgICAgICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgICAgICAgICAgICAgZm9udC1zaXplOiAxLjNlbTtcbiAgICAgICAgICAgICAgICBtYXJnaW4tYm90dG9tOiAuNWVtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLmdlbmVyYXRpb24ge1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgICAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgICAgICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOmdsb2JhbCguaW5wdXQtcmFuZ2UpIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogODAlO1xuICAgICAgICAgICAgICAgIG1heC13aWR0aDogNTAwcHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAuYnV0dG9uIHtcbiAgICAgICAgICAgICAgbWFyZ2luLXRvcDogLjVlbTtcbiAgICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogLjI1ZW07XG4gICAgICAgICAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICAgICAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICAgICAgICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcbiAgICAgICAgICAgICAgY29sb3I6ICNmZmY7XG4gICAgICAgICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgICAgICAgICAgICB0cmFuc2l0aW9uOiBhbGwgLjI1cztcbiAgICAgICAgICAgICAgcGFkZGluZzogNXB4IDEwcHg7XG4gICAgICAgICAgICAgIGZvbnQtc2l6ZTogMS40ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAuYnV0dG9uOmFjdGl2ZSB7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKDBweCwgNXB4KTtcbiAgICAgICAgICAgICAgYm94LXNoYWRvdzogMCAxcHggMCAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAuYnV0dG9uIHtcbiAgICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogJHtiYWNrR3JvdW5kQmx1ZX07XG4gICAgICAgICAgICAgIGJveC1zaGFkb3c6IDAgMnB4IDRweCAwICR7Q29sb3IoYmFja0dyb3VuZEJsdWUpLmRhcmtlbigwLjUpLmhzbCgpLnN0cmluZygpfTtcbiAgICAgICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLmJ1dHRvbjpob3ZlciB7XG4gICAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6ICR7Q29sb3IoYmFja0dyb3VuZEJsdWUpLmxpZ2h0ZW4oMC4yKS5oc2woKS5zdHJpbmcoKX07XG4gICAgICAgICAgICB9XG4gICAgICAgIGB9XG4gICAgICAgIDwvc3R5bGU+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG59XG5cbkdlbmVyYXRpb25VSS5wcm9wVHlwZXMgPSB7XG4gIGdlbmVyYXRlR2FtZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbn07XG5cbmNvbnN0IE51bWJlckNvbnRyb2wgPSAoeyBudW1iZXIsIG9uQ2xpY2ssIGNvbXBsZXRpb25QZXJjZW50YWdlIH0pID0+IChcbiAgPGRpdlxuICAgIGtleT17bnVtYmVyfVxuICAgIGNsYXNzTmFtZT1cIm51bWJlclwiXG4gICAgb25DbGljaz17b25DbGlja31cbiAgPlxuICAgIDxkaXY+e251bWJlcn08L2Rpdj5cbiAgICA8Q2lyY2x1bGFyUHJvZ3Jlc3MgcGVyY2VudD17Y29tcGxldGlvblBlcmNlbnRhZ2V9IC8+XG4gICAgPHN0eWxlIGpzeD57TnVtYmVyQ29udHJvbFN0eWxlfTwvc3R5bGU+XG4gIDwvZGl2PlxuKTtcblxuTnVtYmVyQ29udHJvbC5wcm9wVHlwZXMgPSB7XG4gIG51bWJlcjogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICBvbkNsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgY29tcGxldGlvblBlcmNlbnRhZ2U6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbn07XG5cbk51bWJlckNvbnRyb2wuZGVmYXVsdFByb3BzID0ge1xuICBvbkNsaWNrOiBudWxsLFxufTtcblxuY29uc3QgQ2VsbCA9IChwcm9wcykgPT4ge1xuICBjb25zdCB7XG4gICAgdmFsdWUsIG9uQ2xpY2ssIGlzUGVlciwgaXNTZWxlY3RlZCwgc2FtZVZhbHVlLCBwcmVmaWxsZWQsIG5vdGVzLCBjb25mbGljdCxcbiAgfSA9IHByb3BzO1xuICBjb25zdCBiYWNrZ3JvdW5kQ29sb3IgPSBnZXRCYWNrR3JvdW5kQ29sb3Ioe1xuICAgIGNvbmZsaWN0LCBpc1BlZXIsIHNhbWVWYWx1ZSwgaXNTZWxlY3RlZCxcbiAgfSk7XG4gIGNvbnN0IGZvbnRDb2xvciA9IGdldEZvbnRDb2xvcih7IGNvbmZsaWN0LCBwcmVmaWxsZWQsIHZhbHVlIH0pO1xuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwiY2VsbFwiIG9uQ2xpY2s9e29uQ2xpY2t9PlxuICAgICAge1xuICAgICAgICBub3RlcyA/XG4gICAgICAgICAgcmFuZ2UoOSkubWFwKGkgPT5cbiAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgPGRpdiBrZXk9e2l9IGNsYXNzTmFtZT1cIm5vdGUtbnVtYmVyXCI+XG4gICAgICAgICAgICAgICAge25vdGVzLmhhcyhpICsgMSkgJiYgKGkgKyAxKX1cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICApKSA6XG4gICAgICAgICAgdmFsdWUgJiYgdmFsdWVcbiAgICAgIH1cbiAgICAgIHsvKiBsYW5ndWFnZT1DU1MgKi99XG4gICAgICA8c3R5bGUganN4PntDZWxsU3R5bGV9PC9zdHlsZT5cbiAgICAgIDxzdHlsZSBqc3g+e2BcbiAgICAgICAgICAgICAgICAuY2VsbCB7XG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6ICR7YmFja2dyb3VuZENvbG9yIHx8ICdpbml0aWFsJ307XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiAke2ZvbnRDb2xvciB8fCAnaW5pdGlhbCd9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGB9XG4gICAgICA8L3N0eWxlPlxuICAgIDwvZGl2PlxuICApO1xufTtcblxuQ2VsbC5wcm9wVHlwZXMgPSB7XG4gIC8vIGN1cnJlbnQgbnVtYmVyIHZhbHVlXG4gIHZhbHVlOiBQcm9wVHlwZXMubnVtYmVyLFxuICAvLyBjZWxsIGNsaWNrIGhhbmRsZXJcbiAgb25DbGljazogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgLy8gaWYgdGhlIGNlbGwgaXMgYSBwZWVyIG9mIHRoZSBzZWxlY3RlZCBjZWxsXG4gIGlzUGVlcjogUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZCxcbiAgLy8gaWYgdGhlIGNlbGwgaXMgc2VsZWN0ZWQgYnkgdGhlIHVzZXJcbiAgaXNTZWxlY3RlZDogUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZCxcbiAgLy8gY3VycmVudCBjZWxsIGhhcyB0aGUgc2FtZSB2YWx1ZSBpZiB0aGUgdXNlciBzZWxlY3RlZCBjZWxsXG4gIHNhbWVWYWx1ZTogUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZCxcbiAgLy8gaWYgdGhpcyB3YXMgcHJlZmlsbGVkIGFzIGEgcGFydCBvZiB0aGUgcHV6emxlXG4gIHByZWZpbGxlZDogUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZCxcbiAgLy8gY3VycmVudCBub3RlcyB0YWtlbiBvbiB0aGUgY2VsbFxuICBub3RlczogUHJvcFR5cGVzLmluc3RhbmNlT2YoU2V0KSxcbiAgLy8gaWYgdGhlIGN1cnJlbnQgY2VsbCBkb2VzIG5vdCBzYXRpc2Z5IHRoZSBnYW1lIGNvbnN0cmFpbnRcbiAgY29uZmxpY3Q6IFByb3BUeXBlcy5ib29sLmlzUmVxdWlyZWQsXG59O1xuXG5DZWxsLmRlZmF1bHRQcm9wcyA9IHtcbiAgbm90ZXM6IG51bGwsXG4gIHZhbHVlOiBudWxsLFxufTtcblxuY29uc3QgQ2lyY2x1bGFyUHJvZ3Jlc3MgPSAoeyBwZXJjZW50IH0pID0+IChcbiAgPHN2ZyB2aWV3Qm94PVwiMCAwIDM2IDM2XCIgY2xhc3NOYW1lPVwiY2lyY3VsYXItcHJvZ3Jlc3NcIj5cbiAgICA8cGF0aFxuICAgICAgY2xhc3NOYW1lPVwiY2lyY2xlLWJnXCJcbiAgICAgIGQ9e0NpcmN1bGFyUGF0aER9XG4gICAgLz5cbiAgICA8cGF0aFxuICAgICAgY2xhc3NOYW1lPVwiY2lyY2xlXCJcbiAgICAgIHN0cm9rZURhc2hhcnJheT17YCR7cGVyY2VudCAqIDEwMH0sIDEwMGB9XG4gICAgICBkPXtDaXJjdWxhclBhdGhEfVxuICAgIC8+XG4gICAgeyAvKiBsYW5ndWFnZT1DU1MgKi8gfVxuICAgIDxzdHlsZSBqc3g+e0NpcmN1bHVhclByb2dyZXNzU3R5bGV9PC9zdHlsZT5cbiAgPC9zdmc+XG4pO1xuXG5DaXJjbHVsYXJQcm9ncmVzcy5wcm9wVHlwZXMgPSB7XG4gIHBlcmNlbnQ6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbn07XG5cbmZ1bmN0aW9uIGdldENsaWNrSGFuZGxlcihvbkNsaWNrLCBvbkRvdWJsZUNsaWNrLCBkZWxheSA9IDI1MCkge1xuICBsZXQgdGltZW91dElEID0gbnVsbDtcbiAgcmV0dXJuIChldmVudCkgPT4ge1xuICAgIGlmICghdGltZW91dElEKSB7XG4gICAgICB0aW1lb3V0SUQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgb25DbGljayhldmVudCk7XG4gICAgICAgIHRpbWVvdXRJRCA9IG51bGw7XG4gICAgICB9LCBkZWxheSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpbWVvdXRJRCA9IGNsZWFyVGltZW91dCh0aW1lb3V0SUQpO1xuICAgICAgb25Eb3VibGVDbGljayhldmVudCk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIG1ha2Ugc2l6ZSA5IGFycmF5IG9mIDBzXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIG1ha2VDb3VudE9iamVjdCgpIHtcbiAgY29uc3QgY291bnRPYmogPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSArPSAxKSBjb3VudE9iai5wdXNoKDApO1xuICByZXR1cm4gY291bnRPYmo7XG59XG5cbi8qKlxuICogZ2l2ZW4gYSAyRCBhcnJheSBvZiBudW1iZXJzIGFzIHRoZSBpbml0aWFsIHB1enpsZSwgZ2VuZXJhdGUgdGhlIGluaXRpYWwgZ2FtZSBzdGF0ZVxuICogQHBhcmFtIHB1enpsZVxuICogQHJldHVybnMge2FueX1cbiAqL1xuZnVuY3Rpb24gbWFrZUJvYXJkKHsgcHV6emxlIH0pIHtcbiAgLy8gY3JlYXRlIGluaXRpYWwgY291bnQgb2JqZWN0IHRvIGtlZXAgdHJhY2sgb2YgY29uZmxpY3RzIHBlciBudW1iZXIgdmFsdWVcbiAgY29uc3Qgcm93cyA9IEFycmF5LmZyb20oQXJyYXkoOSkua2V5cygpKS5tYXAoKCkgPT4gbWFrZUNvdW50T2JqZWN0KCkpO1xuICBjb25zdCBjb2x1bW5zID0gQXJyYXkuZnJvbShBcnJheSg5KS5rZXlzKCkpLm1hcCgoKSA9PiBtYWtlQ291bnRPYmplY3QoKSk7XG4gIGNvbnN0IHNxdWFyZXMgPSBBcnJheS5mcm9tKEFycmF5KDkpLmtleXMoKSkubWFwKCgpID0+IG1ha2VDb3VudE9iamVjdCgpKTtcbiAgY29uc3QgcmVzdWx0ID0gcHV6emxlLm1hcCgocm93LCBpKSA9PiAoXG4gICAgcm93Lm1hcCgoY2VsbCwgaikgPT4ge1xuICAgICAgaWYgKGNlbGwpIHtcbiAgICAgICAgcm93c1tpXVtjZWxsXSArPSAxO1xuICAgICAgICBjb2x1bW5zW2pdW2NlbGxdICs9IDE7XG4gICAgICAgIHNxdWFyZXNbKChNYXRoLmZsb29yKGkgLyAzKSkgKiAzKSArIE1hdGguZmxvb3IoaiAvIDMpXVtjZWxsXSArPSAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHB1enpsZVtpXVtqXSA+IDAgPyBwdXp6bGVbaV1bal0gOiBudWxsLFxuICAgICAgICBwcmVmaWxsZWQ6ICEhcHV6emxlW2ldW2pdLFxuICAgICAgfTtcbiAgICB9KVxuICApKTtcbiAgcmV0dXJuIGZyb21KUyh7IHB1enpsZTogcmVzdWx0LCBzZWxlY3RlZDogZmFsc2UsIGNob2ljZXM6IHsgcm93cywgY29sdW1ucywgc3F1YXJlcyB9IH0pO1xufVxuXG4vKipcbiAqIGdpdmUgdGhlIGNvb3JkaW5hdGUgdXBkYXRlIHRoZSBjdXJyZW50IGJvYXJkIHdpdGggYSBudW1iZXIgY2hvaWNlXG4gKiBAcGFyYW0geFxuICogQHBhcmFtIHlcbiAqIEBwYXJhbSBudW1iZXJcbiAqIEBwYXJhbSBmaWxsIHdoZXRoZXIgdG8gc2V0IG9yIHVuc2V0XG4gKiBAcGFyYW0gYm9hcmQgdGhlIGltbXV0YWJsZSBib2FyZCBnaXZlbiB0byBjaGFuZ2VcbiAqL1xuZnVuY3Rpb24gdXBkYXRlQm9hcmRXaXRoTnVtYmVyKHtcbiAgeCwgeSwgbnVtYmVyLCBmaWxsID0gdHJ1ZSwgYm9hcmQsXG59KSB7XG4gIGxldCBjZWxsID0gYm9hcmQuZ2V0KCdwdXp6bGUnKS5nZXRJbihbeCwgeV0pO1xuICAvLyBkZWxldGUgaXRzIG5vdGVzXG4gIGNlbGwgPSBjZWxsLmRlbGV0ZSgnbm90ZXMnKTtcbiAgLy8gc2V0IG9yIHVuc2V0IGl0cyB2YWx1ZSBkZXBlbmRpbmcgb24gYGZpbGxgXG4gIGNlbGwgPSBmaWxsID8gY2VsbC5zZXQoJ3ZhbHVlJywgbnVtYmVyKSA6IGNlbGwuZGVsZXRlKCd2YWx1ZScpO1xuICBjb25zdCBpbmNyZW1lbnQgPSBmaWxsID8gMSA6IC0xO1xuICAvLyB1cGRhdGUgdGhlIGN1cnJlbnQgZ3JvdXAgY2hvaWNlc1xuICBjb25zdCByb3dQYXRoID0gWydjaG9pY2VzJywgJ3Jvd3MnLCB4LCBudW1iZXJdO1xuICBjb25zdCBjb2x1bW5QYXRoID0gWydjaG9pY2VzJywgJ2NvbHVtbnMnLCB5LCBudW1iZXJdO1xuICBjb25zdCBzcXVhcmVQYXRoID0gWydjaG9pY2VzJywgJ3NxdWFyZXMnLFxuICAgICgoTWF0aC5mbG9vcih4IC8gMykpICogMykgKyBNYXRoLmZsb29yKHkgLyAzKSwgbnVtYmVyXTtcbiAgcmV0dXJuIGJvYXJkLnNldEluKHJvd1BhdGgsIGJvYXJkLmdldEluKHJvd1BhdGgpICsgaW5jcmVtZW50KVxuICAgIC5zZXRJbihjb2x1bW5QYXRoLCBib2FyZC5nZXRJbihjb2x1bW5QYXRoKSArIGluY3JlbWVudClcbiAgICAuc2V0SW4oc3F1YXJlUGF0aCwgYm9hcmQuZ2V0SW4oc3F1YXJlUGF0aCkgKyBpbmNyZW1lbnQpXG4gICAgLnNldEluKFsncHV6emxlJywgeCwgeV0sIGNlbGwpO1xufVxuXG5mdW5jdGlvbiBnZXROdW1iZXJPZkdyb3Vwc0Fzc2lnbmVkRm9yTnVtYmVyKG51bWJlciwgZ3JvdXBzKSB7XG4gIHJldHVybiBncm91cHMucmVkdWNlKChhY2N1bXVsYXRvciwgcm93KSA9PlxuICAgIGFjY3VtdWxhdG9yICsgKHJvdy5nZXQobnVtYmVyKSA+IDAgPyAxIDogMCksIDApO1xufVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L25vLW11bHRpLWNvbXBcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEluZGV4IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgc3RhdGUgPSB7fTtcblxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICBpZiAoJ3NlcnZpY2VXb3JrZXInIGluIG5hdmlnYXRvcikge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICAgICBuYXZpZ2F0b3Iuc2VydmljZVdvcmtlclxuICAgICAgICAucmVnaXN0ZXIoJy9zZXJ2aWNlLXdvcmtlci5qcycpXG4gICAgICAgIC50aGVuKChyZWcpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnU2VydmljZVdvcmtlciBzY29wZTogJywgcmVnLnNjb3BlKTtcbiAgICAgICAgICBjb25zb2xlLmxvZygnc2VydmljZSB3b3JrZXIgcmVnaXN0cmF0aW9uIHN1Y2Nlc3NmdWwnKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ3NlcnZpY2Ugd29ya2VyIHJlZ2lzdHJhdGlvbiBmYWlsZWQnLCBlcnIubWVzc2FnZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgXG4gICAgZmV0Y2goJy9hcGkvc29ja2V0aW8nKS5maW5hbGx5KCgpID0+IHtcbiAgICAgIGNvbnN0IHNvY2tldCA9IGlvKClcblxuICAgICAgc29ja2V0Lm9uKCdjb25uZWN0JywgKCkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZygnY29ubmVjdCcpXG4gICAgICAgIHNvY2tldC5lbWl0KCdoZWxsbycpXG4gICAgICB9KVxuXG4gICAgICBzb2NrZXQub24oJ2hlbGxvJywgZGF0YSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdoZWxsbycsIGRhdGEpXG4gICAgICB9KVxuXG4gICAgICBzb2NrZXQub24oJ2EgdXNlciBjb25uZWN0ZWQnLCAoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdhIHVzZXIgY29ubmVjdGVkJylcbiAgICAgIH0pXG5cbiAgICAgIHNvY2tldC5vbignZGlzY29ubmVjdCcsICgpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ2Rpc2Nvbm5lY3QnKVxuICAgICAgfSlcbiAgICB9KVxuICAgXG4gIH1cbiAgZ2V0U2VsZWN0ZWRDZWxsKCkge1xuICAgIGNvbnN0IHsgYm9hcmQgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3Qgc2VsZWN0ZWQgPSBib2FyZC5nZXQoJ3NlbGVjdGVkJyk7XG4gICAgcmV0dXJuIHNlbGVjdGVkICYmIGJvYXJkLmdldCgncHV6emxlJykuZ2V0SW4oW3NlbGVjdGVkLngsIHNlbGVjdGVkLnldKTtcbiAgfVxuXG4gIC8vIGdldCB0aGUgbWluIGJldHdlZW4gaXRzIGNvbXBsZXRpb24gaW4gcm93cywgY29sdW1ucyBhbmQgc3F1YXJlcy5cbiAgZ2V0TnVtYmVyVmFsdWVDb3VudChudW1iZXIpIHtcbiAgICBjb25zdCByb3dzID0gdGhpcy5zdGF0ZS5ib2FyZC5nZXRJbihbJ2Nob2ljZXMnLCAncm93cyddKTtcbiAgICBjb25zdCBjb2x1bW5zID0gdGhpcy5zdGF0ZS5ib2FyZC5nZXRJbihbJ2Nob2ljZXMnLCAnY29sdW1ucyddKTtcbiAgICBjb25zdCBzcXVhcmVzID0gdGhpcy5zdGF0ZS5ib2FyZC5nZXRJbihbJ2Nob2ljZXMnLCAnc3F1YXJlcyddKTtcbiAgICByZXR1cm4gTWF0aC5taW4oXG4gICAgICBnZXROdW1iZXJPZkdyb3Vwc0Fzc2lnbmVkRm9yTnVtYmVyKG51bWJlciwgc3F1YXJlcyksXG4gICAgICBNYXRoLm1pbihcbiAgICAgICAgZ2V0TnVtYmVyT2ZHcm91cHNBc3NpZ25lZEZvck51bWJlcihudW1iZXIsIHJvd3MpLFxuICAgICAgICBnZXROdW1iZXJPZkdyb3Vwc0Fzc2lnbmVkRm9yTnVtYmVyKG51bWJlciwgY29sdW1ucyksXG4gICAgICApLFxuICAgICk7XG4gIH1cblxuICBnZW5lcmF0ZUdhbWUgPSAoZmluYWxDb3VudCA9IDIwKSA9PiB7XG4gICAgLy8gZ2V0IGEgZmlsbGVkIHB1enpsZSBnZW5lcmF0ZWRcbiAgICBjb25zdCBzb2x1dGlvbiA9IG1ha2VQdXp6bGUoKTtcbiAgICAvLyBwbHVjayB2YWx1ZXMgZnJvbSBjZWxscyB0byBjcmVhdGUgdGhlIGdhbWVcbiAgICBjb25zdCB7IHB1enpsZSB9ID0gcGx1Y2soc29sdXRpb24sIGZpbmFsQ291bnQpO1xuICAgIC8vIGluaXRpYWxpemUgdGhlIGJvYXJkIHdpdGggY2hvaWNlIGNvdW50c1xuICAgIGNvbnN0IGJvYXJkID0gbWFrZUJvYXJkKHsgcHV6emxlIH0pO1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgYm9hcmQsIGhpc3Rvcnk6IExpc3Qub2YoYm9hcmQpLCBoaXN0b3J5T2ZmU2V0OiAwLCBzb2x1dGlvbixcbiAgICB9KTtcbiAgfVxuXG4gIGFkZE51bWJlckFzTm90ZSA9IChudW1iZXIpID0+IHtcbiAgICBsZXQgeyBib2FyZCB9ID0gdGhpcy5zdGF0ZTtcbiAgICBsZXQgc2VsZWN0ZWRDZWxsID0gdGhpcy5nZXRTZWxlY3RlZENlbGwoKTtcbiAgICBpZiAoIXNlbGVjdGVkQ2VsbCkgcmV0dXJuO1xuICAgIGNvbnN0IHByZWZpbGxlZCA9IHNlbGVjdGVkQ2VsbC5nZXQoJ3ByZWZpbGxlZCcpO1xuICAgIGlmIChwcmVmaWxsZWQpIHJldHVybjtcbiAgICBjb25zdCB7IHgsIHkgfSA9IGJvYXJkLmdldCgnc2VsZWN0ZWQnKTtcbiAgICBjb25zdCBjdXJyZW50VmFsdWUgPSBzZWxlY3RlZENlbGwuZ2V0KCd2YWx1ZScpO1xuICAgIGlmIChjdXJyZW50VmFsdWUpIHtcbiAgICAgIGJvYXJkID0gdXBkYXRlQm9hcmRXaXRoTnVtYmVyKHtcbiAgICAgICAgeCwgeSwgbnVtYmVyOiBjdXJyZW50VmFsdWUsIGZpbGw6IGZhbHNlLCBib2FyZDogdGhpcy5zdGF0ZS5ib2FyZCxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBsZXQgbm90ZXMgPSBzZWxlY3RlZENlbGwuZ2V0KCdub3RlcycpIHx8IFNldCgpO1xuICAgIGlmIChub3Rlcy5oYXMobnVtYmVyKSkge1xuICAgICAgbm90ZXMgPSBub3Rlcy5kZWxldGUobnVtYmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm90ZXMgPSBub3Rlcy5hZGQobnVtYmVyKTtcbiAgICB9XG4gICAgc2VsZWN0ZWRDZWxsID0gc2VsZWN0ZWRDZWxsLnNldCgnbm90ZXMnLCBub3Rlcyk7XG4gICAgc2VsZWN0ZWRDZWxsID0gc2VsZWN0ZWRDZWxsLmRlbGV0ZSgndmFsdWUnKTtcbiAgICBib2FyZCA9IGJvYXJkLnNldEluKFsncHV6emxlJywgeCwgeV0sIHNlbGVjdGVkQ2VsbCk7XG4gICAgdGhpcy51cGRhdGVCb2FyZChib2FyZCk7XG4gIH07XG5cbiAgdXBkYXRlQm9hcmQgPSAobmV3Qm9hcmQpID0+IHtcbiAgICBsZXQgeyBoaXN0b3J5IH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IHsgaGlzdG9yeU9mZlNldCB9ID0gdGhpcy5zdGF0ZTtcbiAgICAvLyBhbnl0aGluZyBiZWZvcmUgY3VycmVudCBzdGVwIGlzIHN0aWxsIGluIGhpc3RvcnlcbiAgICBoaXN0b3J5ID0gaGlzdG9yeS5zbGljZSgwLCBoaXN0b3J5T2ZmU2V0ICsgMSk7XG4gICAgLy8gYWRkIGl0c2VsZiBvbnRvIHRoZSBoaXN0b3J5XG4gICAgaGlzdG9yeSA9IGhpc3RvcnkucHVzaChuZXdCb2FyZCk7XG4gICAgLy8gdXBkYXRlIHRoZSBnYW1lXG4gICAgdGhpcy5zZXRTdGF0ZSh7IGJvYXJkOiBuZXdCb2FyZCwgaGlzdG9yeSwgaGlzdG9yeU9mZlNldDogaGlzdG9yeS5zaXplIC0gMSB9KTtcbiAgfTtcblxuICBjYW5VbmRvID0gKCkgPT4gdGhpcy5zdGF0ZS5oaXN0b3J5T2ZmU2V0ID4gMFxuXG4gIHJlZG8gPSAoKSA9PiB7XG4gICAgY29uc3QgeyBoaXN0b3J5IH0gPSB0aGlzLnN0YXRlO1xuICAgIGxldCB7IGhpc3RvcnlPZmZTZXQgfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKGhpc3Rvcnkuc2l6ZSkge1xuICAgICAgaGlzdG9yeU9mZlNldCA9IE1hdGgubWluKGhpc3Rvcnkuc2l6ZSAtIDEsIGhpc3RvcnlPZmZTZXQgKyAxKTtcbiAgICAgIGNvbnN0IGJvYXJkID0gaGlzdG9yeS5nZXQoaGlzdG9yeU9mZlNldCk7XG4gICAgICB0aGlzLnNldFN0YXRlKHsgYm9hcmQsIGhpc3RvcnlPZmZTZXQgfSk7XG4gICAgfVxuICB9O1xuXG4gIHVuZG8gPSAoKSA9PiB7XG4gICAgY29uc3QgeyBoaXN0b3J5IH0gPSB0aGlzLnN0YXRlO1xuICAgIGxldCB7IGhpc3RvcnlPZmZTZXQsIGJvYXJkIH0gPSB0aGlzLnN0YXRlO1xuICAgIGlmIChoaXN0b3J5LnNpemUpIHtcbiAgICAgIGhpc3RvcnlPZmZTZXQgPSBNYXRoLm1heCgwLCBoaXN0b3J5T2ZmU2V0IC0gMSk7XG4gICAgICBib2FyZCA9IGhpc3RvcnkuZ2V0KGhpc3RvcnlPZmZTZXQpO1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IGJvYXJkLCBoaXN0b3J5T2ZmU2V0LCBoaXN0b3J5IH0pO1xuICAgIH1cbiAgfTtcblxuICBlcmFzZVNlbGVjdGVkID0gKCkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGVkQ2VsbCA9IHRoaXMuZ2V0U2VsZWN0ZWRDZWxsKCk7XG4gICAgaWYgKCFzZWxlY3RlZENlbGwpIHJldHVybjtcbiAgICB0aGlzLmZpbGxOdW1iZXIoZmFsc2UpO1xuICB9XG5cbiAgZmlsbFNlbGVjdGVkV2l0aFNvbHV0aW9uID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgYm9hcmQsIHNvbHV0aW9uIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IHNlbGVjdGVkQ2VsbCA9IHRoaXMuZ2V0U2VsZWN0ZWRDZWxsKCk7XG4gICAgaWYgKCFzZWxlY3RlZENlbGwpIHJldHVybjtcbiAgICBjb25zdCB7IHgsIHkgfSA9IGJvYXJkLmdldCgnc2VsZWN0ZWQnKTtcbiAgICB0aGlzLmZpbGxOdW1iZXIoc29sdXRpb25beF1beV0pO1xuICB9XG5cblxuICAvLyBmaWxsIGN1cnJlbnRseSBzZWxlY3RlZCBjZWxsIHdpdGggbnVtYmVyXG4gIGZpbGxOdW1iZXIgPSAobnVtYmVyKSA9PiB7XG4gICAgbGV0IHsgYm9hcmQgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3Qgc2VsZWN0ZWRDZWxsID0gdGhpcy5nZXRTZWxlY3RlZENlbGwoKTtcbiAgICAvLyBuby1vcCBpZiBub3RoaW5nIGlzIHNlbGVjdGVkXG4gICAgaWYgKCFzZWxlY3RlZENlbGwpIHJldHVybjtcbiAgICBjb25zdCBwcmVmaWxsZWQgPSBzZWxlY3RlZENlbGwuZ2V0KCdwcmVmaWxsZWQnKTtcbiAgICAvLyBuby1vcCBpZiBpdCBpcyByZWZpbGxlZFxuICAgIGlmIChwcmVmaWxsZWQpIHJldHVybjtcbiAgICBjb25zdCB7IHgsIHkgfSA9IGJvYXJkLmdldCgnc2VsZWN0ZWQnKTtcbiAgICBjb25zdCBjdXJyZW50VmFsdWUgPSBzZWxlY3RlZENlbGwuZ2V0KCd2YWx1ZScpO1xuICAgIC8vIHJlbW92ZSB0aGUgY3VycmVudCB2YWx1ZSBhbmQgdXBkYXRlIHRoZSBnYW1lIHN0YXRlXG4gICAgaWYgKGN1cnJlbnRWYWx1ZSkge1xuICAgICAgYm9hcmQgPSB1cGRhdGVCb2FyZFdpdGhOdW1iZXIoe1xuICAgICAgICB4LCB5LCBudW1iZXI6IGN1cnJlbnRWYWx1ZSwgZmlsbDogZmFsc2UsIGJvYXJkOiB0aGlzLnN0YXRlLmJvYXJkLFxuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIHVwZGF0ZSB0byBuZXcgbnVtYmVyIGlmIGFueVxuICAgIGNvbnN0IHNldE51bWJlciA9IGN1cnJlbnRWYWx1ZSAhPT0gbnVtYmVyICYmIG51bWJlcjtcbiAgICBpZiAoc2V0TnVtYmVyKSB7XG4gICAgICBib2FyZCA9IHVwZGF0ZUJvYXJkV2l0aE51bWJlcih7XG4gICAgICAgIHgsIHksIG51bWJlciwgZmlsbDogdHJ1ZSwgYm9hcmQsXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVCb2FyZChib2FyZCk7XG4gIH07XG5cbiAgc2VsZWN0Q2VsbCA9ICh4LCB5KSA9PiB7XG4gICAgbGV0IHsgYm9hcmQgfSA9IHRoaXMuc3RhdGU7XG4gICAgYm9hcmQgPSBib2FyZC5zZXQoJ3NlbGVjdGVkJywgeyB4LCB5IH0pO1xuICAgIHRoaXMuc2V0U3RhdGUoeyBib2FyZCB9KTtcbiAgfTtcblxuICBpc0NvbmZsaWN0KGksIGopIHtcbiAgICBjb25zdCB7IHZhbHVlIH0gPSB0aGlzLnN0YXRlLmJvYXJkLmdldEluKFsncHV6emxlJywgaSwgal0pLnRvSlNPTigpO1xuICAgIGlmICghdmFsdWUpIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCByb3dDb25mbGljdCA9XG4gICAgICB0aGlzLnN0YXRlLmJvYXJkLmdldEluKFsnY2hvaWNlcycsICdyb3dzJywgaSwgdmFsdWVdKSA+IDE7XG4gICAgY29uc3QgY29sdW1uQ29uZmxpY3QgPVxuICAgICAgdGhpcy5zdGF0ZS5ib2FyZC5nZXRJbihbJ2Nob2ljZXMnLCAnY29sdW1ucycsIGosIHZhbHVlXSkgPiAxO1xuICAgIGNvbnN0IHNxdWFyZUNvbmZsaWN0ID1cbiAgICAgIHRoaXMuc3RhdGUuYm9hcmQuZ2V0SW4oWydjaG9pY2VzJywgJ3NxdWFyZXMnLFxuICAgICAgICAoKE1hdGguZmxvb3IoaSAvIDMpKSAqIDMpICsgTWF0aC5mbG9vcihqIC8gMyksIHZhbHVlXSkgPiAxO1xuICAgIHJldHVybiByb3dDb25mbGljdCB8fCBjb2x1bW5Db25mbGljdCB8fCBzcXVhcmVDb25mbGljdDtcbiAgfVxuXG4gIHJlbmRlckNlbGwoY2VsbCwgeCwgeSkge1xuICAgIGNvbnN0IHsgYm9hcmQgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3Qgc2VsZWN0ZWQgPSB0aGlzLmdldFNlbGVjdGVkQ2VsbCgpO1xuICAgIGNvbnN0IHsgdmFsdWUsIHByZWZpbGxlZCwgbm90ZXMgfSA9IGNlbGwudG9KU09OKCk7XG4gICAgY29uc3QgY29uZmxpY3QgPSB0aGlzLmlzQ29uZmxpY3QoeCwgeSk7XG4gICAgY29uc3QgcGVlciA9IGFyZUNvb3JkaW5hdGVQZWVycyh7IHgsIHkgfSwgYm9hcmQuZ2V0KCdzZWxlY3RlZCcpKTtcbiAgICBjb25zdCBzYW1lVmFsdWUgPSAhIShzZWxlY3RlZCAmJiBzZWxlY3RlZC5nZXQoJ3ZhbHVlJylcbiAgICAgICYmIHZhbHVlID09PSBzZWxlY3RlZC5nZXQoJ3ZhbHVlJykpO1xuXG4gICAgY29uc3QgaXNTZWxlY3RlZCA9IGNlbGwgPT09IHNlbGVjdGVkO1xuICAgIHJldHVybiAoPENlbGxcbiAgICAgIHByZWZpbGxlZD17cHJlZmlsbGVkfVxuICAgICAgbm90ZXM9e25vdGVzfVxuICAgICAgc2FtZVZhbHVlPXtzYW1lVmFsdWV9XG4gICAgICBpc1NlbGVjdGVkPXtpc1NlbGVjdGVkfVxuICAgICAgaXNQZWVyPXtwZWVyfVxuICAgICAgdmFsdWU9e3ZhbHVlfVxuICAgICAgb25DbGljaz17KCkgPT4geyB0aGlzLnNlbGVjdENlbGwoeCwgeSk7IH19XG4gICAgICBrZXk9e3l9XG4gICAgICB4PXt4fVxuICAgICAgeT17eX1cbiAgICAgIGNvbmZsaWN0PXtjb25mbGljdH1cbiAgICAvPik7XG4gIH1cblxuICByZW5kZXJOdW1iZXJDb250cm9sKCkge1xuICAgIGNvbnN0IHNlbGVjdGVkQ2VsbCA9IHRoaXMuZ2V0U2VsZWN0ZWRDZWxsKCk7XG4gICAgY29uc3QgcHJlZmlsbGVkID0gc2VsZWN0ZWRDZWxsICYmIHNlbGVjdGVkQ2VsbC5nZXQoJ3ByZWZpbGxlZCcpO1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRyb2xcIj5cbiAgICAgICAge3JhbmdlKDkpLm1hcCgoaSkgPT4ge1xuICAgICAgICAgIGNvbnN0IG51bWJlciA9IGkgKyAxO1xuICAgICAgICAgIC8vIGhhbmRsZXMgYmluZGluZyBzaW5nbGUgY2xpY2sgYW5kIGRvdWJsZSBjbGljayBjYWxsYmFja3NcbiAgICAgICAgICBjb25zdCBjbGlja0hhbmRsZSA9IGdldENsaWNrSGFuZGxlcihcbiAgICAgICAgICAgICgpID0+IHsgdGhpcy5maWxsTnVtYmVyKG51bWJlcik7IH0sXG4gICAgICAgICAgICAoKSA9PiB7IHRoaXMuYWRkTnVtYmVyQXNOb3RlKG51bWJlcik7IH0sXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPE51bWJlckNvbnRyb2xcbiAgICAgICAgICAgICAga2V5PXtudW1iZXJ9XG4gICAgICAgICAgICAgIG51bWJlcj17bnVtYmVyfVxuICAgICAgICAgICAgICBvbkNsaWNrPXshcHJlZmlsbGVkID8gY2xpY2tIYW5kbGUgOiB1bmRlZmluZWR9XG4gICAgICAgICAgICAgIGNvbXBsZXRpb25QZXJjZW50YWdlPXt0aGlzLmdldE51bWJlclZhbHVlQ291bnQobnVtYmVyKSAvIDl9XG4gICAgICAgICAgICAvPik7XG4gICAgICAgIH0pfVxuICAgICAgICA8c3R5bGUganN4PntDb250cm9sU3R5bGV9PC9zdHlsZT5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cblxuICByZW5kZXJBY3Rpb25zKCkge1xuICAgIGNvbnN0IHsgaGlzdG9yeSB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBzZWxlY3RlZENlbGwgPSB0aGlzLmdldFNlbGVjdGVkQ2VsbCgpO1xuICAgIGNvbnN0IHByZWZpbGxlZCA9IHNlbGVjdGVkQ2VsbCAmJiBzZWxlY3RlZENlbGwuZ2V0KCdwcmVmaWxsZWQnKTtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJhY3Rpb25zXCI+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWN0aW9uXCIgb25DbGljaz17aGlzdG9yeS5zaXplID8gdGhpcy51bmRvIDogbnVsbH0+XG4gICAgICAgICAgPFJlbG9hZEljb24gLz5VbmRvXG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImFjdGlvbiByZWRvXCIgb25DbGljaz17aGlzdG9yeS5zaXplID8gdGhpcy5yZWRvIDogbnVsbH0+XG4gICAgICAgICAgPFJlbG9hZEljb24gLz5SZWRvXG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImFjdGlvblwiIG9uQ2xpY2s9eyFwcmVmaWxsZWQgPyB0aGlzLmVyYXNlU2VsZWN0ZWQgOiBudWxsfT5cbiAgICAgICAgICA8UmVtb3ZlSWNvbiAvPkVyYXNlXG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2XG4gICAgICAgICAgY2xhc3NOYW1lPVwiYWN0aW9uXCJcbiAgICAgICAgICBvbkNsaWNrPXshcHJlZmlsbGVkID9cbiAgICAgICAgICB0aGlzLmZpbGxTZWxlY3RlZFdpdGhTb2x1dGlvbiA6IG51bGx9XG4gICAgICAgID5cbiAgICAgICAgICA8TG91cGVJY29uIC8+SGludFxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPHN0eWxlIGpzeD57QWN0aW9uc1N0eWxlfTwvc3R5bGU+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG5cbiAgcmVuZGVyUHV6emxlKCkge1xuICAgIGNvbnN0IHsgYm9hcmQgfSA9IHRoaXMuc3RhdGU7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwicHV6emxlXCI+XG4gICAgICAgIHtib2FyZC5nZXQoJ3B1enpsZScpLm1hcCgocm93LCBpKSA9PiAoXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L25vLWFycmF5LWluZGV4LWtleVxuICAgICAgICAgIDxkaXYga2V5PXtpfSBjbGFzc05hbWU9XCJyb3dcIj5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcm93Lm1hcCgoY2VsbCwgaikgPT4gdGhpcy5yZW5kZXJDZWxsKGNlbGwsIGksIGopKS50b0FycmF5KClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKSkudG9BcnJheSgpfVxuICAgICAgICA8c3R5bGUganN4PntQdXp6bGVTdHlsZX08L3N0eWxlPlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxuXG4gIHJlbmRlckNvbnRyb2xzKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRyb2xzXCI+XG4gICAgICAgIHt0aGlzLnJlbmRlck51bWJlckNvbnRyb2woKX1cbiAgICAgICAge3RoaXMucmVuZGVyQWN0aW9ucygpfVxuICAgICAgICB7IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG4gICAgICAgIDxzdHlsZSBqc3g+e2BcbiAgICAgICAgICAgIC5jb250cm9scyB7XG4gICAgICAgICAgICAgICAgbWFyZ2luLXRvcDogLjNlbTtcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICAgICAgICAgIGZsZXgtd3JhcDogd3JhcDtcbiAgICAgICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiAuNWVtIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIGB9XG4gICAgICAgIDwvc3R5bGU+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG5cbiAgcmVuZGVyR2VuZXJhdGlvblVJKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8R2VuZXJhdGlvblVJIGdlbmVyYXRlR2FtZT17dGhpcy5nZW5lcmF0ZUdhbWV9IC8+XG4gICAgKTtcbiAgfVxuXG4gIHJlbmRlckhlYWRlcigpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJoZWFkZXJcIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJuZXctZ2FtZVwiIG9uQ2xpY2s9eygpID0+IHRoaXMuc2V0U3RhdGUoeyBib2FyZDogZmFsc2UgfSl9PlxuICAgICAgICAgIDxSZXR1cm5JY29uIC8+XG4gICAgICAgICAgPGRpdj5OZXcgR2FtZTwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPFRpcCAvPlxuICAgICAgICB7IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG4gICAgICAgIDxzdHlsZSBqc3g+e2BcbiAgICAgICAgICAgIC5oZWFkZXIge1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgICAgICAgICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICAgICAgICAgICAgICAgIG1heC13aWR0aDogNTAwcHg7XG4gICAgICAgICAgICAgICAgcGFkZGluZzogMCAwLjVlbTtcbiAgICAgICAgICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLm5ldy1nYW1lIHtcbiAgICAgICAgICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICAgICAgICAgICAgbWFyZ2luLXRvcDogLjJlbTtcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiBpbmxpbmUtZmxleDtcbiAgICAgICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICAgICAgICAgIHBhZGRpbmc6IC4yZW0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC5uZXctZ2FtZSA6Z2xvYmFsKHN2Zykge1xuICAgICAgICAgICAgICAgIGhlaWdodDogMWVtO1xuICAgICAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IC4zZW07XG4gICAgICAgICAgICB9XG4gICAgICAgIGB9XG4gICAgICAgIDwvc3R5bGU+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgYm9hcmQgfSA9IHRoaXMuc3RhdGU7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYm9keVwiPlxuICAgICAgICA8TmV4dEhlYWQ+XG4gICAgICAgICAgPHRpdGxlPlN1ZG9rdSBFdm9sdmVkPC90aXRsZT5cbiAgICAgICAgICA8bWV0YSBuYW1lPVwidmlld3BvcnRcIiBjb250ZW50PVwiaW5pdGlhbC1zY2FsZT0xLjAsIHdpZHRoPWRldmljZS13aWR0aFwiIC8+XG4gICAgICAgICAgPG1ldGEgbmFtZT1cImRlc2NyaXB0aW9uXCIgY29udGVudD17RGVzY3JpcHRpb259IC8+XG4gICAgICAgICAgPGxpbmsgaHJlZj1cImh0dHBzOi8vZm9udHMuZ29vZ2xlYXBpcy5jb20vY3NzP2ZhbWlseT1TcGVjaWFsK0VsaXRlXCIgcmVsPVwic3R5bGVzaGVldFwiIC8+XG4gICAgICAgICAgPG1ldGEgcHJvcGVydHk9XCJvZzp1cmxcIiBjb250ZW50PVwiaHR0cHM6Ly9zdWRva3Uuc2l0aWFubGl1LmNvbS9cIiAvPlxuICAgICAgICAgIDxtZXRhIHByb3BlcnR5PVwib2c6dGl0bGVcIiBjb250ZW50PVwiU3Vkb2t1IEV2b2x2ZWRcIiAvPlxuICAgICAgICAgIDxtZXRhIHByb3BlcnR5PVwib2c6dHlwZVwiIGNvbnRlbnQ9XCJ3ZWJzaXRlXCIgLz5cbiAgICAgICAgICA8bWV0YSBwcm9wZXJ0eT1cIm9nOmRlc2NyaXB0aW9uXCIgY29udGVudD17RGVzY3JpcHRpb259IC8+XG4gICAgICAgICAgPG1ldGEgcHJvcGVydHk9XCJvZzppbWFnZVwiIGNvbnRlbnQ9XCJodHRwczovL3N1ZG9rdS5zaXRpYW5saXUuY29tL3N0YXRpYy9vZy1pbWFnZS5wbmdcIiAvPlxuICAgICAgICA8L05leHRIZWFkPlxuICAgICAgICB7IWJvYXJkICYmIHRoaXMucmVuZGVyR2VuZXJhdGlvblVJKCl9XG4gICAgICAgIHtib2FyZCAmJiB0aGlzLnJlbmRlckhlYWRlcigpfVxuICAgICAgICB7Ym9hcmQgJiYgdGhpcy5yZW5kZXJQdXp6bGUoKX1cbiAgICAgICAge2JvYXJkICYmIHRoaXMucmVuZGVyQ29udHJvbHMoKX1cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJyb290ZXJcIj5cbiAgICAgICAgICBNYWRlIHdpdGggPHNwYW4+4p2k77iPPC9zcGFuPu+4jyBCeSA8YSBocmVmPVwiaHR0cHM6Ly93d3cuc2l0aWFubGl1LmNvbS9cIj5TaXRpYW4gTGl1PC9hPiB8IDxhIGhyZWY9XCJodHRwczovL21lZGl1bS5jb20vQHNpdGlhbmxpdV81NzY4MC9idWlsZGluZy1hLXN1ZG9rdS1nYW1lLWluLXJlYWN0LWNhNjYzOTE1NzEyXCI+QmxvZyBQb3N0PC9hPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgeyAvKiBsYW5ndWFnZT1DU1MgKi8gfVxuICAgICAgICA8c3R5bGUganN4PntgXG4gICAgICAgICAgICA6Z2xvYmFsKGJvZHkpLCAuYm9keSB7XG4gICAgICAgICAgICAgICAgZm9udC1mYW1pbHk6ICdTcGVjaWFsIEVsaXRlJywgY3Vyc2l2ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC5ib2R5IHtcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICAgICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgICAgICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDEwMHZoO1xuICAgICAgICAgICAgICAgIHdpZHRoOiAxMDB2dztcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBAbWVkaWEgKG1pbi13aWR0aDogODAwcHgpIGFuZCAobWluLWhlaWdodDogOTMwcHgpe1xuICAgICAgICAgICAgICAgIDpnbG9iYWwoLmhlYWRlciwgLnB1enpsZSwgLmNvbnRyb2xzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvbnQtc2l6ZTogMS41ZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQG1lZGlhIChtYXgtd2lkdGg6IDgwMHB4KSBhbmQgKG1pbi13aWR0aDogNjAwcHgpe1xuICAgICAgICAgICAgICAgIDpnbG9iYWwoLmhlYWRlciwgLnB1enpsZSwgLmNvbnRyb2xzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvbnQtc2l6ZTogMS4yZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQG1lZGlhIChtYXgtaGVpZ2h0OiA5MzBweCkgYW5kIChtaW4taGVpZ2h0OiA4MDBweCkgYW5kIChtaW4td2lkdGg6IDYwMHB4KXtcbiAgICAgICAgICAgICAgICA6Z2xvYmFsKC5oZWFkZXIsIC5wdXp6bGUsIC5jb250cm9scykge1xuICAgICAgICAgICAgICAgICAgICBmb250LXNpemU6IDEuMmVtO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEBtZWRpYSAobWF4LWhlaWdodDogODAwcHgpIGFuZCAobWluLWhlaWdodDogNjAwcHgpIGFuZCAobWluLXdpZHRoOiAzNzBweCl7XG4gICAgICAgICAgICAgICAgOmdsb2JhbCguaGVhZGVyLCAucHV6emxlLCAuY29udHJvbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9udC1zaXplOiAxZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQG1lZGlhIChtYXgtd2lkdGg6IDM3MHB4KXtcbiAgICAgICAgICAgICAgICA6Z2xvYmFsKC5oZWFkZXIsIC5wdXp6bGUsIC5jb250cm9scykge1xuICAgICAgICAgICAgICAgICAgICBmb250LXNpemU6IC44ZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQG1lZGlhIChtYXgtaGVpZ2h0OiA2MDBweCl7XG4gICAgICAgICAgICAgICAgOmdsb2JhbCguaGVhZGVyLCAucHV6emxlLCAuY29udHJvbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9udC1zaXplOiAuOGVtO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDpnbG9iYWwoYm9keSkge1xuICAgICAgICAgICAgICAgIG1hcmdpbjogMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC5yb290ZXIge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICAgICAgICAgICAgICBib3R0b206IDA7XG4gICAgICAgICAgICAgICAgZm9udC1zaXplOiAuOGVtO1xuICAgICAgICAgICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICAgICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgYH1cbiAgICAgICAgPC9zdHlsZT5cbiAgICAgICAgPHN0eWxlIGpzeCBnbG9iYWw+e1JhbmdlU3R5bGV9PC9zdHlsZT5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cbn1cbiJdfQ== */\n/*@ sourceURL=pages/index.js */');

// eslint-disable-next-line no-lone-blocks
ControlStyle.__hash = '3736506914';
ControlStyle.__scoped = '.control.jsx-404884099{padding:0 2em;cursor:pointer;display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;font-family:\'Special Elite\',cursive;-webkit-transition:filter .5s ease-in-out;transition:filter .5s ease-in-out;width:100%;}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhZ2VzL2luZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQTZGd0IsQUFHbUIsY0FDQyxlQUNLLHNHQUNELDZGQUNKLHlEQUNRLG1HQUNjLG9DQUNILDRFQUN2QixXQUNmIiwiZmlsZSI6InBhZ2VzL2luZGV4LmpzIiwic291cmNlUm9vdCI6Ii9Vc2Vycy9saWNoZW5tYS9Qcm9qZWN0cy9TdUR1b2t1L1N1RHVva3UiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBqc3gtYTExeS9hY2Nlc3NpYmxlLWVtb2ppICovXG5pbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50LCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBTZXQsIExpc3QsIGZyb21KUyB9IGZyb20gJ2ltbXV0YWJsZSc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IE5leHRIZWFkIGZyb20gJ25leHQvaGVhZCc7XG5pbXBvcnQgQ29sb3IgZnJvbSAnY29sb3InO1xuaW1wb3J0IElucHV0UmFuZ2UgZnJvbSAncmVhY3QtaW5wdXQtcmFuZ2UnO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLWV4dHJhbmVvdXMtZGVwZW5kZW5jaWVzXG5pbXBvcnQgY3NzIGZyb20gJ3N0eWxlZC1qc3gvY3NzJztcblxuaW1wb3J0IFJhbmdlU3R5bGUgZnJvbSAnLi4vaW5wdXQtcmFuZ2Utc3R5bGUnO1xuaW1wb3J0IExvdXBlSWNvbiBmcm9tICcuLi9zdmcvbG91cGUuc3ZnJztcbmltcG9ydCBSZW1vdmVJY29uIGZyb20gJy4uL3N2Zy9yZW1vdmUuc3ZnJztcbmltcG9ydCBSZWxvYWRJY29uIGZyb20gJy4uL3N2Zy9yZWxvYWQuc3ZnJztcbmltcG9ydCBSZXR1cm5JY29uIGZyb20gJy4uL3N2Zy9yZXR1cm4uc3ZnJztcblxuaW1wb3J0IHsgbWFrZVB1enpsZSwgcGx1Y2ssIGlzUGVlciBhcyBhcmVDb29yZGluYXRlUGVlcnMsIHJhbmdlIH0gZnJvbSAnLi4vc3Vkb2t1JztcbmltcG9ydCB7IGJhY2tHcm91bmRCbHVlIH0gZnJvbSAnLi4vY29sb3JzJztcbmltcG9ydCBUaXAgZnJvbSAnLi4vY29tcG9uZW50cy90b29sLXRpcCc7XG5cbmltcG9ydCBpbyBmcm9tICdzb2NrZXQuaW8tY2xpZW50J1xuXG5jb25zdCBEZXNjcmlwdGlvbiA9ICdEaXNjb3ZlciB0aGUgbmV4dCBldm9sdXRpb24gb2YgU3Vkb2t1IHdpdGggYW1hemluZyBncmFwaGljcywgYW5pbWF0aW9ucywgYW5kIHVzZXItZnJpZW5kbHkgZmVhdHVyZXMuIEVuam95IGEgU3Vkb2t1IGV4cGVyaWVuY2UgbGlrZSB5b3UgbmV2ZXIgaGF2ZSBiZWZvcmUgd2l0aCBjdXN0b21pemFibGUgZ2FtZSBnZW5lcmF0aW9uLCBjZWxsIGhpZ2hsaWdodGluZywgaW50dWl0aXZlIGNvbnRyb2xzIGFuZCBtb3JlISc7XG5jb25zdCBjZWxsV2lkdGggPSAyLjU7XG5cbmNvbnN0IExpZ2h0Qmx1ZTEwMCA9ICcjQjNFNUZDJztcbmNvbnN0IExpZ2h0Qmx1ZTIwMCA9ICcjODFENEZBJztcbmNvbnN0IExpZ2h0Qmx1ZTMwMCA9ICcjNEZDM0Y3JztcbmNvbnN0IEluZGlnbzcwMCA9ICcjMzAzRjlGJztcbmNvbnN0IERlZXBPcmFuZ2UyMDAgPSAnI0ZGQUI5MSc7XG5jb25zdCBEZWVwT3JhbmdlNjAwID0gJyNGNDUxMUUnO1xuY29uc3QgQ29udHJvbE51bWJlckNvbG9yID0gSW5kaWdvNzAwO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbG9uZS1ibG9ja3NcbnsgLyogbGFuZ3VhZ2U9Q1NTICovIH1cbmNvbnN0IENlbGxTdHlsZSA9IGNzc2Bcbi5jZWxsIHtcbiAgICBoZWlnaHQ6ICR7Y2VsbFdpZHRofWVtO1xuICAgIHdpZHRoOiAke2NlbGxXaWR0aH1lbTtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtd3JhcDogd3JhcDtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgIGZvbnQtc2l6ZTogMS4xZW07XG4gICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgdHJhbnNpdGlvbjogYmFja2dyb3VuZC1jb2xvciAuM3MgZWFzZS1pbi1vdXQ7XG59XG4uY2VsbDpudGgtY2hpbGQoM24rMyk6bm90KDpsYXN0LWNoaWxkKSB7XG4gICAgYm9yZGVyLXJpZ2h0OiAycHggc29saWQgYmxhY2s7XG59XG4uY2VsbDpub3QoOmxhc3QtY2hpbGQpIHtcbiAgICBib3JkZXItcmlnaHQ6IDFweCBzb2xpZCBibGFjaztcbn1cbi5ub3RlLW51bWJlciB7XG4gICAgZm9udC1zaXplOiAuNmVtO1xuICAgIHdpZHRoOiAzMyU7XG4gICAgaGVpZ2h0OiAzMyU7XG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG59XG5gO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbG9uZS1ibG9ja3NcbnsgLyogbGFuZ3VhZ2U9Q1NTICovIH1cbmNvbnN0IEFjdGlvbnNTdHlsZSA9IGNzc2Bcbi5hY3Rpb25zIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIG1heC13aWR0aDogNDAwcHg7XG4gICAgbWFyZ2luLXRvcDogLjVlbTtcbiAgICBwYWRkaW5nOiAwIC42ZW07XG59XG4uYWN0aW9uIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbn1cbi5hY3Rpb24gOmdsb2JhbChzdmcpIHtcbiAgICB3aWR0aDogMi41ZW07XG4gICAgbWFyZ2luLWJvdHRvbTogLjJlbTtcbn1cbi5yZWRvIDpnbG9iYWwoc3ZnKSB7XG4gICAgdHJhbnNmb3JtOiBzY2FsZVgoLTEpO1xufVxuYDtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxvbmUtYmxvY2tzXG57IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG5jb25zdCBDb250cm9sU3R5bGUgPSBjc3NgXG4uY29udHJvbCB7XG4gICAgcGFkZGluZzogMCAyZW07XG4gICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIGRpc3BsYXk6IGlubGluZS1mbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgZmxleC13cmFwOiB3cmFwO1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgIGZvbnQtZmFtaWx5OiAnU3BlY2lhbCBFbGl0ZScsIGN1cnNpdmU7XG4gICAgdHJhbnNpdGlvbjogZmlsdGVyIC41cyBlYXNlLWluLW91dDtcbiAgICB3aWR0aDogMTAwJTtcbn1cbmA7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sb25lLWJsb2Nrc1xueyAvKiBsYW5ndWFnZT1DU1MgKi8gfVxuY29uc3QgTnVtYmVyQ29udHJvbFN0eWxlID0gY3NzYFxuLm51bWJlciB7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBmb250LXNpemU6IDJlbTtcbiAgICBtYXJnaW46IC4xZW07XG4gICAgd2lkdGg6IDEuNWVtO1xuICAgIGhlaWdodDogMS41ZW07XG4gICAgY29sb3I6ICR7Q29udHJvbE51bWJlckNvbG9yfTtcbiAgICBib3gtc2hhZG93OiAwIDFweCAycHggcmdiYSgwLDAsMCwwLjE2KSwgMCAxcHggMnB4IHJnYmEoMCwwLDAsMC4yMyk7XG4gICAgYm9yZGVyLXJhZGl1czogNTAlO1xufVxuLm51bWJlciA+IGRpdiB7XG4gICAgbWFyZ2luLXRvcDogLjNlbTtcbn1cbmA7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sb25lLWJsb2Nrc1xueyAvKiBsYW5ndWFnZT1DU1MgKi8gfVxuY29uc3QgUHV6emxlU3R5bGUgPSBjc3NgXG4ucHV6emxlIHtcbiAgICBtYXJnaW4tdG9wOiAuNWVtO1xuICAgIHdpZHRoOiAke2NlbGxXaWR0aCAqIDl9ZW07XG4gICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIGJveC1zaGFkb3c6IDAgM3B4IDZweCByZ2JhKDAsMCwwLDAuMTYpLCAwIDNweCA2cHggcmdiYSgwLDAsMCwwLjIzKTtcbn1cbi5yb3cge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBmbGV4OiAwO1xuICAgIHdpZHRoOiAke2NlbGxXaWR0aCAqIDl9ZW07XG59XG4ucm93Om5vdCg6bGFzdC1jaGlsZCkge1xuICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCBibGFjaztcbn1cbi5yb3c6bnRoLWNoaWxkKDNuKzMpOm5vdCg6bGFzdC1jaGlsZCkge1xuICAgIGJvcmRlci1ib3R0b206IDJweCBzb2xpZCBibGFjayAhaW1wb3J0YW50O1xufVxuYDtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxvbmUtYmxvY2tzXG57IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG5jb25zdCBDaXJjdWx1YXJQcm9ncmVzc1N0eWxlID0gY3NzYFxuLmNpcmN1bGFyLXByb2dyZXNzIHtcbiAgICBkaXNwbGF5OiBibG9jaztcbiAgICB3aWR0aDogMTAwJTtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgdG9wOiAwO1xuICAgIGxlZnQ6IDA7XG4gICAgdHJhbnNpdGlvbjogZmlsdGVyIC40cyBlYXNlLWluLW91dDtcbn1cblxuLmNpcmNsZS1iZyB7XG4gICAgZmlsbDogbm9uZTtcbiAgICBzdHJva2U6ICNlZWU7XG4gICAgc3Ryb2tlLXdpZHRoOiAzLjg7XG59XG5cbi5jaXJjbGUge1xuICAgIHN0cm9rZTogJHtDb250cm9sTnVtYmVyQ29sb3J9O1xuICAgIHRyYW5zaXRpb246IHN0cm9rZS1kYXNoYXJyYXkgLjRzIGVhc2UtaW4tb3V0O1xuICAgIGZpbGw6IG5vbmU7XG4gICAgc3Ryb2tlLXdpZHRoOiAyLjg7XG4gICAgc3Ryb2tlLWxpbmVjYXA6IHJvdW5kO1xufVxuYDtcblxuY29uc3QgQ2lyY3VsYXJQYXRoRCA9ICdNMTggMi4wODQ1IGEgMTUuOTE1NSAxNS45MTU1IDAgMCAxIDAgMzEuODMxIGEgMTUuOTE1NSAxNS45MTU1IDAgMCAxIDAgLTMxLjgzMSc7XG5cbmZ1bmN0aW9uIGdldEJhY2tHcm91bmRDb2xvcih7XG4gIGNvbmZsaWN0LCBpc1BlZXIsIHNhbWVWYWx1ZSwgaXNTZWxlY3RlZCxcbn0pIHtcbiAgaWYgKGNvbmZsaWN0ICYmIGlzUGVlciAmJiBzYW1lVmFsdWUpIHtcbiAgICByZXR1cm4gRGVlcE9yYW5nZTIwMDtcbiAgfSBlbHNlIGlmIChzYW1lVmFsdWUpIHtcbiAgICByZXR1cm4gTGlnaHRCbHVlMzAwO1xuICB9IGVsc2UgaWYgKGlzU2VsZWN0ZWQpIHtcbiAgICByZXR1cm4gTGlnaHRCbHVlMjAwO1xuICB9IGVsc2UgaWYgKGlzUGVlcikge1xuICAgIHJldHVybiBMaWdodEJsdWUxMDA7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRGb250Q29sb3IoeyB2YWx1ZSwgY29uZmxpY3QsIHByZWZpbGxlZCB9KSB7XG4gIGlmIChjb25mbGljdCAmJiAhcHJlZmlsbGVkKSB7XG4gICAgcmV0dXJuIERlZXBPcmFuZ2U2MDA7XG4gIH0gZWxzZSBpZiAoIXByZWZpbGxlZCAmJiB2YWx1ZSkge1xuICAgIHJldHVybiBDb250cm9sTnVtYmVyQ29sb3I7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5jbGFzcyBHZW5lcmF0aW9uVUkgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcblxuICAgIHRoaXMuc3RhdGUgPSB7IHZhbHVlOiAzMCB9O1xuICB9XG5cbiAgZ2VuZXJhdGVHYW1lID0gKCkgPT4ge1xuICAgIHRoaXMucHJvcHMuZ2VuZXJhdGVHYW1lKHRoaXMuc3RhdGUudmFsdWUpO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImdlbmVyYXRpb25cIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb3B5XCI+U3RhcnQgd2l0aCB7dGhpcy5zdGF0ZS52YWx1ZX0gY2VsbHMgcHJlZmlsbGVkPC9kaXY+XG4gICAgICAgIDxJbnB1dFJhbmdlXG4gICAgICAgICAgbWF4VmFsdWU9ezgxfVxuICAgICAgICAgIG1pblZhbHVlPXsxN31cbiAgICAgICAgICB2YWx1ZT17dGhpcy5zdGF0ZS52YWx1ZX1cbiAgICAgICAgICBvbkNoYW5nZT17dmFsdWUgPT4gdGhpcy5zZXRTdGF0ZSh7IHZhbHVlIH0pfVxuICAgICAgICAvPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImJ1dHRvblwiIG9uQ2xpY2s9e3RoaXMuZ2VuZXJhdGVHYW1lfT5QbGF5IFN1ZG9rdTwvZGl2PlxuICAgICAgICB7IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG4gICAgICAgIDxzdHlsZSBqc3g+e2BcbiAgICAgICAgICAgIC5jb3B5IHtcbiAgICAgICAgICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgICAgICAgICAgICAgZm9udC1zaXplOiAxLjNlbTtcbiAgICAgICAgICAgICAgICBtYXJnaW4tYm90dG9tOiAuNWVtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLmdlbmVyYXRpb24ge1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgICAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgICAgICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOmdsb2JhbCguaW5wdXQtcmFuZ2UpIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogODAlO1xuICAgICAgICAgICAgICAgIG1heC13aWR0aDogNTAwcHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAuYnV0dG9uIHtcbiAgICAgICAgICAgICAgbWFyZ2luLXRvcDogLjVlbTtcbiAgICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogLjI1ZW07XG4gICAgICAgICAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICAgICAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICAgICAgICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcbiAgICAgICAgICAgICAgY29sb3I6ICNmZmY7XG4gICAgICAgICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgICAgICAgICAgICB0cmFuc2l0aW9uOiBhbGwgLjI1cztcbiAgICAgICAgICAgICAgcGFkZGluZzogNXB4IDEwcHg7XG4gICAgICAgICAgICAgIGZvbnQtc2l6ZTogMS40ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAuYnV0dG9uOmFjdGl2ZSB7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKDBweCwgNXB4KTtcbiAgICAgICAgICAgICAgYm94LXNoYWRvdzogMCAxcHggMCAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAuYnV0dG9uIHtcbiAgICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogJHtiYWNrR3JvdW5kQmx1ZX07XG4gICAgICAgICAgICAgIGJveC1zaGFkb3c6IDAgMnB4IDRweCAwICR7Q29sb3IoYmFja0dyb3VuZEJsdWUpLmRhcmtlbigwLjUpLmhzbCgpLnN0cmluZygpfTtcbiAgICAgICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLmJ1dHRvbjpob3ZlciB7XG4gICAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6ICR7Q29sb3IoYmFja0dyb3VuZEJsdWUpLmxpZ2h0ZW4oMC4yKS5oc2woKS5zdHJpbmcoKX07XG4gICAgICAgICAgICB9XG4gICAgICAgIGB9XG4gICAgICAgIDwvc3R5bGU+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG59XG5cbkdlbmVyYXRpb25VSS5wcm9wVHlwZXMgPSB7XG4gIGdlbmVyYXRlR2FtZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbn07XG5cbmNvbnN0IE51bWJlckNvbnRyb2wgPSAoeyBudW1iZXIsIG9uQ2xpY2ssIGNvbXBsZXRpb25QZXJjZW50YWdlIH0pID0+IChcbiAgPGRpdlxuICAgIGtleT17bnVtYmVyfVxuICAgIGNsYXNzTmFtZT1cIm51bWJlclwiXG4gICAgb25DbGljaz17b25DbGlja31cbiAgPlxuICAgIDxkaXY+e251bWJlcn08L2Rpdj5cbiAgICA8Q2lyY2x1bGFyUHJvZ3Jlc3MgcGVyY2VudD17Y29tcGxldGlvblBlcmNlbnRhZ2V9IC8+XG4gICAgPHN0eWxlIGpzeD57TnVtYmVyQ29udHJvbFN0eWxlfTwvc3R5bGU+XG4gIDwvZGl2PlxuKTtcblxuTnVtYmVyQ29udHJvbC5wcm9wVHlwZXMgPSB7XG4gIG51bWJlcjogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICBvbkNsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgY29tcGxldGlvblBlcmNlbnRhZ2U6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbn07XG5cbk51bWJlckNvbnRyb2wuZGVmYXVsdFByb3BzID0ge1xuICBvbkNsaWNrOiBudWxsLFxufTtcblxuY29uc3QgQ2VsbCA9IChwcm9wcykgPT4ge1xuICBjb25zdCB7XG4gICAgdmFsdWUsIG9uQ2xpY2ssIGlzUGVlciwgaXNTZWxlY3RlZCwgc2FtZVZhbHVlLCBwcmVmaWxsZWQsIG5vdGVzLCBjb25mbGljdCxcbiAgfSA9IHByb3BzO1xuICBjb25zdCBiYWNrZ3JvdW5kQ29sb3IgPSBnZXRCYWNrR3JvdW5kQ29sb3Ioe1xuICAgIGNvbmZsaWN0LCBpc1BlZXIsIHNhbWVWYWx1ZSwgaXNTZWxlY3RlZCxcbiAgfSk7XG4gIGNvbnN0IGZvbnRDb2xvciA9IGdldEZvbnRDb2xvcih7IGNvbmZsaWN0LCBwcmVmaWxsZWQsIHZhbHVlIH0pO1xuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwiY2VsbFwiIG9uQ2xpY2s9e29uQ2xpY2t9PlxuICAgICAge1xuICAgICAgICBub3RlcyA/XG4gICAgICAgICAgcmFuZ2UoOSkubWFwKGkgPT5cbiAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgPGRpdiBrZXk9e2l9IGNsYXNzTmFtZT1cIm5vdGUtbnVtYmVyXCI+XG4gICAgICAgICAgICAgICAge25vdGVzLmhhcyhpICsgMSkgJiYgKGkgKyAxKX1cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICApKSA6XG4gICAgICAgICAgdmFsdWUgJiYgdmFsdWVcbiAgICAgIH1cbiAgICAgIHsvKiBsYW5ndWFnZT1DU1MgKi99XG4gICAgICA8c3R5bGUganN4PntDZWxsU3R5bGV9PC9zdHlsZT5cbiAgICAgIDxzdHlsZSBqc3g+e2BcbiAgICAgICAgICAgICAgICAuY2VsbCB7XG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6ICR7YmFja2dyb3VuZENvbG9yIHx8ICdpbml0aWFsJ307XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiAke2ZvbnRDb2xvciB8fCAnaW5pdGlhbCd9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGB9XG4gICAgICA8L3N0eWxlPlxuICAgIDwvZGl2PlxuICApO1xufTtcblxuQ2VsbC5wcm9wVHlwZXMgPSB7XG4gIC8vIGN1cnJlbnQgbnVtYmVyIHZhbHVlXG4gIHZhbHVlOiBQcm9wVHlwZXMubnVtYmVyLFxuICAvLyBjZWxsIGNsaWNrIGhhbmRsZXJcbiAgb25DbGljazogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgLy8gaWYgdGhlIGNlbGwgaXMgYSBwZWVyIG9mIHRoZSBzZWxlY3RlZCBjZWxsXG4gIGlzUGVlcjogUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZCxcbiAgLy8gaWYgdGhlIGNlbGwgaXMgc2VsZWN0ZWQgYnkgdGhlIHVzZXJcbiAgaXNTZWxlY3RlZDogUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZCxcbiAgLy8gY3VycmVudCBjZWxsIGhhcyB0aGUgc2FtZSB2YWx1ZSBpZiB0aGUgdXNlciBzZWxlY3RlZCBjZWxsXG4gIHNhbWVWYWx1ZTogUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZCxcbiAgLy8gaWYgdGhpcyB3YXMgcHJlZmlsbGVkIGFzIGEgcGFydCBvZiB0aGUgcHV6emxlXG4gIHByZWZpbGxlZDogUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZCxcbiAgLy8gY3VycmVudCBub3RlcyB0YWtlbiBvbiB0aGUgY2VsbFxuICBub3RlczogUHJvcFR5cGVzLmluc3RhbmNlT2YoU2V0KSxcbiAgLy8gaWYgdGhlIGN1cnJlbnQgY2VsbCBkb2VzIG5vdCBzYXRpc2Z5IHRoZSBnYW1lIGNvbnN0cmFpbnRcbiAgY29uZmxpY3Q6IFByb3BUeXBlcy5ib29sLmlzUmVxdWlyZWQsXG59O1xuXG5DZWxsLmRlZmF1bHRQcm9wcyA9IHtcbiAgbm90ZXM6IG51bGwsXG4gIHZhbHVlOiBudWxsLFxufTtcblxuY29uc3QgQ2lyY2x1bGFyUHJvZ3Jlc3MgPSAoeyBwZXJjZW50IH0pID0+IChcbiAgPHN2ZyB2aWV3Qm94PVwiMCAwIDM2IDM2XCIgY2xhc3NOYW1lPVwiY2lyY3VsYXItcHJvZ3Jlc3NcIj5cbiAgICA8cGF0aFxuICAgICAgY2xhc3NOYW1lPVwiY2lyY2xlLWJnXCJcbiAgICAgIGQ9e0NpcmN1bGFyUGF0aER9XG4gICAgLz5cbiAgICA8cGF0aFxuICAgICAgY2xhc3NOYW1lPVwiY2lyY2xlXCJcbiAgICAgIHN0cm9rZURhc2hhcnJheT17YCR7cGVyY2VudCAqIDEwMH0sIDEwMGB9XG4gICAgICBkPXtDaXJjdWxhclBhdGhEfVxuICAgIC8+XG4gICAgeyAvKiBsYW5ndWFnZT1DU1MgKi8gfVxuICAgIDxzdHlsZSBqc3g+e0NpcmN1bHVhclByb2dyZXNzU3R5bGV9PC9zdHlsZT5cbiAgPC9zdmc+XG4pO1xuXG5DaXJjbHVsYXJQcm9ncmVzcy5wcm9wVHlwZXMgPSB7XG4gIHBlcmNlbnQ6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbn07XG5cbmZ1bmN0aW9uIGdldENsaWNrSGFuZGxlcihvbkNsaWNrLCBvbkRvdWJsZUNsaWNrLCBkZWxheSA9IDI1MCkge1xuICBsZXQgdGltZW91dElEID0gbnVsbDtcbiAgcmV0dXJuIChldmVudCkgPT4ge1xuICAgIGlmICghdGltZW91dElEKSB7XG4gICAgICB0aW1lb3V0SUQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgb25DbGljayhldmVudCk7XG4gICAgICAgIHRpbWVvdXRJRCA9IG51bGw7XG4gICAgICB9LCBkZWxheSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpbWVvdXRJRCA9IGNsZWFyVGltZW91dCh0aW1lb3V0SUQpO1xuICAgICAgb25Eb3VibGVDbGljayhldmVudCk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIG1ha2Ugc2l6ZSA5IGFycmF5IG9mIDBzXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIG1ha2VDb3VudE9iamVjdCgpIHtcbiAgY29uc3QgY291bnRPYmogPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSArPSAxKSBjb3VudE9iai5wdXNoKDApO1xuICByZXR1cm4gY291bnRPYmo7XG59XG5cbi8qKlxuICogZ2l2ZW4gYSAyRCBhcnJheSBvZiBudW1iZXJzIGFzIHRoZSBpbml0aWFsIHB1enpsZSwgZ2VuZXJhdGUgdGhlIGluaXRpYWwgZ2FtZSBzdGF0ZVxuICogQHBhcmFtIHB1enpsZVxuICogQHJldHVybnMge2FueX1cbiAqL1xuZnVuY3Rpb24gbWFrZUJvYXJkKHsgcHV6emxlIH0pIHtcbiAgLy8gY3JlYXRlIGluaXRpYWwgY291bnQgb2JqZWN0IHRvIGtlZXAgdHJhY2sgb2YgY29uZmxpY3RzIHBlciBudW1iZXIgdmFsdWVcbiAgY29uc3Qgcm93cyA9IEFycmF5LmZyb20oQXJyYXkoOSkua2V5cygpKS5tYXAoKCkgPT4gbWFrZUNvdW50T2JqZWN0KCkpO1xuICBjb25zdCBjb2x1bW5zID0gQXJyYXkuZnJvbShBcnJheSg5KS5rZXlzKCkpLm1hcCgoKSA9PiBtYWtlQ291bnRPYmplY3QoKSk7XG4gIGNvbnN0IHNxdWFyZXMgPSBBcnJheS5mcm9tKEFycmF5KDkpLmtleXMoKSkubWFwKCgpID0+IG1ha2VDb3VudE9iamVjdCgpKTtcbiAgY29uc3QgcmVzdWx0ID0gcHV6emxlLm1hcCgocm93LCBpKSA9PiAoXG4gICAgcm93Lm1hcCgoY2VsbCwgaikgPT4ge1xuICAgICAgaWYgKGNlbGwpIHtcbiAgICAgICAgcm93c1tpXVtjZWxsXSArPSAxO1xuICAgICAgICBjb2x1bW5zW2pdW2NlbGxdICs9IDE7XG4gICAgICAgIHNxdWFyZXNbKChNYXRoLmZsb29yKGkgLyAzKSkgKiAzKSArIE1hdGguZmxvb3IoaiAvIDMpXVtjZWxsXSArPSAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHB1enpsZVtpXVtqXSA+IDAgPyBwdXp6bGVbaV1bal0gOiBudWxsLFxuICAgICAgICBwcmVmaWxsZWQ6ICEhcHV6emxlW2ldW2pdLFxuICAgICAgfTtcbiAgICB9KVxuICApKTtcbiAgcmV0dXJuIGZyb21KUyh7IHB1enpsZTogcmVzdWx0LCBzZWxlY3RlZDogZmFsc2UsIGNob2ljZXM6IHsgcm93cywgY29sdW1ucywgc3F1YXJlcyB9IH0pO1xufVxuXG4vKipcbiAqIGdpdmUgdGhlIGNvb3JkaW5hdGUgdXBkYXRlIHRoZSBjdXJyZW50IGJvYXJkIHdpdGggYSBudW1iZXIgY2hvaWNlXG4gKiBAcGFyYW0geFxuICogQHBhcmFtIHlcbiAqIEBwYXJhbSBudW1iZXJcbiAqIEBwYXJhbSBmaWxsIHdoZXRoZXIgdG8gc2V0IG9yIHVuc2V0XG4gKiBAcGFyYW0gYm9hcmQgdGhlIGltbXV0YWJsZSBib2FyZCBnaXZlbiB0byBjaGFuZ2VcbiAqL1xuZnVuY3Rpb24gdXBkYXRlQm9hcmRXaXRoTnVtYmVyKHtcbiAgeCwgeSwgbnVtYmVyLCBmaWxsID0gdHJ1ZSwgYm9hcmQsXG59KSB7XG4gIGxldCBjZWxsID0gYm9hcmQuZ2V0KCdwdXp6bGUnKS5nZXRJbihbeCwgeV0pO1xuICAvLyBkZWxldGUgaXRzIG5vdGVzXG4gIGNlbGwgPSBjZWxsLmRlbGV0ZSgnbm90ZXMnKTtcbiAgLy8gc2V0IG9yIHVuc2V0IGl0cyB2YWx1ZSBkZXBlbmRpbmcgb24gYGZpbGxgXG4gIGNlbGwgPSBmaWxsID8gY2VsbC5zZXQoJ3ZhbHVlJywgbnVtYmVyKSA6IGNlbGwuZGVsZXRlKCd2YWx1ZScpO1xuICBjb25zdCBpbmNyZW1lbnQgPSBmaWxsID8gMSA6IC0xO1xuICAvLyB1cGRhdGUgdGhlIGN1cnJlbnQgZ3JvdXAgY2hvaWNlc1xuICBjb25zdCByb3dQYXRoID0gWydjaG9pY2VzJywgJ3Jvd3MnLCB4LCBudW1iZXJdO1xuICBjb25zdCBjb2x1bW5QYXRoID0gWydjaG9pY2VzJywgJ2NvbHVtbnMnLCB5LCBudW1iZXJdO1xuICBjb25zdCBzcXVhcmVQYXRoID0gWydjaG9pY2VzJywgJ3NxdWFyZXMnLFxuICAgICgoTWF0aC5mbG9vcih4IC8gMykpICogMykgKyBNYXRoLmZsb29yKHkgLyAzKSwgbnVtYmVyXTtcbiAgcmV0dXJuIGJvYXJkLnNldEluKHJvd1BhdGgsIGJvYXJkLmdldEluKHJvd1BhdGgpICsgaW5jcmVtZW50KVxuICAgIC5zZXRJbihjb2x1bW5QYXRoLCBib2FyZC5nZXRJbihjb2x1bW5QYXRoKSArIGluY3JlbWVudClcbiAgICAuc2V0SW4oc3F1YXJlUGF0aCwgYm9hcmQuZ2V0SW4oc3F1YXJlUGF0aCkgKyBpbmNyZW1lbnQpXG4gICAgLnNldEluKFsncHV6emxlJywgeCwgeV0sIGNlbGwpO1xufVxuXG5mdW5jdGlvbiBnZXROdW1iZXJPZkdyb3Vwc0Fzc2lnbmVkRm9yTnVtYmVyKG51bWJlciwgZ3JvdXBzKSB7XG4gIHJldHVybiBncm91cHMucmVkdWNlKChhY2N1bXVsYXRvciwgcm93KSA9PlxuICAgIGFjY3VtdWxhdG9yICsgKHJvdy5nZXQobnVtYmVyKSA+IDAgPyAxIDogMCksIDApO1xufVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L25vLW11bHRpLWNvbXBcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEluZGV4IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgc3RhdGUgPSB7fTtcblxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICBpZiAoJ3NlcnZpY2VXb3JrZXInIGluIG5hdmlnYXRvcikge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICAgICBuYXZpZ2F0b3Iuc2VydmljZVdvcmtlclxuICAgICAgICAucmVnaXN0ZXIoJy9zZXJ2aWNlLXdvcmtlci5qcycpXG4gICAgICAgIC50aGVuKChyZWcpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnU2VydmljZVdvcmtlciBzY29wZTogJywgcmVnLnNjb3BlKTtcbiAgICAgICAgICBjb25zb2xlLmxvZygnc2VydmljZSB3b3JrZXIgcmVnaXN0cmF0aW9uIHN1Y2Nlc3NmdWwnKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ3NlcnZpY2Ugd29ya2VyIHJlZ2lzdHJhdGlvbiBmYWlsZWQnLCBlcnIubWVzc2FnZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgXG4gICAgZmV0Y2goJy9hcGkvc29ja2V0aW8nKS5maW5hbGx5KCgpID0+IHtcbiAgICAgIGNvbnN0IHNvY2tldCA9IGlvKClcblxuICAgICAgc29ja2V0Lm9uKCdjb25uZWN0JywgKCkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZygnY29ubmVjdCcpXG4gICAgICAgIHNvY2tldC5lbWl0KCdoZWxsbycpXG4gICAgICB9KVxuXG4gICAgICBzb2NrZXQub24oJ2hlbGxvJywgZGF0YSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdoZWxsbycsIGRhdGEpXG4gICAgICB9KVxuXG4gICAgICBzb2NrZXQub24oJ2EgdXNlciBjb25uZWN0ZWQnLCAoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdhIHVzZXIgY29ubmVjdGVkJylcbiAgICAgIH0pXG5cbiAgICAgIHNvY2tldC5vbignZGlzY29ubmVjdCcsICgpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ2Rpc2Nvbm5lY3QnKVxuICAgICAgfSlcbiAgICB9KVxuICAgXG4gIH1cbiAgZ2V0U2VsZWN0ZWRDZWxsKCkge1xuICAgIGNvbnN0IHsgYm9hcmQgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3Qgc2VsZWN0ZWQgPSBib2FyZC5nZXQoJ3NlbGVjdGVkJyk7XG4gICAgcmV0dXJuIHNlbGVjdGVkICYmIGJvYXJkLmdldCgncHV6emxlJykuZ2V0SW4oW3NlbGVjdGVkLngsIHNlbGVjdGVkLnldKTtcbiAgfVxuXG4gIC8vIGdldCB0aGUgbWluIGJldHdlZW4gaXRzIGNvbXBsZXRpb24gaW4gcm93cywgY29sdW1ucyBhbmQgc3F1YXJlcy5cbiAgZ2V0TnVtYmVyVmFsdWVDb3VudChudW1iZXIpIHtcbiAgICBjb25zdCByb3dzID0gdGhpcy5zdGF0ZS5ib2FyZC5nZXRJbihbJ2Nob2ljZXMnLCAncm93cyddKTtcbiAgICBjb25zdCBjb2x1bW5zID0gdGhpcy5zdGF0ZS5ib2FyZC5nZXRJbihbJ2Nob2ljZXMnLCAnY29sdW1ucyddKTtcbiAgICBjb25zdCBzcXVhcmVzID0gdGhpcy5zdGF0ZS5ib2FyZC5nZXRJbihbJ2Nob2ljZXMnLCAnc3F1YXJlcyddKTtcbiAgICByZXR1cm4gTWF0aC5taW4oXG4gICAgICBnZXROdW1iZXJPZkdyb3Vwc0Fzc2lnbmVkRm9yTnVtYmVyKG51bWJlciwgc3F1YXJlcyksXG4gICAgICBNYXRoLm1pbihcbiAgICAgICAgZ2V0TnVtYmVyT2ZHcm91cHNBc3NpZ25lZEZvck51bWJlcihudW1iZXIsIHJvd3MpLFxuICAgICAgICBnZXROdW1iZXJPZkdyb3Vwc0Fzc2lnbmVkRm9yTnVtYmVyKG51bWJlciwgY29sdW1ucyksXG4gICAgICApLFxuICAgICk7XG4gIH1cblxuICBnZW5lcmF0ZUdhbWUgPSAoZmluYWxDb3VudCA9IDIwKSA9PiB7XG4gICAgLy8gZ2V0IGEgZmlsbGVkIHB1enpsZSBnZW5lcmF0ZWRcbiAgICBjb25zdCBzb2x1dGlvbiA9IG1ha2VQdXp6bGUoKTtcbiAgICAvLyBwbHVjayB2YWx1ZXMgZnJvbSBjZWxscyB0byBjcmVhdGUgdGhlIGdhbWVcbiAgICBjb25zdCB7IHB1enpsZSB9ID0gcGx1Y2soc29sdXRpb24sIGZpbmFsQ291bnQpO1xuICAgIC8vIGluaXRpYWxpemUgdGhlIGJvYXJkIHdpdGggY2hvaWNlIGNvdW50c1xuICAgIGNvbnN0IGJvYXJkID0gbWFrZUJvYXJkKHsgcHV6emxlIH0pO1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgYm9hcmQsIGhpc3Rvcnk6IExpc3Qub2YoYm9hcmQpLCBoaXN0b3J5T2ZmU2V0OiAwLCBzb2x1dGlvbixcbiAgICB9KTtcbiAgfVxuXG4gIGFkZE51bWJlckFzTm90ZSA9IChudW1iZXIpID0+IHtcbiAgICBsZXQgeyBib2FyZCB9ID0gdGhpcy5zdGF0ZTtcbiAgICBsZXQgc2VsZWN0ZWRDZWxsID0gdGhpcy5nZXRTZWxlY3RlZENlbGwoKTtcbiAgICBpZiAoIXNlbGVjdGVkQ2VsbCkgcmV0dXJuO1xuICAgIGNvbnN0IHByZWZpbGxlZCA9IHNlbGVjdGVkQ2VsbC5nZXQoJ3ByZWZpbGxlZCcpO1xuICAgIGlmIChwcmVmaWxsZWQpIHJldHVybjtcbiAgICBjb25zdCB7IHgsIHkgfSA9IGJvYXJkLmdldCgnc2VsZWN0ZWQnKTtcbiAgICBjb25zdCBjdXJyZW50VmFsdWUgPSBzZWxlY3RlZENlbGwuZ2V0KCd2YWx1ZScpO1xuICAgIGlmIChjdXJyZW50VmFsdWUpIHtcbiAgICAgIGJvYXJkID0gdXBkYXRlQm9hcmRXaXRoTnVtYmVyKHtcbiAgICAgICAgeCwgeSwgbnVtYmVyOiBjdXJyZW50VmFsdWUsIGZpbGw6IGZhbHNlLCBib2FyZDogdGhpcy5zdGF0ZS5ib2FyZCxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBsZXQgbm90ZXMgPSBzZWxlY3RlZENlbGwuZ2V0KCdub3RlcycpIHx8IFNldCgpO1xuICAgIGlmIChub3Rlcy5oYXMobnVtYmVyKSkge1xuICAgICAgbm90ZXMgPSBub3Rlcy5kZWxldGUobnVtYmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm90ZXMgPSBub3Rlcy5hZGQobnVtYmVyKTtcbiAgICB9XG4gICAgc2VsZWN0ZWRDZWxsID0gc2VsZWN0ZWRDZWxsLnNldCgnbm90ZXMnLCBub3Rlcyk7XG4gICAgc2VsZWN0ZWRDZWxsID0gc2VsZWN0ZWRDZWxsLmRlbGV0ZSgndmFsdWUnKTtcbiAgICBib2FyZCA9IGJvYXJkLnNldEluKFsncHV6emxlJywgeCwgeV0sIHNlbGVjdGVkQ2VsbCk7XG4gICAgdGhpcy51cGRhdGVCb2FyZChib2FyZCk7XG4gIH07XG5cbiAgdXBkYXRlQm9hcmQgPSAobmV3Qm9hcmQpID0+IHtcbiAgICBsZXQgeyBoaXN0b3J5IH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IHsgaGlzdG9yeU9mZlNldCB9ID0gdGhpcy5zdGF0ZTtcbiAgICAvLyBhbnl0aGluZyBiZWZvcmUgY3VycmVudCBzdGVwIGlzIHN0aWxsIGluIGhpc3RvcnlcbiAgICBoaXN0b3J5ID0gaGlzdG9yeS5zbGljZSgwLCBoaXN0b3J5T2ZmU2V0ICsgMSk7XG4gICAgLy8gYWRkIGl0c2VsZiBvbnRvIHRoZSBoaXN0b3J5XG4gICAgaGlzdG9yeSA9IGhpc3RvcnkucHVzaChuZXdCb2FyZCk7XG4gICAgLy8gdXBkYXRlIHRoZSBnYW1lXG4gICAgdGhpcy5zZXRTdGF0ZSh7IGJvYXJkOiBuZXdCb2FyZCwgaGlzdG9yeSwgaGlzdG9yeU9mZlNldDogaGlzdG9yeS5zaXplIC0gMSB9KTtcbiAgfTtcblxuICBjYW5VbmRvID0gKCkgPT4gdGhpcy5zdGF0ZS5oaXN0b3J5T2ZmU2V0ID4gMFxuXG4gIHJlZG8gPSAoKSA9PiB7XG4gICAgY29uc3QgeyBoaXN0b3J5IH0gPSB0aGlzLnN0YXRlO1xuICAgIGxldCB7IGhpc3RvcnlPZmZTZXQgfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKGhpc3Rvcnkuc2l6ZSkge1xuICAgICAgaGlzdG9yeU9mZlNldCA9IE1hdGgubWluKGhpc3Rvcnkuc2l6ZSAtIDEsIGhpc3RvcnlPZmZTZXQgKyAxKTtcbiAgICAgIGNvbnN0IGJvYXJkID0gaGlzdG9yeS5nZXQoaGlzdG9yeU9mZlNldCk7XG4gICAgICB0aGlzLnNldFN0YXRlKHsgYm9hcmQsIGhpc3RvcnlPZmZTZXQgfSk7XG4gICAgfVxuICB9O1xuXG4gIHVuZG8gPSAoKSA9PiB7XG4gICAgY29uc3QgeyBoaXN0b3J5IH0gPSB0aGlzLnN0YXRlO1xuICAgIGxldCB7IGhpc3RvcnlPZmZTZXQsIGJvYXJkIH0gPSB0aGlzLnN0YXRlO1xuICAgIGlmIChoaXN0b3J5LnNpemUpIHtcbiAgICAgIGhpc3RvcnlPZmZTZXQgPSBNYXRoLm1heCgwLCBoaXN0b3J5T2ZmU2V0IC0gMSk7XG4gICAgICBib2FyZCA9IGhpc3RvcnkuZ2V0KGhpc3RvcnlPZmZTZXQpO1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IGJvYXJkLCBoaXN0b3J5T2ZmU2V0LCBoaXN0b3J5IH0pO1xuICAgIH1cbiAgfTtcblxuICBlcmFzZVNlbGVjdGVkID0gKCkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGVkQ2VsbCA9IHRoaXMuZ2V0U2VsZWN0ZWRDZWxsKCk7XG4gICAgaWYgKCFzZWxlY3RlZENlbGwpIHJldHVybjtcbiAgICB0aGlzLmZpbGxOdW1iZXIoZmFsc2UpO1xuICB9XG5cbiAgZmlsbFNlbGVjdGVkV2l0aFNvbHV0aW9uID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgYm9hcmQsIHNvbHV0aW9uIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IHNlbGVjdGVkQ2VsbCA9IHRoaXMuZ2V0U2VsZWN0ZWRDZWxsKCk7XG4gICAgaWYgKCFzZWxlY3RlZENlbGwpIHJldHVybjtcbiAgICBjb25zdCB7IHgsIHkgfSA9IGJvYXJkLmdldCgnc2VsZWN0ZWQnKTtcbiAgICB0aGlzLmZpbGxOdW1iZXIoc29sdXRpb25beF1beV0pO1xuICB9XG5cblxuICAvLyBmaWxsIGN1cnJlbnRseSBzZWxlY3RlZCBjZWxsIHdpdGggbnVtYmVyXG4gIGZpbGxOdW1iZXIgPSAobnVtYmVyKSA9PiB7XG4gICAgbGV0IHsgYm9hcmQgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3Qgc2VsZWN0ZWRDZWxsID0gdGhpcy5nZXRTZWxlY3RlZENlbGwoKTtcbiAgICAvLyBuby1vcCBpZiBub3RoaW5nIGlzIHNlbGVjdGVkXG4gICAgaWYgKCFzZWxlY3RlZENlbGwpIHJldHVybjtcbiAgICBjb25zdCBwcmVmaWxsZWQgPSBzZWxlY3RlZENlbGwuZ2V0KCdwcmVmaWxsZWQnKTtcbiAgICAvLyBuby1vcCBpZiBpdCBpcyByZWZpbGxlZFxuICAgIGlmIChwcmVmaWxsZWQpIHJldHVybjtcbiAgICBjb25zdCB7IHgsIHkgfSA9IGJvYXJkLmdldCgnc2VsZWN0ZWQnKTtcbiAgICBjb25zdCBjdXJyZW50VmFsdWUgPSBzZWxlY3RlZENlbGwuZ2V0KCd2YWx1ZScpO1xuICAgIC8vIHJlbW92ZSB0aGUgY3VycmVudCB2YWx1ZSBhbmQgdXBkYXRlIHRoZSBnYW1lIHN0YXRlXG4gICAgaWYgKGN1cnJlbnRWYWx1ZSkge1xuICAgICAgYm9hcmQgPSB1cGRhdGVCb2FyZFdpdGhOdW1iZXIoe1xuICAgICAgICB4LCB5LCBudW1iZXI6IGN1cnJlbnRWYWx1ZSwgZmlsbDogZmFsc2UsIGJvYXJkOiB0aGlzLnN0YXRlLmJvYXJkLFxuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIHVwZGF0ZSB0byBuZXcgbnVtYmVyIGlmIGFueVxuICAgIGNvbnN0IHNldE51bWJlciA9IGN1cnJlbnRWYWx1ZSAhPT0gbnVtYmVyICYmIG51bWJlcjtcbiAgICBpZiAoc2V0TnVtYmVyKSB7XG4gICAgICBib2FyZCA9IHVwZGF0ZUJvYXJkV2l0aE51bWJlcih7XG4gICAgICAgIHgsIHksIG51bWJlciwgZmlsbDogdHJ1ZSwgYm9hcmQsXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVCb2FyZChib2FyZCk7XG4gIH07XG5cbiAgc2VsZWN0Q2VsbCA9ICh4LCB5KSA9PiB7XG4gICAgbGV0IHsgYm9hcmQgfSA9IHRoaXMuc3RhdGU7XG4gICAgYm9hcmQgPSBib2FyZC5zZXQoJ3NlbGVjdGVkJywgeyB4LCB5IH0pO1xuICAgIHRoaXMuc2V0U3RhdGUoeyBib2FyZCB9KTtcbiAgfTtcblxuICBpc0NvbmZsaWN0KGksIGopIHtcbiAgICBjb25zdCB7IHZhbHVlIH0gPSB0aGlzLnN0YXRlLmJvYXJkLmdldEluKFsncHV6emxlJywgaSwgal0pLnRvSlNPTigpO1xuICAgIGlmICghdmFsdWUpIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCByb3dDb25mbGljdCA9XG4gICAgICB0aGlzLnN0YXRlLmJvYXJkLmdldEluKFsnY2hvaWNlcycsICdyb3dzJywgaSwgdmFsdWVdKSA+IDE7XG4gICAgY29uc3QgY29sdW1uQ29uZmxpY3QgPVxuICAgICAgdGhpcy5zdGF0ZS5ib2FyZC5nZXRJbihbJ2Nob2ljZXMnLCAnY29sdW1ucycsIGosIHZhbHVlXSkgPiAxO1xuICAgIGNvbnN0IHNxdWFyZUNvbmZsaWN0ID1cbiAgICAgIHRoaXMuc3RhdGUuYm9hcmQuZ2V0SW4oWydjaG9pY2VzJywgJ3NxdWFyZXMnLFxuICAgICAgICAoKE1hdGguZmxvb3IoaSAvIDMpKSAqIDMpICsgTWF0aC5mbG9vcihqIC8gMyksIHZhbHVlXSkgPiAxO1xuICAgIHJldHVybiByb3dDb25mbGljdCB8fCBjb2x1bW5Db25mbGljdCB8fCBzcXVhcmVDb25mbGljdDtcbiAgfVxuXG4gIHJlbmRlckNlbGwoY2VsbCwgeCwgeSkge1xuICAgIGNvbnN0IHsgYm9hcmQgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3Qgc2VsZWN0ZWQgPSB0aGlzLmdldFNlbGVjdGVkQ2VsbCgpO1xuICAgIGNvbnN0IHsgdmFsdWUsIHByZWZpbGxlZCwgbm90ZXMgfSA9IGNlbGwudG9KU09OKCk7XG4gICAgY29uc3QgY29uZmxpY3QgPSB0aGlzLmlzQ29uZmxpY3QoeCwgeSk7XG4gICAgY29uc3QgcGVlciA9IGFyZUNvb3JkaW5hdGVQZWVycyh7IHgsIHkgfSwgYm9hcmQuZ2V0KCdzZWxlY3RlZCcpKTtcbiAgICBjb25zdCBzYW1lVmFsdWUgPSAhIShzZWxlY3RlZCAmJiBzZWxlY3RlZC5nZXQoJ3ZhbHVlJylcbiAgICAgICYmIHZhbHVlID09PSBzZWxlY3RlZC5nZXQoJ3ZhbHVlJykpO1xuXG4gICAgY29uc3QgaXNTZWxlY3RlZCA9IGNlbGwgPT09IHNlbGVjdGVkO1xuICAgIHJldHVybiAoPENlbGxcbiAgICAgIHByZWZpbGxlZD17cHJlZmlsbGVkfVxuICAgICAgbm90ZXM9e25vdGVzfVxuICAgICAgc2FtZVZhbHVlPXtzYW1lVmFsdWV9XG4gICAgICBpc1NlbGVjdGVkPXtpc1NlbGVjdGVkfVxuICAgICAgaXNQZWVyPXtwZWVyfVxuICAgICAgdmFsdWU9e3ZhbHVlfVxuICAgICAgb25DbGljaz17KCkgPT4geyB0aGlzLnNlbGVjdENlbGwoeCwgeSk7IH19XG4gICAgICBrZXk9e3l9XG4gICAgICB4PXt4fVxuICAgICAgeT17eX1cbiAgICAgIGNvbmZsaWN0PXtjb25mbGljdH1cbiAgICAvPik7XG4gIH1cblxuICByZW5kZXJOdW1iZXJDb250cm9sKCkge1xuICAgIGNvbnN0IHNlbGVjdGVkQ2VsbCA9IHRoaXMuZ2V0U2VsZWN0ZWRDZWxsKCk7XG4gICAgY29uc3QgcHJlZmlsbGVkID0gc2VsZWN0ZWRDZWxsICYmIHNlbGVjdGVkQ2VsbC5nZXQoJ3ByZWZpbGxlZCcpO1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRyb2xcIj5cbiAgICAgICAge3JhbmdlKDkpLm1hcCgoaSkgPT4ge1xuICAgICAgICAgIGNvbnN0IG51bWJlciA9IGkgKyAxO1xuICAgICAgICAgIC8vIGhhbmRsZXMgYmluZGluZyBzaW5nbGUgY2xpY2sgYW5kIGRvdWJsZSBjbGljayBjYWxsYmFja3NcbiAgICAgICAgICBjb25zdCBjbGlja0hhbmRsZSA9IGdldENsaWNrSGFuZGxlcihcbiAgICAgICAgICAgICgpID0+IHsgdGhpcy5maWxsTnVtYmVyKG51bWJlcik7IH0sXG4gICAgICAgICAgICAoKSA9PiB7IHRoaXMuYWRkTnVtYmVyQXNOb3RlKG51bWJlcik7IH0sXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPE51bWJlckNvbnRyb2xcbiAgICAgICAgICAgICAga2V5PXtudW1iZXJ9XG4gICAgICAgICAgICAgIG51bWJlcj17bnVtYmVyfVxuICAgICAgICAgICAgICBvbkNsaWNrPXshcHJlZmlsbGVkID8gY2xpY2tIYW5kbGUgOiB1bmRlZmluZWR9XG4gICAgICAgICAgICAgIGNvbXBsZXRpb25QZXJjZW50YWdlPXt0aGlzLmdldE51bWJlclZhbHVlQ291bnQobnVtYmVyKSAvIDl9XG4gICAgICAgICAgICAvPik7XG4gICAgICAgIH0pfVxuICAgICAgICA8c3R5bGUganN4PntDb250cm9sU3R5bGV9PC9zdHlsZT5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cblxuICByZW5kZXJBY3Rpb25zKCkge1xuICAgIGNvbnN0IHsgaGlzdG9yeSB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBzZWxlY3RlZENlbGwgPSB0aGlzLmdldFNlbGVjdGVkQ2VsbCgpO1xuICAgIGNvbnN0IHByZWZpbGxlZCA9IHNlbGVjdGVkQ2VsbCAmJiBzZWxlY3RlZENlbGwuZ2V0KCdwcmVmaWxsZWQnKTtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJhY3Rpb25zXCI+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWN0aW9uXCIgb25DbGljaz17aGlzdG9yeS5zaXplID8gdGhpcy51bmRvIDogbnVsbH0+XG4gICAgICAgICAgPFJlbG9hZEljb24gLz5VbmRvXG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImFjdGlvbiByZWRvXCIgb25DbGljaz17aGlzdG9yeS5zaXplID8gdGhpcy5yZWRvIDogbnVsbH0+XG4gICAgICAgICAgPFJlbG9hZEljb24gLz5SZWRvXG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImFjdGlvblwiIG9uQ2xpY2s9eyFwcmVmaWxsZWQgPyB0aGlzLmVyYXNlU2VsZWN0ZWQgOiBudWxsfT5cbiAgICAgICAgICA8UmVtb3ZlSWNvbiAvPkVyYXNlXG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2XG4gICAgICAgICAgY2xhc3NOYW1lPVwiYWN0aW9uXCJcbiAgICAgICAgICBvbkNsaWNrPXshcHJlZmlsbGVkID9cbiAgICAgICAgICB0aGlzLmZpbGxTZWxlY3RlZFdpdGhTb2x1dGlvbiA6IG51bGx9XG4gICAgICAgID5cbiAgICAgICAgICA8TG91cGVJY29uIC8+SGludFxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPHN0eWxlIGpzeD57QWN0aW9uc1N0eWxlfTwvc3R5bGU+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG5cbiAgcmVuZGVyUHV6emxlKCkge1xuICAgIGNvbnN0IHsgYm9hcmQgfSA9IHRoaXMuc3RhdGU7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwicHV6emxlXCI+XG4gICAgICAgIHtib2FyZC5nZXQoJ3B1enpsZScpLm1hcCgocm93LCBpKSA9PiAoXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L25vLWFycmF5LWluZGV4LWtleVxuICAgICAgICAgIDxkaXYga2V5PXtpfSBjbGFzc05hbWU9XCJyb3dcIj5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcm93Lm1hcCgoY2VsbCwgaikgPT4gdGhpcy5yZW5kZXJDZWxsKGNlbGwsIGksIGopKS50b0FycmF5KClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKSkudG9BcnJheSgpfVxuICAgICAgICA8c3R5bGUganN4PntQdXp6bGVTdHlsZX08L3N0eWxlPlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxuXG4gIHJlbmRlckNvbnRyb2xzKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRyb2xzXCI+XG4gICAgICAgIHt0aGlzLnJlbmRlck51bWJlckNvbnRyb2woKX1cbiAgICAgICAge3RoaXMucmVuZGVyQWN0aW9ucygpfVxuICAgICAgICB7IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG4gICAgICAgIDxzdHlsZSBqc3g+e2BcbiAgICAgICAgICAgIC5jb250cm9scyB7XG4gICAgICAgICAgICAgICAgbWFyZ2luLXRvcDogLjNlbTtcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICAgICAgICAgIGZsZXgtd3JhcDogd3JhcDtcbiAgICAgICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiAuNWVtIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIGB9XG4gICAgICAgIDwvc3R5bGU+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG5cbiAgcmVuZGVyR2VuZXJhdGlvblVJKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8R2VuZXJhdGlvblVJIGdlbmVyYXRlR2FtZT17dGhpcy5nZW5lcmF0ZUdhbWV9IC8+XG4gICAgKTtcbiAgfVxuXG4gIHJlbmRlckhlYWRlcigpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJoZWFkZXJcIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJuZXctZ2FtZVwiIG9uQ2xpY2s9eygpID0+IHRoaXMuc2V0U3RhdGUoeyBib2FyZDogZmFsc2UgfSl9PlxuICAgICAgICAgIDxSZXR1cm5JY29uIC8+XG4gICAgICAgICAgPGRpdj5OZXcgR2FtZTwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPFRpcCAvPlxuICAgICAgICB7IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG4gICAgICAgIDxzdHlsZSBqc3g+e2BcbiAgICAgICAgICAgIC5oZWFkZXIge1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgICAgICAgICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICAgICAgICAgICAgICAgIG1heC13aWR0aDogNTAwcHg7XG4gICAgICAgICAgICAgICAgcGFkZGluZzogMCAwLjVlbTtcbiAgICAgICAgICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLm5ldy1nYW1lIHtcbiAgICAgICAgICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICAgICAgICAgICAgbWFyZ2luLXRvcDogLjJlbTtcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiBpbmxpbmUtZmxleDtcbiAgICAgICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICAgICAgICAgIHBhZGRpbmc6IC4yZW0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC5uZXctZ2FtZSA6Z2xvYmFsKHN2Zykge1xuICAgICAgICAgICAgICAgIGhlaWdodDogMWVtO1xuICAgICAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IC4zZW07XG4gICAgICAgICAgICB9XG4gICAgICAgIGB9XG4gICAgICAgIDwvc3R5bGU+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgYm9hcmQgfSA9IHRoaXMuc3RhdGU7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYm9keVwiPlxuICAgICAgICA8TmV4dEhlYWQ+XG4gICAgICAgICAgPHRpdGxlPlN1ZG9rdSBFdm9sdmVkPC90aXRsZT5cbiAgICAgICAgICA8bWV0YSBuYW1lPVwidmlld3BvcnRcIiBjb250ZW50PVwiaW5pdGlhbC1zY2FsZT0xLjAsIHdpZHRoPWRldmljZS13aWR0aFwiIC8+XG4gICAgICAgICAgPG1ldGEgbmFtZT1cImRlc2NyaXB0aW9uXCIgY29udGVudD17RGVzY3JpcHRpb259IC8+XG4gICAgICAgICAgPGxpbmsgaHJlZj1cImh0dHBzOi8vZm9udHMuZ29vZ2xlYXBpcy5jb20vY3NzP2ZhbWlseT1TcGVjaWFsK0VsaXRlXCIgcmVsPVwic3R5bGVzaGVldFwiIC8+XG4gICAgICAgICAgPG1ldGEgcHJvcGVydHk9XCJvZzp1cmxcIiBjb250ZW50PVwiaHR0cHM6Ly9zdWRva3Uuc2l0aWFubGl1LmNvbS9cIiAvPlxuICAgICAgICAgIDxtZXRhIHByb3BlcnR5PVwib2c6dGl0bGVcIiBjb250ZW50PVwiU3Vkb2t1IEV2b2x2ZWRcIiAvPlxuICAgICAgICAgIDxtZXRhIHByb3BlcnR5PVwib2c6dHlwZVwiIGNvbnRlbnQ9XCJ3ZWJzaXRlXCIgLz5cbiAgICAgICAgICA8bWV0YSBwcm9wZXJ0eT1cIm9nOmRlc2NyaXB0aW9uXCIgY29udGVudD17RGVzY3JpcHRpb259IC8+XG4gICAgICAgICAgPG1ldGEgcHJvcGVydHk9XCJvZzppbWFnZVwiIGNvbnRlbnQ9XCJodHRwczovL3N1ZG9rdS5zaXRpYW5saXUuY29tL3N0YXRpYy9vZy1pbWFnZS5wbmdcIiAvPlxuICAgICAgICA8L05leHRIZWFkPlxuICAgICAgICB7IWJvYXJkICYmIHRoaXMucmVuZGVyR2VuZXJhdGlvblVJKCl9XG4gICAgICAgIHtib2FyZCAmJiB0aGlzLnJlbmRlckhlYWRlcigpfVxuICAgICAgICB7Ym9hcmQgJiYgdGhpcy5yZW5kZXJQdXp6bGUoKX1cbiAgICAgICAge2JvYXJkICYmIHRoaXMucmVuZGVyQ29udHJvbHMoKX1cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJyb290ZXJcIj5cbiAgICAgICAgICBNYWRlIHdpdGggPHNwYW4+4p2k77iPPC9zcGFuPu+4jyBCeSA8YSBocmVmPVwiaHR0cHM6Ly93d3cuc2l0aWFubGl1LmNvbS9cIj5TaXRpYW4gTGl1PC9hPiB8IDxhIGhyZWY9XCJodHRwczovL21lZGl1bS5jb20vQHNpdGlhbmxpdV81NzY4MC9idWlsZGluZy1hLXN1ZG9rdS1nYW1lLWluLXJlYWN0LWNhNjYzOTE1NzEyXCI+QmxvZyBQb3N0PC9hPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgeyAvKiBsYW5ndWFnZT1DU1MgKi8gfVxuICAgICAgICA8c3R5bGUganN4PntgXG4gICAgICAgICAgICA6Z2xvYmFsKGJvZHkpLCAuYm9keSB7XG4gICAgICAgICAgICAgICAgZm9udC1mYW1pbHk6ICdTcGVjaWFsIEVsaXRlJywgY3Vyc2l2ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC5ib2R5IHtcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICAgICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgICAgICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDEwMHZoO1xuICAgICAgICAgICAgICAgIHdpZHRoOiAxMDB2dztcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBAbWVkaWEgKG1pbi13aWR0aDogODAwcHgpIGFuZCAobWluLWhlaWdodDogOTMwcHgpe1xuICAgICAgICAgICAgICAgIDpnbG9iYWwoLmhlYWRlciwgLnB1enpsZSwgLmNvbnRyb2xzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvbnQtc2l6ZTogMS41ZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQG1lZGlhIChtYXgtd2lkdGg6IDgwMHB4KSBhbmQgKG1pbi13aWR0aDogNjAwcHgpe1xuICAgICAgICAgICAgICAgIDpnbG9iYWwoLmhlYWRlciwgLnB1enpsZSwgLmNvbnRyb2xzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvbnQtc2l6ZTogMS4yZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQG1lZGlhIChtYXgtaGVpZ2h0OiA5MzBweCkgYW5kIChtaW4taGVpZ2h0OiA4MDBweCkgYW5kIChtaW4td2lkdGg6IDYwMHB4KXtcbiAgICAgICAgICAgICAgICA6Z2xvYmFsKC5oZWFkZXIsIC5wdXp6bGUsIC5jb250cm9scykge1xuICAgICAgICAgICAgICAgICAgICBmb250LXNpemU6IDEuMmVtO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEBtZWRpYSAobWF4LWhlaWdodDogODAwcHgpIGFuZCAobWluLWhlaWdodDogNjAwcHgpIGFuZCAobWluLXdpZHRoOiAzNzBweCl7XG4gICAgICAgICAgICAgICAgOmdsb2JhbCguaGVhZGVyLCAucHV6emxlLCAuY29udHJvbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9udC1zaXplOiAxZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQG1lZGlhIChtYXgtd2lkdGg6IDM3MHB4KXtcbiAgICAgICAgICAgICAgICA6Z2xvYmFsKC5oZWFkZXIsIC5wdXp6bGUsIC5jb250cm9scykge1xuICAgICAgICAgICAgICAgICAgICBmb250LXNpemU6IC44ZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQG1lZGlhIChtYXgtaGVpZ2h0OiA2MDBweCl7XG4gICAgICAgICAgICAgICAgOmdsb2JhbCguaGVhZGVyLCAucHV6emxlLCAuY29udHJvbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9udC1zaXplOiAuOGVtO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDpnbG9iYWwoYm9keSkge1xuICAgICAgICAgICAgICAgIG1hcmdpbjogMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC5yb290ZXIge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICAgICAgICAgICAgICBib3R0b206IDA7XG4gICAgICAgICAgICAgICAgZm9udC1zaXplOiAuOGVtO1xuICAgICAgICAgICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICAgICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgYH1cbiAgICAgICAgPC9zdHlsZT5cbiAgICAgICAgPHN0eWxlIGpzeCBnbG9iYWw+e1JhbmdlU3R5bGV9PC9zdHlsZT5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cbn1cbiJdfQ== */\n/*@ sourceURL=pages/index.js */';
ControlStyle.__scopedHash = '404884099';
{/* language=CSS */}
var NumberControlStyle = new String('.number{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;position:relative;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;font-size:2em;margin:.1em;width:1.5em;height:1.5em;color:' + ControlNumberColor + ';box-shadow:0 1px 2px rgba(0,0,0,0.16),0 1px 2px rgba(0,0,0,0.23);border-radius:50%;}.number>div{margin-top:.3em;}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhZ2VzL2luZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQTZHOEIsQUFHa0IsQUFhRyxnQkFDcEIsMERBYnNCLGtCQUNLLG1HQUNKLDZGQUNMLGNBQ0YsWUFDQSxZQUNDLGFBQ3NCLG1DQUMrQixpRUFDaEQsa0JBQ3RCIiwiZmlsZSI6InBhZ2VzL2luZGV4LmpzIiwic291cmNlUm9vdCI6Ii9Vc2Vycy9saWNoZW5tYS9Qcm9qZWN0cy9TdUR1b2t1L1N1RHVva3UiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBqc3gtYTExeS9hY2Nlc3NpYmxlLWVtb2ppICovXG5pbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50LCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBTZXQsIExpc3QsIGZyb21KUyB9IGZyb20gJ2ltbXV0YWJsZSc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IE5leHRIZWFkIGZyb20gJ25leHQvaGVhZCc7XG5pbXBvcnQgQ29sb3IgZnJvbSAnY29sb3InO1xuaW1wb3J0IElucHV0UmFuZ2UgZnJvbSAncmVhY3QtaW5wdXQtcmFuZ2UnO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLWV4dHJhbmVvdXMtZGVwZW5kZW5jaWVzXG5pbXBvcnQgY3NzIGZyb20gJ3N0eWxlZC1qc3gvY3NzJztcblxuaW1wb3J0IFJhbmdlU3R5bGUgZnJvbSAnLi4vaW5wdXQtcmFuZ2Utc3R5bGUnO1xuaW1wb3J0IExvdXBlSWNvbiBmcm9tICcuLi9zdmcvbG91cGUuc3ZnJztcbmltcG9ydCBSZW1vdmVJY29uIGZyb20gJy4uL3N2Zy9yZW1vdmUuc3ZnJztcbmltcG9ydCBSZWxvYWRJY29uIGZyb20gJy4uL3N2Zy9yZWxvYWQuc3ZnJztcbmltcG9ydCBSZXR1cm5JY29uIGZyb20gJy4uL3N2Zy9yZXR1cm4uc3ZnJztcblxuaW1wb3J0IHsgbWFrZVB1enpsZSwgcGx1Y2ssIGlzUGVlciBhcyBhcmVDb29yZGluYXRlUGVlcnMsIHJhbmdlIH0gZnJvbSAnLi4vc3Vkb2t1JztcbmltcG9ydCB7IGJhY2tHcm91bmRCbHVlIH0gZnJvbSAnLi4vY29sb3JzJztcbmltcG9ydCBUaXAgZnJvbSAnLi4vY29tcG9uZW50cy90b29sLXRpcCc7XG5cbmltcG9ydCBpbyBmcm9tICdzb2NrZXQuaW8tY2xpZW50J1xuXG5jb25zdCBEZXNjcmlwdGlvbiA9ICdEaXNjb3ZlciB0aGUgbmV4dCBldm9sdXRpb24gb2YgU3Vkb2t1IHdpdGggYW1hemluZyBncmFwaGljcywgYW5pbWF0aW9ucywgYW5kIHVzZXItZnJpZW5kbHkgZmVhdHVyZXMuIEVuam95IGEgU3Vkb2t1IGV4cGVyaWVuY2UgbGlrZSB5b3UgbmV2ZXIgaGF2ZSBiZWZvcmUgd2l0aCBjdXN0b21pemFibGUgZ2FtZSBnZW5lcmF0aW9uLCBjZWxsIGhpZ2hsaWdodGluZywgaW50dWl0aXZlIGNvbnRyb2xzIGFuZCBtb3JlISc7XG5jb25zdCBjZWxsV2lkdGggPSAyLjU7XG5cbmNvbnN0IExpZ2h0Qmx1ZTEwMCA9ICcjQjNFNUZDJztcbmNvbnN0IExpZ2h0Qmx1ZTIwMCA9ICcjODFENEZBJztcbmNvbnN0IExpZ2h0Qmx1ZTMwMCA9ICcjNEZDM0Y3JztcbmNvbnN0IEluZGlnbzcwMCA9ICcjMzAzRjlGJztcbmNvbnN0IERlZXBPcmFuZ2UyMDAgPSAnI0ZGQUI5MSc7XG5jb25zdCBEZWVwT3JhbmdlNjAwID0gJyNGNDUxMUUnO1xuY29uc3QgQ29udHJvbE51bWJlckNvbG9yID0gSW5kaWdvNzAwO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbG9uZS1ibG9ja3NcbnsgLyogbGFuZ3VhZ2U9Q1NTICovIH1cbmNvbnN0IENlbGxTdHlsZSA9IGNzc2Bcbi5jZWxsIHtcbiAgICBoZWlnaHQ6ICR7Y2VsbFdpZHRofWVtO1xuICAgIHdpZHRoOiAke2NlbGxXaWR0aH1lbTtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtd3JhcDogd3JhcDtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgIGZvbnQtc2l6ZTogMS4xZW07XG4gICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgdHJhbnNpdGlvbjogYmFja2dyb3VuZC1jb2xvciAuM3MgZWFzZS1pbi1vdXQ7XG59XG4uY2VsbDpudGgtY2hpbGQoM24rMyk6bm90KDpsYXN0LWNoaWxkKSB7XG4gICAgYm9yZGVyLXJpZ2h0OiAycHggc29saWQgYmxhY2s7XG59XG4uY2VsbDpub3QoOmxhc3QtY2hpbGQpIHtcbiAgICBib3JkZXItcmlnaHQ6IDFweCBzb2xpZCBibGFjaztcbn1cbi5ub3RlLW51bWJlciB7XG4gICAgZm9udC1zaXplOiAuNmVtO1xuICAgIHdpZHRoOiAzMyU7XG4gICAgaGVpZ2h0OiAzMyU7XG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG59XG5gO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbG9uZS1ibG9ja3NcbnsgLyogbGFuZ3VhZ2U9Q1NTICovIH1cbmNvbnN0IEFjdGlvbnNTdHlsZSA9IGNzc2Bcbi5hY3Rpb25zIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIG1heC13aWR0aDogNDAwcHg7XG4gICAgbWFyZ2luLXRvcDogLjVlbTtcbiAgICBwYWRkaW5nOiAwIC42ZW07XG59XG4uYWN0aW9uIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbn1cbi5hY3Rpb24gOmdsb2JhbChzdmcpIHtcbiAgICB3aWR0aDogMi41ZW07XG4gICAgbWFyZ2luLWJvdHRvbTogLjJlbTtcbn1cbi5yZWRvIDpnbG9iYWwoc3ZnKSB7XG4gICAgdHJhbnNmb3JtOiBzY2FsZVgoLTEpO1xufVxuYDtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxvbmUtYmxvY2tzXG57IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG5jb25zdCBDb250cm9sU3R5bGUgPSBjc3NgXG4uY29udHJvbCB7XG4gICAgcGFkZGluZzogMCAyZW07XG4gICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIGRpc3BsYXk6IGlubGluZS1mbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgZmxleC13cmFwOiB3cmFwO1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgIGZvbnQtZmFtaWx5OiAnU3BlY2lhbCBFbGl0ZScsIGN1cnNpdmU7XG4gICAgdHJhbnNpdGlvbjogZmlsdGVyIC41cyBlYXNlLWluLW91dDtcbiAgICB3aWR0aDogMTAwJTtcbn1cbmA7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sb25lLWJsb2Nrc1xueyAvKiBsYW5ndWFnZT1DU1MgKi8gfVxuY29uc3QgTnVtYmVyQ29udHJvbFN0eWxlID0gY3NzYFxuLm51bWJlciB7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBmb250LXNpemU6IDJlbTtcbiAgICBtYXJnaW46IC4xZW07XG4gICAgd2lkdGg6IDEuNWVtO1xuICAgIGhlaWdodDogMS41ZW07XG4gICAgY29sb3I6ICR7Q29udHJvbE51bWJlckNvbG9yfTtcbiAgICBib3gtc2hhZG93OiAwIDFweCAycHggcmdiYSgwLDAsMCwwLjE2KSwgMCAxcHggMnB4IHJnYmEoMCwwLDAsMC4yMyk7XG4gICAgYm9yZGVyLXJhZGl1czogNTAlO1xufVxuLm51bWJlciA+IGRpdiB7XG4gICAgbWFyZ2luLXRvcDogLjNlbTtcbn1cbmA7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sb25lLWJsb2Nrc1xueyAvKiBsYW5ndWFnZT1DU1MgKi8gfVxuY29uc3QgUHV6emxlU3R5bGUgPSBjc3NgXG4ucHV6emxlIHtcbiAgICBtYXJnaW4tdG9wOiAuNWVtO1xuICAgIHdpZHRoOiAke2NlbGxXaWR0aCAqIDl9ZW07XG4gICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIGJveC1zaGFkb3c6IDAgM3B4IDZweCByZ2JhKDAsMCwwLDAuMTYpLCAwIDNweCA2cHggcmdiYSgwLDAsMCwwLjIzKTtcbn1cbi5yb3cge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBmbGV4OiAwO1xuICAgIHdpZHRoOiAke2NlbGxXaWR0aCAqIDl9ZW07XG59XG4ucm93Om5vdCg6bGFzdC1jaGlsZCkge1xuICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCBibGFjaztcbn1cbi5yb3c6bnRoLWNoaWxkKDNuKzMpOm5vdCg6bGFzdC1jaGlsZCkge1xuICAgIGJvcmRlci1ib3R0b206IDJweCBzb2xpZCBibGFjayAhaW1wb3J0YW50O1xufVxuYDtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxvbmUtYmxvY2tzXG57IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG5jb25zdCBDaXJjdWx1YXJQcm9ncmVzc1N0eWxlID0gY3NzYFxuLmNpcmN1bGFyLXByb2dyZXNzIHtcbiAgICBkaXNwbGF5OiBibG9jaztcbiAgICB3aWR0aDogMTAwJTtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgdG9wOiAwO1xuICAgIGxlZnQ6IDA7XG4gICAgdHJhbnNpdGlvbjogZmlsdGVyIC40cyBlYXNlLWluLW91dDtcbn1cblxuLmNpcmNsZS1iZyB7XG4gICAgZmlsbDogbm9uZTtcbiAgICBzdHJva2U6ICNlZWU7XG4gICAgc3Ryb2tlLXdpZHRoOiAzLjg7XG59XG5cbi5jaXJjbGUge1xuICAgIHN0cm9rZTogJHtDb250cm9sTnVtYmVyQ29sb3J9O1xuICAgIHRyYW5zaXRpb246IHN0cm9rZS1kYXNoYXJyYXkgLjRzIGVhc2UtaW4tb3V0O1xuICAgIGZpbGw6IG5vbmU7XG4gICAgc3Ryb2tlLXdpZHRoOiAyLjg7XG4gICAgc3Ryb2tlLWxpbmVjYXA6IHJvdW5kO1xufVxuYDtcblxuY29uc3QgQ2lyY3VsYXJQYXRoRCA9ICdNMTggMi4wODQ1IGEgMTUuOTE1NSAxNS45MTU1IDAgMCAxIDAgMzEuODMxIGEgMTUuOTE1NSAxNS45MTU1IDAgMCAxIDAgLTMxLjgzMSc7XG5cbmZ1bmN0aW9uIGdldEJhY2tHcm91bmRDb2xvcih7XG4gIGNvbmZsaWN0LCBpc1BlZXIsIHNhbWVWYWx1ZSwgaXNTZWxlY3RlZCxcbn0pIHtcbiAgaWYgKGNvbmZsaWN0ICYmIGlzUGVlciAmJiBzYW1lVmFsdWUpIHtcbiAgICByZXR1cm4gRGVlcE9yYW5nZTIwMDtcbiAgfSBlbHNlIGlmIChzYW1lVmFsdWUpIHtcbiAgICByZXR1cm4gTGlnaHRCbHVlMzAwO1xuICB9IGVsc2UgaWYgKGlzU2VsZWN0ZWQpIHtcbiAgICByZXR1cm4gTGlnaHRCbHVlMjAwO1xuICB9IGVsc2UgaWYgKGlzUGVlcikge1xuICAgIHJldHVybiBMaWdodEJsdWUxMDA7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRGb250Q29sb3IoeyB2YWx1ZSwgY29uZmxpY3QsIHByZWZpbGxlZCB9KSB7XG4gIGlmIChjb25mbGljdCAmJiAhcHJlZmlsbGVkKSB7XG4gICAgcmV0dXJuIERlZXBPcmFuZ2U2MDA7XG4gIH0gZWxzZSBpZiAoIXByZWZpbGxlZCAmJiB2YWx1ZSkge1xuICAgIHJldHVybiBDb250cm9sTnVtYmVyQ29sb3I7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5jbGFzcyBHZW5lcmF0aW9uVUkgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcblxuICAgIHRoaXMuc3RhdGUgPSB7IHZhbHVlOiAzMCB9O1xuICB9XG5cbiAgZ2VuZXJhdGVHYW1lID0gKCkgPT4ge1xuICAgIHRoaXMucHJvcHMuZ2VuZXJhdGVHYW1lKHRoaXMuc3RhdGUudmFsdWUpO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImdlbmVyYXRpb25cIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb3B5XCI+U3RhcnQgd2l0aCB7dGhpcy5zdGF0ZS52YWx1ZX0gY2VsbHMgcHJlZmlsbGVkPC9kaXY+XG4gICAgICAgIDxJbnB1dFJhbmdlXG4gICAgICAgICAgbWF4VmFsdWU9ezgxfVxuICAgICAgICAgIG1pblZhbHVlPXsxN31cbiAgICAgICAgICB2YWx1ZT17dGhpcy5zdGF0ZS52YWx1ZX1cbiAgICAgICAgICBvbkNoYW5nZT17dmFsdWUgPT4gdGhpcy5zZXRTdGF0ZSh7IHZhbHVlIH0pfVxuICAgICAgICAvPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImJ1dHRvblwiIG9uQ2xpY2s9e3RoaXMuZ2VuZXJhdGVHYW1lfT5QbGF5IFN1ZG9rdTwvZGl2PlxuICAgICAgICB7IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG4gICAgICAgIDxzdHlsZSBqc3g+e2BcbiAgICAgICAgICAgIC5jb3B5IHtcbiAgICAgICAgICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgICAgICAgICAgICAgZm9udC1zaXplOiAxLjNlbTtcbiAgICAgICAgICAgICAgICBtYXJnaW4tYm90dG9tOiAuNWVtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLmdlbmVyYXRpb24ge1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgICAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgICAgICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOmdsb2JhbCguaW5wdXQtcmFuZ2UpIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogODAlO1xuICAgICAgICAgICAgICAgIG1heC13aWR0aDogNTAwcHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAuYnV0dG9uIHtcbiAgICAgICAgICAgICAgbWFyZ2luLXRvcDogLjVlbTtcbiAgICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogLjI1ZW07XG4gICAgICAgICAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICAgICAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICAgICAgICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcbiAgICAgICAgICAgICAgY29sb3I6ICNmZmY7XG4gICAgICAgICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgICAgICAgICAgICB0cmFuc2l0aW9uOiBhbGwgLjI1cztcbiAgICAgICAgICAgICAgcGFkZGluZzogNXB4IDEwcHg7XG4gICAgICAgICAgICAgIGZvbnQtc2l6ZTogMS40ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAuYnV0dG9uOmFjdGl2ZSB7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKDBweCwgNXB4KTtcbiAgICAgICAgICAgICAgYm94LXNoYWRvdzogMCAxcHggMCAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAuYnV0dG9uIHtcbiAgICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogJHtiYWNrR3JvdW5kQmx1ZX07XG4gICAgICAgICAgICAgIGJveC1zaGFkb3c6IDAgMnB4IDRweCAwICR7Q29sb3IoYmFja0dyb3VuZEJsdWUpLmRhcmtlbigwLjUpLmhzbCgpLnN0cmluZygpfTtcbiAgICAgICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLmJ1dHRvbjpob3ZlciB7XG4gICAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6ICR7Q29sb3IoYmFja0dyb3VuZEJsdWUpLmxpZ2h0ZW4oMC4yKS5oc2woKS5zdHJpbmcoKX07XG4gICAgICAgICAgICB9XG4gICAgICAgIGB9XG4gICAgICAgIDwvc3R5bGU+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG59XG5cbkdlbmVyYXRpb25VSS5wcm9wVHlwZXMgPSB7XG4gIGdlbmVyYXRlR2FtZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbn07XG5cbmNvbnN0IE51bWJlckNvbnRyb2wgPSAoeyBudW1iZXIsIG9uQ2xpY2ssIGNvbXBsZXRpb25QZXJjZW50YWdlIH0pID0+IChcbiAgPGRpdlxuICAgIGtleT17bnVtYmVyfVxuICAgIGNsYXNzTmFtZT1cIm51bWJlclwiXG4gICAgb25DbGljaz17b25DbGlja31cbiAgPlxuICAgIDxkaXY+e251bWJlcn08L2Rpdj5cbiAgICA8Q2lyY2x1bGFyUHJvZ3Jlc3MgcGVyY2VudD17Y29tcGxldGlvblBlcmNlbnRhZ2V9IC8+XG4gICAgPHN0eWxlIGpzeD57TnVtYmVyQ29udHJvbFN0eWxlfTwvc3R5bGU+XG4gIDwvZGl2PlxuKTtcblxuTnVtYmVyQ29udHJvbC5wcm9wVHlwZXMgPSB7XG4gIG51bWJlcjogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICBvbkNsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgY29tcGxldGlvblBlcmNlbnRhZ2U6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbn07XG5cbk51bWJlckNvbnRyb2wuZGVmYXVsdFByb3BzID0ge1xuICBvbkNsaWNrOiBudWxsLFxufTtcblxuY29uc3QgQ2VsbCA9IChwcm9wcykgPT4ge1xuICBjb25zdCB7XG4gICAgdmFsdWUsIG9uQ2xpY2ssIGlzUGVlciwgaXNTZWxlY3RlZCwgc2FtZVZhbHVlLCBwcmVmaWxsZWQsIG5vdGVzLCBjb25mbGljdCxcbiAgfSA9IHByb3BzO1xuICBjb25zdCBiYWNrZ3JvdW5kQ29sb3IgPSBnZXRCYWNrR3JvdW5kQ29sb3Ioe1xuICAgIGNvbmZsaWN0LCBpc1BlZXIsIHNhbWVWYWx1ZSwgaXNTZWxlY3RlZCxcbiAgfSk7XG4gIGNvbnN0IGZvbnRDb2xvciA9IGdldEZvbnRDb2xvcih7IGNvbmZsaWN0LCBwcmVmaWxsZWQsIHZhbHVlIH0pO1xuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwiY2VsbFwiIG9uQ2xpY2s9e29uQ2xpY2t9PlxuICAgICAge1xuICAgICAgICBub3RlcyA/XG4gICAgICAgICAgcmFuZ2UoOSkubWFwKGkgPT5cbiAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgPGRpdiBrZXk9e2l9IGNsYXNzTmFtZT1cIm5vdGUtbnVtYmVyXCI+XG4gICAgICAgICAgICAgICAge25vdGVzLmhhcyhpICsgMSkgJiYgKGkgKyAxKX1cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICApKSA6XG4gICAgICAgICAgdmFsdWUgJiYgdmFsdWVcbiAgICAgIH1cbiAgICAgIHsvKiBsYW5ndWFnZT1DU1MgKi99XG4gICAgICA8c3R5bGUganN4PntDZWxsU3R5bGV9PC9zdHlsZT5cbiAgICAgIDxzdHlsZSBqc3g+e2BcbiAgICAgICAgICAgICAgICAuY2VsbCB7XG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6ICR7YmFja2dyb3VuZENvbG9yIHx8ICdpbml0aWFsJ307XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiAke2ZvbnRDb2xvciB8fCAnaW5pdGlhbCd9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGB9XG4gICAgICA8L3N0eWxlPlxuICAgIDwvZGl2PlxuICApO1xufTtcblxuQ2VsbC5wcm9wVHlwZXMgPSB7XG4gIC8vIGN1cnJlbnQgbnVtYmVyIHZhbHVlXG4gIHZhbHVlOiBQcm9wVHlwZXMubnVtYmVyLFxuICAvLyBjZWxsIGNsaWNrIGhhbmRsZXJcbiAgb25DbGljazogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgLy8gaWYgdGhlIGNlbGwgaXMgYSBwZWVyIG9mIHRoZSBzZWxlY3RlZCBjZWxsXG4gIGlzUGVlcjogUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZCxcbiAgLy8gaWYgdGhlIGNlbGwgaXMgc2VsZWN0ZWQgYnkgdGhlIHVzZXJcbiAgaXNTZWxlY3RlZDogUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZCxcbiAgLy8gY3VycmVudCBjZWxsIGhhcyB0aGUgc2FtZSB2YWx1ZSBpZiB0aGUgdXNlciBzZWxlY3RlZCBjZWxsXG4gIHNhbWVWYWx1ZTogUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZCxcbiAgLy8gaWYgdGhpcyB3YXMgcHJlZmlsbGVkIGFzIGEgcGFydCBvZiB0aGUgcHV6emxlXG4gIHByZWZpbGxlZDogUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZCxcbiAgLy8gY3VycmVudCBub3RlcyB0YWtlbiBvbiB0aGUgY2VsbFxuICBub3RlczogUHJvcFR5cGVzLmluc3RhbmNlT2YoU2V0KSxcbiAgLy8gaWYgdGhlIGN1cnJlbnQgY2VsbCBkb2VzIG5vdCBzYXRpc2Z5IHRoZSBnYW1lIGNvbnN0cmFpbnRcbiAgY29uZmxpY3Q6IFByb3BUeXBlcy5ib29sLmlzUmVxdWlyZWQsXG59O1xuXG5DZWxsLmRlZmF1bHRQcm9wcyA9IHtcbiAgbm90ZXM6IG51bGwsXG4gIHZhbHVlOiBudWxsLFxufTtcblxuY29uc3QgQ2lyY2x1bGFyUHJvZ3Jlc3MgPSAoeyBwZXJjZW50IH0pID0+IChcbiAgPHN2ZyB2aWV3Qm94PVwiMCAwIDM2IDM2XCIgY2xhc3NOYW1lPVwiY2lyY3VsYXItcHJvZ3Jlc3NcIj5cbiAgICA8cGF0aFxuICAgICAgY2xhc3NOYW1lPVwiY2lyY2xlLWJnXCJcbiAgICAgIGQ9e0NpcmN1bGFyUGF0aER9XG4gICAgLz5cbiAgICA8cGF0aFxuICAgICAgY2xhc3NOYW1lPVwiY2lyY2xlXCJcbiAgICAgIHN0cm9rZURhc2hhcnJheT17YCR7cGVyY2VudCAqIDEwMH0sIDEwMGB9XG4gICAgICBkPXtDaXJjdWxhclBhdGhEfVxuICAgIC8+XG4gICAgeyAvKiBsYW5ndWFnZT1DU1MgKi8gfVxuICAgIDxzdHlsZSBqc3g+e0NpcmN1bHVhclByb2dyZXNzU3R5bGV9PC9zdHlsZT5cbiAgPC9zdmc+XG4pO1xuXG5DaXJjbHVsYXJQcm9ncmVzcy5wcm9wVHlwZXMgPSB7XG4gIHBlcmNlbnQ6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbn07XG5cbmZ1bmN0aW9uIGdldENsaWNrSGFuZGxlcihvbkNsaWNrLCBvbkRvdWJsZUNsaWNrLCBkZWxheSA9IDI1MCkge1xuICBsZXQgdGltZW91dElEID0gbnVsbDtcbiAgcmV0dXJuIChldmVudCkgPT4ge1xuICAgIGlmICghdGltZW91dElEKSB7XG4gICAgICB0aW1lb3V0SUQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgb25DbGljayhldmVudCk7XG4gICAgICAgIHRpbWVvdXRJRCA9IG51bGw7XG4gICAgICB9LCBkZWxheSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpbWVvdXRJRCA9IGNsZWFyVGltZW91dCh0aW1lb3V0SUQpO1xuICAgICAgb25Eb3VibGVDbGljayhldmVudCk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIG1ha2Ugc2l6ZSA5IGFycmF5IG9mIDBzXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIG1ha2VDb3VudE9iamVjdCgpIHtcbiAgY29uc3QgY291bnRPYmogPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSArPSAxKSBjb3VudE9iai5wdXNoKDApO1xuICByZXR1cm4gY291bnRPYmo7XG59XG5cbi8qKlxuICogZ2l2ZW4gYSAyRCBhcnJheSBvZiBudW1iZXJzIGFzIHRoZSBpbml0aWFsIHB1enpsZSwgZ2VuZXJhdGUgdGhlIGluaXRpYWwgZ2FtZSBzdGF0ZVxuICogQHBhcmFtIHB1enpsZVxuICogQHJldHVybnMge2FueX1cbiAqL1xuZnVuY3Rpb24gbWFrZUJvYXJkKHsgcHV6emxlIH0pIHtcbiAgLy8gY3JlYXRlIGluaXRpYWwgY291bnQgb2JqZWN0IHRvIGtlZXAgdHJhY2sgb2YgY29uZmxpY3RzIHBlciBudW1iZXIgdmFsdWVcbiAgY29uc3Qgcm93cyA9IEFycmF5LmZyb20oQXJyYXkoOSkua2V5cygpKS5tYXAoKCkgPT4gbWFrZUNvdW50T2JqZWN0KCkpO1xuICBjb25zdCBjb2x1bW5zID0gQXJyYXkuZnJvbShBcnJheSg5KS5rZXlzKCkpLm1hcCgoKSA9PiBtYWtlQ291bnRPYmplY3QoKSk7XG4gIGNvbnN0IHNxdWFyZXMgPSBBcnJheS5mcm9tKEFycmF5KDkpLmtleXMoKSkubWFwKCgpID0+IG1ha2VDb3VudE9iamVjdCgpKTtcbiAgY29uc3QgcmVzdWx0ID0gcHV6emxlLm1hcCgocm93LCBpKSA9PiAoXG4gICAgcm93Lm1hcCgoY2VsbCwgaikgPT4ge1xuICAgICAgaWYgKGNlbGwpIHtcbiAgICAgICAgcm93c1tpXVtjZWxsXSArPSAxO1xuICAgICAgICBjb2x1bW5zW2pdW2NlbGxdICs9IDE7XG4gICAgICAgIHNxdWFyZXNbKChNYXRoLmZsb29yKGkgLyAzKSkgKiAzKSArIE1hdGguZmxvb3IoaiAvIDMpXVtjZWxsXSArPSAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHB1enpsZVtpXVtqXSA+IDAgPyBwdXp6bGVbaV1bal0gOiBudWxsLFxuICAgICAgICBwcmVmaWxsZWQ6ICEhcHV6emxlW2ldW2pdLFxuICAgICAgfTtcbiAgICB9KVxuICApKTtcbiAgcmV0dXJuIGZyb21KUyh7IHB1enpsZTogcmVzdWx0LCBzZWxlY3RlZDogZmFsc2UsIGNob2ljZXM6IHsgcm93cywgY29sdW1ucywgc3F1YXJlcyB9IH0pO1xufVxuXG4vKipcbiAqIGdpdmUgdGhlIGNvb3JkaW5hdGUgdXBkYXRlIHRoZSBjdXJyZW50IGJvYXJkIHdpdGggYSBudW1iZXIgY2hvaWNlXG4gKiBAcGFyYW0geFxuICogQHBhcmFtIHlcbiAqIEBwYXJhbSBudW1iZXJcbiAqIEBwYXJhbSBmaWxsIHdoZXRoZXIgdG8gc2V0IG9yIHVuc2V0XG4gKiBAcGFyYW0gYm9hcmQgdGhlIGltbXV0YWJsZSBib2FyZCBnaXZlbiB0byBjaGFuZ2VcbiAqL1xuZnVuY3Rpb24gdXBkYXRlQm9hcmRXaXRoTnVtYmVyKHtcbiAgeCwgeSwgbnVtYmVyLCBmaWxsID0gdHJ1ZSwgYm9hcmQsXG59KSB7XG4gIGxldCBjZWxsID0gYm9hcmQuZ2V0KCdwdXp6bGUnKS5nZXRJbihbeCwgeV0pO1xuICAvLyBkZWxldGUgaXRzIG5vdGVzXG4gIGNlbGwgPSBjZWxsLmRlbGV0ZSgnbm90ZXMnKTtcbiAgLy8gc2V0IG9yIHVuc2V0IGl0cyB2YWx1ZSBkZXBlbmRpbmcgb24gYGZpbGxgXG4gIGNlbGwgPSBmaWxsID8gY2VsbC5zZXQoJ3ZhbHVlJywgbnVtYmVyKSA6IGNlbGwuZGVsZXRlKCd2YWx1ZScpO1xuICBjb25zdCBpbmNyZW1lbnQgPSBmaWxsID8gMSA6IC0xO1xuICAvLyB1cGRhdGUgdGhlIGN1cnJlbnQgZ3JvdXAgY2hvaWNlc1xuICBjb25zdCByb3dQYXRoID0gWydjaG9pY2VzJywgJ3Jvd3MnLCB4LCBudW1iZXJdO1xuICBjb25zdCBjb2x1bW5QYXRoID0gWydjaG9pY2VzJywgJ2NvbHVtbnMnLCB5LCBudW1iZXJdO1xuICBjb25zdCBzcXVhcmVQYXRoID0gWydjaG9pY2VzJywgJ3NxdWFyZXMnLFxuICAgICgoTWF0aC5mbG9vcih4IC8gMykpICogMykgKyBNYXRoLmZsb29yKHkgLyAzKSwgbnVtYmVyXTtcbiAgcmV0dXJuIGJvYXJkLnNldEluKHJvd1BhdGgsIGJvYXJkLmdldEluKHJvd1BhdGgpICsgaW5jcmVtZW50KVxuICAgIC5zZXRJbihjb2x1bW5QYXRoLCBib2FyZC5nZXRJbihjb2x1bW5QYXRoKSArIGluY3JlbWVudClcbiAgICAuc2V0SW4oc3F1YXJlUGF0aCwgYm9hcmQuZ2V0SW4oc3F1YXJlUGF0aCkgKyBpbmNyZW1lbnQpXG4gICAgLnNldEluKFsncHV6emxlJywgeCwgeV0sIGNlbGwpO1xufVxuXG5mdW5jdGlvbiBnZXROdW1iZXJPZkdyb3Vwc0Fzc2lnbmVkRm9yTnVtYmVyKG51bWJlciwgZ3JvdXBzKSB7XG4gIHJldHVybiBncm91cHMucmVkdWNlKChhY2N1bXVsYXRvciwgcm93KSA9PlxuICAgIGFjY3VtdWxhdG9yICsgKHJvdy5nZXQobnVtYmVyKSA+IDAgPyAxIDogMCksIDApO1xufVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L25vLW11bHRpLWNvbXBcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEluZGV4IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgc3RhdGUgPSB7fTtcblxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICBpZiAoJ3NlcnZpY2VXb3JrZXInIGluIG5hdmlnYXRvcikge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICAgICBuYXZpZ2F0b3Iuc2VydmljZVdvcmtlclxuICAgICAgICAucmVnaXN0ZXIoJy9zZXJ2aWNlLXdvcmtlci5qcycpXG4gICAgICAgIC50aGVuKChyZWcpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnU2VydmljZVdvcmtlciBzY29wZTogJywgcmVnLnNjb3BlKTtcbiAgICAgICAgICBjb25zb2xlLmxvZygnc2VydmljZSB3b3JrZXIgcmVnaXN0cmF0aW9uIHN1Y2Nlc3NmdWwnKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ3NlcnZpY2Ugd29ya2VyIHJlZ2lzdHJhdGlvbiBmYWlsZWQnLCBlcnIubWVzc2FnZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgXG4gICAgZmV0Y2goJy9hcGkvc29ja2V0aW8nKS5maW5hbGx5KCgpID0+IHtcbiAgICAgIGNvbnN0IHNvY2tldCA9IGlvKClcblxuICAgICAgc29ja2V0Lm9uKCdjb25uZWN0JywgKCkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZygnY29ubmVjdCcpXG4gICAgICAgIHNvY2tldC5lbWl0KCdoZWxsbycpXG4gICAgICB9KVxuXG4gICAgICBzb2NrZXQub24oJ2hlbGxvJywgZGF0YSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdoZWxsbycsIGRhdGEpXG4gICAgICB9KVxuXG4gICAgICBzb2NrZXQub24oJ2EgdXNlciBjb25uZWN0ZWQnLCAoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdhIHVzZXIgY29ubmVjdGVkJylcbiAgICAgIH0pXG5cbiAgICAgIHNvY2tldC5vbignZGlzY29ubmVjdCcsICgpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ2Rpc2Nvbm5lY3QnKVxuICAgICAgfSlcbiAgICB9KVxuICAgXG4gIH1cbiAgZ2V0U2VsZWN0ZWRDZWxsKCkge1xuICAgIGNvbnN0IHsgYm9hcmQgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3Qgc2VsZWN0ZWQgPSBib2FyZC5nZXQoJ3NlbGVjdGVkJyk7XG4gICAgcmV0dXJuIHNlbGVjdGVkICYmIGJvYXJkLmdldCgncHV6emxlJykuZ2V0SW4oW3NlbGVjdGVkLngsIHNlbGVjdGVkLnldKTtcbiAgfVxuXG4gIC8vIGdldCB0aGUgbWluIGJldHdlZW4gaXRzIGNvbXBsZXRpb24gaW4gcm93cywgY29sdW1ucyBhbmQgc3F1YXJlcy5cbiAgZ2V0TnVtYmVyVmFsdWVDb3VudChudW1iZXIpIHtcbiAgICBjb25zdCByb3dzID0gdGhpcy5zdGF0ZS5ib2FyZC5nZXRJbihbJ2Nob2ljZXMnLCAncm93cyddKTtcbiAgICBjb25zdCBjb2x1bW5zID0gdGhpcy5zdGF0ZS5ib2FyZC5nZXRJbihbJ2Nob2ljZXMnLCAnY29sdW1ucyddKTtcbiAgICBjb25zdCBzcXVhcmVzID0gdGhpcy5zdGF0ZS5ib2FyZC5nZXRJbihbJ2Nob2ljZXMnLCAnc3F1YXJlcyddKTtcbiAgICByZXR1cm4gTWF0aC5taW4oXG4gICAgICBnZXROdW1iZXJPZkdyb3Vwc0Fzc2lnbmVkRm9yTnVtYmVyKG51bWJlciwgc3F1YXJlcyksXG4gICAgICBNYXRoLm1pbihcbiAgICAgICAgZ2V0TnVtYmVyT2ZHcm91cHNBc3NpZ25lZEZvck51bWJlcihudW1iZXIsIHJvd3MpLFxuICAgICAgICBnZXROdW1iZXJPZkdyb3Vwc0Fzc2lnbmVkRm9yTnVtYmVyKG51bWJlciwgY29sdW1ucyksXG4gICAgICApLFxuICAgICk7XG4gIH1cblxuICBnZW5lcmF0ZUdhbWUgPSAoZmluYWxDb3VudCA9IDIwKSA9PiB7XG4gICAgLy8gZ2V0IGEgZmlsbGVkIHB1enpsZSBnZW5lcmF0ZWRcbiAgICBjb25zdCBzb2x1dGlvbiA9IG1ha2VQdXp6bGUoKTtcbiAgICAvLyBwbHVjayB2YWx1ZXMgZnJvbSBjZWxscyB0byBjcmVhdGUgdGhlIGdhbWVcbiAgICBjb25zdCB7IHB1enpsZSB9ID0gcGx1Y2soc29sdXRpb24sIGZpbmFsQ291bnQpO1xuICAgIC8vIGluaXRpYWxpemUgdGhlIGJvYXJkIHdpdGggY2hvaWNlIGNvdW50c1xuICAgIGNvbnN0IGJvYXJkID0gbWFrZUJvYXJkKHsgcHV6emxlIH0pO1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgYm9hcmQsIGhpc3Rvcnk6IExpc3Qub2YoYm9hcmQpLCBoaXN0b3J5T2ZmU2V0OiAwLCBzb2x1dGlvbixcbiAgICB9KTtcbiAgfVxuXG4gIGFkZE51bWJlckFzTm90ZSA9IChudW1iZXIpID0+IHtcbiAgICBsZXQgeyBib2FyZCB9ID0gdGhpcy5zdGF0ZTtcbiAgICBsZXQgc2VsZWN0ZWRDZWxsID0gdGhpcy5nZXRTZWxlY3RlZENlbGwoKTtcbiAgICBpZiAoIXNlbGVjdGVkQ2VsbCkgcmV0dXJuO1xuICAgIGNvbnN0IHByZWZpbGxlZCA9IHNlbGVjdGVkQ2VsbC5nZXQoJ3ByZWZpbGxlZCcpO1xuICAgIGlmIChwcmVmaWxsZWQpIHJldHVybjtcbiAgICBjb25zdCB7IHgsIHkgfSA9IGJvYXJkLmdldCgnc2VsZWN0ZWQnKTtcbiAgICBjb25zdCBjdXJyZW50VmFsdWUgPSBzZWxlY3RlZENlbGwuZ2V0KCd2YWx1ZScpO1xuICAgIGlmIChjdXJyZW50VmFsdWUpIHtcbiAgICAgIGJvYXJkID0gdXBkYXRlQm9hcmRXaXRoTnVtYmVyKHtcbiAgICAgICAgeCwgeSwgbnVtYmVyOiBjdXJyZW50VmFsdWUsIGZpbGw6IGZhbHNlLCBib2FyZDogdGhpcy5zdGF0ZS5ib2FyZCxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBsZXQgbm90ZXMgPSBzZWxlY3RlZENlbGwuZ2V0KCdub3RlcycpIHx8IFNldCgpO1xuICAgIGlmIChub3Rlcy5oYXMobnVtYmVyKSkge1xuICAgICAgbm90ZXMgPSBub3Rlcy5kZWxldGUobnVtYmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm90ZXMgPSBub3Rlcy5hZGQobnVtYmVyKTtcbiAgICB9XG4gICAgc2VsZWN0ZWRDZWxsID0gc2VsZWN0ZWRDZWxsLnNldCgnbm90ZXMnLCBub3Rlcyk7XG4gICAgc2VsZWN0ZWRDZWxsID0gc2VsZWN0ZWRDZWxsLmRlbGV0ZSgndmFsdWUnKTtcbiAgICBib2FyZCA9IGJvYXJkLnNldEluKFsncHV6emxlJywgeCwgeV0sIHNlbGVjdGVkQ2VsbCk7XG4gICAgdGhpcy51cGRhdGVCb2FyZChib2FyZCk7XG4gIH07XG5cbiAgdXBkYXRlQm9hcmQgPSAobmV3Qm9hcmQpID0+IHtcbiAgICBsZXQgeyBoaXN0b3J5IH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IHsgaGlzdG9yeU9mZlNldCB9ID0gdGhpcy5zdGF0ZTtcbiAgICAvLyBhbnl0aGluZyBiZWZvcmUgY3VycmVudCBzdGVwIGlzIHN0aWxsIGluIGhpc3RvcnlcbiAgICBoaXN0b3J5ID0gaGlzdG9yeS5zbGljZSgwLCBoaXN0b3J5T2ZmU2V0ICsgMSk7XG4gICAgLy8gYWRkIGl0c2VsZiBvbnRvIHRoZSBoaXN0b3J5XG4gICAgaGlzdG9yeSA9IGhpc3RvcnkucHVzaChuZXdCb2FyZCk7XG4gICAgLy8gdXBkYXRlIHRoZSBnYW1lXG4gICAgdGhpcy5zZXRTdGF0ZSh7IGJvYXJkOiBuZXdCb2FyZCwgaGlzdG9yeSwgaGlzdG9yeU9mZlNldDogaGlzdG9yeS5zaXplIC0gMSB9KTtcbiAgfTtcblxuICBjYW5VbmRvID0gKCkgPT4gdGhpcy5zdGF0ZS5oaXN0b3J5T2ZmU2V0ID4gMFxuXG4gIHJlZG8gPSAoKSA9PiB7XG4gICAgY29uc3QgeyBoaXN0b3J5IH0gPSB0aGlzLnN0YXRlO1xuICAgIGxldCB7IGhpc3RvcnlPZmZTZXQgfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKGhpc3Rvcnkuc2l6ZSkge1xuICAgICAgaGlzdG9yeU9mZlNldCA9IE1hdGgubWluKGhpc3Rvcnkuc2l6ZSAtIDEsIGhpc3RvcnlPZmZTZXQgKyAxKTtcbiAgICAgIGNvbnN0IGJvYXJkID0gaGlzdG9yeS5nZXQoaGlzdG9yeU9mZlNldCk7XG4gICAgICB0aGlzLnNldFN0YXRlKHsgYm9hcmQsIGhpc3RvcnlPZmZTZXQgfSk7XG4gICAgfVxuICB9O1xuXG4gIHVuZG8gPSAoKSA9PiB7XG4gICAgY29uc3QgeyBoaXN0b3J5IH0gPSB0aGlzLnN0YXRlO1xuICAgIGxldCB7IGhpc3RvcnlPZmZTZXQsIGJvYXJkIH0gPSB0aGlzLnN0YXRlO1xuICAgIGlmIChoaXN0b3J5LnNpemUpIHtcbiAgICAgIGhpc3RvcnlPZmZTZXQgPSBNYXRoLm1heCgwLCBoaXN0b3J5T2ZmU2V0IC0gMSk7XG4gICAgICBib2FyZCA9IGhpc3RvcnkuZ2V0KGhpc3RvcnlPZmZTZXQpO1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IGJvYXJkLCBoaXN0b3J5T2ZmU2V0LCBoaXN0b3J5IH0pO1xuICAgIH1cbiAgfTtcblxuICBlcmFzZVNlbGVjdGVkID0gKCkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGVkQ2VsbCA9IHRoaXMuZ2V0U2VsZWN0ZWRDZWxsKCk7XG4gICAgaWYgKCFzZWxlY3RlZENlbGwpIHJldHVybjtcbiAgICB0aGlzLmZpbGxOdW1iZXIoZmFsc2UpO1xuICB9XG5cbiAgZmlsbFNlbGVjdGVkV2l0aFNvbHV0aW9uID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgYm9hcmQsIHNvbHV0aW9uIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IHNlbGVjdGVkQ2VsbCA9IHRoaXMuZ2V0U2VsZWN0ZWRDZWxsKCk7XG4gICAgaWYgKCFzZWxlY3RlZENlbGwpIHJldHVybjtcbiAgICBjb25zdCB7IHgsIHkgfSA9IGJvYXJkLmdldCgnc2VsZWN0ZWQnKTtcbiAgICB0aGlzLmZpbGxOdW1iZXIoc29sdXRpb25beF1beV0pO1xuICB9XG5cblxuICAvLyBmaWxsIGN1cnJlbnRseSBzZWxlY3RlZCBjZWxsIHdpdGggbnVtYmVyXG4gIGZpbGxOdW1iZXIgPSAobnVtYmVyKSA9PiB7XG4gICAgbGV0IHsgYm9hcmQgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3Qgc2VsZWN0ZWRDZWxsID0gdGhpcy5nZXRTZWxlY3RlZENlbGwoKTtcbiAgICAvLyBuby1vcCBpZiBub3RoaW5nIGlzIHNlbGVjdGVkXG4gICAgaWYgKCFzZWxlY3RlZENlbGwpIHJldHVybjtcbiAgICBjb25zdCBwcmVmaWxsZWQgPSBzZWxlY3RlZENlbGwuZ2V0KCdwcmVmaWxsZWQnKTtcbiAgICAvLyBuby1vcCBpZiBpdCBpcyByZWZpbGxlZFxuICAgIGlmIChwcmVmaWxsZWQpIHJldHVybjtcbiAgICBjb25zdCB7IHgsIHkgfSA9IGJvYXJkLmdldCgnc2VsZWN0ZWQnKTtcbiAgICBjb25zdCBjdXJyZW50VmFsdWUgPSBzZWxlY3RlZENlbGwuZ2V0KCd2YWx1ZScpO1xuICAgIC8vIHJlbW92ZSB0aGUgY3VycmVudCB2YWx1ZSBhbmQgdXBkYXRlIHRoZSBnYW1lIHN0YXRlXG4gICAgaWYgKGN1cnJlbnRWYWx1ZSkge1xuICAgICAgYm9hcmQgPSB1cGRhdGVCb2FyZFdpdGhOdW1iZXIoe1xuICAgICAgICB4LCB5LCBudW1iZXI6IGN1cnJlbnRWYWx1ZSwgZmlsbDogZmFsc2UsIGJvYXJkOiB0aGlzLnN0YXRlLmJvYXJkLFxuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIHVwZGF0ZSB0byBuZXcgbnVtYmVyIGlmIGFueVxuICAgIGNvbnN0IHNldE51bWJlciA9IGN1cnJlbnRWYWx1ZSAhPT0gbnVtYmVyICYmIG51bWJlcjtcbiAgICBpZiAoc2V0TnVtYmVyKSB7XG4gICAgICBib2FyZCA9IHVwZGF0ZUJvYXJkV2l0aE51bWJlcih7XG4gICAgICAgIHgsIHksIG51bWJlciwgZmlsbDogdHJ1ZSwgYm9hcmQsXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVCb2FyZChib2FyZCk7XG4gIH07XG5cbiAgc2VsZWN0Q2VsbCA9ICh4LCB5KSA9PiB7XG4gICAgbGV0IHsgYm9hcmQgfSA9IHRoaXMuc3RhdGU7XG4gICAgYm9hcmQgPSBib2FyZC5zZXQoJ3NlbGVjdGVkJywgeyB4LCB5IH0pO1xuICAgIHRoaXMuc2V0U3RhdGUoeyBib2FyZCB9KTtcbiAgfTtcblxuICBpc0NvbmZsaWN0KGksIGopIHtcbiAgICBjb25zdCB7IHZhbHVlIH0gPSB0aGlzLnN0YXRlLmJvYXJkLmdldEluKFsncHV6emxlJywgaSwgal0pLnRvSlNPTigpO1xuICAgIGlmICghdmFsdWUpIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCByb3dDb25mbGljdCA9XG4gICAgICB0aGlzLnN0YXRlLmJvYXJkLmdldEluKFsnY2hvaWNlcycsICdyb3dzJywgaSwgdmFsdWVdKSA+IDE7XG4gICAgY29uc3QgY29sdW1uQ29uZmxpY3QgPVxuICAgICAgdGhpcy5zdGF0ZS5ib2FyZC5nZXRJbihbJ2Nob2ljZXMnLCAnY29sdW1ucycsIGosIHZhbHVlXSkgPiAxO1xuICAgIGNvbnN0IHNxdWFyZUNvbmZsaWN0ID1cbiAgICAgIHRoaXMuc3RhdGUuYm9hcmQuZ2V0SW4oWydjaG9pY2VzJywgJ3NxdWFyZXMnLFxuICAgICAgICAoKE1hdGguZmxvb3IoaSAvIDMpKSAqIDMpICsgTWF0aC5mbG9vcihqIC8gMyksIHZhbHVlXSkgPiAxO1xuICAgIHJldHVybiByb3dDb25mbGljdCB8fCBjb2x1bW5Db25mbGljdCB8fCBzcXVhcmVDb25mbGljdDtcbiAgfVxuXG4gIHJlbmRlckNlbGwoY2VsbCwgeCwgeSkge1xuICAgIGNvbnN0IHsgYm9hcmQgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3Qgc2VsZWN0ZWQgPSB0aGlzLmdldFNlbGVjdGVkQ2VsbCgpO1xuICAgIGNvbnN0IHsgdmFsdWUsIHByZWZpbGxlZCwgbm90ZXMgfSA9IGNlbGwudG9KU09OKCk7XG4gICAgY29uc3QgY29uZmxpY3QgPSB0aGlzLmlzQ29uZmxpY3QoeCwgeSk7XG4gICAgY29uc3QgcGVlciA9IGFyZUNvb3JkaW5hdGVQZWVycyh7IHgsIHkgfSwgYm9hcmQuZ2V0KCdzZWxlY3RlZCcpKTtcbiAgICBjb25zdCBzYW1lVmFsdWUgPSAhIShzZWxlY3RlZCAmJiBzZWxlY3RlZC5nZXQoJ3ZhbHVlJylcbiAgICAgICYmIHZhbHVlID09PSBzZWxlY3RlZC5nZXQoJ3ZhbHVlJykpO1xuXG4gICAgY29uc3QgaXNTZWxlY3RlZCA9IGNlbGwgPT09IHNlbGVjdGVkO1xuICAgIHJldHVybiAoPENlbGxcbiAgICAgIHByZWZpbGxlZD17cHJlZmlsbGVkfVxuICAgICAgbm90ZXM9e25vdGVzfVxuICAgICAgc2FtZVZhbHVlPXtzYW1lVmFsdWV9XG4gICAgICBpc1NlbGVjdGVkPXtpc1NlbGVjdGVkfVxuICAgICAgaXNQZWVyPXtwZWVyfVxuICAgICAgdmFsdWU9e3ZhbHVlfVxuICAgICAgb25DbGljaz17KCkgPT4geyB0aGlzLnNlbGVjdENlbGwoeCwgeSk7IH19XG4gICAgICBrZXk9e3l9XG4gICAgICB4PXt4fVxuICAgICAgeT17eX1cbiAgICAgIGNvbmZsaWN0PXtjb25mbGljdH1cbiAgICAvPik7XG4gIH1cblxuICByZW5kZXJOdW1iZXJDb250cm9sKCkge1xuICAgIGNvbnN0IHNlbGVjdGVkQ2VsbCA9IHRoaXMuZ2V0U2VsZWN0ZWRDZWxsKCk7XG4gICAgY29uc3QgcHJlZmlsbGVkID0gc2VsZWN0ZWRDZWxsICYmIHNlbGVjdGVkQ2VsbC5nZXQoJ3ByZWZpbGxlZCcpO1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRyb2xcIj5cbiAgICAgICAge3JhbmdlKDkpLm1hcCgoaSkgPT4ge1xuICAgICAgICAgIGNvbnN0IG51bWJlciA9IGkgKyAxO1xuICAgICAgICAgIC8vIGhhbmRsZXMgYmluZGluZyBzaW5nbGUgY2xpY2sgYW5kIGRvdWJsZSBjbGljayBjYWxsYmFja3NcbiAgICAgICAgICBjb25zdCBjbGlja0hhbmRsZSA9IGdldENsaWNrSGFuZGxlcihcbiAgICAgICAgICAgICgpID0+IHsgdGhpcy5maWxsTnVtYmVyKG51bWJlcik7IH0sXG4gICAgICAgICAgICAoKSA9PiB7IHRoaXMuYWRkTnVtYmVyQXNOb3RlKG51bWJlcik7IH0sXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPE51bWJlckNvbnRyb2xcbiAgICAgICAgICAgICAga2V5PXtudW1iZXJ9XG4gICAgICAgICAgICAgIG51bWJlcj17bnVtYmVyfVxuICAgICAgICAgICAgICBvbkNsaWNrPXshcHJlZmlsbGVkID8gY2xpY2tIYW5kbGUgOiB1bmRlZmluZWR9XG4gICAgICAgICAgICAgIGNvbXBsZXRpb25QZXJjZW50YWdlPXt0aGlzLmdldE51bWJlclZhbHVlQ291bnQobnVtYmVyKSAvIDl9XG4gICAgICAgICAgICAvPik7XG4gICAgICAgIH0pfVxuICAgICAgICA8c3R5bGUganN4PntDb250cm9sU3R5bGV9PC9zdHlsZT5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cblxuICByZW5kZXJBY3Rpb25zKCkge1xuICAgIGNvbnN0IHsgaGlzdG9yeSB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBzZWxlY3RlZENlbGwgPSB0aGlzLmdldFNlbGVjdGVkQ2VsbCgpO1xuICAgIGNvbnN0IHByZWZpbGxlZCA9IHNlbGVjdGVkQ2VsbCAmJiBzZWxlY3RlZENlbGwuZ2V0KCdwcmVmaWxsZWQnKTtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJhY3Rpb25zXCI+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWN0aW9uXCIgb25DbGljaz17aGlzdG9yeS5zaXplID8gdGhpcy51bmRvIDogbnVsbH0+XG4gICAgICAgICAgPFJlbG9hZEljb24gLz5VbmRvXG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImFjdGlvbiByZWRvXCIgb25DbGljaz17aGlzdG9yeS5zaXplID8gdGhpcy5yZWRvIDogbnVsbH0+XG4gICAgICAgICAgPFJlbG9hZEljb24gLz5SZWRvXG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImFjdGlvblwiIG9uQ2xpY2s9eyFwcmVmaWxsZWQgPyB0aGlzLmVyYXNlU2VsZWN0ZWQgOiBudWxsfT5cbiAgICAgICAgICA8UmVtb3ZlSWNvbiAvPkVyYXNlXG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2XG4gICAgICAgICAgY2xhc3NOYW1lPVwiYWN0aW9uXCJcbiAgICAgICAgICBvbkNsaWNrPXshcHJlZmlsbGVkID9cbiAgICAgICAgICB0aGlzLmZpbGxTZWxlY3RlZFdpdGhTb2x1dGlvbiA6IG51bGx9XG4gICAgICAgID5cbiAgICAgICAgICA8TG91cGVJY29uIC8+SGludFxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPHN0eWxlIGpzeD57QWN0aW9uc1N0eWxlfTwvc3R5bGU+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG5cbiAgcmVuZGVyUHV6emxlKCkge1xuICAgIGNvbnN0IHsgYm9hcmQgfSA9IHRoaXMuc3RhdGU7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwicHV6emxlXCI+XG4gICAgICAgIHtib2FyZC5nZXQoJ3B1enpsZScpLm1hcCgocm93LCBpKSA9PiAoXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L25vLWFycmF5LWluZGV4LWtleVxuICAgICAgICAgIDxkaXYga2V5PXtpfSBjbGFzc05hbWU9XCJyb3dcIj5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcm93Lm1hcCgoY2VsbCwgaikgPT4gdGhpcy5yZW5kZXJDZWxsKGNlbGwsIGksIGopKS50b0FycmF5KClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKSkudG9BcnJheSgpfVxuICAgICAgICA8c3R5bGUganN4PntQdXp6bGVTdHlsZX08L3N0eWxlPlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxuXG4gIHJlbmRlckNvbnRyb2xzKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRyb2xzXCI+XG4gICAgICAgIHt0aGlzLnJlbmRlck51bWJlckNvbnRyb2woKX1cbiAgICAgICAge3RoaXMucmVuZGVyQWN0aW9ucygpfVxuICAgICAgICB7IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG4gICAgICAgIDxzdHlsZSBqc3g+e2BcbiAgICAgICAgICAgIC5jb250cm9scyB7XG4gICAgICAgICAgICAgICAgbWFyZ2luLXRvcDogLjNlbTtcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICAgICAgICAgIGZsZXgtd3JhcDogd3JhcDtcbiAgICAgICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiAuNWVtIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIGB9XG4gICAgICAgIDwvc3R5bGU+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG5cbiAgcmVuZGVyR2VuZXJhdGlvblVJKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8R2VuZXJhdGlvblVJIGdlbmVyYXRlR2FtZT17dGhpcy5nZW5lcmF0ZUdhbWV9IC8+XG4gICAgKTtcbiAgfVxuXG4gIHJlbmRlckhlYWRlcigpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJoZWFkZXJcIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJuZXctZ2FtZVwiIG9uQ2xpY2s9eygpID0+IHRoaXMuc2V0U3RhdGUoeyBib2FyZDogZmFsc2UgfSl9PlxuICAgICAgICAgIDxSZXR1cm5JY29uIC8+XG4gICAgICAgICAgPGRpdj5OZXcgR2FtZTwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPFRpcCAvPlxuICAgICAgICB7IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG4gICAgICAgIDxzdHlsZSBqc3g+e2BcbiAgICAgICAgICAgIC5oZWFkZXIge1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgICAgICAgICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICAgICAgICAgICAgICAgIG1heC13aWR0aDogNTAwcHg7XG4gICAgICAgICAgICAgICAgcGFkZGluZzogMCAwLjVlbTtcbiAgICAgICAgICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLm5ldy1nYW1lIHtcbiAgICAgICAgICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICAgICAgICAgICAgbWFyZ2luLXRvcDogLjJlbTtcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiBpbmxpbmUtZmxleDtcbiAgICAgICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICAgICAgICAgIHBhZGRpbmc6IC4yZW0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC5uZXctZ2FtZSA6Z2xvYmFsKHN2Zykge1xuICAgICAgICAgICAgICAgIGhlaWdodDogMWVtO1xuICAgICAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IC4zZW07XG4gICAgICAgICAgICB9XG4gICAgICAgIGB9XG4gICAgICAgIDwvc3R5bGU+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgYm9hcmQgfSA9IHRoaXMuc3RhdGU7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYm9keVwiPlxuICAgICAgICA8TmV4dEhlYWQ+XG4gICAgICAgICAgPHRpdGxlPlN1ZG9rdSBFdm9sdmVkPC90aXRsZT5cbiAgICAgICAgICA8bWV0YSBuYW1lPVwidmlld3BvcnRcIiBjb250ZW50PVwiaW5pdGlhbC1zY2FsZT0xLjAsIHdpZHRoPWRldmljZS13aWR0aFwiIC8+XG4gICAgICAgICAgPG1ldGEgbmFtZT1cImRlc2NyaXB0aW9uXCIgY29udGVudD17RGVzY3JpcHRpb259IC8+XG4gICAgICAgICAgPGxpbmsgaHJlZj1cImh0dHBzOi8vZm9udHMuZ29vZ2xlYXBpcy5jb20vY3NzP2ZhbWlseT1TcGVjaWFsK0VsaXRlXCIgcmVsPVwic3R5bGVzaGVldFwiIC8+XG4gICAgICAgICAgPG1ldGEgcHJvcGVydHk9XCJvZzp1cmxcIiBjb250ZW50PVwiaHR0cHM6Ly9zdWRva3Uuc2l0aWFubGl1LmNvbS9cIiAvPlxuICAgICAgICAgIDxtZXRhIHByb3BlcnR5PVwib2c6dGl0bGVcIiBjb250ZW50PVwiU3Vkb2t1IEV2b2x2ZWRcIiAvPlxuICAgICAgICAgIDxtZXRhIHByb3BlcnR5PVwib2c6dHlwZVwiIGNvbnRlbnQ9XCJ3ZWJzaXRlXCIgLz5cbiAgICAgICAgICA8bWV0YSBwcm9wZXJ0eT1cIm9nOmRlc2NyaXB0aW9uXCIgY29udGVudD17RGVzY3JpcHRpb259IC8+XG4gICAgICAgICAgPG1ldGEgcHJvcGVydHk9XCJvZzppbWFnZVwiIGNvbnRlbnQ9XCJodHRwczovL3N1ZG9rdS5zaXRpYW5saXUuY29tL3N0YXRpYy9vZy1pbWFnZS5wbmdcIiAvPlxuICAgICAgICA8L05leHRIZWFkPlxuICAgICAgICB7IWJvYXJkICYmIHRoaXMucmVuZGVyR2VuZXJhdGlvblVJKCl9XG4gICAgICAgIHtib2FyZCAmJiB0aGlzLnJlbmRlckhlYWRlcigpfVxuICAgICAgICB7Ym9hcmQgJiYgdGhpcy5yZW5kZXJQdXp6bGUoKX1cbiAgICAgICAge2JvYXJkICYmIHRoaXMucmVuZGVyQ29udHJvbHMoKX1cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJyb290ZXJcIj5cbiAgICAgICAgICBNYWRlIHdpdGggPHNwYW4+4p2k77iPPC9zcGFuPu+4jyBCeSA8YSBocmVmPVwiaHR0cHM6Ly93d3cuc2l0aWFubGl1LmNvbS9cIj5TaXRpYW4gTGl1PC9hPiB8IDxhIGhyZWY9XCJodHRwczovL21lZGl1bS5jb20vQHNpdGlhbmxpdV81NzY4MC9idWlsZGluZy1hLXN1ZG9rdS1nYW1lLWluLXJlYWN0LWNhNjYzOTE1NzEyXCI+QmxvZyBQb3N0PC9hPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgeyAvKiBsYW5ndWFnZT1DU1MgKi8gfVxuICAgICAgICA8c3R5bGUganN4PntgXG4gICAgICAgICAgICA6Z2xvYmFsKGJvZHkpLCAuYm9keSB7XG4gICAgICAgICAgICAgICAgZm9udC1mYW1pbHk6ICdTcGVjaWFsIEVsaXRlJywgY3Vyc2l2ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC5ib2R5IHtcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICAgICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgICAgICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDEwMHZoO1xuICAgICAgICAgICAgICAgIHdpZHRoOiAxMDB2dztcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBAbWVkaWEgKG1pbi13aWR0aDogODAwcHgpIGFuZCAobWluLWhlaWdodDogOTMwcHgpe1xuICAgICAgICAgICAgICAgIDpnbG9iYWwoLmhlYWRlciwgLnB1enpsZSwgLmNvbnRyb2xzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvbnQtc2l6ZTogMS41ZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQG1lZGlhIChtYXgtd2lkdGg6IDgwMHB4KSBhbmQgKG1pbi13aWR0aDogNjAwcHgpe1xuICAgICAgICAgICAgICAgIDpnbG9iYWwoLmhlYWRlciwgLnB1enpsZSwgLmNvbnRyb2xzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvbnQtc2l6ZTogMS4yZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQG1lZGlhIChtYXgtaGVpZ2h0OiA5MzBweCkgYW5kIChtaW4taGVpZ2h0OiA4MDBweCkgYW5kIChtaW4td2lkdGg6IDYwMHB4KXtcbiAgICAgICAgICAgICAgICA6Z2xvYmFsKC5oZWFkZXIsIC5wdXp6bGUsIC5jb250cm9scykge1xuICAgICAgICAgICAgICAgICAgICBmb250LXNpemU6IDEuMmVtO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEBtZWRpYSAobWF4LWhlaWdodDogODAwcHgpIGFuZCAobWluLWhlaWdodDogNjAwcHgpIGFuZCAobWluLXdpZHRoOiAzNzBweCl7XG4gICAgICAgICAgICAgICAgOmdsb2JhbCguaGVhZGVyLCAucHV6emxlLCAuY29udHJvbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9udC1zaXplOiAxZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQG1lZGlhIChtYXgtd2lkdGg6IDM3MHB4KXtcbiAgICAgICAgICAgICAgICA6Z2xvYmFsKC5oZWFkZXIsIC5wdXp6bGUsIC5jb250cm9scykge1xuICAgICAgICAgICAgICAgICAgICBmb250LXNpemU6IC44ZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQG1lZGlhIChtYXgtaGVpZ2h0OiA2MDBweCl7XG4gICAgICAgICAgICAgICAgOmdsb2JhbCguaGVhZGVyLCAucHV6emxlLCAuY29udHJvbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9udC1zaXplOiAuOGVtO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDpnbG9iYWwoYm9keSkge1xuICAgICAgICAgICAgICAgIG1hcmdpbjogMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC5yb290ZXIge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICAgICAgICAgICAgICBib3R0b206IDA7XG4gICAgICAgICAgICAgICAgZm9udC1zaXplOiAuOGVtO1xuICAgICAgICAgICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICAgICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgYH1cbiAgICAgICAgPC9zdHlsZT5cbiAgICAgICAgPHN0eWxlIGpzeCBnbG9iYWw+e1JhbmdlU3R5bGV9PC9zdHlsZT5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cbn1cbiJdfQ== */\n/*@ sourceURL=pages/index.js */');

// eslint-disable-next-line no-lone-blocks
NumberControlStyle.__hash = '901429852';
NumberControlStyle.__scoped = '.number.jsx-2289524573{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;position:relative;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;font-size:2em;margin:.1em;width:1.5em;height:1.5em;color:' + ControlNumberColor + ';box-shadow:0 1px 2px rgba(0,0,0,0.16),0 1px 2px rgba(0,0,0,0.23);border-radius:50%;}.number.jsx-2289524573>div.jsx-2289524573{margin-top:.3em;}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhZ2VzL2luZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQTZHOEIsQUFHa0IsQUFhRyxnQkFDcEIsMERBYnNCLGtCQUNLLG1HQUNKLDZGQUNMLGNBQ0YsWUFDQSxZQUNDLGFBQ3NCLG1DQUMrQixpRUFDaEQsa0JBQ3RCIiwiZmlsZSI6InBhZ2VzL2luZGV4LmpzIiwic291cmNlUm9vdCI6Ii9Vc2Vycy9saWNoZW5tYS9Qcm9qZWN0cy9TdUR1b2t1L1N1RHVva3UiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBqc3gtYTExeS9hY2Nlc3NpYmxlLWVtb2ppICovXG5pbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50LCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBTZXQsIExpc3QsIGZyb21KUyB9IGZyb20gJ2ltbXV0YWJsZSc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IE5leHRIZWFkIGZyb20gJ25leHQvaGVhZCc7XG5pbXBvcnQgQ29sb3IgZnJvbSAnY29sb3InO1xuaW1wb3J0IElucHV0UmFuZ2UgZnJvbSAncmVhY3QtaW5wdXQtcmFuZ2UnO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLWV4dHJhbmVvdXMtZGVwZW5kZW5jaWVzXG5pbXBvcnQgY3NzIGZyb20gJ3N0eWxlZC1qc3gvY3NzJztcblxuaW1wb3J0IFJhbmdlU3R5bGUgZnJvbSAnLi4vaW5wdXQtcmFuZ2Utc3R5bGUnO1xuaW1wb3J0IExvdXBlSWNvbiBmcm9tICcuLi9zdmcvbG91cGUuc3ZnJztcbmltcG9ydCBSZW1vdmVJY29uIGZyb20gJy4uL3N2Zy9yZW1vdmUuc3ZnJztcbmltcG9ydCBSZWxvYWRJY29uIGZyb20gJy4uL3N2Zy9yZWxvYWQuc3ZnJztcbmltcG9ydCBSZXR1cm5JY29uIGZyb20gJy4uL3N2Zy9yZXR1cm4uc3ZnJztcblxuaW1wb3J0IHsgbWFrZVB1enpsZSwgcGx1Y2ssIGlzUGVlciBhcyBhcmVDb29yZGluYXRlUGVlcnMsIHJhbmdlIH0gZnJvbSAnLi4vc3Vkb2t1JztcbmltcG9ydCB7IGJhY2tHcm91bmRCbHVlIH0gZnJvbSAnLi4vY29sb3JzJztcbmltcG9ydCBUaXAgZnJvbSAnLi4vY29tcG9uZW50cy90b29sLXRpcCc7XG5cbmltcG9ydCBpbyBmcm9tICdzb2NrZXQuaW8tY2xpZW50J1xuXG5jb25zdCBEZXNjcmlwdGlvbiA9ICdEaXNjb3ZlciB0aGUgbmV4dCBldm9sdXRpb24gb2YgU3Vkb2t1IHdpdGggYW1hemluZyBncmFwaGljcywgYW5pbWF0aW9ucywgYW5kIHVzZXItZnJpZW5kbHkgZmVhdHVyZXMuIEVuam95IGEgU3Vkb2t1IGV4cGVyaWVuY2UgbGlrZSB5b3UgbmV2ZXIgaGF2ZSBiZWZvcmUgd2l0aCBjdXN0b21pemFibGUgZ2FtZSBnZW5lcmF0aW9uLCBjZWxsIGhpZ2hsaWdodGluZywgaW50dWl0aXZlIGNvbnRyb2xzIGFuZCBtb3JlISc7XG5jb25zdCBjZWxsV2lkdGggPSAyLjU7XG5cbmNvbnN0IExpZ2h0Qmx1ZTEwMCA9ICcjQjNFNUZDJztcbmNvbnN0IExpZ2h0Qmx1ZTIwMCA9ICcjODFENEZBJztcbmNvbnN0IExpZ2h0Qmx1ZTMwMCA9ICcjNEZDM0Y3JztcbmNvbnN0IEluZGlnbzcwMCA9ICcjMzAzRjlGJztcbmNvbnN0IERlZXBPcmFuZ2UyMDAgPSAnI0ZGQUI5MSc7XG5jb25zdCBEZWVwT3JhbmdlNjAwID0gJyNGNDUxMUUnO1xuY29uc3QgQ29udHJvbE51bWJlckNvbG9yID0gSW5kaWdvNzAwO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbG9uZS1ibG9ja3NcbnsgLyogbGFuZ3VhZ2U9Q1NTICovIH1cbmNvbnN0IENlbGxTdHlsZSA9IGNzc2Bcbi5jZWxsIHtcbiAgICBoZWlnaHQ6ICR7Y2VsbFdpZHRofWVtO1xuICAgIHdpZHRoOiAke2NlbGxXaWR0aH1lbTtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtd3JhcDogd3JhcDtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgIGZvbnQtc2l6ZTogMS4xZW07XG4gICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgdHJhbnNpdGlvbjogYmFja2dyb3VuZC1jb2xvciAuM3MgZWFzZS1pbi1vdXQ7XG59XG4uY2VsbDpudGgtY2hpbGQoM24rMyk6bm90KDpsYXN0LWNoaWxkKSB7XG4gICAgYm9yZGVyLXJpZ2h0OiAycHggc29saWQgYmxhY2s7XG59XG4uY2VsbDpub3QoOmxhc3QtY2hpbGQpIHtcbiAgICBib3JkZXItcmlnaHQ6IDFweCBzb2xpZCBibGFjaztcbn1cbi5ub3RlLW51bWJlciB7XG4gICAgZm9udC1zaXplOiAuNmVtO1xuICAgIHdpZHRoOiAzMyU7XG4gICAgaGVpZ2h0OiAzMyU7XG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG59XG5gO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbG9uZS1ibG9ja3NcbnsgLyogbGFuZ3VhZ2U9Q1NTICovIH1cbmNvbnN0IEFjdGlvbnNTdHlsZSA9IGNzc2Bcbi5hY3Rpb25zIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIG1heC13aWR0aDogNDAwcHg7XG4gICAgbWFyZ2luLXRvcDogLjVlbTtcbiAgICBwYWRkaW5nOiAwIC42ZW07XG59XG4uYWN0aW9uIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbn1cbi5hY3Rpb24gOmdsb2JhbChzdmcpIHtcbiAgICB3aWR0aDogMi41ZW07XG4gICAgbWFyZ2luLWJvdHRvbTogLjJlbTtcbn1cbi5yZWRvIDpnbG9iYWwoc3ZnKSB7XG4gICAgdHJhbnNmb3JtOiBzY2FsZVgoLTEpO1xufVxuYDtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxvbmUtYmxvY2tzXG57IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG5jb25zdCBDb250cm9sU3R5bGUgPSBjc3NgXG4uY29udHJvbCB7XG4gICAgcGFkZGluZzogMCAyZW07XG4gICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIGRpc3BsYXk6IGlubGluZS1mbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgZmxleC13cmFwOiB3cmFwO1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgIGZvbnQtZmFtaWx5OiAnU3BlY2lhbCBFbGl0ZScsIGN1cnNpdmU7XG4gICAgdHJhbnNpdGlvbjogZmlsdGVyIC41cyBlYXNlLWluLW91dDtcbiAgICB3aWR0aDogMTAwJTtcbn1cbmA7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sb25lLWJsb2Nrc1xueyAvKiBsYW5ndWFnZT1DU1MgKi8gfVxuY29uc3QgTnVtYmVyQ29udHJvbFN0eWxlID0gY3NzYFxuLm51bWJlciB7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBmb250LXNpemU6IDJlbTtcbiAgICBtYXJnaW46IC4xZW07XG4gICAgd2lkdGg6IDEuNWVtO1xuICAgIGhlaWdodDogMS41ZW07XG4gICAgY29sb3I6ICR7Q29udHJvbE51bWJlckNvbG9yfTtcbiAgICBib3gtc2hhZG93OiAwIDFweCAycHggcmdiYSgwLDAsMCwwLjE2KSwgMCAxcHggMnB4IHJnYmEoMCwwLDAsMC4yMyk7XG4gICAgYm9yZGVyLXJhZGl1czogNTAlO1xufVxuLm51bWJlciA+IGRpdiB7XG4gICAgbWFyZ2luLXRvcDogLjNlbTtcbn1cbmA7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sb25lLWJsb2Nrc1xueyAvKiBsYW5ndWFnZT1DU1MgKi8gfVxuY29uc3QgUHV6emxlU3R5bGUgPSBjc3NgXG4ucHV6emxlIHtcbiAgICBtYXJnaW4tdG9wOiAuNWVtO1xuICAgIHdpZHRoOiAke2NlbGxXaWR0aCAqIDl9ZW07XG4gICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIGJveC1zaGFkb3c6IDAgM3B4IDZweCByZ2JhKDAsMCwwLDAuMTYpLCAwIDNweCA2cHggcmdiYSgwLDAsMCwwLjIzKTtcbn1cbi5yb3cge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBmbGV4OiAwO1xuICAgIHdpZHRoOiAke2NlbGxXaWR0aCAqIDl9ZW07XG59XG4ucm93Om5vdCg6bGFzdC1jaGlsZCkge1xuICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCBibGFjaztcbn1cbi5yb3c6bnRoLWNoaWxkKDNuKzMpOm5vdCg6bGFzdC1jaGlsZCkge1xuICAgIGJvcmRlci1ib3R0b206IDJweCBzb2xpZCBibGFjayAhaW1wb3J0YW50O1xufVxuYDtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxvbmUtYmxvY2tzXG57IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG5jb25zdCBDaXJjdWx1YXJQcm9ncmVzc1N0eWxlID0gY3NzYFxuLmNpcmN1bGFyLXByb2dyZXNzIHtcbiAgICBkaXNwbGF5OiBibG9jaztcbiAgICB3aWR0aDogMTAwJTtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgdG9wOiAwO1xuICAgIGxlZnQ6IDA7XG4gICAgdHJhbnNpdGlvbjogZmlsdGVyIC40cyBlYXNlLWluLW91dDtcbn1cblxuLmNpcmNsZS1iZyB7XG4gICAgZmlsbDogbm9uZTtcbiAgICBzdHJva2U6ICNlZWU7XG4gICAgc3Ryb2tlLXdpZHRoOiAzLjg7XG59XG5cbi5jaXJjbGUge1xuICAgIHN0cm9rZTogJHtDb250cm9sTnVtYmVyQ29sb3J9O1xuICAgIHRyYW5zaXRpb246IHN0cm9rZS1kYXNoYXJyYXkgLjRzIGVhc2UtaW4tb3V0O1xuICAgIGZpbGw6IG5vbmU7XG4gICAgc3Ryb2tlLXdpZHRoOiAyLjg7XG4gICAgc3Ryb2tlLWxpbmVjYXA6IHJvdW5kO1xufVxuYDtcblxuY29uc3QgQ2lyY3VsYXJQYXRoRCA9ICdNMTggMi4wODQ1IGEgMTUuOTE1NSAxNS45MTU1IDAgMCAxIDAgMzEuODMxIGEgMTUuOTE1NSAxNS45MTU1IDAgMCAxIDAgLTMxLjgzMSc7XG5cbmZ1bmN0aW9uIGdldEJhY2tHcm91bmRDb2xvcih7XG4gIGNvbmZsaWN0LCBpc1BlZXIsIHNhbWVWYWx1ZSwgaXNTZWxlY3RlZCxcbn0pIHtcbiAgaWYgKGNvbmZsaWN0ICYmIGlzUGVlciAmJiBzYW1lVmFsdWUpIHtcbiAgICByZXR1cm4gRGVlcE9yYW5nZTIwMDtcbiAgfSBlbHNlIGlmIChzYW1lVmFsdWUpIHtcbiAgICByZXR1cm4gTGlnaHRCbHVlMzAwO1xuICB9IGVsc2UgaWYgKGlzU2VsZWN0ZWQpIHtcbiAgICByZXR1cm4gTGlnaHRCbHVlMjAwO1xuICB9IGVsc2UgaWYgKGlzUGVlcikge1xuICAgIHJldHVybiBMaWdodEJsdWUxMDA7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRGb250Q29sb3IoeyB2YWx1ZSwgY29uZmxpY3QsIHByZWZpbGxlZCB9KSB7XG4gIGlmIChjb25mbGljdCAmJiAhcHJlZmlsbGVkKSB7XG4gICAgcmV0dXJuIERlZXBPcmFuZ2U2MDA7XG4gIH0gZWxzZSBpZiAoIXByZWZpbGxlZCAmJiB2YWx1ZSkge1xuICAgIHJldHVybiBDb250cm9sTnVtYmVyQ29sb3I7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5jbGFzcyBHZW5lcmF0aW9uVUkgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcblxuICAgIHRoaXMuc3RhdGUgPSB7IHZhbHVlOiAzMCB9O1xuICB9XG5cbiAgZ2VuZXJhdGVHYW1lID0gKCkgPT4ge1xuICAgIHRoaXMucHJvcHMuZ2VuZXJhdGVHYW1lKHRoaXMuc3RhdGUudmFsdWUpO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImdlbmVyYXRpb25cIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb3B5XCI+U3RhcnQgd2l0aCB7dGhpcy5zdGF0ZS52YWx1ZX0gY2VsbHMgcHJlZmlsbGVkPC9kaXY+XG4gICAgICAgIDxJbnB1dFJhbmdlXG4gICAgICAgICAgbWF4VmFsdWU9ezgxfVxuICAgICAgICAgIG1pblZhbHVlPXsxN31cbiAgICAgICAgICB2YWx1ZT17dGhpcy5zdGF0ZS52YWx1ZX1cbiAgICAgICAgICBvbkNoYW5nZT17dmFsdWUgPT4gdGhpcy5zZXRTdGF0ZSh7IHZhbHVlIH0pfVxuICAgICAgICAvPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImJ1dHRvblwiIG9uQ2xpY2s9e3RoaXMuZ2VuZXJhdGVHYW1lfT5QbGF5IFN1ZG9rdTwvZGl2PlxuICAgICAgICB7IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG4gICAgICAgIDxzdHlsZSBqc3g+e2BcbiAgICAgICAgICAgIC5jb3B5IHtcbiAgICAgICAgICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgICAgICAgICAgICAgZm9udC1zaXplOiAxLjNlbTtcbiAgICAgICAgICAgICAgICBtYXJnaW4tYm90dG9tOiAuNWVtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLmdlbmVyYXRpb24ge1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgICAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgICAgICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOmdsb2JhbCguaW5wdXQtcmFuZ2UpIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogODAlO1xuICAgICAgICAgICAgICAgIG1heC13aWR0aDogNTAwcHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAuYnV0dG9uIHtcbiAgICAgICAgICAgICAgbWFyZ2luLXRvcDogLjVlbTtcbiAgICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogLjI1ZW07XG4gICAgICAgICAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICAgICAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICAgICAgICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcbiAgICAgICAgICAgICAgY29sb3I6ICNmZmY7XG4gICAgICAgICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgICAgICAgICAgICB0cmFuc2l0aW9uOiBhbGwgLjI1cztcbiAgICAgICAgICAgICAgcGFkZGluZzogNXB4IDEwcHg7XG4gICAgICAgICAgICAgIGZvbnQtc2l6ZTogMS40ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAuYnV0dG9uOmFjdGl2ZSB7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKDBweCwgNXB4KTtcbiAgICAgICAgICAgICAgYm94LXNoYWRvdzogMCAxcHggMCAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAuYnV0dG9uIHtcbiAgICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogJHtiYWNrR3JvdW5kQmx1ZX07XG4gICAgICAgICAgICAgIGJveC1zaGFkb3c6IDAgMnB4IDRweCAwICR7Q29sb3IoYmFja0dyb3VuZEJsdWUpLmRhcmtlbigwLjUpLmhzbCgpLnN0cmluZygpfTtcbiAgICAgICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLmJ1dHRvbjpob3ZlciB7XG4gICAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6ICR7Q29sb3IoYmFja0dyb3VuZEJsdWUpLmxpZ2h0ZW4oMC4yKS5oc2woKS5zdHJpbmcoKX07XG4gICAgICAgICAgICB9XG4gICAgICAgIGB9XG4gICAgICAgIDwvc3R5bGU+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG59XG5cbkdlbmVyYXRpb25VSS5wcm9wVHlwZXMgPSB7XG4gIGdlbmVyYXRlR2FtZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbn07XG5cbmNvbnN0IE51bWJlckNvbnRyb2wgPSAoeyBudW1iZXIsIG9uQ2xpY2ssIGNvbXBsZXRpb25QZXJjZW50YWdlIH0pID0+IChcbiAgPGRpdlxuICAgIGtleT17bnVtYmVyfVxuICAgIGNsYXNzTmFtZT1cIm51bWJlclwiXG4gICAgb25DbGljaz17b25DbGlja31cbiAgPlxuICAgIDxkaXY+e251bWJlcn08L2Rpdj5cbiAgICA8Q2lyY2x1bGFyUHJvZ3Jlc3MgcGVyY2VudD17Y29tcGxldGlvblBlcmNlbnRhZ2V9IC8+XG4gICAgPHN0eWxlIGpzeD57TnVtYmVyQ29udHJvbFN0eWxlfTwvc3R5bGU+XG4gIDwvZGl2PlxuKTtcblxuTnVtYmVyQ29udHJvbC5wcm9wVHlwZXMgPSB7XG4gIG51bWJlcjogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICBvbkNsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgY29tcGxldGlvblBlcmNlbnRhZ2U6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbn07XG5cbk51bWJlckNvbnRyb2wuZGVmYXVsdFByb3BzID0ge1xuICBvbkNsaWNrOiBudWxsLFxufTtcblxuY29uc3QgQ2VsbCA9IChwcm9wcykgPT4ge1xuICBjb25zdCB7XG4gICAgdmFsdWUsIG9uQ2xpY2ssIGlzUGVlciwgaXNTZWxlY3RlZCwgc2FtZVZhbHVlLCBwcmVmaWxsZWQsIG5vdGVzLCBjb25mbGljdCxcbiAgfSA9IHByb3BzO1xuICBjb25zdCBiYWNrZ3JvdW5kQ29sb3IgPSBnZXRCYWNrR3JvdW5kQ29sb3Ioe1xuICAgIGNvbmZsaWN0LCBpc1BlZXIsIHNhbWVWYWx1ZSwgaXNTZWxlY3RlZCxcbiAgfSk7XG4gIGNvbnN0IGZvbnRDb2xvciA9IGdldEZvbnRDb2xvcih7IGNvbmZsaWN0LCBwcmVmaWxsZWQsIHZhbHVlIH0pO1xuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwiY2VsbFwiIG9uQ2xpY2s9e29uQ2xpY2t9PlxuICAgICAge1xuICAgICAgICBub3RlcyA/XG4gICAgICAgICAgcmFuZ2UoOSkubWFwKGkgPT5cbiAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgPGRpdiBrZXk9e2l9IGNsYXNzTmFtZT1cIm5vdGUtbnVtYmVyXCI+XG4gICAgICAgICAgICAgICAge25vdGVzLmhhcyhpICsgMSkgJiYgKGkgKyAxKX1cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICApKSA6XG4gICAgICAgICAgdmFsdWUgJiYgdmFsdWVcbiAgICAgIH1cbiAgICAgIHsvKiBsYW5ndWFnZT1DU1MgKi99XG4gICAgICA8c3R5bGUganN4PntDZWxsU3R5bGV9PC9zdHlsZT5cbiAgICAgIDxzdHlsZSBqc3g+e2BcbiAgICAgICAgICAgICAgICAuY2VsbCB7XG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6ICR7YmFja2dyb3VuZENvbG9yIHx8ICdpbml0aWFsJ307XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiAke2ZvbnRDb2xvciB8fCAnaW5pdGlhbCd9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGB9XG4gICAgICA8L3N0eWxlPlxuICAgIDwvZGl2PlxuICApO1xufTtcblxuQ2VsbC5wcm9wVHlwZXMgPSB7XG4gIC8vIGN1cnJlbnQgbnVtYmVyIHZhbHVlXG4gIHZhbHVlOiBQcm9wVHlwZXMubnVtYmVyLFxuICAvLyBjZWxsIGNsaWNrIGhhbmRsZXJcbiAgb25DbGljazogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgLy8gaWYgdGhlIGNlbGwgaXMgYSBwZWVyIG9mIHRoZSBzZWxlY3RlZCBjZWxsXG4gIGlzUGVlcjogUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZCxcbiAgLy8gaWYgdGhlIGNlbGwgaXMgc2VsZWN0ZWQgYnkgdGhlIHVzZXJcbiAgaXNTZWxlY3RlZDogUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZCxcbiAgLy8gY3VycmVudCBjZWxsIGhhcyB0aGUgc2FtZSB2YWx1ZSBpZiB0aGUgdXNlciBzZWxlY3RlZCBjZWxsXG4gIHNhbWVWYWx1ZTogUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZCxcbiAgLy8gaWYgdGhpcyB3YXMgcHJlZmlsbGVkIGFzIGEgcGFydCBvZiB0aGUgcHV6emxlXG4gIHByZWZpbGxlZDogUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZCxcbiAgLy8gY3VycmVudCBub3RlcyB0YWtlbiBvbiB0aGUgY2VsbFxuICBub3RlczogUHJvcFR5cGVzLmluc3RhbmNlT2YoU2V0KSxcbiAgLy8gaWYgdGhlIGN1cnJlbnQgY2VsbCBkb2VzIG5vdCBzYXRpc2Z5IHRoZSBnYW1lIGNvbnN0cmFpbnRcbiAgY29uZmxpY3Q6IFByb3BUeXBlcy5ib29sLmlzUmVxdWlyZWQsXG59O1xuXG5DZWxsLmRlZmF1bHRQcm9wcyA9IHtcbiAgbm90ZXM6IG51bGwsXG4gIHZhbHVlOiBudWxsLFxufTtcblxuY29uc3QgQ2lyY2x1bGFyUHJvZ3Jlc3MgPSAoeyBwZXJjZW50IH0pID0+IChcbiAgPHN2ZyB2aWV3Qm94PVwiMCAwIDM2IDM2XCIgY2xhc3NOYW1lPVwiY2lyY3VsYXItcHJvZ3Jlc3NcIj5cbiAgICA8cGF0aFxuICAgICAgY2xhc3NOYW1lPVwiY2lyY2xlLWJnXCJcbiAgICAgIGQ9e0NpcmN1bGFyUGF0aER9XG4gICAgLz5cbiAgICA8cGF0aFxuICAgICAgY2xhc3NOYW1lPVwiY2lyY2xlXCJcbiAgICAgIHN0cm9rZURhc2hhcnJheT17YCR7cGVyY2VudCAqIDEwMH0sIDEwMGB9XG4gICAgICBkPXtDaXJjdWxhclBhdGhEfVxuICAgIC8+XG4gICAgeyAvKiBsYW5ndWFnZT1DU1MgKi8gfVxuICAgIDxzdHlsZSBqc3g+e0NpcmN1bHVhclByb2dyZXNzU3R5bGV9PC9zdHlsZT5cbiAgPC9zdmc+XG4pO1xuXG5DaXJjbHVsYXJQcm9ncmVzcy5wcm9wVHlwZXMgPSB7XG4gIHBlcmNlbnQ6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbn07XG5cbmZ1bmN0aW9uIGdldENsaWNrSGFuZGxlcihvbkNsaWNrLCBvbkRvdWJsZUNsaWNrLCBkZWxheSA9IDI1MCkge1xuICBsZXQgdGltZW91dElEID0gbnVsbDtcbiAgcmV0dXJuIChldmVudCkgPT4ge1xuICAgIGlmICghdGltZW91dElEKSB7XG4gICAgICB0aW1lb3V0SUQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgb25DbGljayhldmVudCk7XG4gICAgICAgIHRpbWVvdXRJRCA9IG51bGw7XG4gICAgICB9LCBkZWxheSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpbWVvdXRJRCA9IGNsZWFyVGltZW91dCh0aW1lb3V0SUQpO1xuICAgICAgb25Eb3VibGVDbGljayhldmVudCk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIG1ha2Ugc2l6ZSA5IGFycmF5IG9mIDBzXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIG1ha2VDb3VudE9iamVjdCgpIHtcbiAgY29uc3QgY291bnRPYmogPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSArPSAxKSBjb3VudE9iai5wdXNoKDApO1xuICByZXR1cm4gY291bnRPYmo7XG59XG5cbi8qKlxuICogZ2l2ZW4gYSAyRCBhcnJheSBvZiBudW1iZXJzIGFzIHRoZSBpbml0aWFsIHB1enpsZSwgZ2VuZXJhdGUgdGhlIGluaXRpYWwgZ2FtZSBzdGF0ZVxuICogQHBhcmFtIHB1enpsZVxuICogQHJldHVybnMge2FueX1cbiAqL1xuZnVuY3Rpb24gbWFrZUJvYXJkKHsgcHV6emxlIH0pIHtcbiAgLy8gY3JlYXRlIGluaXRpYWwgY291bnQgb2JqZWN0IHRvIGtlZXAgdHJhY2sgb2YgY29uZmxpY3RzIHBlciBudW1iZXIgdmFsdWVcbiAgY29uc3Qgcm93cyA9IEFycmF5LmZyb20oQXJyYXkoOSkua2V5cygpKS5tYXAoKCkgPT4gbWFrZUNvdW50T2JqZWN0KCkpO1xuICBjb25zdCBjb2x1bW5zID0gQXJyYXkuZnJvbShBcnJheSg5KS5rZXlzKCkpLm1hcCgoKSA9PiBtYWtlQ291bnRPYmplY3QoKSk7XG4gIGNvbnN0IHNxdWFyZXMgPSBBcnJheS5mcm9tKEFycmF5KDkpLmtleXMoKSkubWFwKCgpID0+IG1ha2VDb3VudE9iamVjdCgpKTtcbiAgY29uc3QgcmVzdWx0ID0gcHV6emxlLm1hcCgocm93LCBpKSA9PiAoXG4gICAgcm93Lm1hcCgoY2VsbCwgaikgPT4ge1xuICAgICAgaWYgKGNlbGwpIHtcbiAgICAgICAgcm93c1tpXVtjZWxsXSArPSAxO1xuICAgICAgICBjb2x1bW5zW2pdW2NlbGxdICs9IDE7XG4gICAgICAgIHNxdWFyZXNbKChNYXRoLmZsb29yKGkgLyAzKSkgKiAzKSArIE1hdGguZmxvb3IoaiAvIDMpXVtjZWxsXSArPSAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHB1enpsZVtpXVtqXSA+IDAgPyBwdXp6bGVbaV1bal0gOiBudWxsLFxuICAgICAgICBwcmVmaWxsZWQ6ICEhcHV6emxlW2ldW2pdLFxuICAgICAgfTtcbiAgICB9KVxuICApKTtcbiAgcmV0dXJuIGZyb21KUyh7IHB1enpsZTogcmVzdWx0LCBzZWxlY3RlZDogZmFsc2UsIGNob2ljZXM6IHsgcm93cywgY29sdW1ucywgc3F1YXJlcyB9IH0pO1xufVxuXG4vKipcbiAqIGdpdmUgdGhlIGNvb3JkaW5hdGUgdXBkYXRlIHRoZSBjdXJyZW50IGJvYXJkIHdpdGggYSBudW1iZXIgY2hvaWNlXG4gKiBAcGFyYW0geFxuICogQHBhcmFtIHlcbiAqIEBwYXJhbSBudW1iZXJcbiAqIEBwYXJhbSBmaWxsIHdoZXRoZXIgdG8gc2V0IG9yIHVuc2V0XG4gKiBAcGFyYW0gYm9hcmQgdGhlIGltbXV0YWJsZSBib2FyZCBnaXZlbiB0byBjaGFuZ2VcbiAqL1xuZnVuY3Rpb24gdXBkYXRlQm9hcmRXaXRoTnVtYmVyKHtcbiAgeCwgeSwgbnVtYmVyLCBmaWxsID0gdHJ1ZSwgYm9hcmQsXG59KSB7XG4gIGxldCBjZWxsID0gYm9hcmQuZ2V0KCdwdXp6bGUnKS5nZXRJbihbeCwgeV0pO1xuICAvLyBkZWxldGUgaXRzIG5vdGVzXG4gIGNlbGwgPSBjZWxsLmRlbGV0ZSgnbm90ZXMnKTtcbiAgLy8gc2V0IG9yIHVuc2V0IGl0cyB2YWx1ZSBkZXBlbmRpbmcgb24gYGZpbGxgXG4gIGNlbGwgPSBmaWxsID8gY2VsbC5zZXQoJ3ZhbHVlJywgbnVtYmVyKSA6IGNlbGwuZGVsZXRlKCd2YWx1ZScpO1xuICBjb25zdCBpbmNyZW1lbnQgPSBmaWxsID8gMSA6IC0xO1xuICAvLyB1cGRhdGUgdGhlIGN1cnJlbnQgZ3JvdXAgY2hvaWNlc1xuICBjb25zdCByb3dQYXRoID0gWydjaG9pY2VzJywgJ3Jvd3MnLCB4LCBudW1iZXJdO1xuICBjb25zdCBjb2x1bW5QYXRoID0gWydjaG9pY2VzJywgJ2NvbHVtbnMnLCB5LCBudW1iZXJdO1xuICBjb25zdCBzcXVhcmVQYXRoID0gWydjaG9pY2VzJywgJ3NxdWFyZXMnLFxuICAgICgoTWF0aC5mbG9vcih4IC8gMykpICogMykgKyBNYXRoLmZsb29yKHkgLyAzKSwgbnVtYmVyXTtcbiAgcmV0dXJuIGJvYXJkLnNldEluKHJvd1BhdGgsIGJvYXJkLmdldEluKHJvd1BhdGgpICsgaW5jcmVtZW50KVxuICAgIC5zZXRJbihjb2x1bW5QYXRoLCBib2FyZC5nZXRJbihjb2x1bW5QYXRoKSArIGluY3JlbWVudClcbiAgICAuc2V0SW4oc3F1YXJlUGF0aCwgYm9hcmQuZ2V0SW4oc3F1YXJlUGF0aCkgKyBpbmNyZW1lbnQpXG4gICAgLnNldEluKFsncHV6emxlJywgeCwgeV0sIGNlbGwpO1xufVxuXG5mdW5jdGlvbiBnZXROdW1iZXJPZkdyb3Vwc0Fzc2lnbmVkRm9yTnVtYmVyKG51bWJlciwgZ3JvdXBzKSB7XG4gIHJldHVybiBncm91cHMucmVkdWNlKChhY2N1bXVsYXRvciwgcm93KSA9PlxuICAgIGFjY3VtdWxhdG9yICsgKHJvdy5nZXQobnVtYmVyKSA+IDAgPyAxIDogMCksIDApO1xufVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L25vLW11bHRpLWNvbXBcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEluZGV4IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgc3RhdGUgPSB7fTtcblxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICBpZiAoJ3NlcnZpY2VXb3JrZXInIGluIG5hdmlnYXRvcikge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICAgICBuYXZpZ2F0b3Iuc2VydmljZVdvcmtlclxuICAgICAgICAucmVnaXN0ZXIoJy9zZXJ2aWNlLXdvcmtlci5qcycpXG4gICAgICAgIC50aGVuKChyZWcpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnU2VydmljZVdvcmtlciBzY29wZTogJywgcmVnLnNjb3BlKTtcbiAgICAgICAgICBjb25zb2xlLmxvZygnc2VydmljZSB3b3JrZXIgcmVnaXN0cmF0aW9uIHN1Y2Nlc3NmdWwnKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ3NlcnZpY2Ugd29ya2VyIHJlZ2lzdHJhdGlvbiBmYWlsZWQnLCBlcnIubWVzc2FnZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgXG4gICAgZmV0Y2goJy9hcGkvc29ja2V0aW8nKS5maW5hbGx5KCgpID0+IHtcbiAgICAgIGNvbnN0IHNvY2tldCA9IGlvKClcblxuICAgICAgc29ja2V0Lm9uKCdjb25uZWN0JywgKCkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZygnY29ubmVjdCcpXG4gICAgICAgIHNvY2tldC5lbWl0KCdoZWxsbycpXG4gICAgICB9KVxuXG4gICAgICBzb2NrZXQub24oJ2hlbGxvJywgZGF0YSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdoZWxsbycsIGRhdGEpXG4gICAgICB9KVxuXG4gICAgICBzb2NrZXQub24oJ2EgdXNlciBjb25uZWN0ZWQnLCAoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdhIHVzZXIgY29ubmVjdGVkJylcbiAgICAgIH0pXG5cbiAgICAgIHNvY2tldC5vbignZGlzY29ubmVjdCcsICgpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ2Rpc2Nvbm5lY3QnKVxuICAgICAgfSlcbiAgICB9KVxuICAgXG4gIH1cbiAgZ2V0U2VsZWN0ZWRDZWxsKCkge1xuICAgIGNvbnN0IHsgYm9hcmQgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3Qgc2VsZWN0ZWQgPSBib2FyZC5nZXQoJ3NlbGVjdGVkJyk7XG4gICAgcmV0dXJuIHNlbGVjdGVkICYmIGJvYXJkLmdldCgncHV6emxlJykuZ2V0SW4oW3NlbGVjdGVkLngsIHNlbGVjdGVkLnldKTtcbiAgfVxuXG4gIC8vIGdldCB0aGUgbWluIGJldHdlZW4gaXRzIGNvbXBsZXRpb24gaW4gcm93cywgY29sdW1ucyBhbmQgc3F1YXJlcy5cbiAgZ2V0TnVtYmVyVmFsdWVDb3VudChudW1iZXIpIHtcbiAgICBjb25zdCByb3dzID0gdGhpcy5zdGF0ZS5ib2FyZC5nZXRJbihbJ2Nob2ljZXMnLCAncm93cyddKTtcbiAgICBjb25zdCBjb2x1bW5zID0gdGhpcy5zdGF0ZS5ib2FyZC5nZXRJbihbJ2Nob2ljZXMnLCAnY29sdW1ucyddKTtcbiAgICBjb25zdCBzcXVhcmVzID0gdGhpcy5zdGF0ZS5ib2FyZC5nZXRJbihbJ2Nob2ljZXMnLCAnc3F1YXJlcyddKTtcbiAgICByZXR1cm4gTWF0aC5taW4oXG4gICAgICBnZXROdW1iZXJPZkdyb3Vwc0Fzc2lnbmVkRm9yTnVtYmVyKG51bWJlciwgc3F1YXJlcyksXG4gICAgICBNYXRoLm1pbihcbiAgICAgICAgZ2V0TnVtYmVyT2ZHcm91cHNBc3NpZ25lZEZvck51bWJlcihudW1iZXIsIHJvd3MpLFxuICAgICAgICBnZXROdW1iZXJPZkdyb3Vwc0Fzc2lnbmVkRm9yTnVtYmVyKG51bWJlciwgY29sdW1ucyksXG4gICAgICApLFxuICAgICk7XG4gIH1cblxuICBnZW5lcmF0ZUdhbWUgPSAoZmluYWxDb3VudCA9IDIwKSA9PiB7XG4gICAgLy8gZ2V0IGEgZmlsbGVkIHB1enpsZSBnZW5lcmF0ZWRcbiAgICBjb25zdCBzb2x1dGlvbiA9IG1ha2VQdXp6bGUoKTtcbiAgICAvLyBwbHVjayB2YWx1ZXMgZnJvbSBjZWxscyB0byBjcmVhdGUgdGhlIGdhbWVcbiAgICBjb25zdCB7IHB1enpsZSB9ID0gcGx1Y2soc29sdXRpb24sIGZpbmFsQ291bnQpO1xuICAgIC8vIGluaXRpYWxpemUgdGhlIGJvYXJkIHdpdGggY2hvaWNlIGNvdW50c1xuICAgIGNvbnN0IGJvYXJkID0gbWFrZUJvYXJkKHsgcHV6emxlIH0pO1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgYm9hcmQsIGhpc3Rvcnk6IExpc3Qub2YoYm9hcmQpLCBoaXN0b3J5T2ZmU2V0OiAwLCBzb2x1dGlvbixcbiAgICB9KTtcbiAgfVxuXG4gIGFkZE51bWJlckFzTm90ZSA9IChudW1iZXIpID0+IHtcbiAgICBsZXQgeyBib2FyZCB9ID0gdGhpcy5zdGF0ZTtcbiAgICBsZXQgc2VsZWN0ZWRDZWxsID0gdGhpcy5nZXRTZWxlY3RlZENlbGwoKTtcbiAgICBpZiAoIXNlbGVjdGVkQ2VsbCkgcmV0dXJuO1xuICAgIGNvbnN0IHByZWZpbGxlZCA9IHNlbGVjdGVkQ2VsbC5nZXQoJ3ByZWZpbGxlZCcpO1xuICAgIGlmIChwcmVmaWxsZWQpIHJldHVybjtcbiAgICBjb25zdCB7IHgsIHkgfSA9IGJvYXJkLmdldCgnc2VsZWN0ZWQnKTtcbiAgICBjb25zdCBjdXJyZW50VmFsdWUgPSBzZWxlY3RlZENlbGwuZ2V0KCd2YWx1ZScpO1xuICAgIGlmIChjdXJyZW50VmFsdWUpIHtcbiAgICAgIGJvYXJkID0gdXBkYXRlQm9hcmRXaXRoTnVtYmVyKHtcbiAgICAgICAgeCwgeSwgbnVtYmVyOiBjdXJyZW50VmFsdWUsIGZpbGw6IGZhbHNlLCBib2FyZDogdGhpcy5zdGF0ZS5ib2FyZCxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBsZXQgbm90ZXMgPSBzZWxlY3RlZENlbGwuZ2V0KCdub3RlcycpIHx8IFNldCgpO1xuICAgIGlmIChub3Rlcy5oYXMobnVtYmVyKSkge1xuICAgICAgbm90ZXMgPSBub3Rlcy5kZWxldGUobnVtYmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm90ZXMgPSBub3Rlcy5hZGQobnVtYmVyKTtcbiAgICB9XG4gICAgc2VsZWN0ZWRDZWxsID0gc2VsZWN0ZWRDZWxsLnNldCgnbm90ZXMnLCBub3Rlcyk7XG4gICAgc2VsZWN0ZWRDZWxsID0gc2VsZWN0ZWRDZWxsLmRlbGV0ZSgndmFsdWUnKTtcbiAgICBib2FyZCA9IGJvYXJkLnNldEluKFsncHV6emxlJywgeCwgeV0sIHNlbGVjdGVkQ2VsbCk7XG4gICAgdGhpcy51cGRhdGVCb2FyZChib2FyZCk7XG4gIH07XG5cbiAgdXBkYXRlQm9hcmQgPSAobmV3Qm9hcmQpID0+IHtcbiAgICBsZXQgeyBoaXN0b3J5IH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IHsgaGlzdG9yeU9mZlNldCB9ID0gdGhpcy5zdGF0ZTtcbiAgICAvLyBhbnl0aGluZyBiZWZvcmUgY3VycmVudCBzdGVwIGlzIHN0aWxsIGluIGhpc3RvcnlcbiAgICBoaXN0b3J5ID0gaGlzdG9yeS5zbGljZSgwLCBoaXN0b3J5T2ZmU2V0ICsgMSk7XG4gICAgLy8gYWRkIGl0c2VsZiBvbnRvIHRoZSBoaXN0b3J5XG4gICAgaGlzdG9yeSA9IGhpc3RvcnkucHVzaChuZXdCb2FyZCk7XG4gICAgLy8gdXBkYXRlIHRoZSBnYW1lXG4gICAgdGhpcy5zZXRTdGF0ZSh7IGJvYXJkOiBuZXdCb2FyZCwgaGlzdG9yeSwgaGlzdG9yeU9mZlNldDogaGlzdG9yeS5zaXplIC0gMSB9KTtcbiAgfTtcblxuICBjYW5VbmRvID0gKCkgPT4gdGhpcy5zdGF0ZS5oaXN0b3J5T2ZmU2V0ID4gMFxuXG4gIHJlZG8gPSAoKSA9PiB7XG4gICAgY29uc3QgeyBoaXN0b3J5IH0gPSB0aGlzLnN0YXRlO1xuICAgIGxldCB7IGhpc3RvcnlPZmZTZXQgfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKGhpc3Rvcnkuc2l6ZSkge1xuICAgICAgaGlzdG9yeU9mZlNldCA9IE1hdGgubWluKGhpc3Rvcnkuc2l6ZSAtIDEsIGhpc3RvcnlPZmZTZXQgKyAxKTtcbiAgICAgIGNvbnN0IGJvYXJkID0gaGlzdG9yeS5nZXQoaGlzdG9yeU9mZlNldCk7XG4gICAgICB0aGlzLnNldFN0YXRlKHsgYm9hcmQsIGhpc3RvcnlPZmZTZXQgfSk7XG4gICAgfVxuICB9O1xuXG4gIHVuZG8gPSAoKSA9PiB7XG4gICAgY29uc3QgeyBoaXN0b3J5IH0gPSB0aGlzLnN0YXRlO1xuICAgIGxldCB7IGhpc3RvcnlPZmZTZXQsIGJvYXJkIH0gPSB0aGlzLnN0YXRlO1xuICAgIGlmIChoaXN0b3J5LnNpemUpIHtcbiAgICAgIGhpc3RvcnlPZmZTZXQgPSBNYXRoLm1heCgwLCBoaXN0b3J5T2ZmU2V0IC0gMSk7XG4gICAgICBib2FyZCA9IGhpc3RvcnkuZ2V0KGhpc3RvcnlPZmZTZXQpO1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IGJvYXJkLCBoaXN0b3J5T2ZmU2V0LCBoaXN0b3J5IH0pO1xuICAgIH1cbiAgfTtcblxuICBlcmFzZVNlbGVjdGVkID0gKCkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGVkQ2VsbCA9IHRoaXMuZ2V0U2VsZWN0ZWRDZWxsKCk7XG4gICAgaWYgKCFzZWxlY3RlZENlbGwpIHJldHVybjtcbiAgICB0aGlzLmZpbGxOdW1iZXIoZmFsc2UpO1xuICB9XG5cbiAgZmlsbFNlbGVjdGVkV2l0aFNvbHV0aW9uID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgYm9hcmQsIHNvbHV0aW9uIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IHNlbGVjdGVkQ2VsbCA9IHRoaXMuZ2V0U2VsZWN0ZWRDZWxsKCk7XG4gICAgaWYgKCFzZWxlY3RlZENlbGwpIHJldHVybjtcbiAgICBjb25zdCB7IHgsIHkgfSA9IGJvYXJkLmdldCgnc2VsZWN0ZWQnKTtcbiAgICB0aGlzLmZpbGxOdW1iZXIoc29sdXRpb25beF1beV0pO1xuICB9XG5cblxuICAvLyBmaWxsIGN1cnJlbnRseSBzZWxlY3RlZCBjZWxsIHdpdGggbnVtYmVyXG4gIGZpbGxOdW1iZXIgPSAobnVtYmVyKSA9PiB7XG4gICAgbGV0IHsgYm9hcmQgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3Qgc2VsZWN0ZWRDZWxsID0gdGhpcy5nZXRTZWxlY3RlZENlbGwoKTtcbiAgICAvLyBuby1vcCBpZiBub3RoaW5nIGlzIHNlbGVjdGVkXG4gICAgaWYgKCFzZWxlY3RlZENlbGwpIHJldHVybjtcbiAgICBjb25zdCBwcmVmaWxsZWQgPSBzZWxlY3RlZENlbGwuZ2V0KCdwcmVmaWxsZWQnKTtcbiAgICAvLyBuby1vcCBpZiBpdCBpcyByZWZpbGxlZFxuICAgIGlmIChwcmVmaWxsZWQpIHJldHVybjtcbiAgICBjb25zdCB7IHgsIHkgfSA9IGJvYXJkLmdldCgnc2VsZWN0ZWQnKTtcbiAgICBjb25zdCBjdXJyZW50VmFsdWUgPSBzZWxlY3RlZENlbGwuZ2V0KCd2YWx1ZScpO1xuICAgIC8vIHJlbW92ZSB0aGUgY3VycmVudCB2YWx1ZSBhbmQgdXBkYXRlIHRoZSBnYW1lIHN0YXRlXG4gICAgaWYgKGN1cnJlbnRWYWx1ZSkge1xuICAgICAgYm9hcmQgPSB1cGRhdGVCb2FyZFdpdGhOdW1iZXIoe1xuICAgICAgICB4LCB5LCBudW1iZXI6IGN1cnJlbnRWYWx1ZSwgZmlsbDogZmFsc2UsIGJvYXJkOiB0aGlzLnN0YXRlLmJvYXJkLFxuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIHVwZGF0ZSB0byBuZXcgbnVtYmVyIGlmIGFueVxuICAgIGNvbnN0IHNldE51bWJlciA9IGN1cnJlbnRWYWx1ZSAhPT0gbnVtYmVyICYmIG51bWJlcjtcbiAgICBpZiAoc2V0TnVtYmVyKSB7XG4gICAgICBib2FyZCA9IHVwZGF0ZUJvYXJkV2l0aE51bWJlcih7XG4gICAgICAgIHgsIHksIG51bWJlciwgZmlsbDogdHJ1ZSwgYm9hcmQsXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVCb2FyZChib2FyZCk7XG4gIH07XG5cbiAgc2VsZWN0Q2VsbCA9ICh4LCB5KSA9PiB7XG4gICAgbGV0IHsgYm9hcmQgfSA9IHRoaXMuc3RhdGU7XG4gICAgYm9hcmQgPSBib2FyZC5zZXQoJ3NlbGVjdGVkJywgeyB4LCB5IH0pO1xuICAgIHRoaXMuc2V0U3RhdGUoeyBib2FyZCB9KTtcbiAgfTtcblxuICBpc0NvbmZsaWN0KGksIGopIHtcbiAgICBjb25zdCB7IHZhbHVlIH0gPSB0aGlzLnN0YXRlLmJvYXJkLmdldEluKFsncHV6emxlJywgaSwgal0pLnRvSlNPTigpO1xuICAgIGlmICghdmFsdWUpIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCByb3dDb25mbGljdCA9XG4gICAgICB0aGlzLnN0YXRlLmJvYXJkLmdldEluKFsnY2hvaWNlcycsICdyb3dzJywgaSwgdmFsdWVdKSA+IDE7XG4gICAgY29uc3QgY29sdW1uQ29uZmxpY3QgPVxuICAgICAgdGhpcy5zdGF0ZS5ib2FyZC5nZXRJbihbJ2Nob2ljZXMnLCAnY29sdW1ucycsIGosIHZhbHVlXSkgPiAxO1xuICAgIGNvbnN0IHNxdWFyZUNvbmZsaWN0ID1cbiAgICAgIHRoaXMuc3RhdGUuYm9hcmQuZ2V0SW4oWydjaG9pY2VzJywgJ3NxdWFyZXMnLFxuICAgICAgICAoKE1hdGguZmxvb3IoaSAvIDMpKSAqIDMpICsgTWF0aC5mbG9vcihqIC8gMyksIHZhbHVlXSkgPiAxO1xuICAgIHJldHVybiByb3dDb25mbGljdCB8fCBjb2x1bW5Db25mbGljdCB8fCBzcXVhcmVDb25mbGljdDtcbiAgfVxuXG4gIHJlbmRlckNlbGwoY2VsbCwgeCwgeSkge1xuICAgIGNvbnN0IHsgYm9hcmQgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3Qgc2VsZWN0ZWQgPSB0aGlzLmdldFNlbGVjdGVkQ2VsbCgpO1xuICAgIGNvbnN0IHsgdmFsdWUsIHByZWZpbGxlZCwgbm90ZXMgfSA9IGNlbGwudG9KU09OKCk7XG4gICAgY29uc3QgY29uZmxpY3QgPSB0aGlzLmlzQ29uZmxpY3QoeCwgeSk7XG4gICAgY29uc3QgcGVlciA9IGFyZUNvb3JkaW5hdGVQZWVycyh7IHgsIHkgfSwgYm9hcmQuZ2V0KCdzZWxlY3RlZCcpKTtcbiAgICBjb25zdCBzYW1lVmFsdWUgPSAhIShzZWxlY3RlZCAmJiBzZWxlY3RlZC5nZXQoJ3ZhbHVlJylcbiAgICAgICYmIHZhbHVlID09PSBzZWxlY3RlZC5nZXQoJ3ZhbHVlJykpO1xuXG4gICAgY29uc3QgaXNTZWxlY3RlZCA9IGNlbGwgPT09IHNlbGVjdGVkO1xuICAgIHJldHVybiAoPENlbGxcbiAgICAgIHByZWZpbGxlZD17cHJlZmlsbGVkfVxuICAgICAgbm90ZXM9e25vdGVzfVxuICAgICAgc2FtZVZhbHVlPXtzYW1lVmFsdWV9XG4gICAgICBpc1NlbGVjdGVkPXtpc1NlbGVjdGVkfVxuICAgICAgaXNQZWVyPXtwZWVyfVxuICAgICAgdmFsdWU9e3ZhbHVlfVxuICAgICAgb25DbGljaz17KCkgPT4geyB0aGlzLnNlbGVjdENlbGwoeCwgeSk7IH19XG4gICAgICBrZXk9e3l9XG4gICAgICB4PXt4fVxuICAgICAgeT17eX1cbiAgICAgIGNvbmZsaWN0PXtjb25mbGljdH1cbiAgICAvPik7XG4gIH1cblxuICByZW5kZXJOdW1iZXJDb250cm9sKCkge1xuICAgIGNvbnN0IHNlbGVjdGVkQ2VsbCA9IHRoaXMuZ2V0U2VsZWN0ZWRDZWxsKCk7XG4gICAgY29uc3QgcHJlZmlsbGVkID0gc2VsZWN0ZWRDZWxsICYmIHNlbGVjdGVkQ2VsbC5nZXQoJ3ByZWZpbGxlZCcpO1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRyb2xcIj5cbiAgICAgICAge3JhbmdlKDkpLm1hcCgoaSkgPT4ge1xuICAgICAgICAgIGNvbnN0IG51bWJlciA9IGkgKyAxO1xuICAgICAgICAgIC8vIGhhbmRsZXMgYmluZGluZyBzaW5nbGUgY2xpY2sgYW5kIGRvdWJsZSBjbGljayBjYWxsYmFja3NcbiAgICAgICAgICBjb25zdCBjbGlja0hhbmRsZSA9IGdldENsaWNrSGFuZGxlcihcbiAgICAgICAgICAgICgpID0+IHsgdGhpcy5maWxsTnVtYmVyKG51bWJlcik7IH0sXG4gICAgICAgICAgICAoKSA9PiB7IHRoaXMuYWRkTnVtYmVyQXNOb3RlKG51bWJlcik7IH0sXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPE51bWJlckNvbnRyb2xcbiAgICAgICAgICAgICAga2V5PXtudW1iZXJ9XG4gICAgICAgICAgICAgIG51bWJlcj17bnVtYmVyfVxuICAgICAgICAgICAgICBvbkNsaWNrPXshcHJlZmlsbGVkID8gY2xpY2tIYW5kbGUgOiB1bmRlZmluZWR9XG4gICAgICAgICAgICAgIGNvbXBsZXRpb25QZXJjZW50YWdlPXt0aGlzLmdldE51bWJlclZhbHVlQ291bnQobnVtYmVyKSAvIDl9XG4gICAgICAgICAgICAvPik7XG4gICAgICAgIH0pfVxuICAgICAgICA8c3R5bGUganN4PntDb250cm9sU3R5bGV9PC9zdHlsZT5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cblxuICByZW5kZXJBY3Rpb25zKCkge1xuICAgIGNvbnN0IHsgaGlzdG9yeSB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBzZWxlY3RlZENlbGwgPSB0aGlzLmdldFNlbGVjdGVkQ2VsbCgpO1xuICAgIGNvbnN0IHByZWZpbGxlZCA9IHNlbGVjdGVkQ2VsbCAmJiBzZWxlY3RlZENlbGwuZ2V0KCdwcmVmaWxsZWQnKTtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJhY3Rpb25zXCI+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWN0aW9uXCIgb25DbGljaz17aGlzdG9yeS5zaXplID8gdGhpcy51bmRvIDogbnVsbH0+XG4gICAgICAgICAgPFJlbG9hZEljb24gLz5VbmRvXG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImFjdGlvbiByZWRvXCIgb25DbGljaz17aGlzdG9yeS5zaXplID8gdGhpcy5yZWRvIDogbnVsbH0+XG4gICAgICAgICAgPFJlbG9hZEljb24gLz5SZWRvXG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImFjdGlvblwiIG9uQ2xpY2s9eyFwcmVmaWxsZWQgPyB0aGlzLmVyYXNlU2VsZWN0ZWQgOiBudWxsfT5cbiAgICAgICAgICA8UmVtb3ZlSWNvbiAvPkVyYXNlXG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2XG4gICAgICAgICAgY2xhc3NOYW1lPVwiYWN0aW9uXCJcbiAgICAgICAgICBvbkNsaWNrPXshcHJlZmlsbGVkID9cbiAgICAgICAgICB0aGlzLmZpbGxTZWxlY3RlZFdpdGhTb2x1dGlvbiA6IG51bGx9XG4gICAgICAgID5cbiAgICAgICAgICA8TG91cGVJY29uIC8+SGludFxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPHN0eWxlIGpzeD57QWN0aW9uc1N0eWxlfTwvc3R5bGU+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG5cbiAgcmVuZGVyUHV6emxlKCkge1xuICAgIGNvbnN0IHsgYm9hcmQgfSA9IHRoaXMuc3RhdGU7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwicHV6emxlXCI+XG4gICAgICAgIHtib2FyZC5nZXQoJ3B1enpsZScpLm1hcCgocm93LCBpKSA9PiAoXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L25vLWFycmF5LWluZGV4LWtleVxuICAgICAgICAgIDxkaXYga2V5PXtpfSBjbGFzc05hbWU9XCJyb3dcIj5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcm93Lm1hcCgoY2VsbCwgaikgPT4gdGhpcy5yZW5kZXJDZWxsKGNlbGwsIGksIGopKS50b0FycmF5KClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKSkudG9BcnJheSgpfVxuICAgICAgICA8c3R5bGUganN4PntQdXp6bGVTdHlsZX08L3N0eWxlPlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxuXG4gIHJlbmRlckNvbnRyb2xzKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRyb2xzXCI+XG4gICAgICAgIHt0aGlzLnJlbmRlck51bWJlckNvbnRyb2woKX1cbiAgICAgICAge3RoaXMucmVuZGVyQWN0aW9ucygpfVxuICAgICAgICB7IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG4gICAgICAgIDxzdHlsZSBqc3g+e2BcbiAgICAgICAgICAgIC5jb250cm9scyB7XG4gICAgICAgICAgICAgICAgbWFyZ2luLXRvcDogLjNlbTtcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICAgICAgICAgIGZsZXgtd3JhcDogd3JhcDtcbiAgICAgICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiAuNWVtIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIGB9XG4gICAgICAgIDwvc3R5bGU+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG5cbiAgcmVuZGVyR2VuZXJhdGlvblVJKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8R2VuZXJhdGlvblVJIGdlbmVyYXRlR2FtZT17dGhpcy5nZW5lcmF0ZUdhbWV9IC8+XG4gICAgKTtcbiAgfVxuXG4gIHJlbmRlckhlYWRlcigpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJoZWFkZXJcIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJuZXctZ2FtZVwiIG9uQ2xpY2s9eygpID0+IHRoaXMuc2V0U3RhdGUoeyBib2FyZDogZmFsc2UgfSl9PlxuICAgICAgICAgIDxSZXR1cm5JY29uIC8+XG4gICAgICAgICAgPGRpdj5OZXcgR2FtZTwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPFRpcCAvPlxuICAgICAgICB7IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG4gICAgICAgIDxzdHlsZSBqc3g+e2BcbiAgICAgICAgICAgIC5oZWFkZXIge1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgICAgICAgICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICAgICAgICAgICAgICAgIG1heC13aWR0aDogNTAwcHg7XG4gICAgICAgICAgICAgICAgcGFkZGluZzogMCAwLjVlbTtcbiAgICAgICAgICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLm5ldy1nYW1lIHtcbiAgICAgICAgICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICAgICAgICAgICAgbWFyZ2luLXRvcDogLjJlbTtcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiBpbmxpbmUtZmxleDtcbiAgICAgICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICAgICAgICAgIHBhZGRpbmc6IC4yZW0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC5uZXctZ2FtZSA6Z2xvYmFsKHN2Zykge1xuICAgICAgICAgICAgICAgIGhlaWdodDogMWVtO1xuICAgICAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IC4zZW07XG4gICAgICAgICAgICB9XG4gICAgICAgIGB9XG4gICAgICAgIDwvc3R5bGU+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgYm9hcmQgfSA9IHRoaXMuc3RhdGU7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYm9keVwiPlxuICAgICAgICA8TmV4dEhlYWQ+XG4gICAgICAgICAgPHRpdGxlPlN1ZG9rdSBFdm9sdmVkPC90aXRsZT5cbiAgICAgICAgICA8bWV0YSBuYW1lPVwidmlld3BvcnRcIiBjb250ZW50PVwiaW5pdGlhbC1zY2FsZT0xLjAsIHdpZHRoPWRldmljZS13aWR0aFwiIC8+XG4gICAgICAgICAgPG1ldGEgbmFtZT1cImRlc2NyaXB0aW9uXCIgY29udGVudD17RGVzY3JpcHRpb259IC8+XG4gICAgICAgICAgPGxpbmsgaHJlZj1cImh0dHBzOi8vZm9udHMuZ29vZ2xlYXBpcy5jb20vY3NzP2ZhbWlseT1TcGVjaWFsK0VsaXRlXCIgcmVsPVwic3R5bGVzaGVldFwiIC8+XG4gICAgICAgICAgPG1ldGEgcHJvcGVydHk9XCJvZzp1cmxcIiBjb250ZW50PVwiaHR0cHM6Ly9zdWRva3Uuc2l0aWFubGl1LmNvbS9cIiAvPlxuICAgICAgICAgIDxtZXRhIHByb3BlcnR5PVwib2c6dGl0bGVcIiBjb250ZW50PVwiU3Vkb2t1IEV2b2x2ZWRcIiAvPlxuICAgICAgICAgIDxtZXRhIHByb3BlcnR5PVwib2c6dHlwZVwiIGNvbnRlbnQ9XCJ3ZWJzaXRlXCIgLz5cbiAgICAgICAgICA8bWV0YSBwcm9wZXJ0eT1cIm9nOmRlc2NyaXB0aW9uXCIgY29udGVudD17RGVzY3JpcHRpb259IC8+XG4gICAgICAgICAgPG1ldGEgcHJvcGVydHk9XCJvZzppbWFnZVwiIGNvbnRlbnQ9XCJodHRwczovL3N1ZG9rdS5zaXRpYW5saXUuY29tL3N0YXRpYy9vZy1pbWFnZS5wbmdcIiAvPlxuICAgICAgICA8L05leHRIZWFkPlxuICAgICAgICB7IWJvYXJkICYmIHRoaXMucmVuZGVyR2VuZXJhdGlvblVJKCl9XG4gICAgICAgIHtib2FyZCAmJiB0aGlzLnJlbmRlckhlYWRlcigpfVxuICAgICAgICB7Ym9hcmQgJiYgdGhpcy5yZW5kZXJQdXp6bGUoKX1cbiAgICAgICAge2JvYXJkICYmIHRoaXMucmVuZGVyQ29udHJvbHMoKX1cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJyb290ZXJcIj5cbiAgICAgICAgICBNYWRlIHdpdGggPHNwYW4+4p2k77iPPC9zcGFuPu+4jyBCeSA8YSBocmVmPVwiaHR0cHM6Ly93d3cuc2l0aWFubGl1LmNvbS9cIj5TaXRpYW4gTGl1PC9hPiB8IDxhIGhyZWY9XCJodHRwczovL21lZGl1bS5jb20vQHNpdGlhbmxpdV81NzY4MC9idWlsZGluZy1hLXN1ZG9rdS1nYW1lLWluLXJlYWN0LWNhNjYzOTE1NzEyXCI+QmxvZyBQb3N0PC9hPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgeyAvKiBsYW5ndWFnZT1DU1MgKi8gfVxuICAgICAgICA8c3R5bGUganN4PntgXG4gICAgICAgICAgICA6Z2xvYmFsKGJvZHkpLCAuYm9keSB7XG4gICAgICAgICAgICAgICAgZm9udC1mYW1pbHk6ICdTcGVjaWFsIEVsaXRlJywgY3Vyc2l2ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC5ib2R5IHtcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICAgICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgICAgICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDEwMHZoO1xuICAgICAgICAgICAgICAgIHdpZHRoOiAxMDB2dztcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBAbWVkaWEgKG1pbi13aWR0aDogODAwcHgpIGFuZCAobWluLWhlaWdodDogOTMwcHgpe1xuICAgICAgICAgICAgICAgIDpnbG9iYWwoLmhlYWRlciwgLnB1enpsZSwgLmNvbnRyb2xzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvbnQtc2l6ZTogMS41ZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQG1lZGlhIChtYXgtd2lkdGg6IDgwMHB4KSBhbmQgKG1pbi13aWR0aDogNjAwcHgpe1xuICAgICAgICAgICAgICAgIDpnbG9iYWwoLmhlYWRlciwgLnB1enpsZSwgLmNvbnRyb2xzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvbnQtc2l6ZTogMS4yZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQG1lZGlhIChtYXgtaGVpZ2h0OiA5MzBweCkgYW5kIChtaW4taGVpZ2h0OiA4MDBweCkgYW5kIChtaW4td2lkdGg6IDYwMHB4KXtcbiAgICAgICAgICAgICAgICA6Z2xvYmFsKC5oZWFkZXIsIC5wdXp6bGUsIC5jb250cm9scykge1xuICAgICAgICAgICAgICAgICAgICBmb250LXNpemU6IDEuMmVtO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEBtZWRpYSAobWF4LWhlaWdodDogODAwcHgpIGFuZCAobWluLWhlaWdodDogNjAwcHgpIGFuZCAobWluLXdpZHRoOiAzNzBweCl7XG4gICAgICAgICAgICAgICAgOmdsb2JhbCguaGVhZGVyLCAucHV6emxlLCAuY29udHJvbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9udC1zaXplOiAxZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQG1lZGlhIChtYXgtd2lkdGg6IDM3MHB4KXtcbiAgICAgICAgICAgICAgICA6Z2xvYmFsKC5oZWFkZXIsIC5wdXp6bGUsIC5jb250cm9scykge1xuICAgICAgICAgICAgICAgICAgICBmb250LXNpemU6IC44ZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQG1lZGlhIChtYXgtaGVpZ2h0OiA2MDBweCl7XG4gICAgICAgICAgICAgICAgOmdsb2JhbCguaGVhZGVyLCAucHV6emxlLCAuY29udHJvbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9udC1zaXplOiAuOGVtO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDpnbG9iYWwoYm9keSkge1xuICAgICAgICAgICAgICAgIG1hcmdpbjogMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC5yb290ZXIge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICAgICAgICAgICAgICBib3R0b206IDA7XG4gICAgICAgICAgICAgICAgZm9udC1zaXplOiAuOGVtO1xuICAgICAgICAgICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICAgICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgYH1cbiAgICAgICAgPC9zdHlsZT5cbiAgICAgICAgPHN0eWxlIGpzeCBnbG9iYWw+e1JhbmdlU3R5bGV9PC9zdHlsZT5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cbn1cbiJdfQ== */\n/*@ sourceURL=pages/index.js */';
NumberControlStyle.__scopedHash = '2289524573';
{/* language=CSS */}
var PuzzleStyle = new String('.puzzle{margin-top:.5em;width:' + cellWidth * 9 + 'em;cursor:pointer;box-shadow:0 3px 6px rgba(0,0,0,0.16),0 3px 6px rgba(0,0,0,0.23);}.row{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-flex:0;-ms-flex:0;flex:0;width:' + cellWidth * 9 + 'em;}.row:not(:last-child){border-bottom:1px solid black;}.row:nth-child(3n+3):not(:last-child){border-bottom:2px solid black !important;}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhZ2VzL2luZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQWtJdUIsQUFHcUIsQUFNSCxBQU1pQixBQUdXLGdCQWRKLGNBWXpDLFdBR0EsWUFkbUIsZUFDbUQsTUFJL0MsMkRBSHZCLGtDQUlXLGlDQUM4QixxQ0FDekMiLCJmaWxlIjoicGFnZXMvaW5kZXguanMiLCJzb3VyY2VSb290IjoiL1VzZXJzL2xpY2hlbm1hL1Byb2plY3RzL1N1RHVva3UvU3VEdW9rdSIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIGpzeC1hMTF5L2FjY2Vzc2libGUtZW1vamkgKi9cbmltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFNldCwgTGlzdCwgZnJvbUpTIH0gZnJvbSAnaW1tdXRhYmxlJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgTmV4dEhlYWQgZnJvbSAnbmV4dC9oZWFkJztcbmltcG9ydCBDb2xvciBmcm9tICdjb2xvcic7XG5pbXBvcnQgSW5wdXRSYW5nZSBmcm9tICdyZWFjdC1pbnB1dC1yYW5nZSc7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tZXh0cmFuZW91cy1kZXBlbmRlbmNpZXNcbmltcG9ydCBjc3MgZnJvbSAnc3R5bGVkLWpzeC9jc3MnO1xuXG5pbXBvcnQgUmFuZ2VTdHlsZSBmcm9tICcuLi9pbnB1dC1yYW5nZS1zdHlsZSc7XG5pbXBvcnQgTG91cGVJY29uIGZyb20gJy4uL3N2Zy9sb3VwZS5zdmcnO1xuaW1wb3J0IFJlbW92ZUljb24gZnJvbSAnLi4vc3ZnL3JlbW92ZS5zdmcnO1xuaW1wb3J0IFJlbG9hZEljb24gZnJvbSAnLi4vc3ZnL3JlbG9hZC5zdmcnO1xuaW1wb3J0IFJldHVybkljb24gZnJvbSAnLi4vc3ZnL3JldHVybi5zdmcnO1xuXG5pbXBvcnQgeyBtYWtlUHV6emxlLCBwbHVjaywgaXNQZWVyIGFzIGFyZUNvb3JkaW5hdGVQZWVycywgcmFuZ2UgfSBmcm9tICcuLi9zdWRva3UnO1xuaW1wb3J0IHsgYmFja0dyb3VuZEJsdWUgfSBmcm9tICcuLi9jb2xvcnMnO1xuaW1wb3J0IFRpcCBmcm9tICcuLi9jb21wb25lbnRzL3Rvb2wtdGlwJztcblxuaW1wb3J0IGlvIGZyb20gJ3NvY2tldC5pby1jbGllbnQnXG5cbmNvbnN0IERlc2NyaXB0aW9uID0gJ0Rpc2NvdmVyIHRoZSBuZXh0IGV2b2x1dGlvbiBvZiBTdWRva3Ugd2l0aCBhbWF6aW5nIGdyYXBoaWNzLCBhbmltYXRpb25zLCBhbmQgdXNlci1mcmllbmRseSBmZWF0dXJlcy4gRW5qb3kgYSBTdWRva3UgZXhwZXJpZW5jZSBsaWtlIHlvdSBuZXZlciBoYXZlIGJlZm9yZSB3aXRoIGN1c3RvbWl6YWJsZSBnYW1lIGdlbmVyYXRpb24sIGNlbGwgaGlnaGxpZ2h0aW5nLCBpbnR1aXRpdmUgY29udHJvbHMgYW5kIG1vcmUhJztcbmNvbnN0IGNlbGxXaWR0aCA9IDIuNTtcblxuY29uc3QgTGlnaHRCbHVlMTAwID0gJyNCM0U1RkMnO1xuY29uc3QgTGlnaHRCbHVlMjAwID0gJyM4MUQ0RkEnO1xuY29uc3QgTGlnaHRCbHVlMzAwID0gJyM0RkMzRjcnO1xuY29uc3QgSW5kaWdvNzAwID0gJyMzMDNGOUYnO1xuY29uc3QgRGVlcE9yYW5nZTIwMCA9ICcjRkZBQjkxJztcbmNvbnN0IERlZXBPcmFuZ2U2MDAgPSAnI0Y0NTExRSc7XG5jb25zdCBDb250cm9sTnVtYmVyQ29sb3IgPSBJbmRpZ283MDA7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sb25lLWJsb2Nrc1xueyAvKiBsYW5ndWFnZT1DU1MgKi8gfVxuY29uc3QgQ2VsbFN0eWxlID0gY3NzYFxuLmNlbGwge1xuICAgIGhlaWdodDogJHtjZWxsV2lkdGh9ZW07XG4gICAgd2lkdGg6ICR7Y2VsbFdpZHRofWVtO1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC13cmFwOiB3cmFwO1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgZm9udC1zaXplOiAxLjFlbTtcbiAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICB0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kLWNvbG9yIC4zcyBlYXNlLWluLW91dDtcbn1cbi5jZWxsOm50aC1jaGlsZCgzbiszKTpub3QoOmxhc3QtY2hpbGQpIHtcbiAgICBib3JkZXItcmlnaHQ6IDJweCBzb2xpZCBibGFjaztcbn1cbi5jZWxsOm5vdCg6bGFzdC1jaGlsZCkge1xuICAgIGJvcmRlci1yaWdodDogMXB4IHNvbGlkIGJsYWNrO1xufVxuLm5vdGUtbnVtYmVyIHtcbiAgICBmb250LXNpemU6IC42ZW07XG4gICAgd2lkdGg6IDMzJTtcbiAgICBoZWlnaHQ6IDMzJTtcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbn1cbmA7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sb25lLWJsb2Nrc1xueyAvKiBsYW5ndWFnZT1DU1MgKi8gfVxuY29uc3QgQWN0aW9uc1N0eWxlID0gY3NzYFxuLmFjdGlvbnMge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgbWF4LXdpZHRoOiA0MDBweDtcbiAgICBtYXJnaW4tdG9wOiAuNWVtO1xuICAgIHBhZGRpbmc6IDAgLjZlbTtcbn1cbi5hY3Rpb24ge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xufVxuLmFjdGlvbiA6Z2xvYmFsKHN2Zykge1xuICAgIHdpZHRoOiAyLjVlbTtcbiAgICBtYXJnaW4tYm90dG9tOiAuMmVtO1xufVxuLnJlZG8gOmdsb2JhbChzdmcpIHtcbiAgICB0cmFuc2Zvcm06IHNjYWxlWCgtMSk7XG59XG5gO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbG9uZS1ibG9ja3NcbnsgLyogbGFuZ3VhZ2U9Q1NTICovIH1cbmNvbnN0IENvbnRyb2xTdHlsZSA9IGNzc2Bcbi5jb250cm9sIHtcbiAgICBwYWRkaW5nOiAwIDJlbTtcbiAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgZGlzcGxheTogaW5saW5lLWZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBmbGV4LXdyYXA6IHdyYXA7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgZm9udC1mYW1pbHk6ICdTcGVjaWFsIEVsaXRlJywgY3Vyc2l2ZTtcbiAgICB0cmFuc2l0aW9uOiBmaWx0ZXIgLjVzIGVhc2UtaW4tb3V0O1xuICAgIHdpZHRoOiAxMDAlO1xufVxuYDtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxvbmUtYmxvY2tzXG57IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG5jb25zdCBOdW1iZXJDb250cm9sU3R5bGUgPSBjc3NgXG4ubnVtYmVyIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGZvbnQtc2l6ZTogMmVtO1xuICAgIG1hcmdpbjogLjFlbTtcbiAgICB3aWR0aDogMS41ZW07XG4gICAgaGVpZ2h0OiAxLjVlbTtcbiAgICBjb2xvcjogJHtDb250cm9sTnVtYmVyQ29sb3J9O1xuICAgIGJveC1zaGFkb3c6IDAgMXB4IDJweCByZ2JhKDAsMCwwLDAuMTYpLCAwIDFweCAycHggcmdiYSgwLDAsMCwwLjIzKTtcbiAgICBib3JkZXItcmFkaXVzOiA1MCU7XG59XG4ubnVtYmVyID4gZGl2IHtcbiAgICBtYXJnaW4tdG9wOiAuM2VtO1xufVxuYDtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxvbmUtYmxvY2tzXG57IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG5jb25zdCBQdXp6bGVTdHlsZSA9IGNzc2Bcbi5wdXp6bGUge1xuICAgIG1hcmdpbi10b3A6IC41ZW07XG4gICAgd2lkdGg6ICR7Y2VsbFdpZHRoICogOX1lbTtcbiAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgYm94LXNoYWRvdzogMCAzcHggNnB4IHJnYmEoMCwwLDAsMC4xNiksIDAgM3B4IDZweCByZ2JhKDAsMCwwLDAuMjMpO1xufVxuLnJvdyB7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGZsZXg6IDA7XG4gICAgd2lkdGg6ICR7Y2VsbFdpZHRoICogOX1lbTtcbn1cbi5yb3c6bm90KDpsYXN0LWNoaWxkKSB7XG4gICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkIGJsYWNrO1xufVxuLnJvdzpudGgtY2hpbGQoM24rMyk6bm90KDpsYXN0LWNoaWxkKSB7XG4gICAgYm9yZGVyLWJvdHRvbTogMnB4IHNvbGlkIGJsYWNrICFpbXBvcnRhbnQ7XG59XG5gO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbG9uZS1ibG9ja3NcbnsgLyogbGFuZ3VhZ2U9Q1NTICovIH1cbmNvbnN0IENpcmN1bHVhclByb2dyZXNzU3R5bGUgPSBjc3NgXG4uY2lyY3VsYXItcHJvZ3Jlc3Mge1xuICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB0b3A6IDA7XG4gICAgbGVmdDogMDtcbiAgICB0cmFuc2l0aW9uOiBmaWx0ZXIgLjRzIGVhc2UtaW4tb3V0O1xufVxuXG4uY2lyY2xlLWJnIHtcbiAgICBmaWxsOiBub25lO1xuICAgIHN0cm9rZTogI2VlZTtcbiAgICBzdHJva2Utd2lkdGg6IDMuODtcbn1cblxuLmNpcmNsZSB7XG4gICAgc3Ryb2tlOiAke0NvbnRyb2xOdW1iZXJDb2xvcn07XG4gICAgdHJhbnNpdGlvbjogc3Ryb2tlLWRhc2hhcnJheSAuNHMgZWFzZS1pbi1vdXQ7XG4gICAgZmlsbDogbm9uZTtcbiAgICBzdHJva2Utd2lkdGg6IDIuODtcbiAgICBzdHJva2UtbGluZWNhcDogcm91bmQ7XG59XG5gO1xuXG5jb25zdCBDaXJjdWxhclBhdGhEID0gJ00xOCAyLjA4NDUgYSAxNS45MTU1IDE1LjkxNTUgMCAwIDEgMCAzMS44MzEgYSAxNS45MTU1IDE1LjkxNTUgMCAwIDEgMCAtMzEuODMxJztcblxuZnVuY3Rpb24gZ2V0QmFja0dyb3VuZENvbG9yKHtcbiAgY29uZmxpY3QsIGlzUGVlciwgc2FtZVZhbHVlLCBpc1NlbGVjdGVkLFxufSkge1xuICBpZiAoY29uZmxpY3QgJiYgaXNQZWVyICYmIHNhbWVWYWx1ZSkge1xuICAgIHJldHVybiBEZWVwT3JhbmdlMjAwO1xuICB9IGVsc2UgaWYgKHNhbWVWYWx1ZSkge1xuICAgIHJldHVybiBMaWdodEJsdWUzMDA7XG4gIH0gZWxzZSBpZiAoaXNTZWxlY3RlZCkge1xuICAgIHJldHVybiBMaWdodEJsdWUyMDA7XG4gIH0gZWxzZSBpZiAoaXNQZWVyKSB7XG4gICAgcmV0dXJuIExpZ2h0Qmx1ZTEwMDtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldEZvbnRDb2xvcih7IHZhbHVlLCBjb25mbGljdCwgcHJlZmlsbGVkIH0pIHtcbiAgaWYgKGNvbmZsaWN0ICYmICFwcmVmaWxsZWQpIHtcbiAgICByZXR1cm4gRGVlcE9yYW5nZTYwMDtcbiAgfSBlbHNlIGlmICghcHJlZmlsbGVkICYmIHZhbHVlKSB7XG4gICAgcmV0dXJuIENvbnRyb2xOdW1iZXJDb2xvcjtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmNsYXNzIEdlbmVyYXRpb25VSSBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuXG4gICAgdGhpcy5zdGF0ZSA9IHsgdmFsdWU6IDMwIH07XG4gIH1cblxuICBnZW5lcmF0ZUdhbWUgPSAoKSA9PiB7XG4gICAgdGhpcy5wcm9wcy5nZW5lcmF0ZUdhbWUodGhpcy5zdGF0ZS52YWx1ZSk7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ2VuZXJhdGlvblwiPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvcHlcIj5TdGFydCB3aXRoIHt0aGlzLnN0YXRlLnZhbHVlfSBjZWxscyBwcmVmaWxsZWQ8L2Rpdj5cbiAgICAgICAgPElucHV0UmFuZ2VcbiAgICAgICAgICBtYXhWYWx1ZT17ODF9XG4gICAgICAgICAgbWluVmFsdWU9ezE3fVxuICAgICAgICAgIHZhbHVlPXt0aGlzLnN0YXRlLnZhbHVlfVxuICAgICAgICAgIG9uQ2hhbmdlPXt2YWx1ZSA9PiB0aGlzLnNldFN0YXRlKHsgdmFsdWUgfSl9XG4gICAgICAgIC8+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYnV0dG9uXCIgb25DbGljaz17dGhpcy5nZW5lcmF0ZUdhbWV9PlBsYXkgU3Vkb2t1PC9kaXY+XG4gICAgICAgIHsgLyogbGFuZ3VhZ2U9Q1NTICovIH1cbiAgICAgICAgPHN0eWxlIGpzeD57YFxuICAgICAgICAgICAgLmNvcHkge1xuICAgICAgICAgICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICAgICAgICAgICAgICBmb250LXNpemU6IDEuM2VtO1xuICAgICAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IC41ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAuZ2VuZXJhdGlvbiB7XG4gICAgICAgICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgICAgICAgICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6Z2xvYmFsKC5pbnB1dC1yYW5nZSkge1xuICAgICAgICAgICAgICAgIHdpZHRoOiA4MCU7XG4gICAgICAgICAgICAgICAgbWF4LXdpZHRoOiA1MDBweDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC5idXR0b24ge1xuICAgICAgICAgICAgICBtYXJnaW4tdG9wOiAuNWVtO1xuICAgICAgICAgICAgICBib3JkZXItcmFkaXVzOiAuMjVlbTtcbiAgICAgICAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgICAgICAgICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICAgICAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xuICAgICAgICAgICAgICBjb2xvcjogI2ZmZjtcbiAgICAgICAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gICAgICAgICAgICAgIHRyYW5zaXRpb246IGFsbCAuMjVzO1xuICAgICAgICAgICAgICBwYWRkaW5nOiA1cHggMTBweDtcbiAgICAgICAgICAgICAgZm9udC1zaXplOiAxLjRlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC5idXR0b246YWN0aXZlIHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoMHB4LCA1cHgpO1xuICAgICAgICAgICAgICBib3gtc2hhZG93OiAwIDFweCAwIDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC5idXR0b24ge1xuICAgICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAke2JhY2tHcm91bmRCbHVlfTtcbiAgICAgICAgICAgICAgYm94LXNoYWRvdzogMCAycHggNHB4IDAgJHtDb2xvcihiYWNrR3JvdW5kQmx1ZSkuZGFya2VuKDAuNSkuaHNsKCkuc3RyaW5nKCl9O1xuICAgICAgICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAuYnV0dG9uOmhvdmVyIHtcbiAgICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogJHtDb2xvcihiYWNrR3JvdW5kQmx1ZSkubGlnaHRlbigwLjIpLmhzbCgpLnN0cmluZygpfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgYH1cbiAgICAgICAgPC9zdHlsZT5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cbn1cblxuR2VuZXJhdGlvblVJLnByb3BUeXBlcyA9IHtcbiAgZ2VuZXJhdGVHYW1lOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxufTtcblxuY29uc3QgTnVtYmVyQ29udHJvbCA9ICh7IG51bWJlciwgb25DbGljaywgY29tcGxldGlvblBlcmNlbnRhZ2UgfSkgPT4gKFxuICA8ZGl2XG4gICAga2V5PXtudW1iZXJ9XG4gICAgY2xhc3NOYW1lPVwibnVtYmVyXCJcbiAgICBvbkNsaWNrPXtvbkNsaWNrfVxuICA+XG4gICAgPGRpdj57bnVtYmVyfTwvZGl2PlxuICAgIDxDaXJjbHVsYXJQcm9ncmVzcyBwZXJjZW50PXtjb21wbGV0aW9uUGVyY2VudGFnZX0gLz5cbiAgICA8c3R5bGUganN4PntOdW1iZXJDb250cm9sU3R5bGV9PC9zdHlsZT5cbiAgPC9kaXY+XG4pO1xuXG5OdW1iZXJDb250cm9sLnByb3BUeXBlcyA9IHtcbiAgbnVtYmVyOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIG9uQ2xpY2s6IFByb3BUeXBlcy5mdW5jLFxuICBjb21wbGV0aW9uUGVyY2VudGFnZTogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxufTtcblxuTnVtYmVyQ29udHJvbC5kZWZhdWx0UHJvcHMgPSB7XG4gIG9uQ2xpY2s6IG51bGwsXG59O1xuXG5jb25zdCBDZWxsID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHtcbiAgICB2YWx1ZSwgb25DbGljaywgaXNQZWVyLCBpc1NlbGVjdGVkLCBzYW1lVmFsdWUsIHByZWZpbGxlZCwgbm90ZXMsIGNvbmZsaWN0LFxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IGJhY2tncm91bmRDb2xvciA9IGdldEJhY2tHcm91bmRDb2xvcih7XG4gICAgY29uZmxpY3QsIGlzUGVlciwgc2FtZVZhbHVlLCBpc1NlbGVjdGVkLFxuICB9KTtcbiAgY29uc3QgZm9udENvbG9yID0gZ2V0Rm9udENvbG9yKHsgY29uZmxpY3QsIHByZWZpbGxlZCwgdmFsdWUgfSk7XG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJjZWxsXCIgb25DbGljaz17b25DbGlja30+XG4gICAgICB7XG4gICAgICAgIG5vdGVzID9cbiAgICAgICAgICByYW5nZSg5KS5tYXAoaSA9PlxuICAgICAgICAgICAgKFxuICAgICAgICAgICAgICA8ZGl2IGtleT17aX0gY2xhc3NOYW1lPVwibm90ZS1udW1iZXJcIj5cbiAgICAgICAgICAgICAgICB7bm90ZXMuaGFzKGkgKyAxKSAmJiAoaSArIDEpfVxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICkpIDpcbiAgICAgICAgICB2YWx1ZSAmJiB2YWx1ZVxuICAgICAgfVxuICAgICAgey8qIGxhbmd1YWdlPUNTUyAqL31cbiAgICAgIDxzdHlsZSBqc3g+e0NlbGxTdHlsZX08L3N0eWxlPlxuICAgICAgPHN0eWxlIGpzeD57YFxuICAgICAgICAgICAgICAgIC5jZWxsIHtcbiAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogJHtiYWNrZ3JvdW5kQ29sb3IgfHwgJ2luaXRpYWwnfTtcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6ICR7Zm9udENvbG9yIHx8ICdpbml0aWFsJ307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgYH1cbiAgICAgIDwvc3R5bGU+XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5DZWxsLnByb3BUeXBlcyA9IHtcbiAgLy8gY3VycmVudCBudW1iZXIgdmFsdWVcbiAgdmFsdWU6IFByb3BUeXBlcy5udW1iZXIsXG4gIC8vIGNlbGwgY2xpY2sgaGFuZGxlclxuICBvbkNsaWNrOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAvLyBpZiB0aGUgY2VsbCBpcyBhIHBlZXIgb2YgdGhlIHNlbGVjdGVkIGNlbGxcbiAgaXNQZWVyOiBQcm9wVHlwZXMuYm9vbC5pc1JlcXVpcmVkLFxuICAvLyBpZiB0aGUgY2VsbCBpcyBzZWxlY3RlZCBieSB0aGUgdXNlclxuICBpc1NlbGVjdGVkOiBQcm9wVHlwZXMuYm9vbC5pc1JlcXVpcmVkLFxuICAvLyBjdXJyZW50IGNlbGwgaGFzIHRoZSBzYW1lIHZhbHVlIGlmIHRoZSB1c2VyIHNlbGVjdGVkIGNlbGxcbiAgc2FtZVZhbHVlOiBQcm9wVHlwZXMuYm9vbC5pc1JlcXVpcmVkLFxuICAvLyBpZiB0aGlzIHdhcyBwcmVmaWxsZWQgYXMgYSBwYXJ0IG9mIHRoZSBwdXp6bGVcbiAgcHJlZmlsbGVkOiBQcm9wVHlwZXMuYm9vbC5pc1JlcXVpcmVkLFxuICAvLyBjdXJyZW50IG5vdGVzIHRha2VuIG9uIHRoZSBjZWxsXG4gIG5vdGVzOiBQcm9wVHlwZXMuaW5zdGFuY2VPZihTZXQpLFxuICAvLyBpZiB0aGUgY3VycmVudCBjZWxsIGRvZXMgbm90IHNhdGlzZnkgdGhlIGdhbWUgY29uc3RyYWludFxuICBjb25mbGljdDogUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZCxcbn07XG5cbkNlbGwuZGVmYXVsdFByb3BzID0ge1xuICBub3RlczogbnVsbCxcbiAgdmFsdWU6IG51bGwsXG59O1xuXG5jb25zdCBDaXJjbHVsYXJQcm9ncmVzcyA9ICh7IHBlcmNlbnQgfSkgPT4gKFxuICA8c3ZnIHZpZXdCb3g9XCIwIDAgMzYgMzZcIiBjbGFzc05hbWU9XCJjaXJjdWxhci1wcm9ncmVzc1wiPlxuICAgIDxwYXRoXG4gICAgICBjbGFzc05hbWU9XCJjaXJjbGUtYmdcIlxuICAgICAgZD17Q2lyY3VsYXJQYXRoRH1cbiAgICAvPlxuICAgIDxwYXRoXG4gICAgICBjbGFzc05hbWU9XCJjaXJjbGVcIlxuICAgICAgc3Ryb2tlRGFzaGFycmF5PXtgJHtwZXJjZW50ICogMTAwfSwgMTAwYH1cbiAgICAgIGQ9e0NpcmN1bGFyUGF0aER9XG4gICAgLz5cbiAgICB7IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG4gICAgPHN0eWxlIGpzeD57Q2lyY3VsdWFyUHJvZ3Jlc3NTdHlsZX08L3N0eWxlPlxuICA8L3N2Zz5cbik7XG5cbkNpcmNsdWxhclByb2dyZXNzLnByb3BUeXBlcyA9IHtcbiAgcGVyY2VudDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxufTtcblxuZnVuY3Rpb24gZ2V0Q2xpY2tIYW5kbGVyKG9uQ2xpY2ssIG9uRG91YmxlQ2xpY2ssIGRlbGF5ID0gMjUwKSB7XG4gIGxldCB0aW1lb3V0SUQgPSBudWxsO1xuICByZXR1cm4gKGV2ZW50KSA9PiB7XG4gICAgaWYgKCF0aW1lb3V0SUQpIHtcbiAgICAgIHRpbWVvdXRJRCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBvbkNsaWNrKGV2ZW50KTtcbiAgICAgICAgdGltZW91dElEID0gbnVsbDtcbiAgICAgIH0sIGRlbGF5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGltZW91dElEID0gY2xlYXJUaW1lb3V0KHRpbWVvdXRJRCk7XG4gICAgICBvbkRvdWJsZUNsaWNrKGV2ZW50KTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogbWFrZSBzaXplIDkgYXJyYXkgb2YgMHNcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZnVuY3Rpb24gbWFrZUNvdW50T2JqZWN0KCkge1xuICBjb25zdCBjb3VudE9iaiA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpICs9IDEpIGNvdW50T2JqLnB1c2goMCk7XG4gIHJldHVybiBjb3VudE9iajtcbn1cblxuLyoqXG4gKiBnaXZlbiBhIDJEIGFycmF5IG9mIG51bWJlcnMgYXMgdGhlIGluaXRpYWwgcHV6emxlLCBnZW5lcmF0ZSB0aGUgaW5pdGlhbCBnYW1lIHN0YXRlXG4gKiBAcGFyYW0gcHV6emxlXG4gKiBAcmV0dXJucyB7YW55fVxuICovXG5mdW5jdGlvbiBtYWtlQm9hcmQoeyBwdXp6bGUgfSkge1xuICAvLyBjcmVhdGUgaW5pdGlhbCBjb3VudCBvYmplY3QgdG8ga2VlcCB0cmFjayBvZiBjb25mbGljdHMgcGVyIG51bWJlciB2YWx1ZVxuICBjb25zdCByb3dzID0gQXJyYXkuZnJvbShBcnJheSg5KS5rZXlzKCkpLm1hcCgoKSA9PiBtYWtlQ291bnRPYmplY3QoKSk7XG4gIGNvbnN0IGNvbHVtbnMgPSBBcnJheS5mcm9tKEFycmF5KDkpLmtleXMoKSkubWFwKCgpID0+IG1ha2VDb3VudE9iamVjdCgpKTtcbiAgY29uc3Qgc3F1YXJlcyA9IEFycmF5LmZyb20oQXJyYXkoOSkua2V5cygpKS5tYXAoKCkgPT4gbWFrZUNvdW50T2JqZWN0KCkpO1xuICBjb25zdCByZXN1bHQgPSBwdXp6bGUubWFwKChyb3csIGkpID0+IChcbiAgICByb3cubWFwKChjZWxsLCBqKSA9PiB7XG4gICAgICBpZiAoY2VsbCkge1xuICAgICAgICByb3dzW2ldW2NlbGxdICs9IDE7XG4gICAgICAgIGNvbHVtbnNbal1bY2VsbF0gKz0gMTtcbiAgICAgICAgc3F1YXJlc1soKE1hdGguZmxvb3IoaSAvIDMpKSAqIDMpICsgTWF0aC5mbG9vcihqIC8gMyldW2NlbGxdICs9IDE7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogcHV6emxlW2ldW2pdID4gMCA/IHB1enpsZVtpXVtqXSA6IG51bGwsXG4gICAgICAgIHByZWZpbGxlZDogISFwdXp6bGVbaV1bal0sXG4gICAgICB9O1xuICAgIH0pXG4gICkpO1xuICByZXR1cm4gZnJvbUpTKHsgcHV6emxlOiByZXN1bHQsIHNlbGVjdGVkOiBmYWxzZSwgY2hvaWNlczogeyByb3dzLCBjb2x1bW5zLCBzcXVhcmVzIH0gfSk7XG59XG5cbi8qKlxuICogZ2l2ZSB0aGUgY29vcmRpbmF0ZSB1cGRhdGUgdGhlIGN1cnJlbnQgYm9hcmQgd2l0aCBhIG51bWJlciBjaG9pY2VcbiAqIEBwYXJhbSB4XG4gKiBAcGFyYW0geVxuICogQHBhcmFtIG51bWJlclxuICogQHBhcmFtIGZpbGwgd2hldGhlciB0byBzZXQgb3IgdW5zZXRcbiAqIEBwYXJhbSBib2FyZCB0aGUgaW1tdXRhYmxlIGJvYXJkIGdpdmVuIHRvIGNoYW5nZVxuICovXG5mdW5jdGlvbiB1cGRhdGVCb2FyZFdpdGhOdW1iZXIoe1xuICB4LCB5LCBudW1iZXIsIGZpbGwgPSB0cnVlLCBib2FyZCxcbn0pIHtcbiAgbGV0IGNlbGwgPSBib2FyZC5nZXQoJ3B1enpsZScpLmdldEluKFt4LCB5XSk7XG4gIC8vIGRlbGV0ZSBpdHMgbm90ZXNcbiAgY2VsbCA9IGNlbGwuZGVsZXRlKCdub3RlcycpO1xuICAvLyBzZXQgb3IgdW5zZXQgaXRzIHZhbHVlIGRlcGVuZGluZyBvbiBgZmlsbGBcbiAgY2VsbCA9IGZpbGwgPyBjZWxsLnNldCgndmFsdWUnLCBudW1iZXIpIDogY2VsbC5kZWxldGUoJ3ZhbHVlJyk7XG4gIGNvbnN0IGluY3JlbWVudCA9IGZpbGwgPyAxIDogLTE7XG4gIC8vIHVwZGF0ZSB0aGUgY3VycmVudCBncm91cCBjaG9pY2VzXG4gIGNvbnN0IHJvd1BhdGggPSBbJ2Nob2ljZXMnLCAncm93cycsIHgsIG51bWJlcl07XG4gIGNvbnN0IGNvbHVtblBhdGggPSBbJ2Nob2ljZXMnLCAnY29sdW1ucycsIHksIG51bWJlcl07XG4gIGNvbnN0IHNxdWFyZVBhdGggPSBbJ2Nob2ljZXMnLCAnc3F1YXJlcycsXG4gICAgKChNYXRoLmZsb29yKHggLyAzKSkgKiAzKSArIE1hdGguZmxvb3IoeSAvIDMpLCBudW1iZXJdO1xuICByZXR1cm4gYm9hcmQuc2V0SW4ocm93UGF0aCwgYm9hcmQuZ2V0SW4ocm93UGF0aCkgKyBpbmNyZW1lbnQpXG4gICAgLnNldEluKGNvbHVtblBhdGgsIGJvYXJkLmdldEluKGNvbHVtblBhdGgpICsgaW5jcmVtZW50KVxuICAgIC5zZXRJbihzcXVhcmVQYXRoLCBib2FyZC5nZXRJbihzcXVhcmVQYXRoKSArIGluY3JlbWVudClcbiAgICAuc2V0SW4oWydwdXp6bGUnLCB4LCB5XSwgY2VsbCk7XG59XG5cbmZ1bmN0aW9uIGdldE51bWJlck9mR3JvdXBzQXNzaWduZWRGb3JOdW1iZXIobnVtYmVyLCBncm91cHMpIHtcbiAgcmV0dXJuIGdyb3Vwcy5yZWR1Y2UoKGFjY3VtdWxhdG9yLCByb3cpID0+XG4gICAgYWNjdW11bGF0b3IgKyAocm93LmdldChudW1iZXIpID4gMCA/IDEgOiAwKSwgMCk7XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3Qvbm8tbXVsdGktY29tcFxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW5kZXggZXh0ZW5kcyBDb21wb25lbnQge1xuICBzdGF0ZSA9IHt9O1xuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgIGlmICgnc2VydmljZVdvcmtlcicgaW4gbmF2aWdhdG9yKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICAgIG5hdmlnYXRvci5zZXJ2aWNlV29ya2VyXG4gICAgICAgIC5yZWdpc3RlcignL3NlcnZpY2Utd29ya2VyLmpzJylcbiAgICAgICAgLnRoZW4oKHJlZykgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdTZXJ2aWNlV29ya2VyIHNjb3BlOiAnLCByZWcuc2NvcGUpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdzZXJ2aWNlIHdvcmtlciByZWdpc3RyYXRpb24gc3VjY2Vzc2Z1bCcpO1xuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgIGNvbnNvbGUud2Fybignc2VydmljZSB3b3JrZXIgcmVnaXN0cmF0aW9uIGZhaWxlZCcsIGVyci5tZXNzYWdlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICBcbiAgICBmZXRjaCgnL2FwaS9zb2NrZXRpbycpLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgY29uc3Qgc29ja2V0ID0gaW8oKVxuXG4gICAgICBzb2NrZXQub24oJ2Nvbm5lY3QnLCAoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdjb25uZWN0JylcbiAgICAgICAgc29ja2V0LmVtaXQoJ2hlbGxvJylcbiAgICAgIH0pXG5cbiAgICAgIHNvY2tldC5vbignaGVsbG8nLCBkYXRhID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ2hlbGxvJywgZGF0YSlcbiAgICAgIH0pXG5cbiAgICAgIHNvY2tldC5vbignYSB1c2VyIGNvbm5lY3RlZCcsICgpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ2EgdXNlciBjb25uZWN0ZWQnKVxuICAgICAgfSlcblxuICAgICAgc29ja2V0Lm9uKCdkaXNjb25uZWN0JywgKCkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZygnZGlzY29ubmVjdCcpXG4gICAgICB9KVxuICAgIH0pXG4gICBcbiAgfVxuICBnZXRTZWxlY3RlZENlbGwoKSB7XG4gICAgY29uc3QgeyBib2FyZCB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBzZWxlY3RlZCA9IGJvYXJkLmdldCgnc2VsZWN0ZWQnKTtcbiAgICByZXR1cm4gc2VsZWN0ZWQgJiYgYm9hcmQuZ2V0KCdwdXp6bGUnKS5nZXRJbihbc2VsZWN0ZWQueCwgc2VsZWN0ZWQueV0pO1xuICB9XG5cbiAgLy8gZ2V0IHRoZSBtaW4gYmV0d2VlbiBpdHMgY29tcGxldGlvbiBpbiByb3dzLCBjb2x1bW5zIGFuZCBzcXVhcmVzLlxuICBnZXROdW1iZXJWYWx1ZUNvdW50KG51bWJlcikge1xuICAgIGNvbnN0IHJvd3MgPSB0aGlzLnN0YXRlLmJvYXJkLmdldEluKFsnY2hvaWNlcycsICdyb3dzJ10pO1xuICAgIGNvbnN0IGNvbHVtbnMgPSB0aGlzLnN0YXRlLmJvYXJkLmdldEluKFsnY2hvaWNlcycsICdjb2x1bW5zJ10pO1xuICAgIGNvbnN0IHNxdWFyZXMgPSB0aGlzLnN0YXRlLmJvYXJkLmdldEluKFsnY2hvaWNlcycsICdzcXVhcmVzJ10pO1xuICAgIHJldHVybiBNYXRoLm1pbihcbiAgICAgIGdldE51bWJlck9mR3JvdXBzQXNzaWduZWRGb3JOdW1iZXIobnVtYmVyLCBzcXVhcmVzKSxcbiAgICAgIE1hdGgubWluKFxuICAgICAgICBnZXROdW1iZXJPZkdyb3Vwc0Fzc2lnbmVkRm9yTnVtYmVyKG51bWJlciwgcm93cyksXG4gICAgICAgIGdldE51bWJlck9mR3JvdXBzQXNzaWduZWRGb3JOdW1iZXIobnVtYmVyLCBjb2x1bW5zKSxcbiAgICAgICksXG4gICAgKTtcbiAgfVxuXG4gIGdlbmVyYXRlR2FtZSA9IChmaW5hbENvdW50ID0gMjApID0+IHtcbiAgICAvLyBnZXQgYSBmaWxsZWQgcHV6emxlIGdlbmVyYXRlZFxuICAgIGNvbnN0IHNvbHV0aW9uID0gbWFrZVB1enpsZSgpO1xuICAgIC8vIHBsdWNrIHZhbHVlcyBmcm9tIGNlbGxzIHRvIGNyZWF0ZSB0aGUgZ2FtZVxuICAgIGNvbnN0IHsgcHV6emxlIH0gPSBwbHVjayhzb2x1dGlvbiwgZmluYWxDb3VudCk7XG4gICAgLy8gaW5pdGlhbGl6ZSB0aGUgYm9hcmQgd2l0aCBjaG9pY2UgY291bnRzXG4gICAgY29uc3QgYm9hcmQgPSBtYWtlQm9hcmQoeyBwdXp6bGUgfSk7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBib2FyZCwgaGlzdG9yeTogTGlzdC5vZihib2FyZCksIGhpc3RvcnlPZmZTZXQ6IDAsIHNvbHV0aW9uLFxuICAgIH0pO1xuICB9XG5cbiAgYWRkTnVtYmVyQXNOb3RlID0gKG51bWJlcikgPT4ge1xuICAgIGxldCB7IGJvYXJkIH0gPSB0aGlzLnN0YXRlO1xuICAgIGxldCBzZWxlY3RlZENlbGwgPSB0aGlzLmdldFNlbGVjdGVkQ2VsbCgpO1xuICAgIGlmICghc2VsZWN0ZWRDZWxsKSByZXR1cm47XG4gICAgY29uc3QgcHJlZmlsbGVkID0gc2VsZWN0ZWRDZWxsLmdldCgncHJlZmlsbGVkJyk7XG4gICAgaWYgKHByZWZpbGxlZCkgcmV0dXJuO1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gYm9hcmQuZ2V0KCdzZWxlY3RlZCcpO1xuICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHNlbGVjdGVkQ2VsbC5nZXQoJ3ZhbHVlJyk7XG4gICAgaWYgKGN1cnJlbnRWYWx1ZSkge1xuICAgICAgYm9hcmQgPSB1cGRhdGVCb2FyZFdpdGhOdW1iZXIoe1xuICAgICAgICB4LCB5LCBudW1iZXI6IGN1cnJlbnRWYWx1ZSwgZmlsbDogZmFsc2UsIGJvYXJkOiB0aGlzLnN0YXRlLmJvYXJkLFxuICAgICAgfSk7XG4gICAgfVxuICAgIGxldCBub3RlcyA9IHNlbGVjdGVkQ2VsbC5nZXQoJ25vdGVzJykgfHwgU2V0KCk7XG4gICAgaWYgKG5vdGVzLmhhcyhudW1iZXIpKSB7XG4gICAgICBub3RlcyA9IG5vdGVzLmRlbGV0ZShudW1iZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub3RlcyA9IG5vdGVzLmFkZChudW1iZXIpO1xuICAgIH1cbiAgICBzZWxlY3RlZENlbGwgPSBzZWxlY3RlZENlbGwuc2V0KCdub3RlcycsIG5vdGVzKTtcbiAgICBzZWxlY3RlZENlbGwgPSBzZWxlY3RlZENlbGwuZGVsZXRlKCd2YWx1ZScpO1xuICAgIGJvYXJkID0gYm9hcmQuc2V0SW4oWydwdXp6bGUnLCB4LCB5XSwgc2VsZWN0ZWRDZWxsKTtcbiAgICB0aGlzLnVwZGF0ZUJvYXJkKGJvYXJkKTtcbiAgfTtcblxuICB1cGRhdGVCb2FyZCA9IChuZXdCb2FyZCkgPT4ge1xuICAgIGxldCB7IGhpc3RvcnkgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgeyBoaXN0b3J5T2ZmU2V0IH0gPSB0aGlzLnN0YXRlO1xuICAgIC8vIGFueXRoaW5nIGJlZm9yZSBjdXJyZW50IHN0ZXAgaXMgc3RpbGwgaW4gaGlzdG9yeVxuICAgIGhpc3RvcnkgPSBoaXN0b3J5LnNsaWNlKDAsIGhpc3RvcnlPZmZTZXQgKyAxKTtcbiAgICAvLyBhZGQgaXRzZWxmIG9udG8gdGhlIGhpc3RvcnlcbiAgICBoaXN0b3J5ID0gaGlzdG9yeS5wdXNoKG5ld0JvYXJkKTtcbiAgICAvLyB1cGRhdGUgdGhlIGdhbWVcbiAgICB0aGlzLnNldFN0YXRlKHsgYm9hcmQ6IG5ld0JvYXJkLCBoaXN0b3J5LCBoaXN0b3J5T2ZmU2V0OiBoaXN0b3J5LnNpemUgLSAxIH0pO1xuICB9O1xuXG4gIGNhblVuZG8gPSAoKSA9PiB0aGlzLnN0YXRlLmhpc3RvcnlPZmZTZXQgPiAwXG5cbiAgcmVkbyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGhpc3RvcnkgfSA9IHRoaXMuc3RhdGU7XG4gICAgbGV0IHsgaGlzdG9yeU9mZlNldCB9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAoaGlzdG9yeS5zaXplKSB7XG4gICAgICBoaXN0b3J5T2ZmU2V0ID0gTWF0aC5taW4oaGlzdG9yeS5zaXplIC0gMSwgaGlzdG9yeU9mZlNldCArIDEpO1xuICAgICAgY29uc3QgYm9hcmQgPSBoaXN0b3J5LmdldChoaXN0b3J5T2ZmU2V0KTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBib2FyZCwgaGlzdG9yeU9mZlNldCB9KTtcbiAgICB9XG4gIH07XG5cbiAgdW5kbyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGhpc3RvcnkgfSA9IHRoaXMuc3RhdGU7XG4gICAgbGV0IHsgaGlzdG9yeU9mZlNldCwgYm9hcmQgfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKGhpc3Rvcnkuc2l6ZSkge1xuICAgICAgaGlzdG9yeU9mZlNldCA9IE1hdGgubWF4KDAsIGhpc3RvcnlPZmZTZXQgLSAxKTtcbiAgICAgIGJvYXJkID0gaGlzdG9yeS5nZXQoaGlzdG9yeU9mZlNldCk7XG4gICAgICB0aGlzLnNldFN0YXRlKHsgYm9hcmQsIGhpc3RvcnlPZmZTZXQsIGhpc3RvcnkgfSk7XG4gICAgfVxuICB9O1xuXG4gIGVyYXNlU2VsZWN0ZWQgPSAoKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0ZWRDZWxsID0gdGhpcy5nZXRTZWxlY3RlZENlbGwoKTtcbiAgICBpZiAoIXNlbGVjdGVkQ2VsbCkgcmV0dXJuO1xuICAgIHRoaXMuZmlsbE51bWJlcihmYWxzZSk7XG4gIH1cblxuICBmaWxsU2VsZWN0ZWRXaXRoU29sdXRpb24gPSAoKSA9PiB7XG4gICAgY29uc3QgeyBib2FyZCwgc29sdXRpb24gfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3Qgc2VsZWN0ZWRDZWxsID0gdGhpcy5nZXRTZWxlY3RlZENlbGwoKTtcbiAgICBpZiAoIXNlbGVjdGVkQ2VsbCkgcmV0dXJuO1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gYm9hcmQuZ2V0KCdzZWxlY3RlZCcpO1xuICAgIHRoaXMuZmlsbE51bWJlcihzb2x1dGlvblt4XVt5XSk7XG4gIH1cblxuXG4gIC8vIGZpbGwgY3VycmVudGx5IHNlbGVjdGVkIGNlbGwgd2l0aCBudW1iZXJcbiAgZmlsbE51bWJlciA9IChudW1iZXIpID0+IHtcbiAgICBsZXQgeyBib2FyZCB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBzZWxlY3RlZENlbGwgPSB0aGlzLmdldFNlbGVjdGVkQ2VsbCgpO1xuICAgIC8vIG5vLW9wIGlmIG5vdGhpbmcgaXMgc2VsZWN0ZWRcbiAgICBpZiAoIXNlbGVjdGVkQ2VsbCkgcmV0dXJuO1xuICAgIGNvbnN0IHByZWZpbGxlZCA9IHNlbGVjdGVkQ2VsbC5nZXQoJ3ByZWZpbGxlZCcpO1xuICAgIC8vIG5vLW9wIGlmIGl0IGlzIHJlZmlsbGVkXG4gICAgaWYgKHByZWZpbGxlZCkgcmV0dXJuO1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gYm9hcmQuZ2V0KCdzZWxlY3RlZCcpO1xuICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHNlbGVjdGVkQ2VsbC5nZXQoJ3ZhbHVlJyk7XG4gICAgLy8gcmVtb3ZlIHRoZSBjdXJyZW50IHZhbHVlIGFuZCB1cGRhdGUgdGhlIGdhbWUgc3RhdGVcbiAgICBpZiAoY3VycmVudFZhbHVlKSB7XG4gICAgICBib2FyZCA9IHVwZGF0ZUJvYXJkV2l0aE51bWJlcih7XG4gICAgICAgIHgsIHksIG51bWJlcjogY3VycmVudFZhbHVlLCBmaWxsOiBmYWxzZSwgYm9hcmQ6IHRoaXMuc3RhdGUuYm9hcmQsXG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gdXBkYXRlIHRvIG5ldyBudW1iZXIgaWYgYW55XG4gICAgY29uc3Qgc2V0TnVtYmVyID0gY3VycmVudFZhbHVlICE9PSBudW1iZXIgJiYgbnVtYmVyO1xuICAgIGlmIChzZXROdW1iZXIpIHtcbiAgICAgIGJvYXJkID0gdXBkYXRlQm9hcmRXaXRoTnVtYmVyKHtcbiAgICAgICAgeCwgeSwgbnVtYmVyLCBmaWxsOiB0cnVlLCBib2FyZCxcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZUJvYXJkKGJvYXJkKTtcbiAgfTtcblxuICBzZWxlY3RDZWxsID0gKHgsIHkpID0+IHtcbiAgICBsZXQgeyBib2FyZCB9ID0gdGhpcy5zdGF0ZTtcbiAgICBib2FyZCA9IGJvYXJkLnNldCgnc2VsZWN0ZWQnLCB7IHgsIHkgfSk7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IGJvYXJkIH0pO1xuICB9O1xuXG4gIGlzQ29uZmxpY3QoaSwgaikge1xuICAgIGNvbnN0IHsgdmFsdWUgfSA9IHRoaXMuc3RhdGUuYm9hcmQuZ2V0SW4oWydwdXp6bGUnLCBpLCBqXSkudG9KU09OKCk7XG4gICAgaWYgKCF2YWx1ZSkgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IHJvd0NvbmZsaWN0ID1cbiAgICAgIHRoaXMuc3RhdGUuYm9hcmQuZ2V0SW4oWydjaG9pY2VzJywgJ3Jvd3MnLCBpLCB2YWx1ZV0pID4gMTtcbiAgICBjb25zdCBjb2x1bW5Db25mbGljdCA9XG4gICAgICB0aGlzLnN0YXRlLmJvYXJkLmdldEluKFsnY2hvaWNlcycsICdjb2x1bW5zJywgaiwgdmFsdWVdKSA+IDE7XG4gICAgY29uc3Qgc3F1YXJlQ29uZmxpY3QgPVxuICAgICAgdGhpcy5zdGF0ZS5ib2FyZC5nZXRJbihbJ2Nob2ljZXMnLCAnc3F1YXJlcycsXG4gICAgICAgICgoTWF0aC5mbG9vcihpIC8gMykpICogMykgKyBNYXRoLmZsb29yKGogLyAzKSwgdmFsdWVdKSA+IDE7XG4gICAgcmV0dXJuIHJvd0NvbmZsaWN0IHx8IGNvbHVtbkNvbmZsaWN0IHx8IHNxdWFyZUNvbmZsaWN0O1xuICB9XG5cbiAgcmVuZGVyQ2VsbChjZWxsLCB4LCB5KSB7XG4gICAgY29uc3QgeyBib2FyZCB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBzZWxlY3RlZCA9IHRoaXMuZ2V0U2VsZWN0ZWRDZWxsKCk7XG4gICAgY29uc3QgeyB2YWx1ZSwgcHJlZmlsbGVkLCBub3RlcyB9ID0gY2VsbC50b0pTT04oKTtcbiAgICBjb25zdCBjb25mbGljdCA9IHRoaXMuaXNDb25mbGljdCh4LCB5KTtcbiAgICBjb25zdCBwZWVyID0gYXJlQ29vcmRpbmF0ZVBlZXJzKHsgeCwgeSB9LCBib2FyZC5nZXQoJ3NlbGVjdGVkJykpO1xuICAgIGNvbnN0IHNhbWVWYWx1ZSA9ICEhKHNlbGVjdGVkICYmIHNlbGVjdGVkLmdldCgndmFsdWUnKVxuICAgICAgJiYgdmFsdWUgPT09IHNlbGVjdGVkLmdldCgndmFsdWUnKSk7XG5cbiAgICBjb25zdCBpc1NlbGVjdGVkID0gY2VsbCA9PT0gc2VsZWN0ZWQ7XG4gICAgcmV0dXJuICg8Q2VsbFxuICAgICAgcHJlZmlsbGVkPXtwcmVmaWxsZWR9XG4gICAgICBub3Rlcz17bm90ZXN9XG4gICAgICBzYW1lVmFsdWU9e3NhbWVWYWx1ZX1cbiAgICAgIGlzU2VsZWN0ZWQ9e2lzU2VsZWN0ZWR9XG4gICAgICBpc1BlZXI9e3BlZXJ9XG4gICAgICB2YWx1ZT17dmFsdWV9XG4gICAgICBvbkNsaWNrPXsoKSA9PiB7IHRoaXMuc2VsZWN0Q2VsbCh4LCB5KTsgfX1cbiAgICAgIGtleT17eX1cbiAgICAgIHg9e3h9XG4gICAgICB5PXt5fVxuICAgICAgY29uZmxpY3Q9e2NvbmZsaWN0fVxuICAgIC8+KTtcbiAgfVxuXG4gIHJlbmRlck51bWJlckNvbnRyb2woKSB7XG4gICAgY29uc3Qgc2VsZWN0ZWRDZWxsID0gdGhpcy5nZXRTZWxlY3RlZENlbGwoKTtcbiAgICBjb25zdCBwcmVmaWxsZWQgPSBzZWxlY3RlZENlbGwgJiYgc2VsZWN0ZWRDZWxsLmdldCgncHJlZmlsbGVkJyk7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29udHJvbFwiPlxuICAgICAgICB7cmFuZ2UoOSkubWFwKChpKSA9PiB7XG4gICAgICAgICAgY29uc3QgbnVtYmVyID0gaSArIDE7XG4gICAgICAgICAgLy8gaGFuZGxlcyBiaW5kaW5nIHNpbmdsZSBjbGljayBhbmQgZG91YmxlIGNsaWNrIGNhbGxiYWNrc1xuICAgICAgICAgIGNvbnN0IGNsaWNrSGFuZGxlID0gZ2V0Q2xpY2tIYW5kbGVyKFxuICAgICAgICAgICAgKCkgPT4geyB0aGlzLmZpbGxOdW1iZXIobnVtYmVyKTsgfSxcbiAgICAgICAgICAgICgpID0+IHsgdGhpcy5hZGROdW1iZXJBc05vdGUobnVtYmVyKTsgfSxcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8TnVtYmVyQ29udHJvbFxuICAgICAgICAgICAgICBrZXk9e251bWJlcn1cbiAgICAgICAgICAgICAgbnVtYmVyPXtudW1iZXJ9XG4gICAgICAgICAgICAgIG9uQ2xpY2s9eyFwcmVmaWxsZWQgPyBjbGlja0hhbmRsZSA6IHVuZGVmaW5lZH1cbiAgICAgICAgICAgICAgY29tcGxldGlvblBlcmNlbnRhZ2U9e3RoaXMuZ2V0TnVtYmVyVmFsdWVDb3VudChudW1iZXIpIC8gOX1cbiAgICAgICAgICAgIC8+KTtcbiAgICAgICAgfSl9XG4gICAgICAgIDxzdHlsZSBqc3g+e0NvbnRyb2xTdHlsZX08L3N0eWxlPlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxuXG4gIHJlbmRlckFjdGlvbnMoKSB7XG4gICAgY29uc3QgeyBoaXN0b3J5IH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IHNlbGVjdGVkQ2VsbCA9IHRoaXMuZ2V0U2VsZWN0ZWRDZWxsKCk7XG4gICAgY29uc3QgcHJlZmlsbGVkID0gc2VsZWN0ZWRDZWxsICYmIHNlbGVjdGVkQ2VsbC5nZXQoJ3ByZWZpbGxlZCcpO1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImFjdGlvbnNcIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJhY3Rpb25cIiBvbkNsaWNrPXtoaXN0b3J5LnNpemUgPyB0aGlzLnVuZG8gOiBudWxsfT5cbiAgICAgICAgICA8UmVsb2FkSWNvbiAvPlVuZG9cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWN0aW9uIHJlZG9cIiBvbkNsaWNrPXtoaXN0b3J5LnNpemUgPyB0aGlzLnJlZG8gOiBudWxsfT5cbiAgICAgICAgICA8UmVsb2FkSWNvbiAvPlJlZG9cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWN0aW9uXCIgb25DbGljaz17IXByZWZpbGxlZCA/IHRoaXMuZXJhc2VTZWxlY3RlZCA6IG51bGx9PlxuICAgICAgICAgIDxSZW1vdmVJY29uIC8+RXJhc2VcbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXZcbiAgICAgICAgICBjbGFzc05hbWU9XCJhY3Rpb25cIlxuICAgICAgICAgIG9uQ2xpY2s9eyFwcmVmaWxsZWQgP1xuICAgICAgICAgIHRoaXMuZmlsbFNlbGVjdGVkV2l0aFNvbHV0aW9uIDogbnVsbH1cbiAgICAgICAgPlxuICAgICAgICAgIDxMb3VwZUljb24gLz5IaW50XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8c3R5bGUganN4PntBY3Rpb25zU3R5bGV9PC9zdHlsZT5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cblxuICByZW5kZXJQdXp6bGUoKSB7XG4gICAgY29uc3QgeyBib2FyZCB9ID0gdGhpcy5zdGF0ZTtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJwdXp6bGVcIj5cbiAgICAgICAge2JvYXJkLmdldCgncHV6emxlJykubWFwKChyb3csIGkpID0+IChcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3Qvbm8tYXJyYXktaW5kZXgta2V5XG4gICAgICAgICAgPGRpdiBrZXk9e2l9IGNsYXNzTmFtZT1cInJvd1wiPlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICByb3cubWFwKChjZWxsLCBqKSA9PiB0aGlzLnJlbmRlckNlbGwoY2VsbCwgaSwgaikpLnRvQXJyYXkoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICApKS50b0FycmF5KCl9XG4gICAgICAgIDxzdHlsZSBqc3g+e1B1enpsZVN0eWxlfTwvc3R5bGU+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG5cbiAgcmVuZGVyQ29udHJvbHMoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29udHJvbHNcIj5cbiAgICAgICAge3RoaXMucmVuZGVyTnVtYmVyQ29udHJvbCgpfVxuICAgICAgICB7dGhpcy5yZW5kZXJBY3Rpb25zKCl9XG4gICAgICAgIHsgLyogbGFuZ3VhZ2U9Q1NTICovIH1cbiAgICAgICAgPHN0eWxlIGpzeD57YFxuICAgICAgICAgICAgLmNvbnRyb2xzIHtcbiAgICAgICAgICAgICAgICBtYXJnaW4tdG9wOiAuM2VtO1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgICAgICAgZmxleC13cmFwOiB3cmFwO1xuICAgICAgICAgICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICAgICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICAgICAgICAgIHBhZGRpbmc6IC41ZW0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgYH1cbiAgICAgICAgPC9zdHlsZT5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cblxuICByZW5kZXJHZW5lcmF0aW9uVUkoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxHZW5lcmF0aW9uVUkgZ2VuZXJhdGVHYW1lPXt0aGlzLmdlbmVyYXRlR2FtZX0gLz5cbiAgICApO1xuICB9XG5cbiAgcmVuZGVySGVhZGVyKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImhlYWRlclwiPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm5ldy1nYW1lXCIgb25DbGljaz17KCkgPT4gdGhpcy5zZXRTdGF0ZSh7IGJvYXJkOiBmYWxzZSB9KX0+XG4gICAgICAgICAgPFJldHVybkljb24gLz5cbiAgICAgICAgICA8ZGl2Pk5ldyBHYW1lPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8VGlwIC8+XG4gICAgICAgIHsgLyogbGFuZ3VhZ2U9Q1NTICovIH1cbiAgICAgICAgPHN0eWxlIGpzeD57YFxuICAgICAgICAgICAgLmhlYWRlciB7XG4gICAgICAgICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gICAgICAgICAgICAgICAgbWF4LXdpZHRoOiA1MDBweDtcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiAwIDAuNWVtO1xuICAgICAgICAgICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAubmV3LWdhbWUge1xuICAgICAgICAgICAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICAgICAgICAgICAgICBtYXJnaW4tdG9wOiAuMmVtO1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6IGlubGluZS1mbGV4O1xuICAgICAgICAgICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgICAgICAgICAgcGFkZGluZzogLjJlbSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLm5ldy1nYW1lIDpnbG9iYWwoc3ZnKSB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxZW07XG4gICAgICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogLjNlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgYH1cbiAgICAgICAgPC9zdHlsZT5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBib2FyZCB9ID0gdGhpcy5zdGF0ZTtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJib2R5XCI+XG4gICAgICAgIDxOZXh0SGVhZD5cbiAgICAgICAgICA8dGl0bGU+U3Vkb2t1IEV2b2x2ZWQ8L3RpdGxlPlxuICAgICAgICAgIDxtZXRhIG5hbWU9XCJ2aWV3cG9ydFwiIGNvbnRlbnQ9XCJpbml0aWFsLXNjYWxlPTEuMCwgd2lkdGg9ZGV2aWNlLXdpZHRoXCIgLz5cbiAgICAgICAgICA8bWV0YSBuYW1lPVwiZGVzY3JpcHRpb25cIiBjb250ZW50PXtEZXNjcmlwdGlvbn0gLz5cbiAgICAgICAgICA8bGluayBocmVmPVwiaHR0cHM6Ly9mb250cy5nb29nbGVhcGlzLmNvbS9jc3M/ZmFtaWx5PVNwZWNpYWwrRWxpdGVcIiByZWw9XCJzdHlsZXNoZWV0XCIgLz5cbiAgICAgICAgICA8bWV0YSBwcm9wZXJ0eT1cIm9nOnVybFwiIGNvbnRlbnQ9XCJodHRwczovL3N1ZG9rdS5zaXRpYW5saXUuY29tL1wiIC8+XG4gICAgICAgICAgPG1ldGEgcHJvcGVydHk9XCJvZzp0aXRsZVwiIGNvbnRlbnQ9XCJTdWRva3UgRXZvbHZlZFwiIC8+XG4gICAgICAgICAgPG1ldGEgcHJvcGVydHk9XCJvZzp0eXBlXCIgY29udGVudD1cIndlYnNpdGVcIiAvPlxuICAgICAgICAgIDxtZXRhIHByb3BlcnR5PVwib2c6ZGVzY3JpcHRpb25cIiBjb250ZW50PXtEZXNjcmlwdGlvbn0gLz5cbiAgICAgICAgICA8bWV0YSBwcm9wZXJ0eT1cIm9nOmltYWdlXCIgY29udGVudD1cImh0dHBzOi8vc3Vkb2t1LnNpdGlhbmxpdS5jb20vc3RhdGljL29nLWltYWdlLnBuZ1wiIC8+XG4gICAgICAgIDwvTmV4dEhlYWQ+XG4gICAgICAgIHshYm9hcmQgJiYgdGhpcy5yZW5kZXJHZW5lcmF0aW9uVUkoKX1cbiAgICAgICAge2JvYXJkICYmIHRoaXMucmVuZGVySGVhZGVyKCl9XG4gICAgICAgIHtib2FyZCAmJiB0aGlzLnJlbmRlclB1enpsZSgpfVxuICAgICAgICB7Ym9hcmQgJiYgdGhpcy5yZW5kZXJDb250cm9scygpfVxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInJvb3RlclwiPlxuICAgICAgICAgIE1hZGUgd2l0aCA8c3Bhbj7inaTvuI88L3NwYW4+77iPIEJ5IDxhIGhyZWY9XCJodHRwczovL3d3dy5zaXRpYW5saXUuY29tL1wiPlNpdGlhbiBMaXU8L2E+IHwgPGEgaHJlZj1cImh0dHBzOi8vbWVkaXVtLmNvbS9Ac2l0aWFubGl1XzU3NjgwL2J1aWxkaW5nLWEtc3Vkb2t1LWdhbWUtaW4tcmVhY3QtY2E2NjM5MTU3MTJcIj5CbG9nIFBvc3Q8L2E+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICB7IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG4gICAgICAgIDxzdHlsZSBqc3g+e2BcbiAgICAgICAgICAgIDpnbG9iYWwoYm9keSksIC5ib2R5IHtcbiAgICAgICAgICAgICAgICBmb250LWZhbWlseTogJ1NwZWNpYWwgRWxpdGUnLCBjdXJzaXZlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLmJvZHkge1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICAgICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICAgICAgICAgIGhlaWdodDogMTAwdmg7XG4gICAgICAgICAgICAgICAgd2lkdGg6IDEwMHZ3O1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEBtZWRpYSAobWluLXdpZHRoOiA4MDBweCkgYW5kIChtaW4taGVpZ2h0OiA5MzBweCl7XG4gICAgICAgICAgICAgICAgOmdsb2JhbCguaGVhZGVyLCAucHV6emxlLCAuY29udHJvbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9udC1zaXplOiAxLjVlbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBAbWVkaWEgKG1heC13aWR0aDogODAwcHgpIGFuZCAobWluLXdpZHRoOiA2MDBweCl7XG4gICAgICAgICAgICAgICAgOmdsb2JhbCguaGVhZGVyLCAucHV6emxlLCAuY29udHJvbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9udC1zaXplOiAxLjJlbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBAbWVkaWEgKG1heC1oZWlnaHQ6IDkzMHB4KSBhbmQgKG1pbi1oZWlnaHQ6IDgwMHB4KSBhbmQgKG1pbi13aWR0aDogNjAwcHgpe1xuICAgICAgICAgICAgICAgIDpnbG9iYWwoLmhlYWRlciwgLnB1enpsZSwgLmNvbnRyb2xzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvbnQtc2l6ZTogMS4yZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQG1lZGlhIChtYXgtaGVpZ2h0OiA4MDBweCkgYW5kIChtaW4taGVpZ2h0OiA2MDBweCkgYW5kIChtaW4td2lkdGg6IDM3MHB4KXtcbiAgICAgICAgICAgICAgICA6Z2xvYmFsKC5oZWFkZXIsIC5wdXp6bGUsIC5jb250cm9scykge1xuICAgICAgICAgICAgICAgICAgICBmb250LXNpemU6IDFlbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBAbWVkaWEgKG1heC13aWR0aDogMzcwcHgpe1xuICAgICAgICAgICAgICAgIDpnbG9iYWwoLmhlYWRlciwgLnB1enpsZSwgLmNvbnRyb2xzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvbnQtc2l6ZTogLjhlbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBAbWVkaWEgKG1heC1oZWlnaHQ6IDYwMHB4KXtcbiAgICAgICAgICAgICAgICA6Z2xvYmFsKC5oZWFkZXIsIC5wdXp6bGUsIC5jb250cm9scykge1xuICAgICAgICAgICAgICAgICAgICBmb250LXNpemU6IC44ZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOmdsb2JhbChib2R5KSB7XG4gICAgICAgICAgICAgICAgbWFyZ2luOiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLnJvb3RlciB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgICAgICAgICAgIGJvdHRvbTogMDtcbiAgICAgICAgICAgICAgICBmb250LXNpemU6IC44ZW07XG4gICAgICAgICAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgICAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICBgfVxuICAgICAgICA8L3N0eWxlPlxuICAgICAgICA8c3R5bGUganN4IGdsb2JhbD57UmFuZ2VTdHlsZX08L3N0eWxlPlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufVxuIl19 */\n/*@ sourceURL=pages/index.js */');

// eslint-disable-next-line no-lone-blocks
PuzzleStyle.__hash = '1343751924';
PuzzleStyle.__scoped = '.puzzle.jsx-113117877{margin-top:.5em;width:' + cellWidth * 9 + 'em;cursor:pointer;box-shadow:0 3px 6px rgba(0,0,0,0.16),0 3px 6px rgba(0,0,0,0.23);}.row.jsx-113117877{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-flex:0;-ms-flex:0;flex:0;width:' + cellWidth * 9 + 'em;}.row.jsx-113117877:not(:last-child){border-bottom:1px solid black;}.row.jsx-113117877:nth-child(3n+3):not(:last-child){border-bottom:2px solid black !important;}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhZ2VzL2luZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQWtJdUIsQUFHcUIsQUFNSCxBQU1pQixBQUdXLGdCQWRKLGNBWXpDLFdBR0EsWUFkbUIsZUFDbUQsTUFJL0MsMkRBSHZCLGtDQUlXLGlDQUM4QixxQ0FDekMiLCJmaWxlIjoicGFnZXMvaW5kZXguanMiLCJzb3VyY2VSb290IjoiL1VzZXJzL2xpY2hlbm1hL1Byb2plY3RzL1N1RHVva3UvU3VEdW9rdSIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIGpzeC1hMTF5L2FjY2Vzc2libGUtZW1vamkgKi9cbmltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFNldCwgTGlzdCwgZnJvbUpTIH0gZnJvbSAnaW1tdXRhYmxlJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgTmV4dEhlYWQgZnJvbSAnbmV4dC9oZWFkJztcbmltcG9ydCBDb2xvciBmcm9tICdjb2xvcic7XG5pbXBvcnQgSW5wdXRSYW5nZSBmcm9tICdyZWFjdC1pbnB1dC1yYW5nZSc7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tZXh0cmFuZW91cy1kZXBlbmRlbmNpZXNcbmltcG9ydCBjc3MgZnJvbSAnc3R5bGVkLWpzeC9jc3MnO1xuXG5pbXBvcnQgUmFuZ2VTdHlsZSBmcm9tICcuLi9pbnB1dC1yYW5nZS1zdHlsZSc7XG5pbXBvcnQgTG91cGVJY29uIGZyb20gJy4uL3N2Zy9sb3VwZS5zdmcnO1xuaW1wb3J0IFJlbW92ZUljb24gZnJvbSAnLi4vc3ZnL3JlbW92ZS5zdmcnO1xuaW1wb3J0IFJlbG9hZEljb24gZnJvbSAnLi4vc3ZnL3JlbG9hZC5zdmcnO1xuaW1wb3J0IFJldHVybkljb24gZnJvbSAnLi4vc3ZnL3JldHVybi5zdmcnO1xuXG5pbXBvcnQgeyBtYWtlUHV6emxlLCBwbHVjaywgaXNQZWVyIGFzIGFyZUNvb3JkaW5hdGVQZWVycywgcmFuZ2UgfSBmcm9tICcuLi9zdWRva3UnO1xuaW1wb3J0IHsgYmFja0dyb3VuZEJsdWUgfSBmcm9tICcuLi9jb2xvcnMnO1xuaW1wb3J0IFRpcCBmcm9tICcuLi9jb21wb25lbnRzL3Rvb2wtdGlwJztcblxuaW1wb3J0IGlvIGZyb20gJ3NvY2tldC5pby1jbGllbnQnXG5cbmNvbnN0IERlc2NyaXB0aW9uID0gJ0Rpc2NvdmVyIHRoZSBuZXh0IGV2b2x1dGlvbiBvZiBTdWRva3Ugd2l0aCBhbWF6aW5nIGdyYXBoaWNzLCBhbmltYXRpb25zLCBhbmQgdXNlci1mcmllbmRseSBmZWF0dXJlcy4gRW5qb3kgYSBTdWRva3UgZXhwZXJpZW5jZSBsaWtlIHlvdSBuZXZlciBoYXZlIGJlZm9yZSB3aXRoIGN1c3RvbWl6YWJsZSBnYW1lIGdlbmVyYXRpb24sIGNlbGwgaGlnaGxpZ2h0aW5nLCBpbnR1aXRpdmUgY29udHJvbHMgYW5kIG1vcmUhJztcbmNvbnN0IGNlbGxXaWR0aCA9IDIuNTtcblxuY29uc3QgTGlnaHRCbHVlMTAwID0gJyNCM0U1RkMnO1xuY29uc3QgTGlnaHRCbHVlMjAwID0gJyM4MUQ0RkEnO1xuY29uc3QgTGlnaHRCbHVlMzAwID0gJyM0RkMzRjcnO1xuY29uc3QgSW5kaWdvNzAwID0gJyMzMDNGOUYnO1xuY29uc3QgRGVlcE9yYW5nZTIwMCA9ICcjRkZBQjkxJztcbmNvbnN0IERlZXBPcmFuZ2U2MDAgPSAnI0Y0NTExRSc7XG5jb25zdCBDb250cm9sTnVtYmVyQ29sb3IgPSBJbmRpZ283MDA7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sb25lLWJsb2Nrc1xueyAvKiBsYW5ndWFnZT1DU1MgKi8gfVxuY29uc3QgQ2VsbFN0eWxlID0gY3NzYFxuLmNlbGwge1xuICAgIGhlaWdodDogJHtjZWxsV2lkdGh9ZW07XG4gICAgd2lkdGg6ICR7Y2VsbFdpZHRofWVtO1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC13cmFwOiB3cmFwO1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgZm9udC1zaXplOiAxLjFlbTtcbiAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICB0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kLWNvbG9yIC4zcyBlYXNlLWluLW91dDtcbn1cbi5jZWxsOm50aC1jaGlsZCgzbiszKTpub3QoOmxhc3QtY2hpbGQpIHtcbiAgICBib3JkZXItcmlnaHQ6IDJweCBzb2xpZCBibGFjaztcbn1cbi5jZWxsOm5vdCg6bGFzdC1jaGlsZCkge1xuICAgIGJvcmRlci1yaWdodDogMXB4IHNvbGlkIGJsYWNrO1xufVxuLm5vdGUtbnVtYmVyIHtcbiAgICBmb250LXNpemU6IC42ZW07XG4gICAgd2lkdGg6IDMzJTtcbiAgICBoZWlnaHQ6IDMzJTtcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbn1cbmA7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sb25lLWJsb2Nrc1xueyAvKiBsYW5ndWFnZT1DU1MgKi8gfVxuY29uc3QgQWN0aW9uc1N0eWxlID0gY3NzYFxuLmFjdGlvbnMge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgbWF4LXdpZHRoOiA0MDBweDtcbiAgICBtYXJnaW4tdG9wOiAuNWVtO1xuICAgIHBhZGRpbmc6IDAgLjZlbTtcbn1cbi5hY3Rpb24ge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xufVxuLmFjdGlvbiA6Z2xvYmFsKHN2Zykge1xuICAgIHdpZHRoOiAyLjVlbTtcbiAgICBtYXJnaW4tYm90dG9tOiAuMmVtO1xufVxuLnJlZG8gOmdsb2JhbChzdmcpIHtcbiAgICB0cmFuc2Zvcm06IHNjYWxlWCgtMSk7XG59XG5gO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbG9uZS1ibG9ja3NcbnsgLyogbGFuZ3VhZ2U9Q1NTICovIH1cbmNvbnN0IENvbnRyb2xTdHlsZSA9IGNzc2Bcbi5jb250cm9sIHtcbiAgICBwYWRkaW5nOiAwIDJlbTtcbiAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgZGlzcGxheTogaW5saW5lLWZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBmbGV4LXdyYXA6IHdyYXA7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgZm9udC1mYW1pbHk6ICdTcGVjaWFsIEVsaXRlJywgY3Vyc2l2ZTtcbiAgICB0cmFuc2l0aW9uOiBmaWx0ZXIgLjVzIGVhc2UtaW4tb3V0O1xuICAgIHdpZHRoOiAxMDAlO1xufVxuYDtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxvbmUtYmxvY2tzXG57IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG5jb25zdCBOdW1iZXJDb250cm9sU3R5bGUgPSBjc3NgXG4ubnVtYmVyIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGZvbnQtc2l6ZTogMmVtO1xuICAgIG1hcmdpbjogLjFlbTtcbiAgICB3aWR0aDogMS41ZW07XG4gICAgaGVpZ2h0OiAxLjVlbTtcbiAgICBjb2xvcjogJHtDb250cm9sTnVtYmVyQ29sb3J9O1xuICAgIGJveC1zaGFkb3c6IDAgMXB4IDJweCByZ2JhKDAsMCwwLDAuMTYpLCAwIDFweCAycHggcmdiYSgwLDAsMCwwLjIzKTtcbiAgICBib3JkZXItcmFkaXVzOiA1MCU7XG59XG4ubnVtYmVyID4gZGl2IHtcbiAgICBtYXJnaW4tdG9wOiAuM2VtO1xufVxuYDtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxvbmUtYmxvY2tzXG57IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG5jb25zdCBQdXp6bGVTdHlsZSA9IGNzc2Bcbi5wdXp6bGUge1xuICAgIG1hcmdpbi10b3A6IC41ZW07XG4gICAgd2lkdGg6ICR7Y2VsbFdpZHRoICogOX1lbTtcbiAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgYm94LXNoYWRvdzogMCAzcHggNnB4IHJnYmEoMCwwLDAsMC4xNiksIDAgM3B4IDZweCByZ2JhKDAsMCwwLDAuMjMpO1xufVxuLnJvdyB7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGZsZXg6IDA7XG4gICAgd2lkdGg6ICR7Y2VsbFdpZHRoICogOX1lbTtcbn1cbi5yb3c6bm90KDpsYXN0LWNoaWxkKSB7XG4gICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkIGJsYWNrO1xufVxuLnJvdzpudGgtY2hpbGQoM24rMyk6bm90KDpsYXN0LWNoaWxkKSB7XG4gICAgYm9yZGVyLWJvdHRvbTogMnB4IHNvbGlkIGJsYWNrICFpbXBvcnRhbnQ7XG59XG5gO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbG9uZS1ibG9ja3NcbnsgLyogbGFuZ3VhZ2U9Q1NTICovIH1cbmNvbnN0IENpcmN1bHVhclByb2dyZXNzU3R5bGUgPSBjc3NgXG4uY2lyY3VsYXItcHJvZ3Jlc3Mge1xuICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB0b3A6IDA7XG4gICAgbGVmdDogMDtcbiAgICB0cmFuc2l0aW9uOiBmaWx0ZXIgLjRzIGVhc2UtaW4tb3V0O1xufVxuXG4uY2lyY2xlLWJnIHtcbiAgICBmaWxsOiBub25lO1xuICAgIHN0cm9rZTogI2VlZTtcbiAgICBzdHJva2Utd2lkdGg6IDMuODtcbn1cblxuLmNpcmNsZSB7XG4gICAgc3Ryb2tlOiAke0NvbnRyb2xOdW1iZXJDb2xvcn07XG4gICAgdHJhbnNpdGlvbjogc3Ryb2tlLWRhc2hhcnJheSAuNHMgZWFzZS1pbi1vdXQ7XG4gICAgZmlsbDogbm9uZTtcbiAgICBzdHJva2Utd2lkdGg6IDIuODtcbiAgICBzdHJva2UtbGluZWNhcDogcm91bmQ7XG59XG5gO1xuXG5jb25zdCBDaXJjdWxhclBhdGhEID0gJ00xOCAyLjA4NDUgYSAxNS45MTU1IDE1LjkxNTUgMCAwIDEgMCAzMS44MzEgYSAxNS45MTU1IDE1LjkxNTUgMCAwIDEgMCAtMzEuODMxJztcblxuZnVuY3Rpb24gZ2V0QmFja0dyb3VuZENvbG9yKHtcbiAgY29uZmxpY3QsIGlzUGVlciwgc2FtZVZhbHVlLCBpc1NlbGVjdGVkLFxufSkge1xuICBpZiAoY29uZmxpY3QgJiYgaXNQZWVyICYmIHNhbWVWYWx1ZSkge1xuICAgIHJldHVybiBEZWVwT3JhbmdlMjAwO1xuICB9IGVsc2UgaWYgKHNhbWVWYWx1ZSkge1xuICAgIHJldHVybiBMaWdodEJsdWUzMDA7XG4gIH0gZWxzZSBpZiAoaXNTZWxlY3RlZCkge1xuICAgIHJldHVybiBMaWdodEJsdWUyMDA7XG4gIH0gZWxzZSBpZiAoaXNQZWVyKSB7XG4gICAgcmV0dXJuIExpZ2h0Qmx1ZTEwMDtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldEZvbnRDb2xvcih7IHZhbHVlLCBjb25mbGljdCwgcHJlZmlsbGVkIH0pIHtcbiAgaWYgKGNvbmZsaWN0ICYmICFwcmVmaWxsZWQpIHtcbiAgICByZXR1cm4gRGVlcE9yYW5nZTYwMDtcbiAgfSBlbHNlIGlmICghcHJlZmlsbGVkICYmIHZhbHVlKSB7XG4gICAgcmV0dXJuIENvbnRyb2xOdW1iZXJDb2xvcjtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmNsYXNzIEdlbmVyYXRpb25VSSBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuXG4gICAgdGhpcy5zdGF0ZSA9IHsgdmFsdWU6IDMwIH07XG4gIH1cblxuICBnZW5lcmF0ZUdhbWUgPSAoKSA9PiB7XG4gICAgdGhpcy5wcm9wcy5nZW5lcmF0ZUdhbWUodGhpcy5zdGF0ZS52YWx1ZSk7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ2VuZXJhdGlvblwiPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvcHlcIj5TdGFydCB3aXRoIHt0aGlzLnN0YXRlLnZhbHVlfSBjZWxscyBwcmVmaWxsZWQ8L2Rpdj5cbiAgICAgICAgPElucHV0UmFuZ2VcbiAgICAgICAgICBtYXhWYWx1ZT17ODF9XG4gICAgICAgICAgbWluVmFsdWU9ezE3fVxuICAgICAgICAgIHZhbHVlPXt0aGlzLnN0YXRlLnZhbHVlfVxuICAgICAgICAgIG9uQ2hhbmdlPXt2YWx1ZSA9PiB0aGlzLnNldFN0YXRlKHsgdmFsdWUgfSl9XG4gICAgICAgIC8+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYnV0dG9uXCIgb25DbGljaz17dGhpcy5nZW5lcmF0ZUdhbWV9PlBsYXkgU3Vkb2t1PC9kaXY+XG4gICAgICAgIHsgLyogbGFuZ3VhZ2U9Q1NTICovIH1cbiAgICAgICAgPHN0eWxlIGpzeD57YFxuICAgICAgICAgICAgLmNvcHkge1xuICAgICAgICAgICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICAgICAgICAgICAgICBmb250LXNpemU6IDEuM2VtO1xuICAgICAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IC41ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAuZ2VuZXJhdGlvbiB7XG4gICAgICAgICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgICAgICAgICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6Z2xvYmFsKC5pbnB1dC1yYW5nZSkge1xuICAgICAgICAgICAgICAgIHdpZHRoOiA4MCU7XG4gICAgICAgICAgICAgICAgbWF4LXdpZHRoOiA1MDBweDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC5idXR0b24ge1xuICAgICAgICAgICAgICBtYXJnaW4tdG9wOiAuNWVtO1xuICAgICAgICAgICAgICBib3JkZXItcmFkaXVzOiAuMjVlbTtcbiAgICAgICAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgICAgICAgICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICAgICAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xuICAgICAgICAgICAgICBjb2xvcjogI2ZmZjtcbiAgICAgICAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gICAgICAgICAgICAgIHRyYW5zaXRpb246IGFsbCAuMjVzO1xuICAgICAgICAgICAgICBwYWRkaW5nOiA1cHggMTBweDtcbiAgICAgICAgICAgICAgZm9udC1zaXplOiAxLjRlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC5idXR0b246YWN0aXZlIHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoMHB4LCA1cHgpO1xuICAgICAgICAgICAgICBib3gtc2hhZG93OiAwIDFweCAwIDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC5idXR0b24ge1xuICAgICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAke2JhY2tHcm91bmRCbHVlfTtcbiAgICAgICAgICAgICAgYm94LXNoYWRvdzogMCAycHggNHB4IDAgJHtDb2xvcihiYWNrR3JvdW5kQmx1ZSkuZGFya2VuKDAuNSkuaHNsKCkuc3RyaW5nKCl9O1xuICAgICAgICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAuYnV0dG9uOmhvdmVyIHtcbiAgICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogJHtDb2xvcihiYWNrR3JvdW5kQmx1ZSkubGlnaHRlbigwLjIpLmhzbCgpLnN0cmluZygpfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgYH1cbiAgICAgICAgPC9zdHlsZT5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cbn1cblxuR2VuZXJhdGlvblVJLnByb3BUeXBlcyA9IHtcbiAgZ2VuZXJhdGVHYW1lOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxufTtcblxuY29uc3QgTnVtYmVyQ29udHJvbCA9ICh7IG51bWJlciwgb25DbGljaywgY29tcGxldGlvblBlcmNlbnRhZ2UgfSkgPT4gKFxuICA8ZGl2XG4gICAga2V5PXtudW1iZXJ9XG4gICAgY2xhc3NOYW1lPVwibnVtYmVyXCJcbiAgICBvbkNsaWNrPXtvbkNsaWNrfVxuICA+XG4gICAgPGRpdj57bnVtYmVyfTwvZGl2PlxuICAgIDxDaXJjbHVsYXJQcm9ncmVzcyBwZXJjZW50PXtjb21wbGV0aW9uUGVyY2VudGFnZX0gLz5cbiAgICA8c3R5bGUganN4PntOdW1iZXJDb250cm9sU3R5bGV9PC9zdHlsZT5cbiAgPC9kaXY+XG4pO1xuXG5OdW1iZXJDb250cm9sLnByb3BUeXBlcyA9IHtcbiAgbnVtYmVyOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIG9uQ2xpY2s6IFByb3BUeXBlcy5mdW5jLFxuICBjb21wbGV0aW9uUGVyY2VudGFnZTogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxufTtcblxuTnVtYmVyQ29udHJvbC5kZWZhdWx0UHJvcHMgPSB7XG4gIG9uQ2xpY2s6IG51bGwsXG59O1xuXG5jb25zdCBDZWxsID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHtcbiAgICB2YWx1ZSwgb25DbGljaywgaXNQZWVyLCBpc1NlbGVjdGVkLCBzYW1lVmFsdWUsIHByZWZpbGxlZCwgbm90ZXMsIGNvbmZsaWN0LFxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IGJhY2tncm91bmRDb2xvciA9IGdldEJhY2tHcm91bmRDb2xvcih7XG4gICAgY29uZmxpY3QsIGlzUGVlciwgc2FtZVZhbHVlLCBpc1NlbGVjdGVkLFxuICB9KTtcbiAgY29uc3QgZm9udENvbG9yID0gZ2V0Rm9udENvbG9yKHsgY29uZmxpY3QsIHByZWZpbGxlZCwgdmFsdWUgfSk7XG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJjZWxsXCIgb25DbGljaz17b25DbGlja30+XG4gICAgICB7XG4gICAgICAgIG5vdGVzID9cbiAgICAgICAgICByYW5nZSg5KS5tYXAoaSA9PlxuICAgICAgICAgICAgKFxuICAgICAgICAgICAgICA8ZGl2IGtleT17aX0gY2xhc3NOYW1lPVwibm90ZS1udW1iZXJcIj5cbiAgICAgICAgICAgICAgICB7bm90ZXMuaGFzKGkgKyAxKSAmJiAoaSArIDEpfVxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICkpIDpcbiAgICAgICAgICB2YWx1ZSAmJiB2YWx1ZVxuICAgICAgfVxuICAgICAgey8qIGxhbmd1YWdlPUNTUyAqL31cbiAgICAgIDxzdHlsZSBqc3g+e0NlbGxTdHlsZX08L3N0eWxlPlxuICAgICAgPHN0eWxlIGpzeD57YFxuICAgICAgICAgICAgICAgIC5jZWxsIHtcbiAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogJHtiYWNrZ3JvdW5kQ29sb3IgfHwgJ2luaXRpYWwnfTtcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6ICR7Zm9udENvbG9yIHx8ICdpbml0aWFsJ307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgYH1cbiAgICAgIDwvc3R5bGU+XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5DZWxsLnByb3BUeXBlcyA9IHtcbiAgLy8gY3VycmVudCBudW1iZXIgdmFsdWVcbiAgdmFsdWU6IFByb3BUeXBlcy5udW1iZXIsXG4gIC8vIGNlbGwgY2xpY2sgaGFuZGxlclxuICBvbkNsaWNrOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAvLyBpZiB0aGUgY2VsbCBpcyBhIHBlZXIgb2YgdGhlIHNlbGVjdGVkIGNlbGxcbiAgaXNQZWVyOiBQcm9wVHlwZXMuYm9vbC5pc1JlcXVpcmVkLFxuICAvLyBpZiB0aGUgY2VsbCBpcyBzZWxlY3RlZCBieSB0aGUgdXNlclxuICBpc1NlbGVjdGVkOiBQcm9wVHlwZXMuYm9vbC5pc1JlcXVpcmVkLFxuICAvLyBjdXJyZW50IGNlbGwgaGFzIHRoZSBzYW1lIHZhbHVlIGlmIHRoZSB1c2VyIHNlbGVjdGVkIGNlbGxcbiAgc2FtZVZhbHVlOiBQcm9wVHlwZXMuYm9vbC5pc1JlcXVpcmVkLFxuICAvLyBpZiB0aGlzIHdhcyBwcmVmaWxsZWQgYXMgYSBwYXJ0IG9mIHRoZSBwdXp6bGVcbiAgcHJlZmlsbGVkOiBQcm9wVHlwZXMuYm9vbC5pc1JlcXVpcmVkLFxuICAvLyBjdXJyZW50IG5vdGVzIHRha2VuIG9uIHRoZSBjZWxsXG4gIG5vdGVzOiBQcm9wVHlwZXMuaW5zdGFuY2VPZihTZXQpLFxuICAvLyBpZiB0aGUgY3VycmVudCBjZWxsIGRvZXMgbm90IHNhdGlzZnkgdGhlIGdhbWUgY29uc3RyYWludFxuICBjb25mbGljdDogUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZCxcbn07XG5cbkNlbGwuZGVmYXVsdFByb3BzID0ge1xuICBub3RlczogbnVsbCxcbiAgdmFsdWU6IG51bGwsXG59O1xuXG5jb25zdCBDaXJjbHVsYXJQcm9ncmVzcyA9ICh7IHBlcmNlbnQgfSkgPT4gKFxuICA8c3ZnIHZpZXdCb3g9XCIwIDAgMzYgMzZcIiBjbGFzc05hbWU9XCJjaXJjdWxhci1wcm9ncmVzc1wiPlxuICAgIDxwYXRoXG4gICAgICBjbGFzc05hbWU9XCJjaXJjbGUtYmdcIlxuICAgICAgZD17Q2lyY3VsYXJQYXRoRH1cbiAgICAvPlxuICAgIDxwYXRoXG4gICAgICBjbGFzc05hbWU9XCJjaXJjbGVcIlxuICAgICAgc3Ryb2tlRGFzaGFycmF5PXtgJHtwZXJjZW50ICogMTAwfSwgMTAwYH1cbiAgICAgIGQ9e0NpcmN1bGFyUGF0aER9XG4gICAgLz5cbiAgICB7IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG4gICAgPHN0eWxlIGpzeD57Q2lyY3VsdWFyUHJvZ3Jlc3NTdHlsZX08L3N0eWxlPlxuICA8L3N2Zz5cbik7XG5cbkNpcmNsdWxhclByb2dyZXNzLnByb3BUeXBlcyA9IHtcbiAgcGVyY2VudDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxufTtcblxuZnVuY3Rpb24gZ2V0Q2xpY2tIYW5kbGVyKG9uQ2xpY2ssIG9uRG91YmxlQ2xpY2ssIGRlbGF5ID0gMjUwKSB7XG4gIGxldCB0aW1lb3V0SUQgPSBudWxsO1xuICByZXR1cm4gKGV2ZW50KSA9PiB7XG4gICAgaWYgKCF0aW1lb3V0SUQpIHtcbiAgICAgIHRpbWVvdXRJRCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBvbkNsaWNrKGV2ZW50KTtcbiAgICAgICAgdGltZW91dElEID0gbnVsbDtcbiAgICAgIH0sIGRlbGF5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGltZW91dElEID0gY2xlYXJUaW1lb3V0KHRpbWVvdXRJRCk7XG4gICAgICBvbkRvdWJsZUNsaWNrKGV2ZW50KTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogbWFrZSBzaXplIDkgYXJyYXkgb2YgMHNcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZnVuY3Rpb24gbWFrZUNvdW50T2JqZWN0KCkge1xuICBjb25zdCBjb3VudE9iaiA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpICs9IDEpIGNvdW50T2JqLnB1c2goMCk7XG4gIHJldHVybiBjb3VudE9iajtcbn1cblxuLyoqXG4gKiBnaXZlbiBhIDJEIGFycmF5IG9mIG51bWJlcnMgYXMgdGhlIGluaXRpYWwgcHV6emxlLCBnZW5lcmF0ZSB0aGUgaW5pdGlhbCBnYW1lIHN0YXRlXG4gKiBAcGFyYW0gcHV6emxlXG4gKiBAcmV0dXJucyB7YW55fVxuICovXG5mdW5jdGlvbiBtYWtlQm9hcmQoeyBwdXp6bGUgfSkge1xuICAvLyBjcmVhdGUgaW5pdGlhbCBjb3VudCBvYmplY3QgdG8ga2VlcCB0cmFjayBvZiBjb25mbGljdHMgcGVyIG51bWJlciB2YWx1ZVxuICBjb25zdCByb3dzID0gQXJyYXkuZnJvbShBcnJheSg5KS5rZXlzKCkpLm1hcCgoKSA9PiBtYWtlQ291bnRPYmplY3QoKSk7XG4gIGNvbnN0IGNvbHVtbnMgPSBBcnJheS5mcm9tKEFycmF5KDkpLmtleXMoKSkubWFwKCgpID0+IG1ha2VDb3VudE9iamVjdCgpKTtcbiAgY29uc3Qgc3F1YXJlcyA9IEFycmF5LmZyb20oQXJyYXkoOSkua2V5cygpKS5tYXAoKCkgPT4gbWFrZUNvdW50T2JqZWN0KCkpO1xuICBjb25zdCByZXN1bHQgPSBwdXp6bGUubWFwKChyb3csIGkpID0+IChcbiAgICByb3cubWFwKChjZWxsLCBqKSA9PiB7XG4gICAgICBpZiAoY2VsbCkge1xuICAgICAgICByb3dzW2ldW2NlbGxdICs9IDE7XG4gICAgICAgIGNvbHVtbnNbal1bY2VsbF0gKz0gMTtcbiAgICAgICAgc3F1YXJlc1soKE1hdGguZmxvb3IoaSAvIDMpKSAqIDMpICsgTWF0aC5mbG9vcihqIC8gMyldW2NlbGxdICs9IDE7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogcHV6emxlW2ldW2pdID4gMCA/IHB1enpsZVtpXVtqXSA6IG51bGwsXG4gICAgICAgIHByZWZpbGxlZDogISFwdXp6bGVbaV1bal0sXG4gICAgICB9O1xuICAgIH0pXG4gICkpO1xuICByZXR1cm4gZnJvbUpTKHsgcHV6emxlOiByZXN1bHQsIHNlbGVjdGVkOiBmYWxzZSwgY2hvaWNlczogeyByb3dzLCBjb2x1bW5zLCBzcXVhcmVzIH0gfSk7XG59XG5cbi8qKlxuICogZ2l2ZSB0aGUgY29vcmRpbmF0ZSB1cGRhdGUgdGhlIGN1cnJlbnQgYm9hcmQgd2l0aCBhIG51bWJlciBjaG9pY2VcbiAqIEBwYXJhbSB4XG4gKiBAcGFyYW0geVxuICogQHBhcmFtIG51bWJlclxuICogQHBhcmFtIGZpbGwgd2hldGhlciB0byBzZXQgb3IgdW5zZXRcbiAqIEBwYXJhbSBib2FyZCB0aGUgaW1tdXRhYmxlIGJvYXJkIGdpdmVuIHRvIGNoYW5nZVxuICovXG5mdW5jdGlvbiB1cGRhdGVCb2FyZFdpdGhOdW1iZXIoe1xuICB4LCB5LCBudW1iZXIsIGZpbGwgPSB0cnVlLCBib2FyZCxcbn0pIHtcbiAgbGV0IGNlbGwgPSBib2FyZC5nZXQoJ3B1enpsZScpLmdldEluKFt4LCB5XSk7XG4gIC8vIGRlbGV0ZSBpdHMgbm90ZXNcbiAgY2VsbCA9IGNlbGwuZGVsZXRlKCdub3RlcycpO1xuICAvLyBzZXQgb3IgdW5zZXQgaXRzIHZhbHVlIGRlcGVuZGluZyBvbiBgZmlsbGBcbiAgY2VsbCA9IGZpbGwgPyBjZWxsLnNldCgndmFsdWUnLCBudW1iZXIpIDogY2VsbC5kZWxldGUoJ3ZhbHVlJyk7XG4gIGNvbnN0IGluY3JlbWVudCA9IGZpbGwgPyAxIDogLTE7XG4gIC8vIHVwZGF0ZSB0aGUgY3VycmVudCBncm91cCBjaG9pY2VzXG4gIGNvbnN0IHJvd1BhdGggPSBbJ2Nob2ljZXMnLCAncm93cycsIHgsIG51bWJlcl07XG4gIGNvbnN0IGNvbHVtblBhdGggPSBbJ2Nob2ljZXMnLCAnY29sdW1ucycsIHksIG51bWJlcl07XG4gIGNvbnN0IHNxdWFyZVBhdGggPSBbJ2Nob2ljZXMnLCAnc3F1YXJlcycsXG4gICAgKChNYXRoLmZsb29yKHggLyAzKSkgKiAzKSArIE1hdGguZmxvb3IoeSAvIDMpLCBudW1iZXJdO1xuICByZXR1cm4gYm9hcmQuc2V0SW4ocm93UGF0aCwgYm9hcmQuZ2V0SW4ocm93UGF0aCkgKyBpbmNyZW1lbnQpXG4gICAgLnNldEluKGNvbHVtblBhdGgsIGJvYXJkLmdldEluKGNvbHVtblBhdGgpICsgaW5jcmVtZW50KVxuICAgIC5zZXRJbihzcXVhcmVQYXRoLCBib2FyZC5nZXRJbihzcXVhcmVQYXRoKSArIGluY3JlbWVudClcbiAgICAuc2V0SW4oWydwdXp6bGUnLCB4LCB5XSwgY2VsbCk7XG59XG5cbmZ1bmN0aW9uIGdldE51bWJlck9mR3JvdXBzQXNzaWduZWRGb3JOdW1iZXIobnVtYmVyLCBncm91cHMpIHtcbiAgcmV0dXJuIGdyb3Vwcy5yZWR1Y2UoKGFjY3VtdWxhdG9yLCByb3cpID0+XG4gICAgYWNjdW11bGF0b3IgKyAocm93LmdldChudW1iZXIpID4gMCA/IDEgOiAwKSwgMCk7XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3Qvbm8tbXVsdGktY29tcFxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW5kZXggZXh0ZW5kcyBDb21wb25lbnQge1xuICBzdGF0ZSA9IHt9O1xuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgIGlmICgnc2VydmljZVdvcmtlcicgaW4gbmF2aWdhdG9yKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICAgIG5hdmlnYXRvci5zZXJ2aWNlV29ya2VyXG4gICAgICAgIC5yZWdpc3RlcignL3NlcnZpY2Utd29ya2VyLmpzJylcbiAgICAgICAgLnRoZW4oKHJlZykgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdTZXJ2aWNlV29ya2VyIHNjb3BlOiAnLCByZWcuc2NvcGUpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdzZXJ2aWNlIHdvcmtlciByZWdpc3RyYXRpb24gc3VjY2Vzc2Z1bCcpO1xuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgIGNvbnNvbGUud2Fybignc2VydmljZSB3b3JrZXIgcmVnaXN0cmF0aW9uIGZhaWxlZCcsIGVyci5tZXNzYWdlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICBcbiAgICBmZXRjaCgnL2FwaS9zb2NrZXRpbycpLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgY29uc3Qgc29ja2V0ID0gaW8oKVxuXG4gICAgICBzb2NrZXQub24oJ2Nvbm5lY3QnLCAoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdjb25uZWN0JylcbiAgICAgICAgc29ja2V0LmVtaXQoJ2hlbGxvJylcbiAgICAgIH0pXG5cbiAgICAgIHNvY2tldC5vbignaGVsbG8nLCBkYXRhID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ2hlbGxvJywgZGF0YSlcbiAgICAgIH0pXG5cbiAgICAgIHNvY2tldC5vbignYSB1c2VyIGNvbm5lY3RlZCcsICgpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ2EgdXNlciBjb25uZWN0ZWQnKVxuICAgICAgfSlcblxuICAgICAgc29ja2V0Lm9uKCdkaXNjb25uZWN0JywgKCkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZygnZGlzY29ubmVjdCcpXG4gICAgICB9KVxuICAgIH0pXG4gICBcbiAgfVxuICBnZXRTZWxlY3RlZENlbGwoKSB7XG4gICAgY29uc3QgeyBib2FyZCB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBzZWxlY3RlZCA9IGJvYXJkLmdldCgnc2VsZWN0ZWQnKTtcbiAgICByZXR1cm4gc2VsZWN0ZWQgJiYgYm9hcmQuZ2V0KCdwdXp6bGUnKS5nZXRJbihbc2VsZWN0ZWQueCwgc2VsZWN0ZWQueV0pO1xuICB9XG5cbiAgLy8gZ2V0IHRoZSBtaW4gYmV0d2VlbiBpdHMgY29tcGxldGlvbiBpbiByb3dzLCBjb2x1bW5zIGFuZCBzcXVhcmVzLlxuICBnZXROdW1iZXJWYWx1ZUNvdW50KG51bWJlcikge1xuICAgIGNvbnN0IHJvd3MgPSB0aGlzLnN0YXRlLmJvYXJkLmdldEluKFsnY2hvaWNlcycsICdyb3dzJ10pO1xuICAgIGNvbnN0IGNvbHVtbnMgPSB0aGlzLnN0YXRlLmJvYXJkLmdldEluKFsnY2hvaWNlcycsICdjb2x1bW5zJ10pO1xuICAgIGNvbnN0IHNxdWFyZXMgPSB0aGlzLnN0YXRlLmJvYXJkLmdldEluKFsnY2hvaWNlcycsICdzcXVhcmVzJ10pO1xuICAgIHJldHVybiBNYXRoLm1pbihcbiAgICAgIGdldE51bWJlck9mR3JvdXBzQXNzaWduZWRGb3JOdW1iZXIobnVtYmVyLCBzcXVhcmVzKSxcbiAgICAgIE1hdGgubWluKFxuICAgICAgICBnZXROdW1iZXJPZkdyb3Vwc0Fzc2lnbmVkRm9yTnVtYmVyKG51bWJlciwgcm93cyksXG4gICAgICAgIGdldE51bWJlck9mR3JvdXBzQXNzaWduZWRGb3JOdW1iZXIobnVtYmVyLCBjb2x1bW5zKSxcbiAgICAgICksXG4gICAgKTtcbiAgfVxuXG4gIGdlbmVyYXRlR2FtZSA9IChmaW5hbENvdW50ID0gMjApID0+IHtcbiAgICAvLyBnZXQgYSBmaWxsZWQgcHV6emxlIGdlbmVyYXRlZFxuICAgIGNvbnN0IHNvbHV0aW9uID0gbWFrZVB1enpsZSgpO1xuICAgIC8vIHBsdWNrIHZhbHVlcyBmcm9tIGNlbGxzIHRvIGNyZWF0ZSB0aGUgZ2FtZVxuICAgIGNvbnN0IHsgcHV6emxlIH0gPSBwbHVjayhzb2x1dGlvbiwgZmluYWxDb3VudCk7XG4gICAgLy8gaW5pdGlhbGl6ZSB0aGUgYm9hcmQgd2l0aCBjaG9pY2UgY291bnRzXG4gICAgY29uc3QgYm9hcmQgPSBtYWtlQm9hcmQoeyBwdXp6bGUgfSk7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBib2FyZCwgaGlzdG9yeTogTGlzdC5vZihib2FyZCksIGhpc3RvcnlPZmZTZXQ6IDAsIHNvbHV0aW9uLFxuICAgIH0pO1xuICB9XG5cbiAgYWRkTnVtYmVyQXNOb3RlID0gKG51bWJlcikgPT4ge1xuICAgIGxldCB7IGJvYXJkIH0gPSB0aGlzLnN0YXRlO1xuICAgIGxldCBzZWxlY3RlZENlbGwgPSB0aGlzLmdldFNlbGVjdGVkQ2VsbCgpO1xuICAgIGlmICghc2VsZWN0ZWRDZWxsKSByZXR1cm47XG4gICAgY29uc3QgcHJlZmlsbGVkID0gc2VsZWN0ZWRDZWxsLmdldCgncHJlZmlsbGVkJyk7XG4gICAgaWYgKHByZWZpbGxlZCkgcmV0dXJuO1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gYm9hcmQuZ2V0KCdzZWxlY3RlZCcpO1xuICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHNlbGVjdGVkQ2VsbC5nZXQoJ3ZhbHVlJyk7XG4gICAgaWYgKGN1cnJlbnRWYWx1ZSkge1xuICAgICAgYm9hcmQgPSB1cGRhdGVCb2FyZFdpdGhOdW1iZXIoe1xuICAgICAgICB4LCB5LCBudW1iZXI6IGN1cnJlbnRWYWx1ZSwgZmlsbDogZmFsc2UsIGJvYXJkOiB0aGlzLnN0YXRlLmJvYXJkLFxuICAgICAgfSk7XG4gICAgfVxuICAgIGxldCBub3RlcyA9IHNlbGVjdGVkQ2VsbC5nZXQoJ25vdGVzJykgfHwgU2V0KCk7XG4gICAgaWYgKG5vdGVzLmhhcyhudW1iZXIpKSB7XG4gICAgICBub3RlcyA9IG5vdGVzLmRlbGV0ZShudW1iZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub3RlcyA9IG5vdGVzLmFkZChudW1iZXIpO1xuICAgIH1cbiAgICBzZWxlY3RlZENlbGwgPSBzZWxlY3RlZENlbGwuc2V0KCdub3RlcycsIG5vdGVzKTtcbiAgICBzZWxlY3RlZENlbGwgPSBzZWxlY3RlZENlbGwuZGVsZXRlKCd2YWx1ZScpO1xuICAgIGJvYXJkID0gYm9hcmQuc2V0SW4oWydwdXp6bGUnLCB4LCB5XSwgc2VsZWN0ZWRDZWxsKTtcbiAgICB0aGlzLnVwZGF0ZUJvYXJkKGJvYXJkKTtcbiAgfTtcblxuICB1cGRhdGVCb2FyZCA9IChuZXdCb2FyZCkgPT4ge1xuICAgIGxldCB7IGhpc3RvcnkgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgeyBoaXN0b3J5T2ZmU2V0IH0gPSB0aGlzLnN0YXRlO1xuICAgIC8vIGFueXRoaW5nIGJlZm9yZSBjdXJyZW50IHN0ZXAgaXMgc3RpbGwgaW4gaGlzdG9yeVxuICAgIGhpc3RvcnkgPSBoaXN0b3J5LnNsaWNlKDAsIGhpc3RvcnlPZmZTZXQgKyAxKTtcbiAgICAvLyBhZGQgaXRzZWxmIG9udG8gdGhlIGhpc3RvcnlcbiAgICBoaXN0b3J5ID0gaGlzdG9yeS5wdXNoKG5ld0JvYXJkKTtcbiAgICAvLyB1cGRhdGUgdGhlIGdhbWVcbiAgICB0aGlzLnNldFN0YXRlKHsgYm9hcmQ6IG5ld0JvYXJkLCBoaXN0b3J5LCBoaXN0b3J5T2ZmU2V0OiBoaXN0b3J5LnNpemUgLSAxIH0pO1xuICB9O1xuXG4gIGNhblVuZG8gPSAoKSA9PiB0aGlzLnN0YXRlLmhpc3RvcnlPZmZTZXQgPiAwXG5cbiAgcmVkbyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGhpc3RvcnkgfSA9IHRoaXMuc3RhdGU7XG4gICAgbGV0IHsgaGlzdG9yeU9mZlNldCB9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAoaGlzdG9yeS5zaXplKSB7XG4gICAgICBoaXN0b3J5T2ZmU2V0ID0gTWF0aC5taW4oaGlzdG9yeS5zaXplIC0gMSwgaGlzdG9yeU9mZlNldCArIDEpO1xuICAgICAgY29uc3QgYm9hcmQgPSBoaXN0b3J5LmdldChoaXN0b3J5T2ZmU2V0KTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBib2FyZCwgaGlzdG9yeU9mZlNldCB9KTtcbiAgICB9XG4gIH07XG5cbiAgdW5kbyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGhpc3RvcnkgfSA9IHRoaXMuc3RhdGU7XG4gICAgbGV0IHsgaGlzdG9yeU9mZlNldCwgYm9hcmQgfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKGhpc3Rvcnkuc2l6ZSkge1xuICAgICAgaGlzdG9yeU9mZlNldCA9IE1hdGgubWF4KDAsIGhpc3RvcnlPZmZTZXQgLSAxKTtcbiAgICAgIGJvYXJkID0gaGlzdG9yeS5nZXQoaGlzdG9yeU9mZlNldCk7XG4gICAgICB0aGlzLnNldFN0YXRlKHsgYm9hcmQsIGhpc3RvcnlPZmZTZXQsIGhpc3RvcnkgfSk7XG4gICAgfVxuICB9O1xuXG4gIGVyYXNlU2VsZWN0ZWQgPSAoKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0ZWRDZWxsID0gdGhpcy5nZXRTZWxlY3RlZENlbGwoKTtcbiAgICBpZiAoIXNlbGVjdGVkQ2VsbCkgcmV0dXJuO1xuICAgIHRoaXMuZmlsbE51bWJlcihmYWxzZSk7XG4gIH1cblxuICBmaWxsU2VsZWN0ZWRXaXRoU29sdXRpb24gPSAoKSA9PiB7XG4gICAgY29uc3QgeyBib2FyZCwgc29sdXRpb24gfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3Qgc2VsZWN0ZWRDZWxsID0gdGhpcy5nZXRTZWxlY3RlZENlbGwoKTtcbiAgICBpZiAoIXNlbGVjdGVkQ2VsbCkgcmV0dXJuO1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gYm9hcmQuZ2V0KCdzZWxlY3RlZCcpO1xuICAgIHRoaXMuZmlsbE51bWJlcihzb2x1dGlvblt4XVt5XSk7XG4gIH1cblxuXG4gIC8vIGZpbGwgY3VycmVudGx5IHNlbGVjdGVkIGNlbGwgd2l0aCBudW1iZXJcbiAgZmlsbE51bWJlciA9IChudW1iZXIpID0+IHtcbiAgICBsZXQgeyBib2FyZCB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBzZWxlY3RlZENlbGwgPSB0aGlzLmdldFNlbGVjdGVkQ2VsbCgpO1xuICAgIC8vIG5vLW9wIGlmIG5vdGhpbmcgaXMgc2VsZWN0ZWRcbiAgICBpZiAoIXNlbGVjdGVkQ2VsbCkgcmV0dXJuO1xuICAgIGNvbnN0IHByZWZpbGxlZCA9IHNlbGVjdGVkQ2VsbC5nZXQoJ3ByZWZpbGxlZCcpO1xuICAgIC8vIG5vLW9wIGlmIGl0IGlzIHJlZmlsbGVkXG4gICAgaWYgKHByZWZpbGxlZCkgcmV0dXJuO1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gYm9hcmQuZ2V0KCdzZWxlY3RlZCcpO1xuICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHNlbGVjdGVkQ2VsbC5nZXQoJ3ZhbHVlJyk7XG4gICAgLy8gcmVtb3ZlIHRoZSBjdXJyZW50IHZhbHVlIGFuZCB1cGRhdGUgdGhlIGdhbWUgc3RhdGVcbiAgICBpZiAoY3VycmVudFZhbHVlKSB7XG4gICAgICBib2FyZCA9IHVwZGF0ZUJvYXJkV2l0aE51bWJlcih7XG4gICAgICAgIHgsIHksIG51bWJlcjogY3VycmVudFZhbHVlLCBmaWxsOiBmYWxzZSwgYm9hcmQ6IHRoaXMuc3RhdGUuYm9hcmQsXG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gdXBkYXRlIHRvIG5ldyBudW1iZXIgaWYgYW55XG4gICAgY29uc3Qgc2V0TnVtYmVyID0gY3VycmVudFZhbHVlICE9PSBudW1iZXIgJiYgbnVtYmVyO1xuICAgIGlmIChzZXROdW1iZXIpIHtcbiAgICAgIGJvYXJkID0gdXBkYXRlQm9hcmRXaXRoTnVtYmVyKHtcbiAgICAgICAgeCwgeSwgbnVtYmVyLCBmaWxsOiB0cnVlLCBib2FyZCxcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZUJvYXJkKGJvYXJkKTtcbiAgfTtcblxuICBzZWxlY3RDZWxsID0gKHgsIHkpID0+IHtcbiAgICBsZXQgeyBib2FyZCB9ID0gdGhpcy5zdGF0ZTtcbiAgICBib2FyZCA9IGJvYXJkLnNldCgnc2VsZWN0ZWQnLCB7IHgsIHkgfSk7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IGJvYXJkIH0pO1xuICB9O1xuXG4gIGlzQ29uZmxpY3QoaSwgaikge1xuICAgIGNvbnN0IHsgdmFsdWUgfSA9IHRoaXMuc3RhdGUuYm9hcmQuZ2V0SW4oWydwdXp6bGUnLCBpLCBqXSkudG9KU09OKCk7XG4gICAgaWYgKCF2YWx1ZSkgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IHJvd0NvbmZsaWN0ID1cbiAgICAgIHRoaXMuc3RhdGUuYm9hcmQuZ2V0SW4oWydjaG9pY2VzJywgJ3Jvd3MnLCBpLCB2YWx1ZV0pID4gMTtcbiAgICBjb25zdCBjb2x1bW5Db25mbGljdCA9XG4gICAgICB0aGlzLnN0YXRlLmJvYXJkLmdldEluKFsnY2hvaWNlcycsICdjb2x1bW5zJywgaiwgdmFsdWVdKSA+IDE7XG4gICAgY29uc3Qgc3F1YXJlQ29uZmxpY3QgPVxuICAgICAgdGhpcy5zdGF0ZS5ib2FyZC5nZXRJbihbJ2Nob2ljZXMnLCAnc3F1YXJlcycsXG4gICAgICAgICgoTWF0aC5mbG9vcihpIC8gMykpICogMykgKyBNYXRoLmZsb29yKGogLyAzKSwgdmFsdWVdKSA+IDE7XG4gICAgcmV0dXJuIHJvd0NvbmZsaWN0IHx8IGNvbHVtbkNvbmZsaWN0IHx8IHNxdWFyZUNvbmZsaWN0O1xuICB9XG5cbiAgcmVuZGVyQ2VsbChjZWxsLCB4LCB5KSB7XG4gICAgY29uc3QgeyBib2FyZCB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBzZWxlY3RlZCA9IHRoaXMuZ2V0U2VsZWN0ZWRDZWxsKCk7XG4gICAgY29uc3QgeyB2YWx1ZSwgcHJlZmlsbGVkLCBub3RlcyB9ID0gY2VsbC50b0pTT04oKTtcbiAgICBjb25zdCBjb25mbGljdCA9IHRoaXMuaXNDb25mbGljdCh4LCB5KTtcbiAgICBjb25zdCBwZWVyID0gYXJlQ29vcmRpbmF0ZVBlZXJzKHsgeCwgeSB9LCBib2FyZC5nZXQoJ3NlbGVjdGVkJykpO1xuICAgIGNvbnN0IHNhbWVWYWx1ZSA9ICEhKHNlbGVjdGVkICYmIHNlbGVjdGVkLmdldCgndmFsdWUnKVxuICAgICAgJiYgdmFsdWUgPT09IHNlbGVjdGVkLmdldCgndmFsdWUnKSk7XG5cbiAgICBjb25zdCBpc1NlbGVjdGVkID0gY2VsbCA9PT0gc2VsZWN0ZWQ7XG4gICAgcmV0dXJuICg8Q2VsbFxuICAgICAgcHJlZmlsbGVkPXtwcmVmaWxsZWR9XG4gICAgICBub3Rlcz17bm90ZXN9XG4gICAgICBzYW1lVmFsdWU9e3NhbWVWYWx1ZX1cbiAgICAgIGlzU2VsZWN0ZWQ9e2lzU2VsZWN0ZWR9XG4gICAgICBpc1BlZXI9e3BlZXJ9XG4gICAgICB2YWx1ZT17dmFsdWV9XG4gICAgICBvbkNsaWNrPXsoKSA9PiB7IHRoaXMuc2VsZWN0Q2VsbCh4LCB5KTsgfX1cbiAgICAgIGtleT17eX1cbiAgICAgIHg9e3h9XG4gICAgICB5PXt5fVxuICAgICAgY29uZmxpY3Q9e2NvbmZsaWN0fVxuICAgIC8+KTtcbiAgfVxuXG4gIHJlbmRlck51bWJlckNvbnRyb2woKSB7XG4gICAgY29uc3Qgc2VsZWN0ZWRDZWxsID0gdGhpcy5nZXRTZWxlY3RlZENlbGwoKTtcbiAgICBjb25zdCBwcmVmaWxsZWQgPSBzZWxlY3RlZENlbGwgJiYgc2VsZWN0ZWRDZWxsLmdldCgncHJlZmlsbGVkJyk7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29udHJvbFwiPlxuICAgICAgICB7cmFuZ2UoOSkubWFwKChpKSA9PiB7XG4gICAgICAgICAgY29uc3QgbnVtYmVyID0gaSArIDE7XG4gICAgICAgICAgLy8gaGFuZGxlcyBiaW5kaW5nIHNpbmdsZSBjbGljayBhbmQgZG91YmxlIGNsaWNrIGNhbGxiYWNrc1xuICAgICAgICAgIGNvbnN0IGNsaWNrSGFuZGxlID0gZ2V0Q2xpY2tIYW5kbGVyKFxuICAgICAgICAgICAgKCkgPT4geyB0aGlzLmZpbGxOdW1iZXIobnVtYmVyKTsgfSxcbiAgICAgICAgICAgICgpID0+IHsgdGhpcy5hZGROdW1iZXJBc05vdGUobnVtYmVyKTsgfSxcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8TnVtYmVyQ29udHJvbFxuICAgICAgICAgICAgICBrZXk9e251bWJlcn1cbiAgICAgICAgICAgICAgbnVtYmVyPXtudW1iZXJ9XG4gICAgICAgICAgICAgIG9uQ2xpY2s9eyFwcmVmaWxsZWQgPyBjbGlja0hhbmRsZSA6IHVuZGVmaW5lZH1cbiAgICAgICAgICAgICAgY29tcGxldGlvblBlcmNlbnRhZ2U9e3RoaXMuZ2V0TnVtYmVyVmFsdWVDb3VudChudW1iZXIpIC8gOX1cbiAgICAgICAgICAgIC8+KTtcbiAgICAgICAgfSl9XG4gICAgICAgIDxzdHlsZSBqc3g+e0NvbnRyb2xTdHlsZX08L3N0eWxlPlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxuXG4gIHJlbmRlckFjdGlvbnMoKSB7XG4gICAgY29uc3QgeyBoaXN0b3J5IH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IHNlbGVjdGVkQ2VsbCA9IHRoaXMuZ2V0U2VsZWN0ZWRDZWxsKCk7XG4gICAgY29uc3QgcHJlZmlsbGVkID0gc2VsZWN0ZWRDZWxsICYmIHNlbGVjdGVkQ2VsbC5nZXQoJ3ByZWZpbGxlZCcpO1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImFjdGlvbnNcIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJhY3Rpb25cIiBvbkNsaWNrPXtoaXN0b3J5LnNpemUgPyB0aGlzLnVuZG8gOiBudWxsfT5cbiAgICAgICAgICA8UmVsb2FkSWNvbiAvPlVuZG9cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWN0aW9uIHJlZG9cIiBvbkNsaWNrPXtoaXN0b3J5LnNpemUgPyB0aGlzLnJlZG8gOiBudWxsfT5cbiAgICAgICAgICA8UmVsb2FkSWNvbiAvPlJlZG9cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWN0aW9uXCIgb25DbGljaz17IXByZWZpbGxlZCA/IHRoaXMuZXJhc2VTZWxlY3RlZCA6IG51bGx9PlxuICAgICAgICAgIDxSZW1vdmVJY29uIC8+RXJhc2VcbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXZcbiAgICAgICAgICBjbGFzc05hbWU9XCJhY3Rpb25cIlxuICAgICAgICAgIG9uQ2xpY2s9eyFwcmVmaWxsZWQgP1xuICAgICAgICAgIHRoaXMuZmlsbFNlbGVjdGVkV2l0aFNvbHV0aW9uIDogbnVsbH1cbiAgICAgICAgPlxuICAgICAgICAgIDxMb3VwZUljb24gLz5IaW50XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8c3R5bGUganN4PntBY3Rpb25zU3R5bGV9PC9zdHlsZT5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cblxuICByZW5kZXJQdXp6bGUoKSB7XG4gICAgY29uc3QgeyBib2FyZCB9ID0gdGhpcy5zdGF0ZTtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJwdXp6bGVcIj5cbiAgICAgICAge2JvYXJkLmdldCgncHV6emxlJykubWFwKChyb3csIGkpID0+IChcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3Qvbm8tYXJyYXktaW5kZXgta2V5XG4gICAgICAgICAgPGRpdiBrZXk9e2l9IGNsYXNzTmFtZT1cInJvd1wiPlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICByb3cubWFwKChjZWxsLCBqKSA9PiB0aGlzLnJlbmRlckNlbGwoY2VsbCwgaSwgaikpLnRvQXJyYXkoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICApKS50b0FycmF5KCl9XG4gICAgICAgIDxzdHlsZSBqc3g+e1B1enpsZVN0eWxlfTwvc3R5bGU+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG5cbiAgcmVuZGVyQ29udHJvbHMoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29udHJvbHNcIj5cbiAgICAgICAge3RoaXMucmVuZGVyTnVtYmVyQ29udHJvbCgpfVxuICAgICAgICB7dGhpcy5yZW5kZXJBY3Rpb25zKCl9XG4gICAgICAgIHsgLyogbGFuZ3VhZ2U9Q1NTICovIH1cbiAgICAgICAgPHN0eWxlIGpzeD57YFxuICAgICAgICAgICAgLmNvbnRyb2xzIHtcbiAgICAgICAgICAgICAgICBtYXJnaW4tdG9wOiAuM2VtO1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgICAgICAgZmxleC13cmFwOiB3cmFwO1xuICAgICAgICAgICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICAgICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICAgICAgICAgIHBhZGRpbmc6IC41ZW0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgYH1cbiAgICAgICAgPC9zdHlsZT5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cblxuICByZW5kZXJHZW5lcmF0aW9uVUkoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxHZW5lcmF0aW9uVUkgZ2VuZXJhdGVHYW1lPXt0aGlzLmdlbmVyYXRlR2FtZX0gLz5cbiAgICApO1xuICB9XG5cbiAgcmVuZGVySGVhZGVyKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImhlYWRlclwiPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm5ldy1nYW1lXCIgb25DbGljaz17KCkgPT4gdGhpcy5zZXRTdGF0ZSh7IGJvYXJkOiBmYWxzZSB9KX0+XG4gICAgICAgICAgPFJldHVybkljb24gLz5cbiAgICAgICAgICA8ZGl2Pk5ldyBHYW1lPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8VGlwIC8+XG4gICAgICAgIHsgLyogbGFuZ3VhZ2U9Q1NTICovIH1cbiAgICAgICAgPHN0eWxlIGpzeD57YFxuICAgICAgICAgICAgLmhlYWRlciB7XG4gICAgICAgICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gICAgICAgICAgICAgICAgbWF4LXdpZHRoOiA1MDBweDtcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiAwIDAuNWVtO1xuICAgICAgICAgICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAubmV3LWdhbWUge1xuICAgICAgICAgICAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICAgICAgICAgICAgICBtYXJnaW4tdG9wOiAuMmVtO1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6IGlubGluZS1mbGV4O1xuICAgICAgICAgICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgICAgICAgICAgcGFkZGluZzogLjJlbSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLm5ldy1nYW1lIDpnbG9iYWwoc3ZnKSB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxZW07XG4gICAgICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogLjNlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgYH1cbiAgICAgICAgPC9zdHlsZT5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBib2FyZCB9ID0gdGhpcy5zdGF0ZTtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJib2R5XCI+XG4gICAgICAgIDxOZXh0SGVhZD5cbiAgICAgICAgICA8dGl0bGU+U3Vkb2t1IEV2b2x2ZWQ8L3RpdGxlPlxuICAgICAgICAgIDxtZXRhIG5hbWU9XCJ2aWV3cG9ydFwiIGNvbnRlbnQ9XCJpbml0aWFsLXNjYWxlPTEuMCwgd2lkdGg9ZGV2aWNlLXdpZHRoXCIgLz5cbiAgICAgICAgICA8bWV0YSBuYW1lPVwiZGVzY3JpcHRpb25cIiBjb250ZW50PXtEZXNjcmlwdGlvbn0gLz5cbiAgICAgICAgICA8bGluayBocmVmPVwiaHR0cHM6Ly9mb250cy5nb29nbGVhcGlzLmNvbS9jc3M/ZmFtaWx5PVNwZWNpYWwrRWxpdGVcIiByZWw9XCJzdHlsZXNoZWV0XCIgLz5cbiAgICAgICAgICA8bWV0YSBwcm9wZXJ0eT1cIm9nOnVybFwiIGNvbnRlbnQ9XCJodHRwczovL3N1ZG9rdS5zaXRpYW5saXUuY29tL1wiIC8+XG4gICAgICAgICAgPG1ldGEgcHJvcGVydHk9XCJvZzp0aXRsZVwiIGNvbnRlbnQ9XCJTdWRva3UgRXZvbHZlZFwiIC8+XG4gICAgICAgICAgPG1ldGEgcHJvcGVydHk9XCJvZzp0eXBlXCIgY29udGVudD1cIndlYnNpdGVcIiAvPlxuICAgICAgICAgIDxtZXRhIHByb3BlcnR5PVwib2c6ZGVzY3JpcHRpb25cIiBjb250ZW50PXtEZXNjcmlwdGlvbn0gLz5cbiAgICAgICAgICA8bWV0YSBwcm9wZXJ0eT1cIm9nOmltYWdlXCIgY29udGVudD1cImh0dHBzOi8vc3Vkb2t1LnNpdGlhbmxpdS5jb20vc3RhdGljL29nLWltYWdlLnBuZ1wiIC8+XG4gICAgICAgIDwvTmV4dEhlYWQ+XG4gICAgICAgIHshYm9hcmQgJiYgdGhpcy5yZW5kZXJHZW5lcmF0aW9uVUkoKX1cbiAgICAgICAge2JvYXJkICYmIHRoaXMucmVuZGVySGVhZGVyKCl9XG4gICAgICAgIHtib2FyZCAmJiB0aGlzLnJlbmRlclB1enpsZSgpfVxuICAgICAgICB7Ym9hcmQgJiYgdGhpcy5yZW5kZXJDb250cm9scygpfVxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInJvb3RlclwiPlxuICAgICAgICAgIE1hZGUgd2l0aCA8c3Bhbj7inaTvuI88L3NwYW4+77iPIEJ5IDxhIGhyZWY9XCJodHRwczovL3d3dy5zaXRpYW5saXUuY29tL1wiPlNpdGlhbiBMaXU8L2E+IHwgPGEgaHJlZj1cImh0dHBzOi8vbWVkaXVtLmNvbS9Ac2l0aWFubGl1XzU3NjgwL2J1aWxkaW5nLWEtc3Vkb2t1LWdhbWUtaW4tcmVhY3QtY2E2NjM5MTU3MTJcIj5CbG9nIFBvc3Q8L2E+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICB7IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG4gICAgICAgIDxzdHlsZSBqc3g+e2BcbiAgICAgICAgICAgIDpnbG9iYWwoYm9keSksIC5ib2R5IHtcbiAgICAgICAgICAgICAgICBmb250LWZhbWlseTogJ1NwZWNpYWwgRWxpdGUnLCBjdXJzaXZlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLmJvZHkge1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICAgICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICAgICAgICAgIGhlaWdodDogMTAwdmg7XG4gICAgICAgICAgICAgICAgd2lkdGg6IDEwMHZ3O1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEBtZWRpYSAobWluLXdpZHRoOiA4MDBweCkgYW5kIChtaW4taGVpZ2h0OiA5MzBweCl7XG4gICAgICAgICAgICAgICAgOmdsb2JhbCguaGVhZGVyLCAucHV6emxlLCAuY29udHJvbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9udC1zaXplOiAxLjVlbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBAbWVkaWEgKG1heC13aWR0aDogODAwcHgpIGFuZCAobWluLXdpZHRoOiA2MDBweCl7XG4gICAgICAgICAgICAgICAgOmdsb2JhbCguaGVhZGVyLCAucHV6emxlLCAuY29udHJvbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9udC1zaXplOiAxLjJlbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBAbWVkaWEgKG1heC1oZWlnaHQ6IDkzMHB4KSBhbmQgKG1pbi1oZWlnaHQ6IDgwMHB4KSBhbmQgKG1pbi13aWR0aDogNjAwcHgpe1xuICAgICAgICAgICAgICAgIDpnbG9iYWwoLmhlYWRlciwgLnB1enpsZSwgLmNvbnRyb2xzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvbnQtc2l6ZTogMS4yZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQG1lZGlhIChtYXgtaGVpZ2h0OiA4MDBweCkgYW5kIChtaW4taGVpZ2h0OiA2MDBweCkgYW5kIChtaW4td2lkdGg6IDM3MHB4KXtcbiAgICAgICAgICAgICAgICA6Z2xvYmFsKC5oZWFkZXIsIC5wdXp6bGUsIC5jb250cm9scykge1xuICAgICAgICAgICAgICAgICAgICBmb250LXNpemU6IDFlbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBAbWVkaWEgKG1heC13aWR0aDogMzcwcHgpe1xuICAgICAgICAgICAgICAgIDpnbG9iYWwoLmhlYWRlciwgLnB1enpsZSwgLmNvbnRyb2xzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvbnQtc2l6ZTogLjhlbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBAbWVkaWEgKG1heC1oZWlnaHQ6IDYwMHB4KXtcbiAgICAgICAgICAgICAgICA6Z2xvYmFsKC5oZWFkZXIsIC5wdXp6bGUsIC5jb250cm9scykge1xuICAgICAgICAgICAgICAgICAgICBmb250LXNpemU6IC44ZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOmdsb2JhbChib2R5KSB7XG4gICAgICAgICAgICAgICAgbWFyZ2luOiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLnJvb3RlciB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgICAgICAgICAgIGJvdHRvbTogMDtcbiAgICAgICAgICAgICAgICBmb250LXNpemU6IC44ZW07XG4gICAgICAgICAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgICAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICBgfVxuICAgICAgICA8L3N0eWxlPlxuICAgICAgICA8c3R5bGUganN4IGdsb2JhbD57UmFuZ2VTdHlsZX08L3N0eWxlPlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufVxuIl19 */\n/*@ sourceURL=pages/index.js */';
PuzzleStyle.__scopedHash = '113117877';
{/* language=CSS */}
var CirculuarProgressStyle = new String('.circular-progress{display:block;width:100%;position:absolute;top:0;left:0;-webkit-transition:filter .4s ease-in-out;transition:filter .4s ease-in-out;}.circle-bg{fill:none;stroke:#eee;stroke-width:3.8;}.circle{stroke:' + ControlNumberColor + ';-webkit-transition:stroke-dasharray .4s ease-in-out;transition:stroke-dasharray .4s ease-in-out;fill:none;stroke-width:2.8;stroke-linecap:round;}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhZ2VzL2luZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQXlKa0MsQUFHbUIsQUFTSixBQU0wQixVQUx4QixJQVRELFFBVU0sR0FUQyxXQWMwQixHQUpoRCxJQVRVLE1BQ0MsT0FDMkIsNEVBQ3RDLEFBV2MsVUFDTyxpQkFDSSxxQkFDekIiLCJmaWxlIjoicGFnZXMvaW5kZXguanMiLCJzb3VyY2VSb290IjoiL1VzZXJzL2xpY2hlbm1hL1Byb2plY3RzL1N1RHVva3UvU3VEdW9rdSIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIGpzeC1hMTF5L2FjY2Vzc2libGUtZW1vamkgKi9cbmltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFNldCwgTGlzdCwgZnJvbUpTIH0gZnJvbSAnaW1tdXRhYmxlJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgTmV4dEhlYWQgZnJvbSAnbmV4dC9oZWFkJztcbmltcG9ydCBDb2xvciBmcm9tICdjb2xvcic7XG5pbXBvcnQgSW5wdXRSYW5nZSBmcm9tICdyZWFjdC1pbnB1dC1yYW5nZSc7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tZXh0cmFuZW91cy1kZXBlbmRlbmNpZXNcbmltcG9ydCBjc3MgZnJvbSAnc3R5bGVkLWpzeC9jc3MnO1xuXG5pbXBvcnQgUmFuZ2VTdHlsZSBmcm9tICcuLi9pbnB1dC1yYW5nZS1zdHlsZSc7XG5pbXBvcnQgTG91cGVJY29uIGZyb20gJy4uL3N2Zy9sb3VwZS5zdmcnO1xuaW1wb3J0IFJlbW92ZUljb24gZnJvbSAnLi4vc3ZnL3JlbW92ZS5zdmcnO1xuaW1wb3J0IFJlbG9hZEljb24gZnJvbSAnLi4vc3ZnL3JlbG9hZC5zdmcnO1xuaW1wb3J0IFJldHVybkljb24gZnJvbSAnLi4vc3ZnL3JldHVybi5zdmcnO1xuXG5pbXBvcnQgeyBtYWtlUHV6emxlLCBwbHVjaywgaXNQZWVyIGFzIGFyZUNvb3JkaW5hdGVQZWVycywgcmFuZ2UgfSBmcm9tICcuLi9zdWRva3UnO1xuaW1wb3J0IHsgYmFja0dyb3VuZEJsdWUgfSBmcm9tICcuLi9jb2xvcnMnO1xuaW1wb3J0IFRpcCBmcm9tICcuLi9jb21wb25lbnRzL3Rvb2wtdGlwJztcblxuaW1wb3J0IGlvIGZyb20gJ3NvY2tldC5pby1jbGllbnQnXG5cbmNvbnN0IERlc2NyaXB0aW9uID0gJ0Rpc2NvdmVyIHRoZSBuZXh0IGV2b2x1dGlvbiBvZiBTdWRva3Ugd2l0aCBhbWF6aW5nIGdyYXBoaWNzLCBhbmltYXRpb25zLCBhbmQgdXNlci1mcmllbmRseSBmZWF0dXJlcy4gRW5qb3kgYSBTdWRva3UgZXhwZXJpZW5jZSBsaWtlIHlvdSBuZXZlciBoYXZlIGJlZm9yZSB3aXRoIGN1c3RvbWl6YWJsZSBnYW1lIGdlbmVyYXRpb24sIGNlbGwgaGlnaGxpZ2h0aW5nLCBpbnR1aXRpdmUgY29udHJvbHMgYW5kIG1vcmUhJztcbmNvbnN0IGNlbGxXaWR0aCA9IDIuNTtcblxuY29uc3QgTGlnaHRCbHVlMTAwID0gJyNCM0U1RkMnO1xuY29uc3QgTGlnaHRCbHVlMjAwID0gJyM4MUQ0RkEnO1xuY29uc3QgTGlnaHRCbHVlMzAwID0gJyM0RkMzRjcnO1xuY29uc3QgSW5kaWdvNzAwID0gJyMzMDNGOUYnO1xuY29uc3QgRGVlcE9yYW5nZTIwMCA9ICcjRkZBQjkxJztcbmNvbnN0IERlZXBPcmFuZ2U2MDAgPSAnI0Y0NTExRSc7XG5jb25zdCBDb250cm9sTnVtYmVyQ29sb3IgPSBJbmRpZ283MDA7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sb25lLWJsb2Nrc1xueyAvKiBsYW5ndWFnZT1DU1MgKi8gfVxuY29uc3QgQ2VsbFN0eWxlID0gY3NzYFxuLmNlbGwge1xuICAgIGhlaWdodDogJHtjZWxsV2lkdGh9ZW07XG4gICAgd2lkdGg6ICR7Y2VsbFdpZHRofWVtO1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC13cmFwOiB3cmFwO1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgZm9udC1zaXplOiAxLjFlbTtcbiAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICB0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kLWNvbG9yIC4zcyBlYXNlLWluLW91dDtcbn1cbi5jZWxsOm50aC1jaGlsZCgzbiszKTpub3QoOmxhc3QtY2hpbGQpIHtcbiAgICBib3JkZXItcmlnaHQ6IDJweCBzb2xpZCBibGFjaztcbn1cbi5jZWxsOm5vdCg6bGFzdC1jaGlsZCkge1xuICAgIGJvcmRlci1yaWdodDogMXB4IHNvbGlkIGJsYWNrO1xufVxuLm5vdGUtbnVtYmVyIHtcbiAgICBmb250LXNpemU6IC42ZW07XG4gICAgd2lkdGg6IDMzJTtcbiAgICBoZWlnaHQ6IDMzJTtcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbn1cbmA7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sb25lLWJsb2Nrc1xueyAvKiBsYW5ndWFnZT1DU1MgKi8gfVxuY29uc3QgQWN0aW9uc1N0eWxlID0gY3NzYFxuLmFjdGlvbnMge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgbWF4LXdpZHRoOiA0MDBweDtcbiAgICBtYXJnaW4tdG9wOiAuNWVtO1xuICAgIHBhZGRpbmc6IDAgLjZlbTtcbn1cbi5hY3Rpb24ge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xufVxuLmFjdGlvbiA6Z2xvYmFsKHN2Zykge1xuICAgIHdpZHRoOiAyLjVlbTtcbiAgICBtYXJnaW4tYm90dG9tOiAuMmVtO1xufVxuLnJlZG8gOmdsb2JhbChzdmcpIHtcbiAgICB0cmFuc2Zvcm06IHNjYWxlWCgtMSk7XG59XG5gO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbG9uZS1ibG9ja3NcbnsgLyogbGFuZ3VhZ2U9Q1NTICovIH1cbmNvbnN0IENvbnRyb2xTdHlsZSA9IGNzc2Bcbi5jb250cm9sIHtcbiAgICBwYWRkaW5nOiAwIDJlbTtcbiAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgZGlzcGxheTogaW5saW5lLWZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBmbGV4LXdyYXA6IHdyYXA7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgZm9udC1mYW1pbHk6ICdTcGVjaWFsIEVsaXRlJywgY3Vyc2l2ZTtcbiAgICB0cmFuc2l0aW9uOiBmaWx0ZXIgLjVzIGVhc2UtaW4tb3V0O1xuICAgIHdpZHRoOiAxMDAlO1xufVxuYDtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxvbmUtYmxvY2tzXG57IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG5jb25zdCBOdW1iZXJDb250cm9sU3R5bGUgPSBjc3NgXG4ubnVtYmVyIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGZvbnQtc2l6ZTogMmVtO1xuICAgIG1hcmdpbjogLjFlbTtcbiAgICB3aWR0aDogMS41ZW07XG4gICAgaGVpZ2h0OiAxLjVlbTtcbiAgICBjb2xvcjogJHtDb250cm9sTnVtYmVyQ29sb3J9O1xuICAgIGJveC1zaGFkb3c6IDAgMXB4IDJweCByZ2JhKDAsMCwwLDAuMTYpLCAwIDFweCAycHggcmdiYSgwLDAsMCwwLjIzKTtcbiAgICBib3JkZXItcmFkaXVzOiA1MCU7XG59XG4ubnVtYmVyID4gZGl2IHtcbiAgICBtYXJnaW4tdG9wOiAuM2VtO1xufVxuYDtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxvbmUtYmxvY2tzXG57IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG5jb25zdCBQdXp6bGVTdHlsZSA9IGNzc2Bcbi5wdXp6bGUge1xuICAgIG1hcmdpbi10b3A6IC41ZW07XG4gICAgd2lkdGg6ICR7Y2VsbFdpZHRoICogOX1lbTtcbiAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgYm94LXNoYWRvdzogMCAzcHggNnB4IHJnYmEoMCwwLDAsMC4xNiksIDAgM3B4IDZweCByZ2JhKDAsMCwwLDAuMjMpO1xufVxuLnJvdyB7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGZsZXg6IDA7XG4gICAgd2lkdGg6ICR7Y2VsbFdpZHRoICogOX1lbTtcbn1cbi5yb3c6bm90KDpsYXN0LWNoaWxkKSB7XG4gICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkIGJsYWNrO1xufVxuLnJvdzpudGgtY2hpbGQoM24rMyk6bm90KDpsYXN0LWNoaWxkKSB7XG4gICAgYm9yZGVyLWJvdHRvbTogMnB4IHNvbGlkIGJsYWNrICFpbXBvcnRhbnQ7XG59XG5gO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbG9uZS1ibG9ja3NcbnsgLyogbGFuZ3VhZ2U9Q1NTICovIH1cbmNvbnN0IENpcmN1bHVhclByb2dyZXNzU3R5bGUgPSBjc3NgXG4uY2lyY3VsYXItcHJvZ3Jlc3Mge1xuICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB0b3A6IDA7XG4gICAgbGVmdDogMDtcbiAgICB0cmFuc2l0aW9uOiBmaWx0ZXIgLjRzIGVhc2UtaW4tb3V0O1xufVxuXG4uY2lyY2xlLWJnIHtcbiAgICBmaWxsOiBub25lO1xuICAgIHN0cm9rZTogI2VlZTtcbiAgICBzdHJva2Utd2lkdGg6IDMuODtcbn1cblxuLmNpcmNsZSB7XG4gICAgc3Ryb2tlOiAke0NvbnRyb2xOdW1iZXJDb2xvcn07XG4gICAgdHJhbnNpdGlvbjogc3Ryb2tlLWRhc2hhcnJheSAuNHMgZWFzZS1pbi1vdXQ7XG4gICAgZmlsbDogbm9uZTtcbiAgICBzdHJva2Utd2lkdGg6IDIuODtcbiAgICBzdHJva2UtbGluZWNhcDogcm91bmQ7XG59XG5gO1xuXG5jb25zdCBDaXJjdWxhclBhdGhEID0gJ00xOCAyLjA4NDUgYSAxNS45MTU1IDE1LjkxNTUgMCAwIDEgMCAzMS44MzEgYSAxNS45MTU1IDE1LjkxNTUgMCAwIDEgMCAtMzEuODMxJztcblxuZnVuY3Rpb24gZ2V0QmFja0dyb3VuZENvbG9yKHtcbiAgY29uZmxpY3QsIGlzUGVlciwgc2FtZVZhbHVlLCBpc1NlbGVjdGVkLFxufSkge1xuICBpZiAoY29uZmxpY3QgJiYgaXNQZWVyICYmIHNhbWVWYWx1ZSkge1xuICAgIHJldHVybiBEZWVwT3JhbmdlMjAwO1xuICB9IGVsc2UgaWYgKHNhbWVWYWx1ZSkge1xuICAgIHJldHVybiBMaWdodEJsdWUzMDA7XG4gIH0gZWxzZSBpZiAoaXNTZWxlY3RlZCkge1xuICAgIHJldHVybiBMaWdodEJsdWUyMDA7XG4gIH0gZWxzZSBpZiAoaXNQZWVyKSB7XG4gICAgcmV0dXJuIExpZ2h0Qmx1ZTEwMDtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldEZvbnRDb2xvcih7IHZhbHVlLCBjb25mbGljdCwgcHJlZmlsbGVkIH0pIHtcbiAgaWYgKGNvbmZsaWN0ICYmICFwcmVmaWxsZWQpIHtcbiAgICByZXR1cm4gRGVlcE9yYW5nZTYwMDtcbiAgfSBlbHNlIGlmICghcHJlZmlsbGVkICYmIHZhbHVlKSB7XG4gICAgcmV0dXJuIENvbnRyb2xOdW1iZXJDb2xvcjtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmNsYXNzIEdlbmVyYXRpb25VSSBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuXG4gICAgdGhpcy5zdGF0ZSA9IHsgdmFsdWU6IDMwIH07XG4gIH1cblxuICBnZW5lcmF0ZUdhbWUgPSAoKSA9PiB7XG4gICAgdGhpcy5wcm9wcy5nZW5lcmF0ZUdhbWUodGhpcy5zdGF0ZS52YWx1ZSk7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ2VuZXJhdGlvblwiPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvcHlcIj5TdGFydCB3aXRoIHt0aGlzLnN0YXRlLnZhbHVlfSBjZWxscyBwcmVmaWxsZWQ8L2Rpdj5cbiAgICAgICAgPElucHV0UmFuZ2VcbiAgICAgICAgICBtYXhWYWx1ZT17ODF9XG4gICAgICAgICAgbWluVmFsdWU9ezE3fVxuICAgICAgICAgIHZhbHVlPXt0aGlzLnN0YXRlLnZhbHVlfVxuICAgICAgICAgIG9uQ2hhbmdlPXt2YWx1ZSA9PiB0aGlzLnNldFN0YXRlKHsgdmFsdWUgfSl9XG4gICAgICAgIC8+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYnV0dG9uXCIgb25DbGljaz17dGhpcy5nZW5lcmF0ZUdhbWV9PlBsYXkgU3Vkb2t1PC9kaXY+XG4gICAgICAgIHsgLyogbGFuZ3VhZ2U9Q1NTICovIH1cbiAgICAgICAgPHN0eWxlIGpzeD57YFxuICAgICAgICAgICAgLmNvcHkge1xuICAgICAgICAgICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICAgICAgICAgICAgICBmb250LXNpemU6IDEuM2VtO1xuICAgICAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IC41ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAuZ2VuZXJhdGlvbiB7XG4gICAgICAgICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgICAgICAgICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6Z2xvYmFsKC5pbnB1dC1yYW5nZSkge1xuICAgICAgICAgICAgICAgIHdpZHRoOiA4MCU7XG4gICAgICAgICAgICAgICAgbWF4LXdpZHRoOiA1MDBweDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC5idXR0b24ge1xuICAgICAgICAgICAgICBtYXJnaW4tdG9wOiAuNWVtO1xuICAgICAgICAgICAgICBib3JkZXItcmFkaXVzOiAuMjVlbTtcbiAgICAgICAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgICAgICAgICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICAgICAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xuICAgICAgICAgICAgICBjb2xvcjogI2ZmZjtcbiAgICAgICAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gICAgICAgICAgICAgIHRyYW5zaXRpb246IGFsbCAuMjVzO1xuICAgICAgICAgICAgICBwYWRkaW5nOiA1cHggMTBweDtcbiAgICAgICAgICAgICAgZm9udC1zaXplOiAxLjRlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC5idXR0b246YWN0aXZlIHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoMHB4LCA1cHgpO1xuICAgICAgICAgICAgICBib3gtc2hhZG93OiAwIDFweCAwIDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC5idXR0b24ge1xuICAgICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAke2JhY2tHcm91bmRCbHVlfTtcbiAgICAgICAgICAgICAgYm94LXNoYWRvdzogMCAycHggNHB4IDAgJHtDb2xvcihiYWNrR3JvdW5kQmx1ZSkuZGFya2VuKDAuNSkuaHNsKCkuc3RyaW5nKCl9O1xuICAgICAgICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAuYnV0dG9uOmhvdmVyIHtcbiAgICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogJHtDb2xvcihiYWNrR3JvdW5kQmx1ZSkubGlnaHRlbigwLjIpLmhzbCgpLnN0cmluZygpfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgYH1cbiAgICAgICAgPC9zdHlsZT5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cbn1cblxuR2VuZXJhdGlvblVJLnByb3BUeXBlcyA9IHtcbiAgZ2VuZXJhdGVHYW1lOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxufTtcblxuY29uc3QgTnVtYmVyQ29udHJvbCA9ICh7IG51bWJlciwgb25DbGljaywgY29tcGxldGlvblBlcmNlbnRhZ2UgfSkgPT4gKFxuICA8ZGl2XG4gICAga2V5PXtudW1iZXJ9XG4gICAgY2xhc3NOYW1lPVwibnVtYmVyXCJcbiAgICBvbkNsaWNrPXtvbkNsaWNrfVxuICA+XG4gICAgPGRpdj57bnVtYmVyfTwvZGl2PlxuICAgIDxDaXJjbHVsYXJQcm9ncmVzcyBwZXJjZW50PXtjb21wbGV0aW9uUGVyY2VudGFnZX0gLz5cbiAgICA8c3R5bGUganN4PntOdW1iZXJDb250cm9sU3R5bGV9PC9zdHlsZT5cbiAgPC9kaXY+XG4pO1xuXG5OdW1iZXJDb250cm9sLnByb3BUeXBlcyA9IHtcbiAgbnVtYmVyOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIG9uQ2xpY2s6IFByb3BUeXBlcy5mdW5jLFxuICBjb21wbGV0aW9uUGVyY2VudGFnZTogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxufTtcblxuTnVtYmVyQ29udHJvbC5kZWZhdWx0UHJvcHMgPSB7XG4gIG9uQ2xpY2s6IG51bGwsXG59O1xuXG5jb25zdCBDZWxsID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHtcbiAgICB2YWx1ZSwgb25DbGljaywgaXNQZWVyLCBpc1NlbGVjdGVkLCBzYW1lVmFsdWUsIHByZWZpbGxlZCwgbm90ZXMsIGNvbmZsaWN0LFxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IGJhY2tncm91bmRDb2xvciA9IGdldEJhY2tHcm91bmRDb2xvcih7XG4gICAgY29uZmxpY3QsIGlzUGVlciwgc2FtZVZhbHVlLCBpc1NlbGVjdGVkLFxuICB9KTtcbiAgY29uc3QgZm9udENvbG9yID0gZ2V0Rm9udENvbG9yKHsgY29uZmxpY3QsIHByZWZpbGxlZCwgdmFsdWUgfSk7XG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJjZWxsXCIgb25DbGljaz17b25DbGlja30+XG4gICAgICB7XG4gICAgICAgIG5vdGVzID9cbiAgICAgICAgICByYW5nZSg5KS5tYXAoaSA9PlxuICAgICAgICAgICAgKFxuICAgICAgICAgICAgICA8ZGl2IGtleT17aX0gY2xhc3NOYW1lPVwibm90ZS1udW1iZXJcIj5cbiAgICAgICAgICAgICAgICB7bm90ZXMuaGFzKGkgKyAxKSAmJiAoaSArIDEpfVxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICkpIDpcbiAgICAgICAgICB2YWx1ZSAmJiB2YWx1ZVxuICAgICAgfVxuICAgICAgey8qIGxhbmd1YWdlPUNTUyAqL31cbiAgICAgIDxzdHlsZSBqc3g+e0NlbGxTdHlsZX08L3N0eWxlPlxuICAgICAgPHN0eWxlIGpzeD57YFxuICAgICAgICAgICAgICAgIC5jZWxsIHtcbiAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogJHtiYWNrZ3JvdW5kQ29sb3IgfHwgJ2luaXRpYWwnfTtcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6ICR7Zm9udENvbG9yIHx8ICdpbml0aWFsJ307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgYH1cbiAgICAgIDwvc3R5bGU+XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5DZWxsLnByb3BUeXBlcyA9IHtcbiAgLy8gY3VycmVudCBudW1iZXIgdmFsdWVcbiAgdmFsdWU6IFByb3BUeXBlcy5udW1iZXIsXG4gIC8vIGNlbGwgY2xpY2sgaGFuZGxlclxuICBvbkNsaWNrOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAvLyBpZiB0aGUgY2VsbCBpcyBhIHBlZXIgb2YgdGhlIHNlbGVjdGVkIGNlbGxcbiAgaXNQZWVyOiBQcm9wVHlwZXMuYm9vbC5pc1JlcXVpcmVkLFxuICAvLyBpZiB0aGUgY2VsbCBpcyBzZWxlY3RlZCBieSB0aGUgdXNlclxuICBpc1NlbGVjdGVkOiBQcm9wVHlwZXMuYm9vbC5pc1JlcXVpcmVkLFxuICAvLyBjdXJyZW50IGNlbGwgaGFzIHRoZSBzYW1lIHZhbHVlIGlmIHRoZSB1c2VyIHNlbGVjdGVkIGNlbGxcbiAgc2FtZVZhbHVlOiBQcm9wVHlwZXMuYm9vbC5pc1JlcXVpcmVkLFxuICAvLyBpZiB0aGlzIHdhcyBwcmVmaWxsZWQgYXMgYSBwYXJ0IG9mIHRoZSBwdXp6bGVcbiAgcHJlZmlsbGVkOiBQcm9wVHlwZXMuYm9vbC5pc1JlcXVpcmVkLFxuICAvLyBjdXJyZW50IG5vdGVzIHRha2VuIG9uIHRoZSBjZWxsXG4gIG5vdGVzOiBQcm9wVHlwZXMuaW5zdGFuY2VPZihTZXQpLFxuICAvLyBpZiB0aGUgY3VycmVudCBjZWxsIGRvZXMgbm90IHNhdGlzZnkgdGhlIGdhbWUgY29uc3RyYWludFxuICBjb25mbGljdDogUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZCxcbn07XG5cbkNlbGwuZGVmYXVsdFByb3BzID0ge1xuICBub3RlczogbnVsbCxcbiAgdmFsdWU6IG51bGwsXG59O1xuXG5jb25zdCBDaXJjbHVsYXJQcm9ncmVzcyA9ICh7IHBlcmNlbnQgfSkgPT4gKFxuICA8c3ZnIHZpZXdCb3g9XCIwIDAgMzYgMzZcIiBjbGFzc05hbWU9XCJjaXJjdWxhci1wcm9ncmVzc1wiPlxuICAgIDxwYXRoXG4gICAgICBjbGFzc05hbWU9XCJjaXJjbGUtYmdcIlxuICAgICAgZD17Q2lyY3VsYXJQYXRoRH1cbiAgICAvPlxuICAgIDxwYXRoXG4gICAgICBjbGFzc05hbWU9XCJjaXJjbGVcIlxuICAgICAgc3Ryb2tlRGFzaGFycmF5PXtgJHtwZXJjZW50ICogMTAwfSwgMTAwYH1cbiAgICAgIGQ9e0NpcmN1bGFyUGF0aER9XG4gICAgLz5cbiAgICB7IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG4gICAgPHN0eWxlIGpzeD57Q2lyY3VsdWFyUHJvZ3Jlc3NTdHlsZX08L3N0eWxlPlxuICA8L3N2Zz5cbik7XG5cbkNpcmNsdWxhclByb2dyZXNzLnByb3BUeXBlcyA9IHtcbiAgcGVyY2VudDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxufTtcblxuZnVuY3Rpb24gZ2V0Q2xpY2tIYW5kbGVyKG9uQ2xpY2ssIG9uRG91YmxlQ2xpY2ssIGRlbGF5ID0gMjUwKSB7XG4gIGxldCB0aW1lb3V0SUQgPSBudWxsO1xuICByZXR1cm4gKGV2ZW50KSA9PiB7XG4gICAgaWYgKCF0aW1lb3V0SUQpIHtcbiAgICAgIHRpbWVvdXRJRCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBvbkNsaWNrKGV2ZW50KTtcbiAgICAgICAgdGltZW91dElEID0gbnVsbDtcbiAgICAgIH0sIGRlbGF5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGltZW91dElEID0gY2xlYXJUaW1lb3V0KHRpbWVvdXRJRCk7XG4gICAgICBvbkRvdWJsZUNsaWNrKGV2ZW50KTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogbWFrZSBzaXplIDkgYXJyYXkgb2YgMHNcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZnVuY3Rpb24gbWFrZUNvdW50T2JqZWN0KCkge1xuICBjb25zdCBjb3VudE9iaiA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpICs9IDEpIGNvdW50T2JqLnB1c2goMCk7XG4gIHJldHVybiBjb3VudE9iajtcbn1cblxuLyoqXG4gKiBnaXZlbiBhIDJEIGFycmF5IG9mIG51bWJlcnMgYXMgdGhlIGluaXRpYWwgcHV6emxlLCBnZW5lcmF0ZSB0aGUgaW5pdGlhbCBnYW1lIHN0YXRlXG4gKiBAcGFyYW0gcHV6emxlXG4gKiBAcmV0dXJucyB7YW55fVxuICovXG5mdW5jdGlvbiBtYWtlQm9hcmQoeyBwdXp6bGUgfSkge1xuICAvLyBjcmVhdGUgaW5pdGlhbCBjb3VudCBvYmplY3QgdG8ga2VlcCB0cmFjayBvZiBjb25mbGljdHMgcGVyIG51bWJlciB2YWx1ZVxuICBjb25zdCByb3dzID0gQXJyYXkuZnJvbShBcnJheSg5KS5rZXlzKCkpLm1hcCgoKSA9PiBtYWtlQ291bnRPYmplY3QoKSk7XG4gIGNvbnN0IGNvbHVtbnMgPSBBcnJheS5mcm9tKEFycmF5KDkpLmtleXMoKSkubWFwKCgpID0+IG1ha2VDb3VudE9iamVjdCgpKTtcbiAgY29uc3Qgc3F1YXJlcyA9IEFycmF5LmZyb20oQXJyYXkoOSkua2V5cygpKS5tYXAoKCkgPT4gbWFrZUNvdW50T2JqZWN0KCkpO1xuICBjb25zdCByZXN1bHQgPSBwdXp6bGUubWFwKChyb3csIGkpID0+IChcbiAgICByb3cubWFwKChjZWxsLCBqKSA9PiB7XG4gICAgICBpZiAoY2VsbCkge1xuICAgICAgICByb3dzW2ldW2NlbGxdICs9IDE7XG4gICAgICAgIGNvbHVtbnNbal1bY2VsbF0gKz0gMTtcbiAgICAgICAgc3F1YXJlc1soKE1hdGguZmxvb3IoaSAvIDMpKSAqIDMpICsgTWF0aC5mbG9vcihqIC8gMyldW2NlbGxdICs9IDE7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogcHV6emxlW2ldW2pdID4gMCA/IHB1enpsZVtpXVtqXSA6IG51bGwsXG4gICAgICAgIHByZWZpbGxlZDogISFwdXp6bGVbaV1bal0sXG4gICAgICB9O1xuICAgIH0pXG4gICkpO1xuICByZXR1cm4gZnJvbUpTKHsgcHV6emxlOiByZXN1bHQsIHNlbGVjdGVkOiBmYWxzZSwgY2hvaWNlczogeyByb3dzLCBjb2x1bW5zLCBzcXVhcmVzIH0gfSk7XG59XG5cbi8qKlxuICogZ2l2ZSB0aGUgY29vcmRpbmF0ZSB1cGRhdGUgdGhlIGN1cnJlbnQgYm9hcmQgd2l0aCBhIG51bWJlciBjaG9pY2VcbiAqIEBwYXJhbSB4XG4gKiBAcGFyYW0geVxuICogQHBhcmFtIG51bWJlclxuICogQHBhcmFtIGZpbGwgd2hldGhlciB0byBzZXQgb3IgdW5zZXRcbiAqIEBwYXJhbSBib2FyZCB0aGUgaW1tdXRhYmxlIGJvYXJkIGdpdmVuIHRvIGNoYW5nZVxuICovXG5mdW5jdGlvbiB1cGRhdGVCb2FyZFdpdGhOdW1iZXIoe1xuICB4LCB5LCBudW1iZXIsIGZpbGwgPSB0cnVlLCBib2FyZCxcbn0pIHtcbiAgbGV0IGNlbGwgPSBib2FyZC5nZXQoJ3B1enpsZScpLmdldEluKFt4LCB5XSk7XG4gIC8vIGRlbGV0ZSBpdHMgbm90ZXNcbiAgY2VsbCA9IGNlbGwuZGVsZXRlKCdub3RlcycpO1xuICAvLyBzZXQgb3IgdW5zZXQgaXRzIHZhbHVlIGRlcGVuZGluZyBvbiBgZmlsbGBcbiAgY2VsbCA9IGZpbGwgPyBjZWxsLnNldCgndmFsdWUnLCBudW1iZXIpIDogY2VsbC5kZWxldGUoJ3ZhbHVlJyk7XG4gIGNvbnN0IGluY3JlbWVudCA9IGZpbGwgPyAxIDogLTE7XG4gIC8vIHVwZGF0ZSB0aGUgY3VycmVudCBncm91cCBjaG9pY2VzXG4gIGNvbnN0IHJvd1BhdGggPSBbJ2Nob2ljZXMnLCAncm93cycsIHgsIG51bWJlcl07XG4gIGNvbnN0IGNvbHVtblBhdGggPSBbJ2Nob2ljZXMnLCAnY29sdW1ucycsIHksIG51bWJlcl07XG4gIGNvbnN0IHNxdWFyZVBhdGggPSBbJ2Nob2ljZXMnLCAnc3F1YXJlcycsXG4gICAgKChNYXRoLmZsb29yKHggLyAzKSkgKiAzKSArIE1hdGguZmxvb3IoeSAvIDMpLCBudW1iZXJdO1xuICByZXR1cm4gYm9hcmQuc2V0SW4ocm93UGF0aCwgYm9hcmQuZ2V0SW4ocm93UGF0aCkgKyBpbmNyZW1lbnQpXG4gICAgLnNldEluKGNvbHVtblBhdGgsIGJvYXJkLmdldEluKGNvbHVtblBhdGgpICsgaW5jcmVtZW50KVxuICAgIC5zZXRJbihzcXVhcmVQYXRoLCBib2FyZC5nZXRJbihzcXVhcmVQYXRoKSArIGluY3JlbWVudClcbiAgICAuc2V0SW4oWydwdXp6bGUnLCB4LCB5XSwgY2VsbCk7XG59XG5cbmZ1bmN0aW9uIGdldE51bWJlck9mR3JvdXBzQXNzaWduZWRGb3JOdW1iZXIobnVtYmVyLCBncm91cHMpIHtcbiAgcmV0dXJuIGdyb3Vwcy5yZWR1Y2UoKGFjY3VtdWxhdG9yLCByb3cpID0+XG4gICAgYWNjdW11bGF0b3IgKyAocm93LmdldChudW1iZXIpID4gMCA/IDEgOiAwKSwgMCk7XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3Qvbm8tbXVsdGktY29tcFxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW5kZXggZXh0ZW5kcyBDb21wb25lbnQge1xuICBzdGF0ZSA9IHt9O1xuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgIGlmICgnc2VydmljZVdvcmtlcicgaW4gbmF2aWdhdG9yKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICAgIG5hdmlnYXRvci5zZXJ2aWNlV29ya2VyXG4gICAgICAgIC5yZWdpc3RlcignL3NlcnZpY2Utd29ya2VyLmpzJylcbiAgICAgICAgLnRoZW4oKHJlZykgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdTZXJ2aWNlV29ya2VyIHNjb3BlOiAnLCByZWcuc2NvcGUpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdzZXJ2aWNlIHdvcmtlciByZWdpc3RyYXRpb24gc3VjY2Vzc2Z1bCcpO1xuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgIGNvbnNvbGUud2Fybignc2VydmljZSB3b3JrZXIgcmVnaXN0cmF0aW9uIGZhaWxlZCcsIGVyci5tZXNzYWdlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICBcbiAgICBmZXRjaCgnL2FwaS9zb2NrZXRpbycpLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgY29uc3Qgc29ja2V0ID0gaW8oKVxuXG4gICAgICBzb2NrZXQub24oJ2Nvbm5lY3QnLCAoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdjb25uZWN0JylcbiAgICAgICAgc29ja2V0LmVtaXQoJ2hlbGxvJylcbiAgICAgIH0pXG5cbiAgICAgIHNvY2tldC5vbignaGVsbG8nLCBkYXRhID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ2hlbGxvJywgZGF0YSlcbiAgICAgIH0pXG5cbiAgICAgIHNvY2tldC5vbignYSB1c2VyIGNvbm5lY3RlZCcsICgpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ2EgdXNlciBjb25uZWN0ZWQnKVxuICAgICAgfSlcblxuICAgICAgc29ja2V0Lm9uKCdkaXNjb25uZWN0JywgKCkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZygnZGlzY29ubmVjdCcpXG4gICAgICB9KVxuICAgIH0pXG4gICBcbiAgfVxuICBnZXRTZWxlY3RlZENlbGwoKSB7XG4gICAgY29uc3QgeyBib2FyZCB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBzZWxlY3RlZCA9IGJvYXJkLmdldCgnc2VsZWN0ZWQnKTtcbiAgICByZXR1cm4gc2VsZWN0ZWQgJiYgYm9hcmQuZ2V0KCdwdXp6bGUnKS5nZXRJbihbc2VsZWN0ZWQueCwgc2VsZWN0ZWQueV0pO1xuICB9XG5cbiAgLy8gZ2V0IHRoZSBtaW4gYmV0d2VlbiBpdHMgY29tcGxldGlvbiBpbiByb3dzLCBjb2x1bW5zIGFuZCBzcXVhcmVzLlxuICBnZXROdW1iZXJWYWx1ZUNvdW50KG51bWJlcikge1xuICAgIGNvbnN0IHJvd3MgPSB0aGlzLnN0YXRlLmJvYXJkLmdldEluKFsnY2hvaWNlcycsICdyb3dzJ10pO1xuICAgIGNvbnN0IGNvbHVtbnMgPSB0aGlzLnN0YXRlLmJvYXJkLmdldEluKFsnY2hvaWNlcycsICdjb2x1bW5zJ10pO1xuICAgIGNvbnN0IHNxdWFyZXMgPSB0aGlzLnN0YXRlLmJvYXJkLmdldEluKFsnY2hvaWNlcycsICdzcXVhcmVzJ10pO1xuICAgIHJldHVybiBNYXRoLm1pbihcbiAgICAgIGdldE51bWJlck9mR3JvdXBzQXNzaWduZWRGb3JOdW1iZXIobnVtYmVyLCBzcXVhcmVzKSxcbiAgICAgIE1hdGgubWluKFxuICAgICAgICBnZXROdW1iZXJPZkdyb3Vwc0Fzc2lnbmVkRm9yTnVtYmVyKG51bWJlciwgcm93cyksXG4gICAgICAgIGdldE51bWJlck9mR3JvdXBzQXNzaWduZWRGb3JOdW1iZXIobnVtYmVyLCBjb2x1bW5zKSxcbiAgICAgICksXG4gICAgKTtcbiAgfVxuXG4gIGdlbmVyYXRlR2FtZSA9IChmaW5hbENvdW50ID0gMjApID0+IHtcbiAgICAvLyBnZXQgYSBmaWxsZWQgcHV6emxlIGdlbmVyYXRlZFxuICAgIGNvbnN0IHNvbHV0aW9uID0gbWFrZVB1enpsZSgpO1xuICAgIC8vIHBsdWNrIHZhbHVlcyBmcm9tIGNlbGxzIHRvIGNyZWF0ZSB0aGUgZ2FtZVxuICAgIGNvbnN0IHsgcHV6emxlIH0gPSBwbHVjayhzb2x1dGlvbiwgZmluYWxDb3VudCk7XG4gICAgLy8gaW5pdGlhbGl6ZSB0aGUgYm9hcmQgd2l0aCBjaG9pY2UgY291bnRzXG4gICAgY29uc3QgYm9hcmQgPSBtYWtlQm9hcmQoeyBwdXp6bGUgfSk7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBib2FyZCwgaGlzdG9yeTogTGlzdC5vZihib2FyZCksIGhpc3RvcnlPZmZTZXQ6IDAsIHNvbHV0aW9uLFxuICAgIH0pO1xuICB9XG5cbiAgYWRkTnVtYmVyQXNOb3RlID0gKG51bWJlcikgPT4ge1xuICAgIGxldCB7IGJvYXJkIH0gPSB0aGlzLnN0YXRlO1xuICAgIGxldCBzZWxlY3RlZENlbGwgPSB0aGlzLmdldFNlbGVjdGVkQ2VsbCgpO1xuICAgIGlmICghc2VsZWN0ZWRDZWxsKSByZXR1cm47XG4gICAgY29uc3QgcHJlZmlsbGVkID0gc2VsZWN0ZWRDZWxsLmdldCgncHJlZmlsbGVkJyk7XG4gICAgaWYgKHByZWZpbGxlZCkgcmV0dXJuO1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gYm9hcmQuZ2V0KCdzZWxlY3RlZCcpO1xuICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHNlbGVjdGVkQ2VsbC5nZXQoJ3ZhbHVlJyk7XG4gICAgaWYgKGN1cnJlbnRWYWx1ZSkge1xuICAgICAgYm9hcmQgPSB1cGRhdGVCb2FyZFdpdGhOdW1iZXIoe1xuICAgICAgICB4LCB5LCBudW1iZXI6IGN1cnJlbnRWYWx1ZSwgZmlsbDogZmFsc2UsIGJvYXJkOiB0aGlzLnN0YXRlLmJvYXJkLFxuICAgICAgfSk7XG4gICAgfVxuICAgIGxldCBub3RlcyA9IHNlbGVjdGVkQ2VsbC5nZXQoJ25vdGVzJykgfHwgU2V0KCk7XG4gICAgaWYgKG5vdGVzLmhhcyhudW1iZXIpKSB7XG4gICAgICBub3RlcyA9IG5vdGVzLmRlbGV0ZShudW1iZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub3RlcyA9IG5vdGVzLmFkZChudW1iZXIpO1xuICAgIH1cbiAgICBzZWxlY3RlZENlbGwgPSBzZWxlY3RlZENlbGwuc2V0KCdub3RlcycsIG5vdGVzKTtcbiAgICBzZWxlY3RlZENlbGwgPSBzZWxlY3RlZENlbGwuZGVsZXRlKCd2YWx1ZScpO1xuICAgIGJvYXJkID0gYm9hcmQuc2V0SW4oWydwdXp6bGUnLCB4LCB5XSwgc2VsZWN0ZWRDZWxsKTtcbiAgICB0aGlzLnVwZGF0ZUJvYXJkKGJvYXJkKTtcbiAgfTtcblxuICB1cGRhdGVCb2FyZCA9IChuZXdCb2FyZCkgPT4ge1xuICAgIGxldCB7IGhpc3RvcnkgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgeyBoaXN0b3J5T2ZmU2V0IH0gPSB0aGlzLnN0YXRlO1xuICAgIC8vIGFueXRoaW5nIGJlZm9yZSBjdXJyZW50IHN0ZXAgaXMgc3RpbGwgaW4gaGlzdG9yeVxuICAgIGhpc3RvcnkgPSBoaXN0b3J5LnNsaWNlKDAsIGhpc3RvcnlPZmZTZXQgKyAxKTtcbiAgICAvLyBhZGQgaXRzZWxmIG9udG8gdGhlIGhpc3RvcnlcbiAgICBoaXN0b3J5ID0gaGlzdG9yeS5wdXNoKG5ld0JvYXJkKTtcbiAgICAvLyB1cGRhdGUgdGhlIGdhbWVcbiAgICB0aGlzLnNldFN0YXRlKHsgYm9hcmQ6IG5ld0JvYXJkLCBoaXN0b3J5LCBoaXN0b3J5T2ZmU2V0OiBoaXN0b3J5LnNpemUgLSAxIH0pO1xuICB9O1xuXG4gIGNhblVuZG8gPSAoKSA9PiB0aGlzLnN0YXRlLmhpc3RvcnlPZmZTZXQgPiAwXG5cbiAgcmVkbyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGhpc3RvcnkgfSA9IHRoaXMuc3RhdGU7XG4gICAgbGV0IHsgaGlzdG9yeU9mZlNldCB9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAoaGlzdG9yeS5zaXplKSB7XG4gICAgICBoaXN0b3J5T2ZmU2V0ID0gTWF0aC5taW4oaGlzdG9yeS5zaXplIC0gMSwgaGlzdG9yeU9mZlNldCArIDEpO1xuICAgICAgY29uc3QgYm9hcmQgPSBoaXN0b3J5LmdldChoaXN0b3J5T2ZmU2V0KTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBib2FyZCwgaGlzdG9yeU9mZlNldCB9KTtcbiAgICB9XG4gIH07XG5cbiAgdW5kbyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGhpc3RvcnkgfSA9IHRoaXMuc3RhdGU7XG4gICAgbGV0IHsgaGlzdG9yeU9mZlNldCwgYm9hcmQgfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKGhpc3Rvcnkuc2l6ZSkge1xuICAgICAgaGlzdG9yeU9mZlNldCA9IE1hdGgubWF4KDAsIGhpc3RvcnlPZmZTZXQgLSAxKTtcbiAgICAgIGJvYXJkID0gaGlzdG9yeS5nZXQoaGlzdG9yeU9mZlNldCk7XG4gICAgICB0aGlzLnNldFN0YXRlKHsgYm9hcmQsIGhpc3RvcnlPZmZTZXQsIGhpc3RvcnkgfSk7XG4gICAgfVxuICB9O1xuXG4gIGVyYXNlU2VsZWN0ZWQgPSAoKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0ZWRDZWxsID0gdGhpcy5nZXRTZWxlY3RlZENlbGwoKTtcbiAgICBpZiAoIXNlbGVjdGVkQ2VsbCkgcmV0dXJuO1xuICAgIHRoaXMuZmlsbE51bWJlcihmYWxzZSk7XG4gIH1cblxuICBmaWxsU2VsZWN0ZWRXaXRoU29sdXRpb24gPSAoKSA9PiB7XG4gICAgY29uc3QgeyBib2FyZCwgc29sdXRpb24gfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3Qgc2VsZWN0ZWRDZWxsID0gdGhpcy5nZXRTZWxlY3RlZENlbGwoKTtcbiAgICBpZiAoIXNlbGVjdGVkQ2VsbCkgcmV0dXJuO1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gYm9hcmQuZ2V0KCdzZWxlY3RlZCcpO1xuICAgIHRoaXMuZmlsbE51bWJlcihzb2x1dGlvblt4XVt5XSk7XG4gIH1cblxuXG4gIC8vIGZpbGwgY3VycmVudGx5IHNlbGVjdGVkIGNlbGwgd2l0aCBudW1iZXJcbiAgZmlsbE51bWJlciA9IChudW1iZXIpID0+IHtcbiAgICBsZXQgeyBib2FyZCB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBzZWxlY3RlZENlbGwgPSB0aGlzLmdldFNlbGVjdGVkQ2VsbCgpO1xuICAgIC8vIG5vLW9wIGlmIG5vdGhpbmcgaXMgc2VsZWN0ZWRcbiAgICBpZiAoIXNlbGVjdGVkQ2VsbCkgcmV0dXJuO1xuICAgIGNvbnN0IHByZWZpbGxlZCA9IHNlbGVjdGVkQ2VsbC5nZXQoJ3ByZWZpbGxlZCcpO1xuICAgIC8vIG5vLW9wIGlmIGl0IGlzIHJlZmlsbGVkXG4gICAgaWYgKHByZWZpbGxlZCkgcmV0dXJuO1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gYm9hcmQuZ2V0KCdzZWxlY3RlZCcpO1xuICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHNlbGVjdGVkQ2VsbC5nZXQoJ3ZhbHVlJyk7XG4gICAgLy8gcmVtb3ZlIHRoZSBjdXJyZW50IHZhbHVlIGFuZCB1cGRhdGUgdGhlIGdhbWUgc3RhdGVcbiAgICBpZiAoY3VycmVudFZhbHVlKSB7XG4gICAgICBib2FyZCA9IHVwZGF0ZUJvYXJkV2l0aE51bWJlcih7XG4gICAgICAgIHgsIHksIG51bWJlcjogY3VycmVudFZhbHVlLCBmaWxsOiBmYWxzZSwgYm9hcmQ6IHRoaXMuc3RhdGUuYm9hcmQsXG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gdXBkYXRlIHRvIG5ldyBudW1iZXIgaWYgYW55XG4gICAgY29uc3Qgc2V0TnVtYmVyID0gY3VycmVudFZhbHVlICE9PSBudW1iZXIgJiYgbnVtYmVyO1xuICAgIGlmIChzZXROdW1iZXIpIHtcbiAgICAgIGJvYXJkID0gdXBkYXRlQm9hcmRXaXRoTnVtYmVyKHtcbiAgICAgICAgeCwgeSwgbnVtYmVyLCBmaWxsOiB0cnVlLCBib2FyZCxcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZUJvYXJkKGJvYXJkKTtcbiAgfTtcblxuICBzZWxlY3RDZWxsID0gKHgsIHkpID0+IHtcbiAgICBsZXQgeyBib2FyZCB9ID0gdGhpcy5zdGF0ZTtcbiAgICBib2FyZCA9IGJvYXJkLnNldCgnc2VsZWN0ZWQnLCB7IHgsIHkgfSk7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IGJvYXJkIH0pO1xuICB9O1xuXG4gIGlzQ29uZmxpY3QoaSwgaikge1xuICAgIGNvbnN0IHsgdmFsdWUgfSA9IHRoaXMuc3RhdGUuYm9hcmQuZ2V0SW4oWydwdXp6bGUnLCBpLCBqXSkudG9KU09OKCk7XG4gICAgaWYgKCF2YWx1ZSkgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IHJvd0NvbmZsaWN0ID1cbiAgICAgIHRoaXMuc3RhdGUuYm9hcmQuZ2V0SW4oWydjaG9pY2VzJywgJ3Jvd3MnLCBpLCB2YWx1ZV0pID4gMTtcbiAgICBjb25zdCBjb2x1bW5Db25mbGljdCA9XG4gICAgICB0aGlzLnN0YXRlLmJvYXJkLmdldEluKFsnY2hvaWNlcycsICdjb2x1bW5zJywgaiwgdmFsdWVdKSA+IDE7XG4gICAgY29uc3Qgc3F1YXJlQ29uZmxpY3QgPVxuICAgICAgdGhpcy5zdGF0ZS5ib2FyZC5nZXRJbihbJ2Nob2ljZXMnLCAnc3F1YXJlcycsXG4gICAgICAgICgoTWF0aC5mbG9vcihpIC8gMykpICogMykgKyBNYXRoLmZsb29yKGogLyAzKSwgdmFsdWVdKSA+IDE7XG4gICAgcmV0dXJuIHJvd0NvbmZsaWN0IHx8IGNvbHVtbkNvbmZsaWN0IHx8IHNxdWFyZUNvbmZsaWN0O1xuICB9XG5cbiAgcmVuZGVyQ2VsbChjZWxsLCB4LCB5KSB7XG4gICAgY29uc3QgeyBib2FyZCB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBzZWxlY3RlZCA9IHRoaXMuZ2V0U2VsZWN0ZWRDZWxsKCk7XG4gICAgY29uc3QgeyB2YWx1ZSwgcHJlZmlsbGVkLCBub3RlcyB9ID0gY2VsbC50b0pTT04oKTtcbiAgICBjb25zdCBjb25mbGljdCA9IHRoaXMuaXNDb25mbGljdCh4LCB5KTtcbiAgICBjb25zdCBwZWVyID0gYXJlQ29vcmRpbmF0ZVBlZXJzKHsgeCwgeSB9LCBib2FyZC5nZXQoJ3NlbGVjdGVkJykpO1xuICAgIGNvbnN0IHNhbWVWYWx1ZSA9ICEhKHNlbGVjdGVkICYmIHNlbGVjdGVkLmdldCgndmFsdWUnKVxuICAgICAgJiYgdmFsdWUgPT09IHNlbGVjdGVkLmdldCgndmFsdWUnKSk7XG5cbiAgICBjb25zdCBpc1NlbGVjdGVkID0gY2VsbCA9PT0gc2VsZWN0ZWQ7XG4gICAgcmV0dXJuICg8Q2VsbFxuICAgICAgcHJlZmlsbGVkPXtwcmVmaWxsZWR9XG4gICAgICBub3Rlcz17bm90ZXN9XG4gICAgICBzYW1lVmFsdWU9e3NhbWVWYWx1ZX1cbiAgICAgIGlzU2VsZWN0ZWQ9e2lzU2VsZWN0ZWR9XG4gICAgICBpc1BlZXI9e3BlZXJ9XG4gICAgICB2YWx1ZT17dmFsdWV9XG4gICAgICBvbkNsaWNrPXsoKSA9PiB7IHRoaXMuc2VsZWN0Q2VsbCh4LCB5KTsgfX1cbiAgICAgIGtleT17eX1cbiAgICAgIHg9e3h9XG4gICAgICB5PXt5fVxuICAgICAgY29uZmxpY3Q9e2NvbmZsaWN0fVxuICAgIC8+KTtcbiAgfVxuXG4gIHJlbmRlck51bWJlckNvbnRyb2woKSB7XG4gICAgY29uc3Qgc2VsZWN0ZWRDZWxsID0gdGhpcy5nZXRTZWxlY3RlZENlbGwoKTtcbiAgICBjb25zdCBwcmVmaWxsZWQgPSBzZWxlY3RlZENlbGwgJiYgc2VsZWN0ZWRDZWxsLmdldCgncHJlZmlsbGVkJyk7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29udHJvbFwiPlxuICAgICAgICB7cmFuZ2UoOSkubWFwKChpKSA9PiB7XG4gICAgICAgICAgY29uc3QgbnVtYmVyID0gaSArIDE7XG4gICAgICAgICAgLy8gaGFuZGxlcyBiaW5kaW5nIHNpbmdsZSBjbGljayBhbmQgZG91YmxlIGNsaWNrIGNhbGxiYWNrc1xuICAgICAgICAgIGNvbnN0IGNsaWNrSGFuZGxlID0gZ2V0Q2xpY2tIYW5kbGVyKFxuICAgICAgICAgICAgKCkgPT4geyB0aGlzLmZpbGxOdW1iZXIobnVtYmVyKTsgfSxcbiAgICAgICAgICAgICgpID0+IHsgdGhpcy5hZGROdW1iZXJBc05vdGUobnVtYmVyKTsgfSxcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8TnVtYmVyQ29udHJvbFxuICAgICAgICAgICAgICBrZXk9e251bWJlcn1cbiAgICAgICAgICAgICAgbnVtYmVyPXtudW1iZXJ9XG4gICAgICAgICAgICAgIG9uQ2xpY2s9eyFwcmVmaWxsZWQgPyBjbGlja0hhbmRsZSA6IHVuZGVmaW5lZH1cbiAgICAgICAgICAgICAgY29tcGxldGlvblBlcmNlbnRhZ2U9e3RoaXMuZ2V0TnVtYmVyVmFsdWVDb3VudChudW1iZXIpIC8gOX1cbiAgICAgICAgICAgIC8+KTtcbiAgICAgICAgfSl9XG4gICAgICAgIDxzdHlsZSBqc3g+e0NvbnRyb2xTdHlsZX08L3N0eWxlPlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxuXG4gIHJlbmRlckFjdGlvbnMoKSB7XG4gICAgY29uc3QgeyBoaXN0b3J5IH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IHNlbGVjdGVkQ2VsbCA9IHRoaXMuZ2V0U2VsZWN0ZWRDZWxsKCk7XG4gICAgY29uc3QgcHJlZmlsbGVkID0gc2VsZWN0ZWRDZWxsICYmIHNlbGVjdGVkQ2VsbC5nZXQoJ3ByZWZpbGxlZCcpO1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImFjdGlvbnNcIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJhY3Rpb25cIiBvbkNsaWNrPXtoaXN0b3J5LnNpemUgPyB0aGlzLnVuZG8gOiBudWxsfT5cbiAgICAgICAgICA8UmVsb2FkSWNvbiAvPlVuZG9cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWN0aW9uIHJlZG9cIiBvbkNsaWNrPXtoaXN0b3J5LnNpemUgPyB0aGlzLnJlZG8gOiBudWxsfT5cbiAgICAgICAgICA8UmVsb2FkSWNvbiAvPlJlZG9cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWN0aW9uXCIgb25DbGljaz17IXByZWZpbGxlZCA/IHRoaXMuZXJhc2VTZWxlY3RlZCA6IG51bGx9PlxuICAgICAgICAgIDxSZW1vdmVJY29uIC8+RXJhc2VcbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXZcbiAgICAgICAgICBjbGFzc05hbWU9XCJhY3Rpb25cIlxuICAgICAgICAgIG9uQ2xpY2s9eyFwcmVmaWxsZWQgP1xuICAgICAgICAgIHRoaXMuZmlsbFNlbGVjdGVkV2l0aFNvbHV0aW9uIDogbnVsbH1cbiAgICAgICAgPlxuICAgICAgICAgIDxMb3VwZUljb24gLz5IaW50XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8c3R5bGUganN4PntBY3Rpb25zU3R5bGV9PC9zdHlsZT5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cblxuICByZW5kZXJQdXp6bGUoKSB7XG4gICAgY29uc3QgeyBib2FyZCB9ID0gdGhpcy5zdGF0ZTtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJwdXp6bGVcIj5cbiAgICAgICAge2JvYXJkLmdldCgncHV6emxlJykubWFwKChyb3csIGkpID0+IChcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3Qvbm8tYXJyYXktaW5kZXgta2V5XG4gICAgICAgICAgPGRpdiBrZXk9e2l9IGNsYXNzTmFtZT1cInJvd1wiPlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICByb3cubWFwKChjZWxsLCBqKSA9PiB0aGlzLnJlbmRlckNlbGwoY2VsbCwgaSwgaikpLnRvQXJyYXkoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICApKS50b0FycmF5KCl9XG4gICAgICAgIDxzdHlsZSBqc3g+e1B1enpsZVN0eWxlfTwvc3R5bGU+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG5cbiAgcmVuZGVyQ29udHJvbHMoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29udHJvbHNcIj5cbiAgICAgICAge3RoaXMucmVuZGVyTnVtYmVyQ29udHJvbCgpfVxuICAgICAgICB7dGhpcy5yZW5kZXJBY3Rpb25zKCl9XG4gICAgICAgIHsgLyogbGFuZ3VhZ2U9Q1NTICovIH1cbiAgICAgICAgPHN0eWxlIGpzeD57YFxuICAgICAgICAgICAgLmNvbnRyb2xzIHtcbiAgICAgICAgICAgICAgICBtYXJnaW4tdG9wOiAuM2VtO1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgICAgICAgZmxleC13cmFwOiB3cmFwO1xuICAgICAgICAgICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICAgICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICAgICAgICAgIHBhZGRpbmc6IC41ZW0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgYH1cbiAgICAgICAgPC9zdHlsZT5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cblxuICByZW5kZXJHZW5lcmF0aW9uVUkoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxHZW5lcmF0aW9uVUkgZ2VuZXJhdGVHYW1lPXt0aGlzLmdlbmVyYXRlR2FtZX0gLz5cbiAgICApO1xuICB9XG5cbiAgcmVuZGVySGVhZGVyKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImhlYWRlclwiPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm5ldy1nYW1lXCIgb25DbGljaz17KCkgPT4gdGhpcy5zZXRTdGF0ZSh7IGJvYXJkOiBmYWxzZSB9KX0+XG4gICAgICAgICAgPFJldHVybkljb24gLz5cbiAgICAgICAgICA8ZGl2Pk5ldyBHYW1lPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8VGlwIC8+XG4gICAgICAgIHsgLyogbGFuZ3VhZ2U9Q1NTICovIH1cbiAgICAgICAgPHN0eWxlIGpzeD57YFxuICAgICAgICAgICAgLmhlYWRlciB7XG4gICAgICAgICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gICAgICAgICAgICAgICAgbWF4LXdpZHRoOiA1MDBweDtcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiAwIDAuNWVtO1xuICAgICAgICAgICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAubmV3LWdhbWUge1xuICAgICAgICAgICAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICAgICAgICAgICAgICBtYXJnaW4tdG9wOiAuMmVtO1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6IGlubGluZS1mbGV4O1xuICAgICAgICAgICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgICAgICAgICAgcGFkZGluZzogLjJlbSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLm5ldy1nYW1lIDpnbG9iYWwoc3ZnKSB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxZW07XG4gICAgICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogLjNlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgYH1cbiAgICAgICAgPC9zdHlsZT5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBib2FyZCB9ID0gdGhpcy5zdGF0ZTtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJib2R5XCI+XG4gICAgICAgIDxOZXh0SGVhZD5cbiAgICAgICAgICA8dGl0bGU+U3Vkb2t1IEV2b2x2ZWQ8L3RpdGxlPlxuICAgICAgICAgIDxtZXRhIG5hbWU9XCJ2aWV3cG9ydFwiIGNvbnRlbnQ9XCJpbml0aWFsLXNjYWxlPTEuMCwgd2lkdGg9ZGV2aWNlLXdpZHRoXCIgLz5cbiAgICAgICAgICA8bWV0YSBuYW1lPVwiZGVzY3JpcHRpb25cIiBjb250ZW50PXtEZXNjcmlwdGlvbn0gLz5cbiAgICAgICAgICA8bGluayBocmVmPVwiaHR0cHM6Ly9mb250cy5nb29nbGVhcGlzLmNvbS9jc3M/ZmFtaWx5PVNwZWNpYWwrRWxpdGVcIiByZWw9XCJzdHlsZXNoZWV0XCIgLz5cbiAgICAgICAgICA8bWV0YSBwcm9wZXJ0eT1cIm9nOnVybFwiIGNvbnRlbnQ9XCJodHRwczovL3N1ZG9rdS5zaXRpYW5saXUuY29tL1wiIC8+XG4gICAgICAgICAgPG1ldGEgcHJvcGVydHk9XCJvZzp0aXRsZVwiIGNvbnRlbnQ9XCJTdWRva3UgRXZvbHZlZFwiIC8+XG4gICAgICAgICAgPG1ldGEgcHJvcGVydHk9XCJvZzp0eXBlXCIgY29udGVudD1cIndlYnNpdGVcIiAvPlxuICAgICAgICAgIDxtZXRhIHByb3BlcnR5PVwib2c6ZGVzY3JpcHRpb25cIiBjb250ZW50PXtEZXNjcmlwdGlvbn0gLz5cbiAgICAgICAgICA8bWV0YSBwcm9wZXJ0eT1cIm9nOmltYWdlXCIgY29udGVudD1cImh0dHBzOi8vc3Vkb2t1LnNpdGlhbmxpdS5jb20vc3RhdGljL29nLWltYWdlLnBuZ1wiIC8+XG4gICAgICAgIDwvTmV4dEhlYWQ+XG4gICAgICAgIHshYm9hcmQgJiYgdGhpcy5yZW5kZXJHZW5lcmF0aW9uVUkoKX1cbiAgICAgICAge2JvYXJkICYmIHRoaXMucmVuZGVySGVhZGVyKCl9XG4gICAgICAgIHtib2FyZCAmJiB0aGlzLnJlbmRlclB1enpsZSgpfVxuICAgICAgICB7Ym9hcmQgJiYgdGhpcy5yZW5kZXJDb250cm9scygpfVxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInJvb3RlclwiPlxuICAgICAgICAgIE1hZGUgd2l0aCA8c3Bhbj7inaTvuI88L3NwYW4+77iPIEJ5IDxhIGhyZWY9XCJodHRwczovL3d3dy5zaXRpYW5saXUuY29tL1wiPlNpdGlhbiBMaXU8L2E+IHwgPGEgaHJlZj1cImh0dHBzOi8vbWVkaXVtLmNvbS9Ac2l0aWFubGl1XzU3NjgwL2J1aWxkaW5nLWEtc3Vkb2t1LWdhbWUtaW4tcmVhY3QtY2E2NjM5MTU3MTJcIj5CbG9nIFBvc3Q8L2E+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICB7IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG4gICAgICAgIDxzdHlsZSBqc3g+e2BcbiAgICAgICAgICAgIDpnbG9iYWwoYm9keSksIC5ib2R5IHtcbiAgICAgICAgICAgICAgICBmb250LWZhbWlseTogJ1NwZWNpYWwgRWxpdGUnLCBjdXJzaXZlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLmJvZHkge1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICAgICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICAgICAgICAgIGhlaWdodDogMTAwdmg7XG4gICAgICAgICAgICAgICAgd2lkdGg6IDEwMHZ3O1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEBtZWRpYSAobWluLXdpZHRoOiA4MDBweCkgYW5kIChtaW4taGVpZ2h0OiA5MzBweCl7XG4gICAgICAgICAgICAgICAgOmdsb2JhbCguaGVhZGVyLCAucHV6emxlLCAuY29udHJvbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9udC1zaXplOiAxLjVlbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBAbWVkaWEgKG1heC13aWR0aDogODAwcHgpIGFuZCAobWluLXdpZHRoOiA2MDBweCl7XG4gICAgICAgICAgICAgICAgOmdsb2JhbCguaGVhZGVyLCAucHV6emxlLCAuY29udHJvbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9udC1zaXplOiAxLjJlbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBAbWVkaWEgKG1heC1oZWlnaHQ6IDkzMHB4KSBhbmQgKG1pbi1oZWlnaHQ6IDgwMHB4KSBhbmQgKG1pbi13aWR0aDogNjAwcHgpe1xuICAgICAgICAgICAgICAgIDpnbG9iYWwoLmhlYWRlciwgLnB1enpsZSwgLmNvbnRyb2xzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvbnQtc2l6ZTogMS4yZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQG1lZGlhIChtYXgtaGVpZ2h0OiA4MDBweCkgYW5kIChtaW4taGVpZ2h0OiA2MDBweCkgYW5kIChtaW4td2lkdGg6IDM3MHB4KXtcbiAgICAgICAgICAgICAgICA6Z2xvYmFsKC5oZWFkZXIsIC5wdXp6bGUsIC5jb250cm9scykge1xuICAgICAgICAgICAgICAgICAgICBmb250LXNpemU6IDFlbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBAbWVkaWEgKG1heC13aWR0aDogMzcwcHgpe1xuICAgICAgICAgICAgICAgIDpnbG9iYWwoLmhlYWRlciwgLnB1enpsZSwgLmNvbnRyb2xzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvbnQtc2l6ZTogLjhlbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBAbWVkaWEgKG1heC1oZWlnaHQ6IDYwMHB4KXtcbiAgICAgICAgICAgICAgICA6Z2xvYmFsKC5oZWFkZXIsIC5wdXp6bGUsIC5jb250cm9scykge1xuICAgICAgICAgICAgICAgICAgICBmb250LXNpemU6IC44ZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOmdsb2JhbChib2R5KSB7XG4gICAgICAgICAgICAgICAgbWFyZ2luOiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLnJvb3RlciB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgICAgICAgICAgIGJvdHRvbTogMDtcbiAgICAgICAgICAgICAgICBmb250LXNpemU6IC44ZW07XG4gICAgICAgICAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgICAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICBgfVxuICAgICAgICA8L3N0eWxlPlxuICAgICAgICA8c3R5bGUganN4IGdsb2JhbD57UmFuZ2VTdHlsZX08L3N0eWxlPlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufVxuIl19 */\n/*@ sourceURL=pages/index.js */');

CirculuarProgressStyle.__hash = '2505613647';
CirculuarProgressStyle.__scoped = '.circular-progress.jsx-1171755374{display:block;width:100%;position:absolute;top:0;left:0;-webkit-transition:filter .4s ease-in-out;transition:filter .4s ease-in-out;}.circle-bg.jsx-1171755374{fill:none;stroke:#eee;stroke-width:3.8;}.circle.jsx-1171755374{stroke:' + ControlNumberColor + ';-webkit-transition:stroke-dasharray .4s ease-in-out;transition:stroke-dasharray .4s ease-in-out;fill:none;stroke-width:2.8;stroke-linecap:round;}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhZ2VzL2luZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQXlKa0MsQUFHbUIsQUFTSixBQU0wQixVQUx4QixJQVRELFFBVU0sR0FUQyxXQWMwQixHQUpoRCxJQVRVLE1BQ0MsT0FDMkIsNEVBQ3RDLEFBV2MsVUFDTyxpQkFDSSxxQkFDekIiLCJmaWxlIjoicGFnZXMvaW5kZXguanMiLCJzb3VyY2VSb290IjoiL1VzZXJzL2xpY2hlbm1hL1Byb2plY3RzL1N1RHVva3UvU3VEdW9rdSIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIGpzeC1hMTF5L2FjY2Vzc2libGUtZW1vamkgKi9cbmltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFNldCwgTGlzdCwgZnJvbUpTIH0gZnJvbSAnaW1tdXRhYmxlJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgTmV4dEhlYWQgZnJvbSAnbmV4dC9oZWFkJztcbmltcG9ydCBDb2xvciBmcm9tICdjb2xvcic7XG5pbXBvcnQgSW5wdXRSYW5nZSBmcm9tICdyZWFjdC1pbnB1dC1yYW5nZSc7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tZXh0cmFuZW91cy1kZXBlbmRlbmNpZXNcbmltcG9ydCBjc3MgZnJvbSAnc3R5bGVkLWpzeC9jc3MnO1xuXG5pbXBvcnQgUmFuZ2VTdHlsZSBmcm9tICcuLi9pbnB1dC1yYW5nZS1zdHlsZSc7XG5pbXBvcnQgTG91cGVJY29uIGZyb20gJy4uL3N2Zy9sb3VwZS5zdmcnO1xuaW1wb3J0IFJlbW92ZUljb24gZnJvbSAnLi4vc3ZnL3JlbW92ZS5zdmcnO1xuaW1wb3J0IFJlbG9hZEljb24gZnJvbSAnLi4vc3ZnL3JlbG9hZC5zdmcnO1xuaW1wb3J0IFJldHVybkljb24gZnJvbSAnLi4vc3ZnL3JldHVybi5zdmcnO1xuXG5pbXBvcnQgeyBtYWtlUHV6emxlLCBwbHVjaywgaXNQZWVyIGFzIGFyZUNvb3JkaW5hdGVQZWVycywgcmFuZ2UgfSBmcm9tICcuLi9zdWRva3UnO1xuaW1wb3J0IHsgYmFja0dyb3VuZEJsdWUgfSBmcm9tICcuLi9jb2xvcnMnO1xuaW1wb3J0IFRpcCBmcm9tICcuLi9jb21wb25lbnRzL3Rvb2wtdGlwJztcblxuaW1wb3J0IGlvIGZyb20gJ3NvY2tldC5pby1jbGllbnQnXG5cbmNvbnN0IERlc2NyaXB0aW9uID0gJ0Rpc2NvdmVyIHRoZSBuZXh0IGV2b2x1dGlvbiBvZiBTdWRva3Ugd2l0aCBhbWF6aW5nIGdyYXBoaWNzLCBhbmltYXRpb25zLCBhbmQgdXNlci1mcmllbmRseSBmZWF0dXJlcy4gRW5qb3kgYSBTdWRva3UgZXhwZXJpZW5jZSBsaWtlIHlvdSBuZXZlciBoYXZlIGJlZm9yZSB3aXRoIGN1c3RvbWl6YWJsZSBnYW1lIGdlbmVyYXRpb24sIGNlbGwgaGlnaGxpZ2h0aW5nLCBpbnR1aXRpdmUgY29udHJvbHMgYW5kIG1vcmUhJztcbmNvbnN0IGNlbGxXaWR0aCA9IDIuNTtcblxuY29uc3QgTGlnaHRCbHVlMTAwID0gJyNCM0U1RkMnO1xuY29uc3QgTGlnaHRCbHVlMjAwID0gJyM4MUQ0RkEnO1xuY29uc3QgTGlnaHRCbHVlMzAwID0gJyM0RkMzRjcnO1xuY29uc3QgSW5kaWdvNzAwID0gJyMzMDNGOUYnO1xuY29uc3QgRGVlcE9yYW5nZTIwMCA9ICcjRkZBQjkxJztcbmNvbnN0IERlZXBPcmFuZ2U2MDAgPSAnI0Y0NTExRSc7XG5jb25zdCBDb250cm9sTnVtYmVyQ29sb3IgPSBJbmRpZ283MDA7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sb25lLWJsb2Nrc1xueyAvKiBsYW5ndWFnZT1DU1MgKi8gfVxuY29uc3QgQ2VsbFN0eWxlID0gY3NzYFxuLmNlbGwge1xuICAgIGhlaWdodDogJHtjZWxsV2lkdGh9ZW07XG4gICAgd2lkdGg6ICR7Y2VsbFdpZHRofWVtO1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC13cmFwOiB3cmFwO1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgZm9udC1zaXplOiAxLjFlbTtcbiAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICB0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kLWNvbG9yIC4zcyBlYXNlLWluLW91dDtcbn1cbi5jZWxsOm50aC1jaGlsZCgzbiszKTpub3QoOmxhc3QtY2hpbGQpIHtcbiAgICBib3JkZXItcmlnaHQ6IDJweCBzb2xpZCBibGFjaztcbn1cbi5jZWxsOm5vdCg6bGFzdC1jaGlsZCkge1xuICAgIGJvcmRlci1yaWdodDogMXB4IHNvbGlkIGJsYWNrO1xufVxuLm5vdGUtbnVtYmVyIHtcbiAgICBmb250LXNpemU6IC42ZW07XG4gICAgd2lkdGg6IDMzJTtcbiAgICBoZWlnaHQ6IDMzJTtcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbn1cbmA7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sb25lLWJsb2Nrc1xueyAvKiBsYW5ndWFnZT1DU1MgKi8gfVxuY29uc3QgQWN0aW9uc1N0eWxlID0gY3NzYFxuLmFjdGlvbnMge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgbWF4LXdpZHRoOiA0MDBweDtcbiAgICBtYXJnaW4tdG9wOiAuNWVtO1xuICAgIHBhZGRpbmc6IDAgLjZlbTtcbn1cbi5hY3Rpb24ge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xufVxuLmFjdGlvbiA6Z2xvYmFsKHN2Zykge1xuICAgIHdpZHRoOiAyLjVlbTtcbiAgICBtYXJnaW4tYm90dG9tOiAuMmVtO1xufVxuLnJlZG8gOmdsb2JhbChzdmcpIHtcbiAgICB0cmFuc2Zvcm06IHNjYWxlWCgtMSk7XG59XG5gO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbG9uZS1ibG9ja3NcbnsgLyogbGFuZ3VhZ2U9Q1NTICovIH1cbmNvbnN0IENvbnRyb2xTdHlsZSA9IGNzc2Bcbi5jb250cm9sIHtcbiAgICBwYWRkaW5nOiAwIDJlbTtcbiAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgZGlzcGxheTogaW5saW5lLWZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBmbGV4LXdyYXA6IHdyYXA7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgZm9udC1mYW1pbHk6ICdTcGVjaWFsIEVsaXRlJywgY3Vyc2l2ZTtcbiAgICB0cmFuc2l0aW9uOiBmaWx0ZXIgLjVzIGVhc2UtaW4tb3V0O1xuICAgIHdpZHRoOiAxMDAlO1xufVxuYDtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxvbmUtYmxvY2tzXG57IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG5jb25zdCBOdW1iZXJDb250cm9sU3R5bGUgPSBjc3NgXG4ubnVtYmVyIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGZvbnQtc2l6ZTogMmVtO1xuICAgIG1hcmdpbjogLjFlbTtcbiAgICB3aWR0aDogMS41ZW07XG4gICAgaGVpZ2h0OiAxLjVlbTtcbiAgICBjb2xvcjogJHtDb250cm9sTnVtYmVyQ29sb3J9O1xuICAgIGJveC1zaGFkb3c6IDAgMXB4IDJweCByZ2JhKDAsMCwwLDAuMTYpLCAwIDFweCAycHggcmdiYSgwLDAsMCwwLjIzKTtcbiAgICBib3JkZXItcmFkaXVzOiA1MCU7XG59XG4ubnVtYmVyID4gZGl2IHtcbiAgICBtYXJnaW4tdG9wOiAuM2VtO1xufVxuYDtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxvbmUtYmxvY2tzXG57IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG5jb25zdCBQdXp6bGVTdHlsZSA9IGNzc2Bcbi5wdXp6bGUge1xuICAgIG1hcmdpbi10b3A6IC41ZW07XG4gICAgd2lkdGg6ICR7Y2VsbFdpZHRoICogOX1lbTtcbiAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgYm94LXNoYWRvdzogMCAzcHggNnB4IHJnYmEoMCwwLDAsMC4xNiksIDAgM3B4IDZweCByZ2JhKDAsMCwwLDAuMjMpO1xufVxuLnJvdyB7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGZsZXg6IDA7XG4gICAgd2lkdGg6ICR7Y2VsbFdpZHRoICogOX1lbTtcbn1cbi5yb3c6bm90KDpsYXN0LWNoaWxkKSB7XG4gICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkIGJsYWNrO1xufVxuLnJvdzpudGgtY2hpbGQoM24rMyk6bm90KDpsYXN0LWNoaWxkKSB7XG4gICAgYm9yZGVyLWJvdHRvbTogMnB4IHNvbGlkIGJsYWNrICFpbXBvcnRhbnQ7XG59XG5gO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbG9uZS1ibG9ja3NcbnsgLyogbGFuZ3VhZ2U9Q1NTICovIH1cbmNvbnN0IENpcmN1bHVhclByb2dyZXNzU3R5bGUgPSBjc3NgXG4uY2lyY3VsYXItcHJvZ3Jlc3Mge1xuICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB0b3A6IDA7XG4gICAgbGVmdDogMDtcbiAgICB0cmFuc2l0aW9uOiBmaWx0ZXIgLjRzIGVhc2UtaW4tb3V0O1xufVxuXG4uY2lyY2xlLWJnIHtcbiAgICBmaWxsOiBub25lO1xuICAgIHN0cm9rZTogI2VlZTtcbiAgICBzdHJva2Utd2lkdGg6IDMuODtcbn1cblxuLmNpcmNsZSB7XG4gICAgc3Ryb2tlOiAke0NvbnRyb2xOdW1iZXJDb2xvcn07XG4gICAgdHJhbnNpdGlvbjogc3Ryb2tlLWRhc2hhcnJheSAuNHMgZWFzZS1pbi1vdXQ7XG4gICAgZmlsbDogbm9uZTtcbiAgICBzdHJva2Utd2lkdGg6IDIuODtcbiAgICBzdHJva2UtbGluZWNhcDogcm91bmQ7XG59XG5gO1xuXG5jb25zdCBDaXJjdWxhclBhdGhEID0gJ00xOCAyLjA4NDUgYSAxNS45MTU1IDE1LjkxNTUgMCAwIDEgMCAzMS44MzEgYSAxNS45MTU1IDE1LjkxNTUgMCAwIDEgMCAtMzEuODMxJztcblxuZnVuY3Rpb24gZ2V0QmFja0dyb3VuZENvbG9yKHtcbiAgY29uZmxpY3QsIGlzUGVlciwgc2FtZVZhbHVlLCBpc1NlbGVjdGVkLFxufSkge1xuICBpZiAoY29uZmxpY3QgJiYgaXNQZWVyICYmIHNhbWVWYWx1ZSkge1xuICAgIHJldHVybiBEZWVwT3JhbmdlMjAwO1xuICB9IGVsc2UgaWYgKHNhbWVWYWx1ZSkge1xuICAgIHJldHVybiBMaWdodEJsdWUzMDA7XG4gIH0gZWxzZSBpZiAoaXNTZWxlY3RlZCkge1xuICAgIHJldHVybiBMaWdodEJsdWUyMDA7XG4gIH0gZWxzZSBpZiAoaXNQZWVyKSB7XG4gICAgcmV0dXJuIExpZ2h0Qmx1ZTEwMDtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldEZvbnRDb2xvcih7IHZhbHVlLCBjb25mbGljdCwgcHJlZmlsbGVkIH0pIHtcbiAgaWYgKGNvbmZsaWN0ICYmICFwcmVmaWxsZWQpIHtcbiAgICByZXR1cm4gRGVlcE9yYW5nZTYwMDtcbiAgfSBlbHNlIGlmICghcHJlZmlsbGVkICYmIHZhbHVlKSB7XG4gICAgcmV0dXJuIENvbnRyb2xOdW1iZXJDb2xvcjtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmNsYXNzIEdlbmVyYXRpb25VSSBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuXG4gICAgdGhpcy5zdGF0ZSA9IHsgdmFsdWU6IDMwIH07XG4gIH1cblxuICBnZW5lcmF0ZUdhbWUgPSAoKSA9PiB7XG4gICAgdGhpcy5wcm9wcy5nZW5lcmF0ZUdhbWUodGhpcy5zdGF0ZS52YWx1ZSk7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ2VuZXJhdGlvblwiPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvcHlcIj5TdGFydCB3aXRoIHt0aGlzLnN0YXRlLnZhbHVlfSBjZWxscyBwcmVmaWxsZWQ8L2Rpdj5cbiAgICAgICAgPElucHV0UmFuZ2VcbiAgICAgICAgICBtYXhWYWx1ZT17ODF9XG4gICAgICAgICAgbWluVmFsdWU9ezE3fVxuICAgICAgICAgIHZhbHVlPXt0aGlzLnN0YXRlLnZhbHVlfVxuICAgICAgICAgIG9uQ2hhbmdlPXt2YWx1ZSA9PiB0aGlzLnNldFN0YXRlKHsgdmFsdWUgfSl9XG4gICAgICAgIC8+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYnV0dG9uXCIgb25DbGljaz17dGhpcy5nZW5lcmF0ZUdhbWV9PlBsYXkgU3Vkb2t1PC9kaXY+XG4gICAgICAgIHsgLyogbGFuZ3VhZ2U9Q1NTICovIH1cbiAgICAgICAgPHN0eWxlIGpzeD57YFxuICAgICAgICAgICAgLmNvcHkge1xuICAgICAgICAgICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICAgICAgICAgICAgICBmb250LXNpemU6IDEuM2VtO1xuICAgICAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IC41ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAuZ2VuZXJhdGlvbiB7XG4gICAgICAgICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgICAgICAgICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6Z2xvYmFsKC5pbnB1dC1yYW5nZSkge1xuICAgICAgICAgICAgICAgIHdpZHRoOiA4MCU7XG4gICAgICAgICAgICAgICAgbWF4LXdpZHRoOiA1MDBweDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC5idXR0b24ge1xuICAgICAgICAgICAgICBtYXJnaW4tdG9wOiAuNWVtO1xuICAgICAgICAgICAgICBib3JkZXItcmFkaXVzOiAuMjVlbTtcbiAgICAgICAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgICAgICAgICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICAgICAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xuICAgICAgICAgICAgICBjb2xvcjogI2ZmZjtcbiAgICAgICAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gICAgICAgICAgICAgIHRyYW5zaXRpb246IGFsbCAuMjVzO1xuICAgICAgICAgICAgICBwYWRkaW5nOiA1cHggMTBweDtcbiAgICAgICAgICAgICAgZm9udC1zaXplOiAxLjRlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC5idXR0b246YWN0aXZlIHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoMHB4LCA1cHgpO1xuICAgICAgICAgICAgICBib3gtc2hhZG93OiAwIDFweCAwIDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC5idXR0b24ge1xuICAgICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAke2JhY2tHcm91bmRCbHVlfTtcbiAgICAgICAgICAgICAgYm94LXNoYWRvdzogMCAycHggNHB4IDAgJHtDb2xvcihiYWNrR3JvdW5kQmx1ZSkuZGFya2VuKDAuNSkuaHNsKCkuc3RyaW5nKCl9O1xuICAgICAgICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAuYnV0dG9uOmhvdmVyIHtcbiAgICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogJHtDb2xvcihiYWNrR3JvdW5kQmx1ZSkubGlnaHRlbigwLjIpLmhzbCgpLnN0cmluZygpfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgYH1cbiAgICAgICAgPC9zdHlsZT5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cbn1cblxuR2VuZXJhdGlvblVJLnByb3BUeXBlcyA9IHtcbiAgZ2VuZXJhdGVHYW1lOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxufTtcblxuY29uc3QgTnVtYmVyQ29udHJvbCA9ICh7IG51bWJlciwgb25DbGljaywgY29tcGxldGlvblBlcmNlbnRhZ2UgfSkgPT4gKFxuICA8ZGl2XG4gICAga2V5PXtudW1iZXJ9XG4gICAgY2xhc3NOYW1lPVwibnVtYmVyXCJcbiAgICBvbkNsaWNrPXtvbkNsaWNrfVxuICA+XG4gICAgPGRpdj57bnVtYmVyfTwvZGl2PlxuICAgIDxDaXJjbHVsYXJQcm9ncmVzcyBwZXJjZW50PXtjb21wbGV0aW9uUGVyY2VudGFnZX0gLz5cbiAgICA8c3R5bGUganN4PntOdW1iZXJDb250cm9sU3R5bGV9PC9zdHlsZT5cbiAgPC9kaXY+XG4pO1xuXG5OdW1iZXJDb250cm9sLnByb3BUeXBlcyA9IHtcbiAgbnVtYmVyOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIG9uQ2xpY2s6IFByb3BUeXBlcy5mdW5jLFxuICBjb21wbGV0aW9uUGVyY2VudGFnZTogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxufTtcblxuTnVtYmVyQ29udHJvbC5kZWZhdWx0UHJvcHMgPSB7XG4gIG9uQ2xpY2s6IG51bGwsXG59O1xuXG5jb25zdCBDZWxsID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHtcbiAgICB2YWx1ZSwgb25DbGljaywgaXNQZWVyLCBpc1NlbGVjdGVkLCBzYW1lVmFsdWUsIHByZWZpbGxlZCwgbm90ZXMsIGNvbmZsaWN0LFxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IGJhY2tncm91bmRDb2xvciA9IGdldEJhY2tHcm91bmRDb2xvcih7XG4gICAgY29uZmxpY3QsIGlzUGVlciwgc2FtZVZhbHVlLCBpc1NlbGVjdGVkLFxuICB9KTtcbiAgY29uc3QgZm9udENvbG9yID0gZ2V0Rm9udENvbG9yKHsgY29uZmxpY3QsIHByZWZpbGxlZCwgdmFsdWUgfSk7XG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJjZWxsXCIgb25DbGljaz17b25DbGlja30+XG4gICAgICB7XG4gICAgICAgIG5vdGVzID9cbiAgICAgICAgICByYW5nZSg5KS5tYXAoaSA9PlxuICAgICAgICAgICAgKFxuICAgICAgICAgICAgICA8ZGl2IGtleT17aX0gY2xhc3NOYW1lPVwibm90ZS1udW1iZXJcIj5cbiAgICAgICAgICAgICAgICB7bm90ZXMuaGFzKGkgKyAxKSAmJiAoaSArIDEpfVxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICkpIDpcbiAgICAgICAgICB2YWx1ZSAmJiB2YWx1ZVxuICAgICAgfVxuICAgICAgey8qIGxhbmd1YWdlPUNTUyAqL31cbiAgICAgIDxzdHlsZSBqc3g+e0NlbGxTdHlsZX08L3N0eWxlPlxuICAgICAgPHN0eWxlIGpzeD57YFxuICAgICAgICAgICAgICAgIC5jZWxsIHtcbiAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogJHtiYWNrZ3JvdW5kQ29sb3IgfHwgJ2luaXRpYWwnfTtcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6ICR7Zm9udENvbG9yIHx8ICdpbml0aWFsJ307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgYH1cbiAgICAgIDwvc3R5bGU+XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5DZWxsLnByb3BUeXBlcyA9IHtcbiAgLy8gY3VycmVudCBudW1iZXIgdmFsdWVcbiAgdmFsdWU6IFByb3BUeXBlcy5udW1iZXIsXG4gIC8vIGNlbGwgY2xpY2sgaGFuZGxlclxuICBvbkNsaWNrOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAvLyBpZiB0aGUgY2VsbCBpcyBhIHBlZXIgb2YgdGhlIHNlbGVjdGVkIGNlbGxcbiAgaXNQZWVyOiBQcm9wVHlwZXMuYm9vbC5pc1JlcXVpcmVkLFxuICAvLyBpZiB0aGUgY2VsbCBpcyBzZWxlY3RlZCBieSB0aGUgdXNlclxuICBpc1NlbGVjdGVkOiBQcm9wVHlwZXMuYm9vbC5pc1JlcXVpcmVkLFxuICAvLyBjdXJyZW50IGNlbGwgaGFzIHRoZSBzYW1lIHZhbHVlIGlmIHRoZSB1c2VyIHNlbGVjdGVkIGNlbGxcbiAgc2FtZVZhbHVlOiBQcm9wVHlwZXMuYm9vbC5pc1JlcXVpcmVkLFxuICAvLyBpZiB0aGlzIHdhcyBwcmVmaWxsZWQgYXMgYSBwYXJ0IG9mIHRoZSBwdXp6bGVcbiAgcHJlZmlsbGVkOiBQcm9wVHlwZXMuYm9vbC5pc1JlcXVpcmVkLFxuICAvLyBjdXJyZW50IG5vdGVzIHRha2VuIG9uIHRoZSBjZWxsXG4gIG5vdGVzOiBQcm9wVHlwZXMuaW5zdGFuY2VPZihTZXQpLFxuICAvLyBpZiB0aGUgY3VycmVudCBjZWxsIGRvZXMgbm90IHNhdGlzZnkgdGhlIGdhbWUgY29uc3RyYWludFxuICBjb25mbGljdDogUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZCxcbn07XG5cbkNlbGwuZGVmYXVsdFByb3BzID0ge1xuICBub3RlczogbnVsbCxcbiAgdmFsdWU6IG51bGwsXG59O1xuXG5jb25zdCBDaXJjbHVsYXJQcm9ncmVzcyA9ICh7IHBlcmNlbnQgfSkgPT4gKFxuICA8c3ZnIHZpZXdCb3g9XCIwIDAgMzYgMzZcIiBjbGFzc05hbWU9XCJjaXJjdWxhci1wcm9ncmVzc1wiPlxuICAgIDxwYXRoXG4gICAgICBjbGFzc05hbWU9XCJjaXJjbGUtYmdcIlxuICAgICAgZD17Q2lyY3VsYXJQYXRoRH1cbiAgICAvPlxuICAgIDxwYXRoXG4gICAgICBjbGFzc05hbWU9XCJjaXJjbGVcIlxuICAgICAgc3Ryb2tlRGFzaGFycmF5PXtgJHtwZXJjZW50ICogMTAwfSwgMTAwYH1cbiAgICAgIGQ9e0NpcmN1bGFyUGF0aER9XG4gICAgLz5cbiAgICB7IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG4gICAgPHN0eWxlIGpzeD57Q2lyY3VsdWFyUHJvZ3Jlc3NTdHlsZX08L3N0eWxlPlxuICA8L3N2Zz5cbik7XG5cbkNpcmNsdWxhclByb2dyZXNzLnByb3BUeXBlcyA9IHtcbiAgcGVyY2VudDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxufTtcblxuZnVuY3Rpb24gZ2V0Q2xpY2tIYW5kbGVyKG9uQ2xpY2ssIG9uRG91YmxlQ2xpY2ssIGRlbGF5ID0gMjUwKSB7XG4gIGxldCB0aW1lb3V0SUQgPSBudWxsO1xuICByZXR1cm4gKGV2ZW50KSA9PiB7XG4gICAgaWYgKCF0aW1lb3V0SUQpIHtcbiAgICAgIHRpbWVvdXRJRCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBvbkNsaWNrKGV2ZW50KTtcbiAgICAgICAgdGltZW91dElEID0gbnVsbDtcbiAgICAgIH0sIGRlbGF5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGltZW91dElEID0gY2xlYXJUaW1lb3V0KHRpbWVvdXRJRCk7XG4gICAgICBvbkRvdWJsZUNsaWNrKGV2ZW50KTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogbWFrZSBzaXplIDkgYXJyYXkgb2YgMHNcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZnVuY3Rpb24gbWFrZUNvdW50T2JqZWN0KCkge1xuICBjb25zdCBjb3VudE9iaiA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpICs9IDEpIGNvdW50T2JqLnB1c2goMCk7XG4gIHJldHVybiBjb3VudE9iajtcbn1cblxuLyoqXG4gKiBnaXZlbiBhIDJEIGFycmF5IG9mIG51bWJlcnMgYXMgdGhlIGluaXRpYWwgcHV6emxlLCBnZW5lcmF0ZSB0aGUgaW5pdGlhbCBnYW1lIHN0YXRlXG4gKiBAcGFyYW0gcHV6emxlXG4gKiBAcmV0dXJucyB7YW55fVxuICovXG5mdW5jdGlvbiBtYWtlQm9hcmQoeyBwdXp6bGUgfSkge1xuICAvLyBjcmVhdGUgaW5pdGlhbCBjb3VudCBvYmplY3QgdG8ga2VlcCB0cmFjayBvZiBjb25mbGljdHMgcGVyIG51bWJlciB2YWx1ZVxuICBjb25zdCByb3dzID0gQXJyYXkuZnJvbShBcnJheSg5KS5rZXlzKCkpLm1hcCgoKSA9PiBtYWtlQ291bnRPYmplY3QoKSk7XG4gIGNvbnN0IGNvbHVtbnMgPSBBcnJheS5mcm9tKEFycmF5KDkpLmtleXMoKSkubWFwKCgpID0+IG1ha2VDb3VudE9iamVjdCgpKTtcbiAgY29uc3Qgc3F1YXJlcyA9IEFycmF5LmZyb20oQXJyYXkoOSkua2V5cygpKS5tYXAoKCkgPT4gbWFrZUNvdW50T2JqZWN0KCkpO1xuICBjb25zdCByZXN1bHQgPSBwdXp6bGUubWFwKChyb3csIGkpID0+IChcbiAgICByb3cubWFwKChjZWxsLCBqKSA9PiB7XG4gICAgICBpZiAoY2VsbCkge1xuICAgICAgICByb3dzW2ldW2NlbGxdICs9IDE7XG4gICAgICAgIGNvbHVtbnNbal1bY2VsbF0gKz0gMTtcbiAgICAgICAgc3F1YXJlc1soKE1hdGguZmxvb3IoaSAvIDMpKSAqIDMpICsgTWF0aC5mbG9vcihqIC8gMyldW2NlbGxdICs9IDE7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogcHV6emxlW2ldW2pdID4gMCA/IHB1enpsZVtpXVtqXSA6IG51bGwsXG4gICAgICAgIHByZWZpbGxlZDogISFwdXp6bGVbaV1bal0sXG4gICAgICB9O1xuICAgIH0pXG4gICkpO1xuICByZXR1cm4gZnJvbUpTKHsgcHV6emxlOiByZXN1bHQsIHNlbGVjdGVkOiBmYWxzZSwgY2hvaWNlczogeyByb3dzLCBjb2x1bW5zLCBzcXVhcmVzIH0gfSk7XG59XG5cbi8qKlxuICogZ2l2ZSB0aGUgY29vcmRpbmF0ZSB1cGRhdGUgdGhlIGN1cnJlbnQgYm9hcmQgd2l0aCBhIG51bWJlciBjaG9pY2VcbiAqIEBwYXJhbSB4XG4gKiBAcGFyYW0geVxuICogQHBhcmFtIG51bWJlclxuICogQHBhcmFtIGZpbGwgd2hldGhlciB0byBzZXQgb3IgdW5zZXRcbiAqIEBwYXJhbSBib2FyZCB0aGUgaW1tdXRhYmxlIGJvYXJkIGdpdmVuIHRvIGNoYW5nZVxuICovXG5mdW5jdGlvbiB1cGRhdGVCb2FyZFdpdGhOdW1iZXIoe1xuICB4LCB5LCBudW1iZXIsIGZpbGwgPSB0cnVlLCBib2FyZCxcbn0pIHtcbiAgbGV0IGNlbGwgPSBib2FyZC5nZXQoJ3B1enpsZScpLmdldEluKFt4LCB5XSk7XG4gIC8vIGRlbGV0ZSBpdHMgbm90ZXNcbiAgY2VsbCA9IGNlbGwuZGVsZXRlKCdub3RlcycpO1xuICAvLyBzZXQgb3IgdW5zZXQgaXRzIHZhbHVlIGRlcGVuZGluZyBvbiBgZmlsbGBcbiAgY2VsbCA9IGZpbGwgPyBjZWxsLnNldCgndmFsdWUnLCBudW1iZXIpIDogY2VsbC5kZWxldGUoJ3ZhbHVlJyk7XG4gIGNvbnN0IGluY3JlbWVudCA9IGZpbGwgPyAxIDogLTE7XG4gIC8vIHVwZGF0ZSB0aGUgY3VycmVudCBncm91cCBjaG9pY2VzXG4gIGNvbnN0IHJvd1BhdGggPSBbJ2Nob2ljZXMnLCAncm93cycsIHgsIG51bWJlcl07XG4gIGNvbnN0IGNvbHVtblBhdGggPSBbJ2Nob2ljZXMnLCAnY29sdW1ucycsIHksIG51bWJlcl07XG4gIGNvbnN0IHNxdWFyZVBhdGggPSBbJ2Nob2ljZXMnLCAnc3F1YXJlcycsXG4gICAgKChNYXRoLmZsb29yKHggLyAzKSkgKiAzKSArIE1hdGguZmxvb3IoeSAvIDMpLCBudW1iZXJdO1xuICByZXR1cm4gYm9hcmQuc2V0SW4ocm93UGF0aCwgYm9hcmQuZ2V0SW4ocm93UGF0aCkgKyBpbmNyZW1lbnQpXG4gICAgLnNldEluKGNvbHVtblBhdGgsIGJvYXJkLmdldEluKGNvbHVtblBhdGgpICsgaW5jcmVtZW50KVxuICAgIC5zZXRJbihzcXVhcmVQYXRoLCBib2FyZC5nZXRJbihzcXVhcmVQYXRoKSArIGluY3JlbWVudClcbiAgICAuc2V0SW4oWydwdXp6bGUnLCB4LCB5XSwgY2VsbCk7XG59XG5cbmZ1bmN0aW9uIGdldE51bWJlck9mR3JvdXBzQXNzaWduZWRGb3JOdW1iZXIobnVtYmVyLCBncm91cHMpIHtcbiAgcmV0dXJuIGdyb3Vwcy5yZWR1Y2UoKGFjY3VtdWxhdG9yLCByb3cpID0+XG4gICAgYWNjdW11bGF0b3IgKyAocm93LmdldChudW1iZXIpID4gMCA/IDEgOiAwKSwgMCk7XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3Qvbm8tbXVsdGktY29tcFxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW5kZXggZXh0ZW5kcyBDb21wb25lbnQge1xuICBzdGF0ZSA9IHt9O1xuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgIGlmICgnc2VydmljZVdvcmtlcicgaW4gbmF2aWdhdG9yKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICAgIG5hdmlnYXRvci5zZXJ2aWNlV29ya2VyXG4gICAgICAgIC5yZWdpc3RlcignL3NlcnZpY2Utd29ya2VyLmpzJylcbiAgICAgICAgLnRoZW4oKHJlZykgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdTZXJ2aWNlV29ya2VyIHNjb3BlOiAnLCByZWcuc2NvcGUpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdzZXJ2aWNlIHdvcmtlciByZWdpc3RyYXRpb24gc3VjY2Vzc2Z1bCcpO1xuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgIGNvbnNvbGUud2Fybignc2VydmljZSB3b3JrZXIgcmVnaXN0cmF0aW9uIGZhaWxlZCcsIGVyci5tZXNzYWdlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICBcbiAgICBmZXRjaCgnL2FwaS9zb2NrZXRpbycpLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgY29uc3Qgc29ja2V0ID0gaW8oKVxuXG4gICAgICBzb2NrZXQub24oJ2Nvbm5lY3QnLCAoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdjb25uZWN0JylcbiAgICAgICAgc29ja2V0LmVtaXQoJ2hlbGxvJylcbiAgICAgIH0pXG5cbiAgICAgIHNvY2tldC5vbignaGVsbG8nLCBkYXRhID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ2hlbGxvJywgZGF0YSlcbiAgICAgIH0pXG5cbiAgICAgIHNvY2tldC5vbignYSB1c2VyIGNvbm5lY3RlZCcsICgpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ2EgdXNlciBjb25uZWN0ZWQnKVxuICAgICAgfSlcblxuICAgICAgc29ja2V0Lm9uKCdkaXNjb25uZWN0JywgKCkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZygnZGlzY29ubmVjdCcpXG4gICAgICB9KVxuICAgIH0pXG4gICBcbiAgfVxuICBnZXRTZWxlY3RlZENlbGwoKSB7XG4gICAgY29uc3QgeyBib2FyZCB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBzZWxlY3RlZCA9IGJvYXJkLmdldCgnc2VsZWN0ZWQnKTtcbiAgICByZXR1cm4gc2VsZWN0ZWQgJiYgYm9hcmQuZ2V0KCdwdXp6bGUnKS5nZXRJbihbc2VsZWN0ZWQueCwgc2VsZWN0ZWQueV0pO1xuICB9XG5cbiAgLy8gZ2V0IHRoZSBtaW4gYmV0d2VlbiBpdHMgY29tcGxldGlvbiBpbiByb3dzLCBjb2x1bW5zIGFuZCBzcXVhcmVzLlxuICBnZXROdW1iZXJWYWx1ZUNvdW50KG51bWJlcikge1xuICAgIGNvbnN0IHJvd3MgPSB0aGlzLnN0YXRlLmJvYXJkLmdldEluKFsnY2hvaWNlcycsICdyb3dzJ10pO1xuICAgIGNvbnN0IGNvbHVtbnMgPSB0aGlzLnN0YXRlLmJvYXJkLmdldEluKFsnY2hvaWNlcycsICdjb2x1bW5zJ10pO1xuICAgIGNvbnN0IHNxdWFyZXMgPSB0aGlzLnN0YXRlLmJvYXJkLmdldEluKFsnY2hvaWNlcycsICdzcXVhcmVzJ10pO1xuICAgIHJldHVybiBNYXRoLm1pbihcbiAgICAgIGdldE51bWJlck9mR3JvdXBzQXNzaWduZWRGb3JOdW1iZXIobnVtYmVyLCBzcXVhcmVzKSxcbiAgICAgIE1hdGgubWluKFxuICAgICAgICBnZXROdW1iZXJPZkdyb3Vwc0Fzc2lnbmVkRm9yTnVtYmVyKG51bWJlciwgcm93cyksXG4gICAgICAgIGdldE51bWJlck9mR3JvdXBzQXNzaWduZWRGb3JOdW1iZXIobnVtYmVyLCBjb2x1bW5zKSxcbiAgICAgICksXG4gICAgKTtcbiAgfVxuXG4gIGdlbmVyYXRlR2FtZSA9IChmaW5hbENvdW50ID0gMjApID0+IHtcbiAgICAvLyBnZXQgYSBmaWxsZWQgcHV6emxlIGdlbmVyYXRlZFxuICAgIGNvbnN0IHNvbHV0aW9uID0gbWFrZVB1enpsZSgpO1xuICAgIC8vIHBsdWNrIHZhbHVlcyBmcm9tIGNlbGxzIHRvIGNyZWF0ZSB0aGUgZ2FtZVxuICAgIGNvbnN0IHsgcHV6emxlIH0gPSBwbHVjayhzb2x1dGlvbiwgZmluYWxDb3VudCk7XG4gICAgLy8gaW5pdGlhbGl6ZSB0aGUgYm9hcmQgd2l0aCBjaG9pY2UgY291bnRzXG4gICAgY29uc3QgYm9hcmQgPSBtYWtlQm9hcmQoeyBwdXp6bGUgfSk7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBib2FyZCwgaGlzdG9yeTogTGlzdC5vZihib2FyZCksIGhpc3RvcnlPZmZTZXQ6IDAsIHNvbHV0aW9uLFxuICAgIH0pO1xuICB9XG5cbiAgYWRkTnVtYmVyQXNOb3RlID0gKG51bWJlcikgPT4ge1xuICAgIGxldCB7IGJvYXJkIH0gPSB0aGlzLnN0YXRlO1xuICAgIGxldCBzZWxlY3RlZENlbGwgPSB0aGlzLmdldFNlbGVjdGVkQ2VsbCgpO1xuICAgIGlmICghc2VsZWN0ZWRDZWxsKSByZXR1cm47XG4gICAgY29uc3QgcHJlZmlsbGVkID0gc2VsZWN0ZWRDZWxsLmdldCgncHJlZmlsbGVkJyk7XG4gICAgaWYgKHByZWZpbGxlZCkgcmV0dXJuO1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gYm9hcmQuZ2V0KCdzZWxlY3RlZCcpO1xuICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHNlbGVjdGVkQ2VsbC5nZXQoJ3ZhbHVlJyk7XG4gICAgaWYgKGN1cnJlbnRWYWx1ZSkge1xuICAgICAgYm9hcmQgPSB1cGRhdGVCb2FyZFdpdGhOdW1iZXIoe1xuICAgICAgICB4LCB5LCBudW1iZXI6IGN1cnJlbnRWYWx1ZSwgZmlsbDogZmFsc2UsIGJvYXJkOiB0aGlzLnN0YXRlLmJvYXJkLFxuICAgICAgfSk7XG4gICAgfVxuICAgIGxldCBub3RlcyA9IHNlbGVjdGVkQ2VsbC5nZXQoJ25vdGVzJykgfHwgU2V0KCk7XG4gICAgaWYgKG5vdGVzLmhhcyhudW1iZXIpKSB7XG4gICAgICBub3RlcyA9IG5vdGVzLmRlbGV0ZShudW1iZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub3RlcyA9IG5vdGVzLmFkZChudW1iZXIpO1xuICAgIH1cbiAgICBzZWxlY3RlZENlbGwgPSBzZWxlY3RlZENlbGwuc2V0KCdub3RlcycsIG5vdGVzKTtcbiAgICBzZWxlY3RlZENlbGwgPSBzZWxlY3RlZENlbGwuZGVsZXRlKCd2YWx1ZScpO1xuICAgIGJvYXJkID0gYm9hcmQuc2V0SW4oWydwdXp6bGUnLCB4LCB5XSwgc2VsZWN0ZWRDZWxsKTtcbiAgICB0aGlzLnVwZGF0ZUJvYXJkKGJvYXJkKTtcbiAgfTtcblxuICB1cGRhdGVCb2FyZCA9IChuZXdCb2FyZCkgPT4ge1xuICAgIGxldCB7IGhpc3RvcnkgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgeyBoaXN0b3J5T2ZmU2V0IH0gPSB0aGlzLnN0YXRlO1xuICAgIC8vIGFueXRoaW5nIGJlZm9yZSBjdXJyZW50IHN0ZXAgaXMgc3RpbGwgaW4gaGlzdG9yeVxuICAgIGhpc3RvcnkgPSBoaXN0b3J5LnNsaWNlKDAsIGhpc3RvcnlPZmZTZXQgKyAxKTtcbiAgICAvLyBhZGQgaXRzZWxmIG9udG8gdGhlIGhpc3RvcnlcbiAgICBoaXN0b3J5ID0gaGlzdG9yeS5wdXNoKG5ld0JvYXJkKTtcbiAgICAvLyB1cGRhdGUgdGhlIGdhbWVcbiAgICB0aGlzLnNldFN0YXRlKHsgYm9hcmQ6IG5ld0JvYXJkLCBoaXN0b3J5LCBoaXN0b3J5T2ZmU2V0OiBoaXN0b3J5LnNpemUgLSAxIH0pO1xuICB9O1xuXG4gIGNhblVuZG8gPSAoKSA9PiB0aGlzLnN0YXRlLmhpc3RvcnlPZmZTZXQgPiAwXG5cbiAgcmVkbyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGhpc3RvcnkgfSA9IHRoaXMuc3RhdGU7XG4gICAgbGV0IHsgaGlzdG9yeU9mZlNldCB9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAoaGlzdG9yeS5zaXplKSB7XG4gICAgICBoaXN0b3J5T2ZmU2V0ID0gTWF0aC5taW4oaGlzdG9yeS5zaXplIC0gMSwgaGlzdG9yeU9mZlNldCArIDEpO1xuICAgICAgY29uc3QgYm9hcmQgPSBoaXN0b3J5LmdldChoaXN0b3J5T2ZmU2V0KTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBib2FyZCwgaGlzdG9yeU9mZlNldCB9KTtcbiAgICB9XG4gIH07XG5cbiAgdW5kbyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGhpc3RvcnkgfSA9IHRoaXMuc3RhdGU7XG4gICAgbGV0IHsgaGlzdG9yeU9mZlNldCwgYm9hcmQgfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKGhpc3Rvcnkuc2l6ZSkge1xuICAgICAgaGlzdG9yeU9mZlNldCA9IE1hdGgubWF4KDAsIGhpc3RvcnlPZmZTZXQgLSAxKTtcbiAgICAgIGJvYXJkID0gaGlzdG9yeS5nZXQoaGlzdG9yeU9mZlNldCk7XG4gICAgICB0aGlzLnNldFN0YXRlKHsgYm9hcmQsIGhpc3RvcnlPZmZTZXQsIGhpc3RvcnkgfSk7XG4gICAgfVxuICB9O1xuXG4gIGVyYXNlU2VsZWN0ZWQgPSAoKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0ZWRDZWxsID0gdGhpcy5nZXRTZWxlY3RlZENlbGwoKTtcbiAgICBpZiAoIXNlbGVjdGVkQ2VsbCkgcmV0dXJuO1xuICAgIHRoaXMuZmlsbE51bWJlcihmYWxzZSk7XG4gIH1cblxuICBmaWxsU2VsZWN0ZWRXaXRoU29sdXRpb24gPSAoKSA9PiB7XG4gICAgY29uc3QgeyBib2FyZCwgc29sdXRpb24gfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3Qgc2VsZWN0ZWRDZWxsID0gdGhpcy5nZXRTZWxlY3RlZENlbGwoKTtcbiAgICBpZiAoIXNlbGVjdGVkQ2VsbCkgcmV0dXJuO1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gYm9hcmQuZ2V0KCdzZWxlY3RlZCcpO1xuICAgIHRoaXMuZmlsbE51bWJlcihzb2x1dGlvblt4XVt5XSk7XG4gIH1cblxuXG4gIC8vIGZpbGwgY3VycmVudGx5IHNlbGVjdGVkIGNlbGwgd2l0aCBudW1iZXJcbiAgZmlsbE51bWJlciA9IChudW1iZXIpID0+IHtcbiAgICBsZXQgeyBib2FyZCB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBzZWxlY3RlZENlbGwgPSB0aGlzLmdldFNlbGVjdGVkQ2VsbCgpO1xuICAgIC8vIG5vLW9wIGlmIG5vdGhpbmcgaXMgc2VsZWN0ZWRcbiAgICBpZiAoIXNlbGVjdGVkQ2VsbCkgcmV0dXJuO1xuICAgIGNvbnN0IHByZWZpbGxlZCA9IHNlbGVjdGVkQ2VsbC5nZXQoJ3ByZWZpbGxlZCcpO1xuICAgIC8vIG5vLW9wIGlmIGl0IGlzIHJlZmlsbGVkXG4gICAgaWYgKHByZWZpbGxlZCkgcmV0dXJuO1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gYm9hcmQuZ2V0KCdzZWxlY3RlZCcpO1xuICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHNlbGVjdGVkQ2VsbC5nZXQoJ3ZhbHVlJyk7XG4gICAgLy8gcmVtb3ZlIHRoZSBjdXJyZW50IHZhbHVlIGFuZCB1cGRhdGUgdGhlIGdhbWUgc3RhdGVcbiAgICBpZiAoY3VycmVudFZhbHVlKSB7XG4gICAgICBib2FyZCA9IHVwZGF0ZUJvYXJkV2l0aE51bWJlcih7XG4gICAgICAgIHgsIHksIG51bWJlcjogY3VycmVudFZhbHVlLCBmaWxsOiBmYWxzZSwgYm9hcmQ6IHRoaXMuc3RhdGUuYm9hcmQsXG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gdXBkYXRlIHRvIG5ldyBudW1iZXIgaWYgYW55XG4gICAgY29uc3Qgc2V0TnVtYmVyID0gY3VycmVudFZhbHVlICE9PSBudW1iZXIgJiYgbnVtYmVyO1xuICAgIGlmIChzZXROdW1iZXIpIHtcbiAgICAgIGJvYXJkID0gdXBkYXRlQm9hcmRXaXRoTnVtYmVyKHtcbiAgICAgICAgeCwgeSwgbnVtYmVyLCBmaWxsOiB0cnVlLCBib2FyZCxcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZUJvYXJkKGJvYXJkKTtcbiAgfTtcblxuICBzZWxlY3RDZWxsID0gKHgsIHkpID0+IHtcbiAgICBsZXQgeyBib2FyZCB9ID0gdGhpcy5zdGF0ZTtcbiAgICBib2FyZCA9IGJvYXJkLnNldCgnc2VsZWN0ZWQnLCB7IHgsIHkgfSk7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IGJvYXJkIH0pO1xuICB9O1xuXG4gIGlzQ29uZmxpY3QoaSwgaikge1xuICAgIGNvbnN0IHsgdmFsdWUgfSA9IHRoaXMuc3RhdGUuYm9hcmQuZ2V0SW4oWydwdXp6bGUnLCBpLCBqXSkudG9KU09OKCk7XG4gICAgaWYgKCF2YWx1ZSkgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IHJvd0NvbmZsaWN0ID1cbiAgICAgIHRoaXMuc3RhdGUuYm9hcmQuZ2V0SW4oWydjaG9pY2VzJywgJ3Jvd3MnLCBpLCB2YWx1ZV0pID4gMTtcbiAgICBjb25zdCBjb2x1bW5Db25mbGljdCA9XG4gICAgICB0aGlzLnN0YXRlLmJvYXJkLmdldEluKFsnY2hvaWNlcycsICdjb2x1bW5zJywgaiwgdmFsdWVdKSA+IDE7XG4gICAgY29uc3Qgc3F1YXJlQ29uZmxpY3QgPVxuICAgICAgdGhpcy5zdGF0ZS5ib2FyZC5nZXRJbihbJ2Nob2ljZXMnLCAnc3F1YXJlcycsXG4gICAgICAgICgoTWF0aC5mbG9vcihpIC8gMykpICogMykgKyBNYXRoLmZsb29yKGogLyAzKSwgdmFsdWVdKSA+IDE7XG4gICAgcmV0dXJuIHJvd0NvbmZsaWN0IHx8IGNvbHVtbkNvbmZsaWN0IHx8IHNxdWFyZUNvbmZsaWN0O1xuICB9XG5cbiAgcmVuZGVyQ2VsbChjZWxsLCB4LCB5KSB7XG4gICAgY29uc3QgeyBib2FyZCB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBzZWxlY3RlZCA9IHRoaXMuZ2V0U2VsZWN0ZWRDZWxsKCk7XG4gICAgY29uc3QgeyB2YWx1ZSwgcHJlZmlsbGVkLCBub3RlcyB9ID0gY2VsbC50b0pTT04oKTtcbiAgICBjb25zdCBjb25mbGljdCA9IHRoaXMuaXNDb25mbGljdCh4LCB5KTtcbiAgICBjb25zdCBwZWVyID0gYXJlQ29vcmRpbmF0ZVBlZXJzKHsgeCwgeSB9LCBib2FyZC5nZXQoJ3NlbGVjdGVkJykpO1xuICAgIGNvbnN0IHNhbWVWYWx1ZSA9ICEhKHNlbGVjdGVkICYmIHNlbGVjdGVkLmdldCgndmFsdWUnKVxuICAgICAgJiYgdmFsdWUgPT09IHNlbGVjdGVkLmdldCgndmFsdWUnKSk7XG5cbiAgICBjb25zdCBpc1NlbGVjdGVkID0gY2VsbCA9PT0gc2VsZWN0ZWQ7XG4gICAgcmV0dXJuICg8Q2VsbFxuICAgICAgcHJlZmlsbGVkPXtwcmVmaWxsZWR9XG4gICAgICBub3Rlcz17bm90ZXN9XG4gICAgICBzYW1lVmFsdWU9e3NhbWVWYWx1ZX1cbiAgICAgIGlzU2VsZWN0ZWQ9e2lzU2VsZWN0ZWR9XG4gICAgICBpc1BlZXI9e3BlZXJ9XG4gICAgICB2YWx1ZT17dmFsdWV9XG4gICAgICBvbkNsaWNrPXsoKSA9PiB7IHRoaXMuc2VsZWN0Q2VsbCh4LCB5KTsgfX1cbiAgICAgIGtleT17eX1cbiAgICAgIHg9e3h9XG4gICAgICB5PXt5fVxuICAgICAgY29uZmxpY3Q9e2NvbmZsaWN0fVxuICAgIC8+KTtcbiAgfVxuXG4gIHJlbmRlck51bWJlckNvbnRyb2woKSB7XG4gICAgY29uc3Qgc2VsZWN0ZWRDZWxsID0gdGhpcy5nZXRTZWxlY3RlZENlbGwoKTtcbiAgICBjb25zdCBwcmVmaWxsZWQgPSBzZWxlY3RlZENlbGwgJiYgc2VsZWN0ZWRDZWxsLmdldCgncHJlZmlsbGVkJyk7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29udHJvbFwiPlxuICAgICAgICB7cmFuZ2UoOSkubWFwKChpKSA9PiB7XG4gICAgICAgICAgY29uc3QgbnVtYmVyID0gaSArIDE7XG4gICAgICAgICAgLy8gaGFuZGxlcyBiaW5kaW5nIHNpbmdsZSBjbGljayBhbmQgZG91YmxlIGNsaWNrIGNhbGxiYWNrc1xuICAgICAgICAgIGNvbnN0IGNsaWNrSGFuZGxlID0gZ2V0Q2xpY2tIYW5kbGVyKFxuICAgICAgICAgICAgKCkgPT4geyB0aGlzLmZpbGxOdW1iZXIobnVtYmVyKTsgfSxcbiAgICAgICAgICAgICgpID0+IHsgdGhpcy5hZGROdW1iZXJBc05vdGUobnVtYmVyKTsgfSxcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8TnVtYmVyQ29udHJvbFxuICAgICAgICAgICAgICBrZXk9e251bWJlcn1cbiAgICAgICAgICAgICAgbnVtYmVyPXtudW1iZXJ9XG4gICAgICAgICAgICAgIG9uQ2xpY2s9eyFwcmVmaWxsZWQgPyBjbGlja0hhbmRsZSA6IHVuZGVmaW5lZH1cbiAgICAgICAgICAgICAgY29tcGxldGlvblBlcmNlbnRhZ2U9e3RoaXMuZ2V0TnVtYmVyVmFsdWVDb3VudChudW1iZXIpIC8gOX1cbiAgICAgICAgICAgIC8+KTtcbiAgICAgICAgfSl9XG4gICAgICAgIDxzdHlsZSBqc3g+e0NvbnRyb2xTdHlsZX08L3N0eWxlPlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxuXG4gIHJlbmRlckFjdGlvbnMoKSB7XG4gICAgY29uc3QgeyBoaXN0b3J5IH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IHNlbGVjdGVkQ2VsbCA9IHRoaXMuZ2V0U2VsZWN0ZWRDZWxsKCk7XG4gICAgY29uc3QgcHJlZmlsbGVkID0gc2VsZWN0ZWRDZWxsICYmIHNlbGVjdGVkQ2VsbC5nZXQoJ3ByZWZpbGxlZCcpO1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImFjdGlvbnNcIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJhY3Rpb25cIiBvbkNsaWNrPXtoaXN0b3J5LnNpemUgPyB0aGlzLnVuZG8gOiBudWxsfT5cbiAgICAgICAgICA8UmVsb2FkSWNvbiAvPlVuZG9cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWN0aW9uIHJlZG9cIiBvbkNsaWNrPXtoaXN0b3J5LnNpemUgPyB0aGlzLnJlZG8gOiBudWxsfT5cbiAgICAgICAgICA8UmVsb2FkSWNvbiAvPlJlZG9cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWN0aW9uXCIgb25DbGljaz17IXByZWZpbGxlZCA/IHRoaXMuZXJhc2VTZWxlY3RlZCA6IG51bGx9PlxuICAgICAgICAgIDxSZW1vdmVJY29uIC8+RXJhc2VcbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXZcbiAgICAgICAgICBjbGFzc05hbWU9XCJhY3Rpb25cIlxuICAgICAgICAgIG9uQ2xpY2s9eyFwcmVmaWxsZWQgP1xuICAgICAgICAgIHRoaXMuZmlsbFNlbGVjdGVkV2l0aFNvbHV0aW9uIDogbnVsbH1cbiAgICAgICAgPlxuICAgICAgICAgIDxMb3VwZUljb24gLz5IaW50XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8c3R5bGUganN4PntBY3Rpb25zU3R5bGV9PC9zdHlsZT5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cblxuICByZW5kZXJQdXp6bGUoKSB7XG4gICAgY29uc3QgeyBib2FyZCB9ID0gdGhpcy5zdGF0ZTtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJwdXp6bGVcIj5cbiAgICAgICAge2JvYXJkLmdldCgncHV6emxlJykubWFwKChyb3csIGkpID0+IChcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3Qvbm8tYXJyYXktaW5kZXgta2V5XG4gICAgICAgICAgPGRpdiBrZXk9e2l9IGNsYXNzTmFtZT1cInJvd1wiPlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICByb3cubWFwKChjZWxsLCBqKSA9PiB0aGlzLnJlbmRlckNlbGwoY2VsbCwgaSwgaikpLnRvQXJyYXkoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICApKS50b0FycmF5KCl9XG4gICAgICAgIDxzdHlsZSBqc3g+e1B1enpsZVN0eWxlfTwvc3R5bGU+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG5cbiAgcmVuZGVyQ29udHJvbHMoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29udHJvbHNcIj5cbiAgICAgICAge3RoaXMucmVuZGVyTnVtYmVyQ29udHJvbCgpfVxuICAgICAgICB7dGhpcy5yZW5kZXJBY3Rpb25zKCl9XG4gICAgICAgIHsgLyogbGFuZ3VhZ2U9Q1NTICovIH1cbiAgICAgICAgPHN0eWxlIGpzeD57YFxuICAgICAgICAgICAgLmNvbnRyb2xzIHtcbiAgICAgICAgICAgICAgICBtYXJnaW4tdG9wOiAuM2VtO1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgICAgICAgZmxleC13cmFwOiB3cmFwO1xuICAgICAgICAgICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICAgICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICAgICAgICAgIHBhZGRpbmc6IC41ZW0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgYH1cbiAgICAgICAgPC9zdHlsZT5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cblxuICByZW5kZXJHZW5lcmF0aW9uVUkoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxHZW5lcmF0aW9uVUkgZ2VuZXJhdGVHYW1lPXt0aGlzLmdlbmVyYXRlR2FtZX0gLz5cbiAgICApO1xuICB9XG5cbiAgcmVuZGVySGVhZGVyKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImhlYWRlclwiPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm5ldy1nYW1lXCIgb25DbGljaz17KCkgPT4gdGhpcy5zZXRTdGF0ZSh7IGJvYXJkOiBmYWxzZSB9KX0+XG4gICAgICAgICAgPFJldHVybkljb24gLz5cbiAgICAgICAgICA8ZGl2Pk5ldyBHYW1lPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8VGlwIC8+XG4gICAgICAgIHsgLyogbGFuZ3VhZ2U9Q1NTICovIH1cbiAgICAgICAgPHN0eWxlIGpzeD57YFxuICAgICAgICAgICAgLmhlYWRlciB7XG4gICAgICAgICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gICAgICAgICAgICAgICAgbWF4LXdpZHRoOiA1MDBweDtcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiAwIDAuNWVtO1xuICAgICAgICAgICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAubmV3LWdhbWUge1xuICAgICAgICAgICAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICAgICAgICAgICAgICBtYXJnaW4tdG9wOiAuMmVtO1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6IGlubGluZS1mbGV4O1xuICAgICAgICAgICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgICAgICAgICAgcGFkZGluZzogLjJlbSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLm5ldy1nYW1lIDpnbG9iYWwoc3ZnKSB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxZW07XG4gICAgICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogLjNlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgYH1cbiAgICAgICAgPC9zdHlsZT5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBib2FyZCB9ID0gdGhpcy5zdGF0ZTtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJib2R5XCI+XG4gICAgICAgIDxOZXh0SGVhZD5cbiAgICAgICAgICA8dGl0bGU+U3Vkb2t1IEV2b2x2ZWQ8L3RpdGxlPlxuICAgICAgICAgIDxtZXRhIG5hbWU9XCJ2aWV3cG9ydFwiIGNvbnRlbnQ9XCJpbml0aWFsLXNjYWxlPTEuMCwgd2lkdGg9ZGV2aWNlLXdpZHRoXCIgLz5cbiAgICAgICAgICA8bWV0YSBuYW1lPVwiZGVzY3JpcHRpb25cIiBjb250ZW50PXtEZXNjcmlwdGlvbn0gLz5cbiAgICAgICAgICA8bGluayBocmVmPVwiaHR0cHM6Ly9mb250cy5nb29nbGVhcGlzLmNvbS9jc3M/ZmFtaWx5PVNwZWNpYWwrRWxpdGVcIiByZWw9XCJzdHlsZXNoZWV0XCIgLz5cbiAgICAgICAgICA8bWV0YSBwcm9wZXJ0eT1cIm9nOnVybFwiIGNvbnRlbnQ9XCJodHRwczovL3N1ZG9rdS5zaXRpYW5saXUuY29tL1wiIC8+XG4gICAgICAgICAgPG1ldGEgcHJvcGVydHk9XCJvZzp0aXRsZVwiIGNvbnRlbnQ9XCJTdWRva3UgRXZvbHZlZFwiIC8+XG4gICAgICAgICAgPG1ldGEgcHJvcGVydHk9XCJvZzp0eXBlXCIgY29udGVudD1cIndlYnNpdGVcIiAvPlxuICAgICAgICAgIDxtZXRhIHByb3BlcnR5PVwib2c6ZGVzY3JpcHRpb25cIiBjb250ZW50PXtEZXNjcmlwdGlvbn0gLz5cbiAgICAgICAgICA8bWV0YSBwcm9wZXJ0eT1cIm9nOmltYWdlXCIgY29udGVudD1cImh0dHBzOi8vc3Vkb2t1LnNpdGlhbmxpdS5jb20vc3RhdGljL29nLWltYWdlLnBuZ1wiIC8+XG4gICAgICAgIDwvTmV4dEhlYWQ+XG4gICAgICAgIHshYm9hcmQgJiYgdGhpcy5yZW5kZXJHZW5lcmF0aW9uVUkoKX1cbiAgICAgICAge2JvYXJkICYmIHRoaXMucmVuZGVySGVhZGVyKCl9XG4gICAgICAgIHtib2FyZCAmJiB0aGlzLnJlbmRlclB1enpsZSgpfVxuICAgICAgICB7Ym9hcmQgJiYgdGhpcy5yZW5kZXJDb250cm9scygpfVxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInJvb3RlclwiPlxuICAgICAgICAgIE1hZGUgd2l0aCA8c3Bhbj7inaTvuI88L3NwYW4+77iPIEJ5IDxhIGhyZWY9XCJodHRwczovL3d3dy5zaXRpYW5saXUuY29tL1wiPlNpdGlhbiBMaXU8L2E+IHwgPGEgaHJlZj1cImh0dHBzOi8vbWVkaXVtLmNvbS9Ac2l0aWFubGl1XzU3NjgwL2J1aWxkaW5nLWEtc3Vkb2t1LWdhbWUtaW4tcmVhY3QtY2E2NjM5MTU3MTJcIj5CbG9nIFBvc3Q8L2E+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICB7IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG4gICAgICAgIDxzdHlsZSBqc3g+e2BcbiAgICAgICAgICAgIDpnbG9iYWwoYm9keSksIC5ib2R5IHtcbiAgICAgICAgICAgICAgICBmb250LWZhbWlseTogJ1NwZWNpYWwgRWxpdGUnLCBjdXJzaXZlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLmJvZHkge1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICAgICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICAgICAgICAgIGhlaWdodDogMTAwdmg7XG4gICAgICAgICAgICAgICAgd2lkdGg6IDEwMHZ3O1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEBtZWRpYSAobWluLXdpZHRoOiA4MDBweCkgYW5kIChtaW4taGVpZ2h0OiA5MzBweCl7XG4gICAgICAgICAgICAgICAgOmdsb2JhbCguaGVhZGVyLCAucHV6emxlLCAuY29udHJvbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9udC1zaXplOiAxLjVlbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBAbWVkaWEgKG1heC13aWR0aDogODAwcHgpIGFuZCAobWluLXdpZHRoOiA2MDBweCl7XG4gICAgICAgICAgICAgICAgOmdsb2JhbCguaGVhZGVyLCAucHV6emxlLCAuY29udHJvbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9udC1zaXplOiAxLjJlbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBAbWVkaWEgKG1heC1oZWlnaHQ6IDkzMHB4KSBhbmQgKG1pbi1oZWlnaHQ6IDgwMHB4KSBhbmQgKG1pbi13aWR0aDogNjAwcHgpe1xuICAgICAgICAgICAgICAgIDpnbG9iYWwoLmhlYWRlciwgLnB1enpsZSwgLmNvbnRyb2xzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvbnQtc2l6ZTogMS4yZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQG1lZGlhIChtYXgtaGVpZ2h0OiA4MDBweCkgYW5kIChtaW4taGVpZ2h0OiA2MDBweCkgYW5kIChtaW4td2lkdGg6IDM3MHB4KXtcbiAgICAgICAgICAgICAgICA6Z2xvYmFsKC5oZWFkZXIsIC5wdXp6bGUsIC5jb250cm9scykge1xuICAgICAgICAgICAgICAgICAgICBmb250LXNpemU6IDFlbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBAbWVkaWEgKG1heC13aWR0aDogMzcwcHgpe1xuICAgICAgICAgICAgICAgIDpnbG9iYWwoLmhlYWRlciwgLnB1enpsZSwgLmNvbnRyb2xzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvbnQtc2l6ZTogLjhlbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBAbWVkaWEgKG1heC1oZWlnaHQ6IDYwMHB4KXtcbiAgICAgICAgICAgICAgICA6Z2xvYmFsKC5oZWFkZXIsIC5wdXp6bGUsIC5jb250cm9scykge1xuICAgICAgICAgICAgICAgICAgICBmb250LXNpemU6IC44ZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOmdsb2JhbChib2R5KSB7XG4gICAgICAgICAgICAgICAgbWFyZ2luOiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLnJvb3RlciB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgICAgICAgICAgIGJvdHRvbTogMDtcbiAgICAgICAgICAgICAgICBmb250LXNpemU6IC44ZW07XG4gICAgICAgICAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgICAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICBgfVxuICAgICAgICA8L3N0eWxlPlxuICAgICAgICA8c3R5bGUganN4IGdsb2JhbD57UmFuZ2VTdHlsZX08L3N0eWxlPlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufVxuIl19 */\n/*@ sourceURL=pages/index.js */';
CirculuarProgressStyle.__scopedHash = '1171755374';
var CircularPathD = 'M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831';

function getBackGroundColor(_ref) {
  var conflict = _ref.conflict,
      isPeer = _ref.isPeer,
      sameValue = _ref.sameValue,
      isSelected = _ref.isSelected;

  if (conflict && isPeer && sameValue) {
    return DeepOrange200;
  } else if (sameValue) {
    return LightBlue300;
  } else if (isSelected) {
    return LightBlue200;
  } else if (isPeer) {
    return LightBlue100;
  }
  return false;
}

function getFontColor(_ref2) {
  var value = _ref2.value,
      conflict = _ref2.conflict,
      prefilled = _ref2.prefilled;

  if (conflict && !prefilled) {
    return DeepOrange600;
  } else if (!prefilled && value) {
    return ControlNumberColor;
  }
  return false;
}

var GenerationUI = function (_Component) {
  _inherits(GenerationUI, _Component);

  function GenerationUI(props) {
    _classCallCheck(this, GenerationUI);

    var _this = _possibleConstructorReturn(this, (GenerationUI.__proto__ || Object.getPrototypeOf(GenerationUI)).call(this, props));

    _this.generateGame = function () {
      _this.props.generateGame(_this.state.value);
    };

    _this.state = { value: 30 };
    return _this;
  }

  _createClass(GenerationUI, [{
    key: 'render',
    value: function render() {
      var _this2 = this;

      return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
        'div',
        {
          className: 'jsx-1304814462' + ' ' + 'generation',
          __source: {
            fileName: _jsxFileName,
            lineNumber: 218
          }
        },
        __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
          'div',
          {
            className: 'jsx-1304814462' + ' ' + 'copy',
            __source: {
              fileName: _jsxFileName,
              lineNumber: 219
            }
          },
          'Start with ',
          this.state.value,
          ' cells prefilled'
        ),
        __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_6_react_input_range___default.a, {
          maxValue: 81,
          minValue: 17,
          value: this.state.value,
          onChange: function onChange(value) {
            return _this2.setState({ value: value });
          },
          __source: {
            fileName: _jsxFileName,
            lineNumber: 220
          }
        }),
        __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
          'div',
          { onClick: this.generateGame, className: 'jsx-1304814462' + ' ' + 'button',
            __source: {
              fileName: _jsxFileName,
              lineNumber: 226
            }
          },
          'Play Sudoku'
        ),
        __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_0_styled_jsx_style___default.a, {
          styleId: '1304814462',
          css: '.copy.jsx-1304814462{text-align:center;font-size:1.3em;margin-bottom:.5em;}.generation.jsx-1304814462{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;width:100%;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}.input-range{width:80%;max-width:500px;}.button.jsx-1304814462{margin-top:.5em;border-radius:.25em;cursor:pointer;font-weight:bold;text-decoration:none;color:#fff;position:relative;display:inline-block;-webkit-transition:all .25s;transition:all .25s;padding:5px 10px;font-size:1.4em;}.button.jsx-1304814462:active{-webkit-transform:translate(0px,5px);-ms-transform:translate(0px,5px);transform:translate(0px,5px);box-shadow:0 1px 0 0;}.button.jsx-1304814462{background-color:' + __WEBPACK_IMPORTED_MODULE_13__colors__["a" /* backGroundBlue */] + ';box-shadow:0 2px 4px 0 ' + __WEBPACK_IMPORTED_MODULE_5_color___default()(__WEBPACK_IMPORTED_MODULE_13__colors__["a" /* backGroundBlue */]).darken(0.5).hsl().string() + ';display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}.button.jsx-1304814462:hover{background-color:' + __WEBPACK_IMPORTED_MODULE_5_color___default()(__WEBPACK_IMPORTED_MODULE_13__colors__["a" /* backGroundBlue */]).lighten(0.2).hsl().string() + ';}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhZ2VzL2luZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQW1Pb0IsQUFHbUMsQUFLTCxBQU9ILEFBSUksQUFhYyxBQUtnQixBQU9BLFVBNUI1QixNQUlFLEVBaEJGLFFBYXBCLFFBWnVCLEVBZ0JOLFVBaUJxQyxBQU90RCxLQXZCbUIsRUFoQm5CLGVBaUJ1QixNQWRJLGVBZWQsU0FlRSxDQU5RLENBUkgsa0JBQ0csRUFRdkIsbUJBUHNCLGlDQWFELENBOUJLLGNBa0JQLGlCQUNELGdCQUNsQiwrQkFuQmUsV0FDUSxHQTZCdkIsMEZBNUJBIiwiZmlsZSI6InBhZ2VzL2luZGV4LmpzIiwic291cmNlUm9vdCI6Ii9Vc2Vycy9saWNoZW5tYS9Qcm9qZWN0cy9TdUR1b2t1L1N1RHVva3UiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBqc3gtYTExeS9hY2Nlc3NpYmxlLWVtb2ppICovXG5pbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50LCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBTZXQsIExpc3QsIGZyb21KUyB9IGZyb20gJ2ltbXV0YWJsZSc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IE5leHRIZWFkIGZyb20gJ25leHQvaGVhZCc7XG5pbXBvcnQgQ29sb3IgZnJvbSAnY29sb3InO1xuaW1wb3J0IElucHV0UmFuZ2UgZnJvbSAncmVhY3QtaW5wdXQtcmFuZ2UnO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLWV4dHJhbmVvdXMtZGVwZW5kZW5jaWVzXG5pbXBvcnQgY3NzIGZyb20gJ3N0eWxlZC1qc3gvY3NzJztcblxuaW1wb3J0IFJhbmdlU3R5bGUgZnJvbSAnLi4vaW5wdXQtcmFuZ2Utc3R5bGUnO1xuaW1wb3J0IExvdXBlSWNvbiBmcm9tICcuLi9zdmcvbG91cGUuc3ZnJztcbmltcG9ydCBSZW1vdmVJY29uIGZyb20gJy4uL3N2Zy9yZW1vdmUuc3ZnJztcbmltcG9ydCBSZWxvYWRJY29uIGZyb20gJy4uL3N2Zy9yZWxvYWQuc3ZnJztcbmltcG9ydCBSZXR1cm5JY29uIGZyb20gJy4uL3N2Zy9yZXR1cm4uc3ZnJztcblxuaW1wb3J0IHsgbWFrZVB1enpsZSwgcGx1Y2ssIGlzUGVlciBhcyBhcmVDb29yZGluYXRlUGVlcnMsIHJhbmdlIH0gZnJvbSAnLi4vc3Vkb2t1JztcbmltcG9ydCB7IGJhY2tHcm91bmRCbHVlIH0gZnJvbSAnLi4vY29sb3JzJztcbmltcG9ydCBUaXAgZnJvbSAnLi4vY29tcG9uZW50cy90b29sLXRpcCc7XG5cbmltcG9ydCBpbyBmcm9tICdzb2NrZXQuaW8tY2xpZW50J1xuXG5jb25zdCBEZXNjcmlwdGlvbiA9ICdEaXNjb3ZlciB0aGUgbmV4dCBldm9sdXRpb24gb2YgU3Vkb2t1IHdpdGggYW1hemluZyBncmFwaGljcywgYW5pbWF0aW9ucywgYW5kIHVzZXItZnJpZW5kbHkgZmVhdHVyZXMuIEVuam95IGEgU3Vkb2t1IGV4cGVyaWVuY2UgbGlrZSB5b3UgbmV2ZXIgaGF2ZSBiZWZvcmUgd2l0aCBjdXN0b21pemFibGUgZ2FtZSBnZW5lcmF0aW9uLCBjZWxsIGhpZ2hsaWdodGluZywgaW50dWl0aXZlIGNvbnRyb2xzIGFuZCBtb3JlISc7XG5jb25zdCBjZWxsV2lkdGggPSAyLjU7XG5cbmNvbnN0IExpZ2h0Qmx1ZTEwMCA9ICcjQjNFNUZDJztcbmNvbnN0IExpZ2h0Qmx1ZTIwMCA9ICcjODFENEZBJztcbmNvbnN0IExpZ2h0Qmx1ZTMwMCA9ICcjNEZDM0Y3JztcbmNvbnN0IEluZGlnbzcwMCA9ICcjMzAzRjlGJztcbmNvbnN0IERlZXBPcmFuZ2UyMDAgPSAnI0ZGQUI5MSc7XG5jb25zdCBEZWVwT3JhbmdlNjAwID0gJyNGNDUxMUUnO1xuY29uc3QgQ29udHJvbE51bWJlckNvbG9yID0gSW5kaWdvNzAwO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbG9uZS1ibG9ja3NcbnsgLyogbGFuZ3VhZ2U9Q1NTICovIH1cbmNvbnN0IENlbGxTdHlsZSA9IGNzc2Bcbi5jZWxsIHtcbiAgICBoZWlnaHQ6ICR7Y2VsbFdpZHRofWVtO1xuICAgIHdpZHRoOiAke2NlbGxXaWR0aH1lbTtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtd3JhcDogd3JhcDtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgIGZvbnQtc2l6ZTogMS4xZW07XG4gICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgdHJhbnNpdGlvbjogYmFja2dyb3VuZC1jb2xvciAuM3MgZWFzZS1pbi1vdXQ7XG59XG4uY2VsbDpudGgtY2hpbGQoM24rMyk6bm90KDpsYXN0LWNoaWxkKSB7XG4gICAgYm9yZGVyLXJpZ2h0OiAycHggc29saWQgYmxhY2s7XG59XG4uY2VsbDpub3QoOmxhc3QtY2hpbGQpIHtcbiAgICBib3JkZXItcmlnaHQ6IDFweCBzb2xpZCBibGFjaztcbn1cbi5ub3RlLW51bWJlciB7XG4gICAgZm9udC1zaXplOiAuNmVtO1xuICAgIHdpZHRoOiAzMyU7XG4gICAgaGVpZ2h0OiAzMyU7XG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG59XG5gO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbG9uZS1ibG9ja3NcbnsgLyogbGFuZ3VhZ2U9Q1NTICovIH1cbmNvbnN0IEFjdGlvbnNTdHlsZSA9IGNzc2Bcbi5hY3Rpb25zIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIG1heC13aWR0aDogNDAwcHg7XG4gICAgbWFyZ2luLXRvcDogLjVlbTtcbiAgICBwYWRkaW5nOiAwIC42ZW07XG59XG4uYWN0aW9uIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbn1cbi5hY3Rpb24gOmdsb2JhbChzdmcpIHtcbiAgICB3aWR0aDogMi41ZW07XG4gICAgbWFyZ2luLWJvdHRvbTogLjJlbTtcbn1cbi5yZWRvIDpnbG9iYWwoc3ZnKSB7XG4gICAgdHJhbnNmb3JtOiBzY2FsZVgoLTEpO1xufVxuYDtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxvbmUtYmxvY2tzXG57IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG5jb25zdCBDb250cm9sU3R5bGUgPSBjc3NgXG4uY29udHJvbCB7XG4gICAgcGFkZGluZzogMCAyZW07XG4gICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIGRpc3BsYXk6IGlubGluZS1mbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgZmxleC13cmFwOiB3cmFwO1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgIGZvbnQtZmFtaWx5OiAnU3BlY2lhbCBFbGl0ZScsIGN1cnNpdmU7XG4gICAgdHJhbnNpdGlvbjogZmlsdGVyIC41cyBlYXNlLWluLW91dDtcbiAgICB3aWR0aDogMTAwJTtcbn1cbmA7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sb25lLWJsb2Nrc1xueyAvKiBsYW5ndWFnZT1DU1MgKi8gfVxuY29uc3QgTnVtYmVyQ29udHJvbFN0eWxlID0gY3NzYFxuLm51bWJlciB7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBmb250LXNpemU6IDJlbTtcbiAgICBtYXJnaW46IC4xZW07XG4gICAgd2lkdGg6IDEuNWVtO1xuICAgIGhlaWdodDogMS41ZW07XG4gICAgY29sb3I6ICR7Q29udHJvbE51bWJlckNvbG9yfTtcbiAgICBib3gtc2hhZG93OiAwIDFweCAycHggcmdiYSgwLDAsMCwwLjE2KSwgMCAxcHggMnB4IHJnYmEoMCwwLDAsMC4yMyk7XG4gICAgYm9yZGVyLXJhZGl1czogNTAlO1xufVxuLm51bWJlciA+IGRpdiB7XG4gICAgbWFyZ2luLXRvcDogLjNlbTtcbn1cbmA7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sb25lLWJsb2Nrc1xueyAvKiBsYW5ndWFnZT1DU1MgKi8gfVxuY29uc3QgUHV6emxlU3R5bGUgPSBjc3NgXG4ucHV6emxlIHtcbiAgICBtYXJnaW4tdG9wOiAuNWVtO1xuICAgIHdpZHRoOiAke2NlbGxXaWR0aCAqIDl9ZW07XG4gICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIGJveC1zaGFkb3c6IDAgM3B4IDZweCByZ2JhKDAsMCwwLDAuMTYpLCAwIDNweCA2cHggcmdiYSgwLDAsMCwwLjIzKTtcbn1cbi5yb3cge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBmbGV4OiAwO1xuICAgIHdpZHRoOiAke2NlbGxXaWR0aCAqIDl9ZW07XG59XG4ucm93Om5vdCg6bGFzdC1jaGlsZCkge1xuICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCBibGFjaztcbn1cbi5yb3c6bnRoLWNoaWxkKDNuKzMpOm5vdCg6bGFzdC1jaGlsZCkge1xuICAgIGJvcmRlci1ib3R0b206IDJweCBzb2xpZCBibGFjayAhaW1wb3J0YW50O1xufVxuYDtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxvbmUtYmxvY2tzXG57IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG5jb25zdCBDaXJjdWx1YXJQcm9ncmVzc1N0eWxlID0gY3NzYFxuLmNpcmN1bGFyLXByb2dyZXNzIHtcbiAgICBkaXNwbGF5OiBibG9jaztcbiAgICB3aWR0aDogMTAwJTtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgdG9wOiAwO1xuICAgIGxlZnQ6IDA7XG4gICAgdHJhbnNpdGlvbjogZmlsdGVyIC40cyBlYXNlLWluLW91dDtcbn1cblxuLmNpcmNsZS1iZyB7XG4gICAgZmlsbDogbm9uZTtcbiAgICBzdHJva2U6ICNlZWU7XG4gICAgc3Ryb2tlLXdpZHRoOiAzLjg7XG59XG5cbi5jaXJjbGUge1xuICAgIHN0cm9rZTogJHtDb250cm9sTnVtYmVyQ29sb3J9O1xuICAgIHRyYW5zaXRpb246IHN0cm9rZS1kYXNoYXJyYXkgLjRzIGVhc2UtaW4tb3V0O1xuICAgIGZpbGw6IG5vbmU7XG4gICAgc3Ryb2tlLXdpZHRoOiAyLjg7XG4gICAgc3Ryb2tlLWxpbmVjYXA6IHJvdW5kO1xufVxuYDtcblxuY29uc3QgQ2lyY3VsYXJQYXRoRCA9ICdNMTggMi4wODQ1IGEgMTUuOTE1NSAxNS45MTU1IDAgMCAxIDAgMzEuODMxIGEgMTUuOTE1NSAxNS45MTU1IDAgMCAxIDAgLTMxLjgzMSc7XG5cbmZ1bmN0aW9uIGdldEJhY2tHcm91bmRDb2xvcih7XG4gIGNvbmZsaWN0LCBpc1BlZXIsIHNhbWVWYWx1ZSwgaXNTZWxlY3RlZCxcbn0pIHtcbiAgaWYgKGNvbmZsaWN0ICYmIGlzUGVlciAmJiBzYW1lVmFsdWUpIHtcbiAgICByZXR1cm4gRGVlcE9yYW5nZTIwMDtcbiAgfSBlbHNlIGlmIChzYW1lVmFsdWUpIHtcbiAgICByZXR1cm4gTGlnaHRCbHVlMzAwO1xuICB9IGVsc2UgaWYgKGlzU2VsZWN0ZWQpIHtcbiAgICByZXR1cm4gTGlnaHRCbHVlMjAwO1xuICB9IGVsc2UgaWYgKGlzUGVlcikge1xuICAgIHJldHVybiBMaWdodEJsdWUxMDA7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRGb250Q29sb3IoeyB2YWx1ZSwgY29uZmxpY3QsIHByZWZpbGxlZCB9KSB7XG4gIGlmIChjb25mbGljdCAmJiAhcHJlZmlsbGVkKSB7XG4gICAgcmV0dXJuIERlZXBPcmFuZ2U2MDA7XG4gIH0gZWxzZSBpZiAoIXByZWZpbGxlZCAmJiB2YWx1ZSkge1xuICAgIHJldHVybiBDb250cm9sTnVtYmVyQ29sb3I7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5jbGFzcyBHZW5lcmF0aW9uVUkgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcblxuICAgIHRoaXMuc3RhdGUgPSB7IHZhbHVlOiAzMCB9O1xuICB9XG5cbiAgZ2VuZXJhdGVHYW1lID0gKCkgPT4ge1xuICAgIHRoaXMucHJvcHMuZ2VuZXJhdGVHYW1lKHRoaXMuc3RhdGUudmFsdWUpO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImdlbmVyYXRpb25cIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb3B5XCI+U3RhcnQgd2l0aCB7dGhpcy5zdGF0ZS52YWx1ZX0gY2VsbHMgcHJlZmlsbGVkPC9kaXY+XG4gICAgICAgIDxJbnB1dFJhbmdlXG4gICAgICAgICAgbWF4VmFsdWU9ezgxfVxuICAgICAgICAgIG1pblZhbHVlPXsxN31cbiAgICAgICAgICB2YWx1ZT17dGhpcy5zdGF0ZS52YWx1ZX1cbiAgICAgICAgICBvbkNoYW5nZT17dmFsdWUgPT4gdGhpcy5zZXRTdGF0ZSh7IHZhbHVlIH0pfVxuICAgICAgICAvPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImJ1dHRvblwiIG9uQ2xpY2s9e3RoaXMuZ2VuZXJhdGVHYW1lfT5QbGF5IFN1ZG9rdTwvZGl2PlxuICAgICAgICB7IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG4gICAgICAgIDxzdHlsZSBqc3g+e2BcbiAgICAgICAgICAgIC5jb3B5IHtcbiAgICAgICAgICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgICAgICAgICAgICAgZm9udC1zaXplOiAxLjNlbTtcbiAgICAgICAgICAgICAgICBtYXJnaW4tYm90dG9tOiAuNWVtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLmdlbmVyYXRpb24ge1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgICAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgICAgICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOmdsb2JhbCguaW5wdXQtcmFuZ2UpIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogODAlO1xuICAgICAgICAgICAgICAgIG1heC13aWR0aDogNTAwcHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAuYnV0dG9uIHtcbiAgICAgICAgICAgICAgbWFyZ2luLXRvcDogLjVlbTtcbiAgICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogLjI1ZW07XG4gICAgICAgICAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICAgICAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICAgICAgICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcbiAgICAgICAgICAgICAgY29sb3I6ICNmZmY7XG4gICAgICAgICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgICAgICAgICAgICB0cmFuc2l0aW9uOiBhbGwgLjI1cztcbiAgICAgICAgICAgICAgcGFkZGluZzogNXB4IDEwcHg7XG4gICAgICAgICAgICAgIGZvbnQtc2l6ZTogMS40ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAuYnV0dG9uOmFjdGl2ZSB7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKDBweCwgNXB4KTtcbiAgICAgICAgICAgICAgYm94LXNoYWRvdzogMCAxcHggMCAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAuYnV0dG9uIHtcbiAgICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogJHtiYWNrR3JvdW5kQmx1ZX07XG4gICAgICAgICAgICAgIGJveC1zaGFkb3c6IDAgMnB4IDRweCAwICR7Q29sb3IoYmFja0dyb3VuZEJsdWUpLmRhcmtlbigwLjUpLmhzbCgpLnN0cmluZygpfTtcbiAgICAgICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLmJ1dHRvbjpob3ZlciB7XG4gICAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6ICR7Q29sb3IoYmFja0dyb3VuZEJsdWUpLmxpZ2h0ZW4oMC4yKS5oc2woKS5zdHJpbmcoKX07XG4gICAgICAgICAgICB9XG4gICAgICAgIGB9XG4gICAgICAgIDwvc3R5bGU+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG59XG5cbkdlbmVyYXRpb25VSS5wcm9wVHlwZXMgPSB7XG4gIGdlbmVyYXRlR2FtZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbn07XG5cbmNvbnN0IE51bWJlckNvbnRyb2wgPSAoeyBudW1iZXIsIG9uQ2xpY2ssIGNvbXBsZXRpb25QZXJjZW50YWdlIH0pID0+IChcbiAgPGRpdlxuICAgIGtleT17bnVtYmVyfVxuICAgIGNsYXNzTmFtZT1cIm51bWJlclwiXG4gICAgb25DbGljaz17b25DbGlja31cbiAgPlxuICAgIDxkaXY+e251bWJlcn08L2Rpdj5cbiAgICA8Q2lyY2x1bGFyUHJvZ3Jlc3MgcGVyY2VudD17Y29tcGxldGlvblBlcmNlbnRhZ2V9IC8+XG4gICAgPHN0eWxlIGpzeD57TnVtYmVyQ29udHJvbFN0eWxlfTwvc3R5bGU+XG4gIDwvZGl2PlxuKTtcblxuTnVtYmVyQ29udHJvbC5wcm9wVHlwZXMgPSB7XG4gIG51bWJlcjogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICBvbkNsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgY29tcGxldGlvblBlcmNlbnRhZ2U6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbn07XG5cbk51bWJlckNvbnRyb2wuZGVmYXVsdFByb3BzID0ge1xuICBvbkNsaWNrOiBudWxsLFxufTtcblxuY29uc3QgQ2VsbCA9IChwcm9wcykgPT4ge1xuICBjb25zdCB7XG4gICAgdmFsdWUsIG9uQ2xpY2ssIGlzUGVlciwgaXNTZWxlY3RlZCwgc2FtZVZhbHVlLCBwcmVmaWxsZWQsIG5vdGVzLCBjb25mbGljdCxcbiAgfSA9IHByb3BzO1xuICBjb25zdCBiYWNrZ3JvdW5kQ29sb3IgPSBnZXRCYWNrR3JvdW5kQ29sb3Ioe1xuICAgIGNvbmZsaWN0LCBpc1BlZXIsIHNhbWVWYWx1ZSwgaXNTZWxlY3RlZCxcbiAgfSk7XG4gIGNvbnN0IGZvbnRDb2xvciA9IGdldEZvbnRDb2xvcih7IGNvbmZsaWN0LCBwcmVmaWxsZWQsIHZhbHVlIH0pO1xuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwiY2VsbFwiIG9uQ2xpY2s9e29uQ2xpY2t9PlxuICAgICAge1xuICAgICAgICBub3RlcyA/XG4gICAgICAgICAgcmFuZ2UoOSkubWFwKGkgPT5cbiAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgPGRpdiBrZXk9e2l9IGNsYXNzTmFtZT1cIm5vdGUtbnVtYmVyXCI+XG4gICAgICAgICAgICAgICAge25vdGVzLmhhcyhpICsgMSkgJiYgKGkgKyAxKX1cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICApKSA6XG4gICAgICAgICAgdmFsdWUgJiYgdmFsdWVcbiAgICAgIH1cbiAgICAgIHsvKiBsYW5ndWFnZT1DU1MgKi99XG4gICAgICA8c3R5bGUganN4PntDZWxsU3R5bGV9PC9zdHlsZT5cbiAgICAgIDxzdHlsZSBqc3g+e2BcbiAgICAgICAgICAgICAgICAuY2VsbCB7XG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6ICR7YmFja2dyb3VuZENvbG9yIHx8ICdpbml0aWFsJ307XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiAke2ZvbnRDb2xvciB8fCAnaW5pdGlhbCd9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGB9XG4gICAgICA8L3N0eWxlPlxuICAgIDwvZGl2PlxuICApO1xufTtcblxuQ2VsbC5wcm9wVHlwZXMgPSB7XG4gIC8vIGN1cnJlbnQgbnVtYmVyIHZhbHVlXG4gIHZhbHVlOiBQcm9wVHlwZXMubnVtYmVyLFxuICAvLyBjZWxsIGNsaWNrIGhhbmRsZXJcbiAgb25DbGljazogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgLy8gaWYgdGhlIGNlbGwgaXMgYSBwZWVyIG9mIHRoZSBzZWxlY3RlZCBjZWxsXG4gIGlzUGVlcjogUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZCxcbiAgLy8gaWYgdGhlIGNlbGwgaXMgc2VsZWN0ZWQgYnkgdGhlIHVzZXJcbiAgaXNTZWxlY3RlZDogUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZCxcbiAgLy8gY3VycmVudCBjZWxsIGhhcyB0aGUgc2FtZSB2YWx1ZSBpZiB0aGUgdXNlciBzZWxlY3RlZCBjZWxsXG4gIHNhbWVWYWx1ZTogUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZCxcbiAgLy8gaWYgdGhpcyB3YXMgcHJlZmlsbGVkIGFzIGEgcGFydCBvZiB0aGUgcHV6emxlXG4gIHByZWZpbGxlZDogUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZCxcbiAgLy8gY3VycmVudCBub3RlcyB0YWtlbiBvbiB0aGUgY2VsbFxuICBub3RlczogUHJvcFR5cGVzLmluc3RhbmNlT2YoU2V0KSxcbiAgLy8gaWYgdGhlIGN1cnJlbnQgY2VsbCBkb2VzIG5vdCBzYXRpc2Z5IHRoZSBnYW1lIGNvbnN0cmFpbnRcbiAgY29uZmxpY3Q6IFByb3BUeXBlcy5ib29sLmlzUmVxdWlyZWQsXG59O1xuXG5DZWxsLmRlZmF1bHRQcm9wcyA9IHtcbiAgbm90ZXM6IG51bGwsXG4gIHZhbHVlOiBudWxsLFxufTtcblxuY29uc3QgQ2lyY2x1bGFyUHJvZ3Jlc3MgPSAoeyBwZXJjZW50IH0pID0+IChcbiAgPHN2ZyB2aWV3Qm94PVwiMCAwIDM2IDM2XCIgY2xhc3NOYW1lPVwiY2lyY3VsYXItcHJvZ3Jlc3NcIj5cbiAgICA8cGF0aFxuICAgICAgY2xhc3NOYW1lPVwiY2lyY2xlLWJnXCJcbiAgICAgIGQ9e0NpcmN1bGFyUGF0aER9XG4gICAgLz5cbiAgICA8cGF0aFxuICAgICAgY2xhc3NOYW1lPVwiY2lyY2xlXCJcbiAgICAgIHN0cm9rZURhc2hhcnJheT17YCR7cGVyY2VudCAqIDEwMH0sIDEwMGB9XG4gICAgICBkPXtDaXJjdWxhclBhdGhEfVxuICAgIC8+XG4gICAgeyAvKiBsYW5ndWFnZT1DU1MgKi8gfVxuICAgIDxzdHlsZSBqc3g+e0NpcmN1bHVhclByb2dyZXNzU3R5bGV9PC9zdHlsZT5cbiAgPC9zdmc+XG4pO1xuXG5DaXJjbHVsYXJQcm9ncmVzcy5wcm9wVHlwZXMgPSB7XG4gIHBlcmNlbnQ6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbn07XG5cbmZ1bmN0aW9uIGdldENsaWNrSGFuZGxlcihvbkNsaWNrLCBvbkRvdWJsZUNsaWNrLCBkZWxheSA9IDI1MCkge1xuICBsZXQgdGltZW91dElEID0gbnVsbDtcbiAgcmV0dXJuIChldmVudCkgPT4ge1xuICAgIGlmICghdGltZW91dElEKSB7XG4gICAgICB0aW1lb3V0SUQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgb25DbGljayhldmVudCk7XG4gICAgICAgIHRpbWVvdXRJRCA9IG51bGw7XG4gICAgICB9LCBkZWxheSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpbWVvdXRJRCA9IGNsZWFyVGltZW91dCh0aW1lb3V0SUQpO1xuICAgICAgb25Eb3VibGVDbGljayhldmVudCk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIG1ha2Ugc2l6ZSA5IGFycmF5IG9mIDBzXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIG1ha2VDb3VudE9iamVjdCgpIHtcbiAgY29uc3QgY291bnRPYmogPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSArPSAxKSBjb3VudE9iai5wdXNoKDApO1xuICByZXR1cm4gY291bnRPYmo7XG59XG5cbi8qKlxuICogZ2l2ZW4gYSAyRCBhcnJheSBvZiBudW1iZXJzIGFzIHRoZSBpbml0aWFsIHB1enpsZSwgZ2VuZXJhdGUgdGhlIGluaXRpYWwgZ2FtZSBzdGF0ZVxuICogQHBhcmFtIHB1enpsZVxuICogQHJldHVybnMge2FueX1cbiAqL1xuZnVuY3Rpb24gbWFrZUJvYXJkKHsgcHV6emxlIH0pIHtcbiAgLy8gY3JlYXRlIGluaXRpYWwgY291bnQgb2JqZWN0IHRvIGtlZXAgdHJhY2sgb2YgY29uZmxpY3RzIHBlciBudW1iZXIgdmFsdWVcbiAgY29uc3Qgcm93cyA9IEFycmF5LmZyb20oQXJyYXkoOSkua2V5cygpKS5tYXAoKCkgPT4gbWFrZUNvdW50T2JqZWN0KCkpO1xuICBjb25zdCBjb2x1bW5zID0gQXJyYXkuZnJvbShBcnJheSg5KS5rZXlzKCkpLm1hcCgoKSA9PiBtYWtlQ291bnRPYmplY3QoKSk7XG4gIGNvbnN0IHNxdWFyZXMgPSBBcnJheS5mcm9tKEFycmF5KDkpLmtleXMoKSkubWFwKCgpID0+IG1ha2VDb3VudE9iamVjdCgpKTtcbiAgY29uc3QgcmVzdWx0ID0gcHV6emxlLm1hcCgocm93LCBpKSA9PiAoXG4gICAgcm93Lm1hcCgoY2VsbCwgaikgPT4ge1xuICAgICAgaWYgKGNlbGwpIHtcbiAgICAgICAgcm93c1tpXVtjZWxsXSArPSAxO1xuICAgICAgICBjb2x1bW5zW2pdW2NlbGxdICs9IDE7XG4gICAgICAgIHNxdWFyZXNbKChNYXRoLmZsb29yKGkgLyAzKSkgKiAzKSArIE1hdGguZmxvb3IoaiAvIDMpXVtjZWxsXSArPSAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHB1enpsZVtpXVtqXSA+IDAgPyBwdXp6bGVbaV1bal0gOiBudWxsLFxuICAgICAgICBwcmVmaWxsZWQ6ICEhcHV6emxlW2ldW2pdLFxuICAgICAgfTtcbiAgICB9KVxuICApKTtcbiAgcmV0dXJuIGZyb21KUyh7IHB1enpsZTogcmVzdWx0LCBzZWxlY3RlZDogZmFsc2UsIGNob2ljZXM6IHsgcm93cywgY29sdW1ucywgc3F1YXJlcyB9IH0pO1xufVxuXG4vKipcbiAqIGdpdmUgdGhlIGNvb3JkaW5hdGUgdXBkYXRlIHRoZSBjdXJyZW50IGJvYXJkIHdpdGggYSBudW1iZXIgY2hvaWNlXG4gKiBAcGFyYW0geFxuICogQHBhcmFtIHlcbiAqIEBwYXJhbSBudW1iZXJcbiAqIEBwYXJhbSBmaWxsIHdoZXRoZXIgdG8gc2V0IG9yIHVuc2V0XG4gKiBAcGFyYW0gYm9hcmQgdGhlIGltbXV0YWJsZSBib2FyZCBnaXZlbiB0byBjaGFuZ2VcbiAqL1xuZnVuY3Rpb24gdXBkYXRlQm9hcmRXaXRoTnVtYmVyKHtcbiAgeCwgeSwgbnVtYmVyLCBmaWxsID0gdHJ1ZSwgYm9hcmQsXG59KSB7XG4gIGxldCBjZWxsID0gYm9hcmQuZ2V0KCdwdXp6bGUnKS5nZXRJbihbeCwgeV0pO1xuICAvLyBkZWxldGUgaXRzIG5vdGVzXG4gIGNlbGwgPSBjZWxsLmRlbGV0ZSgnbm90ZXMnKTtcbiAgLy8gc2V0IG9yIHVuc2V0IGl0cyB2YWx1ZSBkZXBlbmRpbmcgb24gYGZpbGxgXG4gIGNlbGwgPSBmaWxsID8gY2VsbC5zZXQoJ3ZhbHVlJywgbnVtYmVyKSA6IGNlbGwuZGVsZXRlKCd2YWx1ZScpO1xuICBjb25zdCBpbmNyZW1lbnQgPSBmaWxsID8gMSA6IC0xO1xuICAvLyB1cGRhdGUgdGhlIGN1cnJlbnQgZ3JvdXAgY2hvaWNlc1xuICBjb25zdCByb3dQYXRoID0gWydjaG9pY2VzJywgJ3Jvd3MnLCB4LCBudW1iZXJdO1xuICBjb25zdCBjb2x1bW5QYXRoID0gWydjaG9pY2VzJywgJ2NvbHVtbnMnLCB5LCBudW1iZXJdO1xuICBjb25zdCBzcXVhcmVQYXRoID0gWydjaG9pY2VzJywgJ3NxdWFyZXMnLFxuICAgICgoTWF0aC5mbG9vcih4IC8gMykpICogMykgKyBNYXRoLmZsb29yKHkgLyAzKSwgbnVtYmVyXTtcbiAgcmV0dXJuIGJvYXJkLnNldEluKHJvd1BhdGgsIGJvYXJkLmdldEluKHJvd1BhdGgpICsgaW5jcmVtZW50KVxuICAgIC5zZXRJbihjb2x1bW5QYXRoLCBib2FyZC5nZXRJbihjb2x1bW5QYXRoKSArIGluY3JlbWVudClcbiAgICAuc2V0SW4oc3F1YXJlUGF0aCwgYm9hcmQuZ2V0SW4oc3F1YXJlUGF0aCkgKyBpbmNyZW1lbnQpXG4gICAgLnNldEluKFsncHV6emxlJywgeCwgeV0sIGNlbGwpO1xufVxuXG5mdW5jdGlvbiBnZXROdW1iZXJPZkdyb3Vwc0Fzc2lnbmVkRm9yTnVtYmVyKG51bWJlciwgZ3JvdXBzKSB7XG4gIHJldHVybiBncm91cHMucmVkdWNlKChhY2N1bXVsYXRvciwgcm93KSA9PlxuICAgIGFjY3VtdWxhdG9yICsgKHJvdy5nZXQobnVtYmVyKSA+IDAgPyAxIDogMCksIDApO1xufVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L25vLW11bHRpLWNvbXBcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEluZGV4IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgc3RhdGUgPSB7fTtcblxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICBpZiAoJ3NlcnZpY2VXb3JrZXInIGluIG5hdmlnYXRvcikge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICAgICBuYXZpZ2F0b3Iuc2VydmljZVdvcmtlclxuICAgICAgICAucmVnaXN0ZXIoJy9zZXJ2aWNlLXdvcmtlci5qcycpXG4gICAgICAgIC50aGVuKChyZWcpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnU2VydmljZVdvcmtlciBzY29wZTogJywgcmVnLnNjb3BlKTtcbiAgICAgICAgICBjb25zb2xlLmxvZygnc2VydmljZSB3b3JrZXIgcmVnaXN0cmF0aW9uIHN1Y2Nlc3NmdWwnKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ3NlcnZpY2Ugd29ya2VyIHJlZ2lzdHJhdGlvbiBmYWlsZWQnLCBlcnIubWVzc2FnZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgXG4gICAgZmV0Y2goJy9hcGkvc29ja2V0aW8nKS5maW5hbGx5KCgpID0+IHtcbiAgICAgIGNvbnN0IHNvY2tldCA9IGlvKClcblxuICAgICAgc29ja2V0Lm9uKCdjb25uZWN0JywgKCkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZygnY29ubmVjdCcpXG4gICAgICAgIHNvY2tldC5lbWl0KCdoZWxsbycpXG4gICAgICB9KVxuXG4gICAgICBzb2NrZXQub24oJ2hlbGxvJywgZGF0YSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdoZWxsbycsIGRhdGEpXG4gICAgICB9KVxuXG4gICAgICBzb2NrZXQub24oJ2EgdXNlciBjb25uZWN0ZWQnLCAoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdhIHVzZXIgY29ubmVjdGVkJylcbiAgICAgIH0pXG5cbiAgICAgIHNvY2tldC5vbignZGlzY29ubmVjdCcsICgpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ2Rpc2Nvbm5lY3QnKVxuICAgICAgfSlcbiAgICB9KVxuICAgXG4gIH1cbiAgZ2V0U2VsZWN0ZWRDZWxsKCkge1xuICAgIGNvbnN0IHsgYm9hcmQgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3Qgc2VsZWN0ZWQgPSBib2FyZC5nZXQoJ3NlbGVjdGVkJyk7XG4gICAgcmV0dXJuIHNlbGVjdGVkICYmIGJvYXJkLmdldCgncHV6emxlJykuZ2V0SW4oW3NlbGVjdGVkLngsIHNlbGVjdGVkLnldKTtcbiAgfVxuXG4gIC8vIGdldCB0aGUgbWluIGJldHdlZW4gaXRzIGNvbXBsZXRpb24gaW4gcm93cywgY29sdW1ucyBhbmQgc3F1YXJlcy5cbiAgZ2V0TnVtYmVyVmFsdWVDb3VudChudW1iZXIpIHtcbiAgICBjb25zdCByb3dzID0gdGhpcy5zdGF0ZS5ib2FyZC5nZXRJbihbJ2Nob2ljZXMnLCAncm93cyddKTtcbiAgICBjb25zdCBjb2x1bW5zID0gdGhpcy5zdGF0ZS5ib2FyZC5nZXRJbihbJ2Nob2ljZXMnLCAnY29sdW1ucyddKTtcbiAgICBjb25zdCBzcXVhcmVzID0gdGhpcy5zdGF0ZS5ib2FyZC5nZXRJbihbJ2Nob2ljZXMnLCAnc3F1YXJlcyddKTtcbiAgICByZXR1cm4gTWF0aC5taW4oXG4gICAgICBnZXROdW1iZXJPZkdyb3Vwc0Fzc2lnbmVkRm9yTnVtYmVyKG51bWJlciwgc3F1YXJlcyksXG4gICAgICBNYXRoLm1pbihcbiAgICAgICAgZ2V0TnVtYmVyT2ZHcm91cHNBc3NpZ25lZEZvck51bWJlcihudW1iZXIsIHJvd3MpLFxuICAgICAgICBnZXROdW1iZXJPZkdyb3Vwc0Fzc2lnbmVkRm9yTnVtYmVyKG51bWJlciwgY29sdW1ucyksXG4gICAgICApLFxuICAgICk7XG4gIH1cblxuICBnZW5lcmF0ZUdhbWUgPSAoZmluYWxDb3VudCA9IDIwKSA9PiB7XG4gICAgLy8gZ2V0IGEgZmlsbGVkIHB1enpsZSBnZW5lcmF0ZWRcbiAgICBjb25zdCBzb2x1dGlvbiA9IG1ha2VQdXp6bGUoKTtcbiAgICAvLyBwbHVjayB2YWx1ZXMgZnJvbSBjZWxscyB0byBjcmVhdGUgdGhlIGdhbWVcbiAgICBjb25zdCB7IHB1enpsZSB9ID0gcGx1Y2soc29sdXRpb24sIGZpbmFsQ291bnQpO1xuICAgIC8vIGluaXRpYWxpemUgdGhlIGJvYXJkIHdpdGggY2hvaWNlIGNvdW50c1xuICAgIGNvbnN0IGJvYXJkID0gbWFrZUJvYXJkKHsgcHV6emxlIH0pO1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgYm9hcmQsIGhpc3Rvcnk6IExpc3Qub2YoYm9hcmQpLCBoaXN0b3J5T2ZmU2V0OiAwLCBzb2x1dGlvbixcbiAgICB9KTtcbiAgfVxuXG4gIGFkZE51bWJlckFzTm90ZSA9IChudW1iZXIpID0+IHtcbiAgICBsZXQgeyBib2FyZCB9ID0gdGhpcy5zdGF0ZTtcbiAgICBsZXQgc2VsZWN0ZWRDZWxsID0gdGhpcy5nZXRTZWxlY3RlZENlbGwoKTtcbiAgICBpZiAoIXNlbGVjdGVkQ2VsbCkgcmV0dXJuO1xuICAgIGNvbnN0IHByZWZpbGxlZCA9IHNlbGVjdGVkQ2VsbC5nZXQoJ3ByZWZpbGxlZCcpO1xuICAgIGlmIChwcmVmaWxsZWQpIHJldHVybjtcbiAgICBjb25zdCB7IHgsIHkgfSA9IGJvYXJkLmdldCgnc2VsZWN0ZWQnKTtcbiAgICBjb25zdCBjdXJyZW50VmFsdWUgPSBzZWxlY3RlZENlbGwuZ2V0KCd2YWx1ZScpO1xuICAgIGlmIChjdXJyZW50VmFsdWUpIHtcbiAgICAgIGJvYXJkID0gdXBkYXRlQm9hcmRXaXRoTnVtYmVyKHtcbiAgICAgICAgeCwgeSwgbnVtYmVyOiBjdXJyZW50VmFsdWUsIGZpbGw6IGZhbHNlLCBib2FyZDogdGhpcy5zdGF0ZS5ib2FyZCxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBsZXQgbm90ZXMgPSBzZWxlY3RlZENlbGwuZ2V0KCdub3RlcycpIHx8IFNldCgpO1xuICAgIGlmIChub3Rlcy5oYXMobnVtYmVyKSkge1xuICAgICAgbm90ZXMgPSBub3Rlcy5kZWxldGUobnVtYmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm90ZXMgPSBub3Rlcy5hZGQobnVtYmVyKTtcbiAgICB9XG4gICAgc2VsZWN0ZWRDZWxsID0gc2VsZWN0ZWRDZWxsLnNldCgnbm90ZXMnLCBub3Rlcyk7XG4gICAgc2VsZWN0ZWRDZWxsID0gc2VsZWN0ZWRDZWxsLmRlbGV0ZSgndmFsdWUnKTtcbiAgICBib2FyZCA9IGJvYXJkLnNldEluKFsncHV6emxlJywgeCwgeV0sIHNlbGVjdGVkQ2VsbCk7XG4gICAgdGhpcy51cGRhdGVCb2FyZChib2FyZCk7XG4gIH07XG5cbiAgdXBkYXRlQm9hcmQgPSAobmV3Qm9hcmQpID0+IHtcbiAgICBsZXQgeyBoaXN0b3J5IH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IHsgaGlzdG9yeU9mZlNldCB9ID0gdGhpcy5zdGF0ZTtcbiAgICAvLyBhbnl0aGluZyBiZWZvcmUgY3VycmVudCBzdGVwIGlzIHN0aWxsIGluIGhpc3RvcnlcbiAgICBoaXN0b3J5ID0gaGlzdG9yeS5zbGljZSgwLCBoaXN0b3J5T2ZmU2V0ICsgMSk7XG4gICAgLy8gYWRkIGl0c2VsZiBvbnRvIHRoZSBoaXN0b3J5XG4gICAgaGlzdG9yeSA9IGhpc3RvcnkucHVzaChuZXdCb2FyZCk7XG4gICAgLy8gdXBkYXRlIHRoZSBnYW1lXG4gICAgdGhpcy5zZXRTdGF0ZSh7IGJvYXJkOiBuZXdCb2FyZCwgaGlzdG9yeSwgaGlzdG9yeU9mZlNldDogaGlzdG9yeS5zaXplIC0gMSB9KTtcbiAgfTtcblxuICBjYW5VbmRvID0gKCkgPT4gdGhpcy5zdGF0ZS5oaXN0b3J5T2ZmU2V0ID4gMFxuXG4gIHJlZG8gPSAoKSA9PiB7XG4gICAgY29uc3QgeyBoaXN0b3J5IH0gPSB0aGlzLnN0YXRlO1xuICAgIGxldCB7IGhpc3RvcnlPZmZTZXQgfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKGhpc3Rvcnkuc2l6ZSkge1xuICAgICAgaGlzdG9yeU9mZlNldCA9IE1hdGgubWluKGhpc3Rvcnkuc2l6ZSAtIDEsIGhpc3RvcnlPZmZTZXQgKyAxKTtcbiAgICAgIGNvbnN0IGJvYXJkID0gaGlzdG9yeS5nZXQoaGlzdG9yeU9mZlNldCk7XG4gICAgICB0aGlzLnNldFN0YXRlKHsgYm9hcmQsIGhpc3RvcnlPZmZTZXQgfSk7XG4gICAgfVxuICB9O1xuXG4gIHVuZG8gPSAoKSA9PiB7XG4gICAgY29uc3QgeyBoaXN0b3J5IH0gPSB0aGlzLnN0YXRlO1xuICAgIGxldCB7IGhpc3RvcnlPZmZTZXQsIGJvYXJkIH0gPSB0aGlzLnN0YXRlO1xuICAgIGlmIChoaXN0b3J5LnNpemUpIHtcbiAgICAgIGhpc3RvcnlPZmZTZXQgPSBNYXRoLm1heCgwLCBoaXN0b3J5T2ZmU2V0IC0gMSk7XG4gICAgICBib2FyZCA9IGhpc3RvcnkuZ2V0KGhpc3RvcnlPZmZTZXQpO1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IGJvYXJkLCBoaXN0b3J5T2ZmU2V0LCBoaXN0b3J5IH0pO1xuICAgIH1cbiAgfTtcblxuICBlcmFzZVNlbGVjdGVkID0gKCkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGVkQ2VsbCA9IHRoaXMuZ2V0U2VsZWN0ZWRDZWxsKCk7XG4gICAgaWYgKCFzZWxlY3RlZENlbGwpIHJldHVybjtcbiAgICB0aGlzLmZpbGxOdW1iZXIoZmFsc2UpO1xuICB9XG5cbiAgZmlsbFNlbGVjdGVkV2l0aFNvbHV0aW9uID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgYm9hcmQsIHNvbHV0aW9uIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IHNlbGVjdGVkQ2VsbCA9IHRoaXMuZ2V0U2VsZWN0ZWRDZWxsKCk7XG4gICAgaWYgKCFzZWxlY3RlZENlbGwpIHJldHVybjtcbiAgICBjb25zdCB7IHgsIHkgfSA9IGJvYXJkLmdldCgnc2VsZWN0ZWQnKTtcbiAgICB0aGlzLmZpbGxOdW1iZXIoc29sdXRpb25beF1beV0pO1xuICB9XG5cblxuICAvLyBmaWxsIGN1cnJlbnRseSBzZWxlY3RlZCBjZWxsIHdpdGggbnVtYmVyXG4gIGZpbGxOdW1iZXIgPSAobnVtYmVyKSA9PiB7XG4gICAgbGV0IHsgYm9hcmQgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3Qgc2VsZWN0ZWRDZWxsID0gdGhpcy5nZXRTZWxlY3RlZENlbGwoKTtcbiAgICAvLyBuby1vcCBpZiBub3RoaW5nIGlzIHNlbGVjdGVkXG4gICAgaWYgKCFzZWxlY3RlZENlbGwpIHJldHVybjtcbiAgICBjb25zdCBwcmVmaWxsZWQgPSBzZWxlY3RlZENlbGwuZ2V0KCdwcmVmaWxsZWQnKTtcbiAgICAvLyBuby1vcCBpZiBpdCBpcyByZWZpbGxlZFxuICAgIGlmIChwcmVmaWxsZWQpIHJldHVybjtcbiAgICBjb25zdCB7IHgsIHkgfSA9IGJvYXJkLmdldCgnc2VsZWN0ZWQnKTtcbiAgICBjb25zdCBjdXJyZW50VmFsdWUgPSBzZWxlY3RlZENlbGwuZ2V0KCd2YWx1ZScpO1xuICAgIC8vIHJlbW92ZSB0aGUgY3VycmVudCB2YWx1ZSBhbmQgdXBkYXRlIHRoZSBnYW1lIHN0YXRlXG4gICAgaWYgKGN1cnJlbnRWYWx1ZSkge1xuICAgICAgYm9hcmQgPSB1cGRhdGVCb2FyZFdpdGhOdW1iZXIoe1xuICAgICAgICB4LCB5LCBudW1iZXI6IGN1cnJlbnRWYWx1ZSwgZmlsbDogZmFsc2UsIGJvYXJkOiB0aGlzLnN0YXRlLmJvYXJkLFxuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIHVwZGF0ZSB0byBuZXcgbnVtYmVyIGlmIGFueVxuICAgIGNvbnN0IHNldE51bWJlciA9IGN1cnJlbnRWYWx1ZSAhPT0gbnVtYmVyICYmIG51bWJlcjtcbiAgICBpZiAoc2V0TnVtYmVyKSB7XG4gICAgICBib2FyZCA9IHVwZGF0ZUJvYXJkV2l0aE51bWJlcih7XG4gICAgICAgIHgsIHksIG51bWJlciwgZmlsbDogdHJ1ZSwgYm9hcmQsXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVCb2FyZChib2FyZCk7XG4gIH07XG5cbiAgc2VsZWN0Q2VsbCA9ICh4LCB5KSA9PiB7XG4gICAgbGV0IHsgYm9hcmQgfSA9IHRoaXMuc3RhdGU7XG4gICAgYm9hcmQgPSBib2FyZC5zZXQoJ3NlbGVjdGVkJywgeyB4LCB5IH0pO1xuICAgIHRoaXMuc2V0U3RhdGUoeyBib2FyZCB9KTtcbiAgfTtcblxuICBpc0NvbmZsaWN0KGksIGopIHtcbiAgICBjb25zdCB7IHZhbHVlIH0gPSB0aGlzLnN0YXRlLmJvYXJkLmdldEluKFsncHV6emxlJywgaSwgal0pLnRvSlNPTigpO1xuICAgIGlmICghdmFsdWUpIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCByb3dDb25mbGljdCA9XG4gICAgICB0aGlzLnN0YXRlLmJvYXJkLmdldEluKFsnY2hvaWNlcycsICdyb3dzJywgaSwgdmFsdWVdKSA+IDE7XG4gICAgY29uc3QgY29sdW1uQ29uZmxpY3QgPVxuICAgICAgdGhpcy5zdGF0ZS5ib2FyZC5nZXRJbihbJ2Nob2ljZXMnLCAnY29sdW1ucycsIGosIHZhbHVlXSkgPiAxO1xuICAgIGNvbnN0IHNxdWFyZUNvbmZsaWN0ID1cbiAgICAgIHRoaXMuc3RhdGUuYm9hcmQuZ2V0SW4oWydjaG9pY2VzJywgJ3NxdWFyZXMnLFxuICAgICAgICAoKE1hdGguZmxvb3IoaSAvIDMpKSAqIDMpICsgTWF0aC5mbG9vcihqIC8gMyksIHZhbHVlXSkgPiAxO1xuICAgIHJldHVybiByb3dDb25mbGljdCB8fCBjb2x1bW5Db25mbGljdCB8fCBzcXVhcmVDb25mbGljdDtcbiAgfVxuXG4gIHJlbmRlckNlbGwoY2VsbCwgeCwgeSkge1xuICAgIGNvbnN0IHsgYm9hcmQgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3Qgc2VsZWN0ZWQgPSB0aGlzLmdldFNlbGVjdGVkQ2VsbCgpO1xuICAgIGNvbnN0IHsgdmFsdWUsIHByZWZpbGxlZCwgbm90ZXMgfSA9IGNlbGwudG9KU09OKCk7XG4gICAgY29uc3QgY29uZmxpY3QgPSB0aGlzLmlzQ29uZmxpY3QoeCwgeSk7XG4gICAgY29uc3QgcGVlciA9IGFyZUNvb3JkaW5hdGVQZWVycyh7IHgsIHkgfSwgYm9hcmQuZ2V0KCdzZWxlY3RlZCcpKTtcbiAgICBjb25zdCBzYW1lVmFsdWUgPSAhIShzZWxlY3RlZCAmJiBzZWxlY3RlZC5nZXQoJ3ZhbHVlJylcbiAgICAgICYmIHZhbHVlID09PSBzZWxlY3RlZC5nZXQoJ3ZhbHVlJykpO1xuXG4gICAgY29uc3QgaXNTZWxlY3RlZCA9IGNlbGwgPT09IHNlbGVjdGVkO1xuICAgIHJldHVybiAoPENlbGxcbiAgICAgIHByZWZpbGxlZD17cHJlZmlsbGVkfVxuICAgICAgbm90ZXM9e25vdGVzfVxuICAgICAgc2FtZVZhbHVlPXtzYW1lVmFsdWV9XG4gICAgICBpc1NlbGVjdGVkPXtpc1NlbGVjdGVkfVxuICAgICAgaXNQZWVyPXtwZWVyfVxuICAgICAgdmFsdWU9e3ZhbHVlfVxuICAgICAgb25DbGljaz17KCkgPT4geyB0aGlzLnNlbGVjdENlbGwoeCwgeSk7IH19XG4gICAgICBrZXk9e3l9XG4gICAgICB4PXt4fVxuICAgICAgeT17eX1cbiAgICAgIGNvbmZsaWN0PXtjb25mbGljdH1cbiAgICAvPik7XG4gIH1cblxuICByZW5kZXJOdW1iZXJDb250cm9sKCkge1xuICAgIGNvbnN0IHNlbGVjdGVkQ2VsbCA9IHRoaXMuZ2V0U2VsZWN0ZWRDZWxsKCk7XG4gICAgY29uc3QgcHJlZmlsbGVkID0gc2VsZWN0ZWRDZWxsICYmIHNlbGVjdGVkQ2VsbC5nZXQoJ3ByZWZpbGxlZCcpO1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRyb2xcIj5cbiAgICAgICAge3JhbmdlKDkpLm1hcCgoaSkgPT4ge1xuICAgICAgICAgIGNvbnN0IG51bWJlciA9IGkgKyAxO1xuICAgICAgICAgIC8vIGhhbmRsZXMgYmluZGluZyBzaW5nbGUgY2xpY2sgYW5kIGRvdWJsZSBjbGljayBjYWxsYmFja3NcbiAgICAgICAgICBjb25zdCBjbGlja0hhbmRsZSA9IGdldENsaWNrSGFuZGxlcihcbiAgICAgICAgICAgICgpID0+IHsgdGhpcy5maWxsTnVtYmVyKG51bWJlcik7IH0sXG4gICAgICAgICAgICAoKSA9PiB7IHRoaXMuYWRkTnVtYmVyQXNOb3RlKG51bWJlcik7IH0sXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPE51bWJlckNvbnRyb2xcbiAgICAgICAgICAgICAga2V5PXtudW1iZXJ9XG4gICAgICAgICAgICAgIG51bWJlcj17bnVtYmVyfVxuICAgICAgICAgICAgICBvbkNsaWNrPXshcHJlZmlsbGVkID8gY2xpY2tIYW5kbGUgOiB1bmRlZmluZWR9XG4gICAgICAgICAgICAgIGNvbXBsZXRpb25QZXJjZW50YWdlPXt0aGlzLmdldE51bWJlclZhbHVlQ291bnQobnVtYmVyKSAvIDl9XG4gICAgICAgICAgICAvPik7XG4gICAgICAgIH0pfVxuICAgICAgICA8c3R5bGUganN4PntDb250cm9sU3R5bGV9PC9zdHlsZT5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cblxuICByZW5kZXJBY3Rpb25zKCkge1xuICAgIGNvbnN0IHsgaGlzdG9yeSB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBzZWxlY3RlZENlbGwgPSB0aGlzLmdldFNlbGVjdGVkQ2VsbCgpO1xuICAgIGNvbnN0IHByZWZpbGxlZCA9IHNlbGVjdGVkQ2VsbCAmJiBzZWxlY3RlZENlbGwuZ2V0KCdwcmVmaWxsZWQnKTtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJhY3Rpb25zXCI+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWN0aW9uXCIgb25DbGljaz17aGlzdG9yeS5zaXplID8gdGhpcy51bmRvIDogbnVsbH0+XG4gICAgICAgICAgPFJlbG9hZEljb24gLz5VbmRvXG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImFjdGlvbiByZWRvXCIgb25DbGljaz17aGlzdG9yeS5zaXplID8gdGhpcy5yZWRvIDogbnVsbH0+XG4gICAgICAgICAgPFJlbG9hZEljb24gLz5SZWRvXG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImFjdGlvblwiIG9uQ2xpY2s9eyFwcmVmaWxsZWQgPyB0aGlzLmVyYXNlU2VsZWN0ZWQgOiBudWxsfT5cbiAgICAgICAgICA8UmVtb3ZlSWNvbiAvPkVyYXNlXG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2XG4gICAgICAgICAgY2xhc3NOYW1lPVwiYWN0aW9uXCJcbiAgICAgICAgICBvbkNsaWNrPXshcHJlZmlsbGVkID9cbiAgICAgICAgICB0aGlzLmZpbGxTZWxlY3RlZFdpdGhTb2x1dGlvbiA6IG51bGx9XG4gICAgICAgID5cbiAgICAgICAgICA8TG91cGVJY29uIC8+SGludFxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPHN0eWxlIGpzeD57QWN0aW9uc1N0eWxlfTwvc3R5bGU+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG5cbiAgcmVuZGVyUHV6emxlKCkge1xuICAgIGNvbnN0IHsgYm9hcmQgfSA9IHRoaXMuc3RhdGU7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwicHV6emxlXCI+XG4gICAgICAgIHtib2FyZC5nZXQoJ3B1enpsZScpLm1hcCgocm93LCBpKSA9PiAoXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L25vLWFycmF5LWluZGV4LWtleVxuICAgICAgICAgIDxkaXYga2V5PXtpfSBjbGFzc05hbWU9XCJyb3dcIj5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcm93Lm1hcCgoY2VsbCwgaikgPT4gdGhpcy5yZW5kZXJDZWxsKGNlbGwsIGksIGopKS50b0FycmF5KClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKSkudG9BcnJheSgpfVxuICAgICAgICA8c3R5bGUganN4PntQdXp6bGVTdHlsZX08L3N0eWxlPlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxuXG4gIHJlbmRlckNvbnRyb2xzKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRyb2xzXCI+XG4gICAgICAgIHt0aGlzLnJlbmRlck51bWJlckNvbnRyb2woKX1cbiAgICAgICAge3RoaXMucmVuZGVyQWN0aW9ucygpfVxuICAgICAgICB7IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG4gICAgICAgIDxzdHlsZSBqc3g+e2BcbiAgICAgICAgICAgIC5jb250cm9scyB7XG4gICAgICAgICAgICAgICAgbWFyZ2luLXRvcDogLjNlbTtcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICAgICAgICAgIGZsZXgtd3JhcDogd3JhcDtcbiAgICAgICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiAuNWVtIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIGB9XG4gICAgICAgIDwvc3R5bGU+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG5cbiAgcmVuZGVyR2VuZXJhdGlvblVJKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8R2VuZXJhdGlvblVJIGdlbmVyYXRlR2FtZT17dGhpcy5nZW5lcmF0ZUdhbWV9IC8+XG4gICAgKTtcbiAgfVxuXG4gIHJlbmRlckhlYWRlcigpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJoZWFkZXJcIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJuZXctZ2FtZVwiIG9uQ2xpY2s9eygpID0+IHRoaXMuc2V0U3RhdGUoeyBib2FyZDogZmFsc2UgfSl9PlxuICAgICAgICAgIDxSZXR1cm5JY29uIC8+XG4gICAgICAgICAgPGRpdj5OZXcgR2FtZTwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPFRpcCAvPlxuICAgICAgICB7IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG4gICAgICAgIDxzdHlsZSBqc3g+e2BcbiAgICAgICAgICAgIC5oZWFkZXIge1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgICAgICAgICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICAgICAgICAgICAgICAgIG1heC13aWR0aDogNTAwcHg7XG4gICAgICAgICAgICAgICAgcGFkZGluZzogMCAwLjVlbTtcbiAgICAgICAgICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLm5ldy1nYW1lIHtcbiAgICAgICAgICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICAgICAgICAgICAgbWFyZ2luLXRvcDogLjJlbTtcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiBpbmxpbmUtZmxleDtcbiAgICAgICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICAgICAgICAgIHBhZGRpbmc6IC4yZW0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC5uZXctZ2FtZSA6Z2xvYmFsKHN2Zykge1xuICAgICAgICAgICAgICAgIGhlaWdodDogMWVtO1xuICAgICAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IC4zZW07XG4gICAgICAgICAgICB9XG4gICAgICAgIGB9XG4gICAgICAgIDwvc3R5bGU+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgYm9hcmQgfSA9IHRoaXMuc3RhdGU7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYm9keVwiPlxuICAgICAgICA8TmV4dEhlYWQ+XG4gICAgICAgICAgPHRpdGxlPlN1ZG9rdSBFdm9sdmVkPC90aXRsZT5cbiAgICAgICAgICA8bWV0YSBuYW1lPVwidmlld3BvcnRcIiBjb250ZW50PVwiaW5pdGlhbC1zY2FsZT0xLjAsIHdpZHRoPWRldmljZS13aWR0aFwiIC8+XG4gICAgICAgICAgPG1ldGEgbmFtZT1cImRlc2NyaXB0aW9uXCIgY29udGVudD17RGVzY3JpcHRpb259IC8+XG4gICAgICAgICAgPGxpbmsgaHJlZj1cImh0dHBzOi8vZm9udHMuZ29vZ2xlYXBpcy5jb20vY3NzP2ZhbWlseT1TcGVjaWFsK0VsaXRlXCIgcmVsPVwic3R5bGVzaGVldFwiIC8+XG4gICAgICAgICAgPG1ldGEgcHJvcGVydHk9XCJvZzp1cmxcIiBjb250ZW50PVwiaHR0cHM6Ly9zdWRva3Uuc2l0aWFubGl1LmNvbS9cIiAvPlxuICAgICAgICAgIDxtZXRhIHByb3BlcnR5PVwib2c6dGl0bGVcIiBjb250ZW50PVwiU3Vkb2t1IEV2b2x2ZWRcIiAvPlxuICAgICAgICAgIDxtZXRhIHByb3BlcnR5PVwib2c6dHlwZVwiIGNvbnRlbnQ9XCJ3ZWJzaXRlXCIgLz5cbiAgICAgICAgICA8bWV0YSBwcm9wZXJ0eT1cIm9nOmRlc2NyaXB0aW9uXCIgY29udGVudD17RGVzY3JpcHRpb259IC8+XG4gICAgICAgICAgPG1ldGEgcHJvcGVydHk9XCJvZzppbWFnZVwiIGNvbnRlbnQ9XCJodHRwczovL3N1ZG9rdS5zaXRpYW5saXUuY29tL3N0YXRpYy9vZy1pbWFnZS5wbmdcIiAvPlxuICAgICAgICA8L05leHRIZWFkPlxuICAgICAgICB7IWJvYXJkICYmIHRoaXMucmVuZGVyR2VuZXJhdGlvblVJKCl9XG4gICAgICAgIHtib2FyZCAmJiB0aGlzLnJlbmRlckhlYWRlcigpfVxuICAgICAgICB7Ym9hcmQgJiYgdGhpcy5yZW5kZXJQdXp6bGUoKX1cbiAgICAgICAge2JvYXJkICYmIHRoaXMucmVuZGVyQ29udHJvbHMoKX1cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJyb290ZXJcIj5cbiAgICAgICAgICBNYWRlIHdpdGggPHNwYW4+4p2k77iPPC9zcGFuPu+4jyBCeSA8YSBocmVmPVwiaHR0cHM6Ly93d3cuc2l0aWFubGl1LmNvbS9cIj5TaXRpYW4gTGl1PC9hPiB8IDxhIGhyZWY9XCJodHRwczovL21lZGl1bS5jb20vQHNpdGlhbmxpdV81NzY4MC9idWlsZGluZy1hLXN1ZG9rdS1nYW1lLWluLXJlYWN0LWNhNjYzOTE1NzEyXCI+QmxvZyBQb3N0PC9hPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgeyAvKiBsYW5ndWFnZT1DU1MgKi8gfVxuICAgICAgICA8c3R5bGUganN4PntgXG4gICAgICAgICAgICA6Z2xvYmFsKGJvZHkpLCAuYm9keSB7XG4gICAgICAgICAgICAgICAgZm9udC1mYW1pbHk6ICdTcGVjaWFsIEVsaXRlJywgY3Vyc2l2ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC5ib2R5IHtcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICAgICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgICAgICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDEwMHZoO1xuICAgICAgICAgICAgICAgIHdpZHRoOiAxMDB2dztcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBAbWVkaWEgKG1pbi13aWR0aDogODAwcHgpIGFuZCAobWluLWhlaWdodDogOTMwcHgpe1xuICAgICAgICAgICAgICAgIDpnbG9iYWwoLmhlYWRlciwgLnB1enpsZSwgLmNvbnRyb2xzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvbnQtc2l6ZTogMS41ZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQG1lZGlhIChtYXgtd2lkdGg6IDgwMHB4KSBhbmQgKG1pbi13aWR0aDogNjAwcHgpe1xuICAgICAgICAgICAgICAgIDpnbG9iYWwoLmhlYWRlciwgLnB1enpsZSwgLmNvbnRyb2xzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvbnQtc2l6ZTogMS4yZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQG1lZGlhIChtYXgtaGVpZ2h0OiA5MzBweCkgYW5kIChtaW4taGVpZ2h0OiA4MDBweCkgYW5kIChtaW4td2lkdGg6IDYwMHB4KXtcbiAgICAgICAgICAgICAgICA6Z2xvYmFsKC5oZWFkZXIsIC5wdXp6bGUsIC5jb250cm9scykge1xuICAgICAgICAgICAgICAgICAgICBmb250LXNpemU6IDEuMmVtO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEBtZWRpYSAobWF4LWhlaWdodDogODAwcHgpIGFuZCAobWluLWhlaWdodDogNjAwcHgpIGFuZCAobWluLXdpZHRoOiAzNzBweCl7XG4gICAgICAgICAgICAgICAgOmdsb2JhbCguaGVhZGVyLCAucHV6emxlLCAuY29udHJvbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9udC1zaXplOiAxZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQG1lZGlhIChtYXgtd2lkdGg6IDM3MHB4KXtcbiAgICAgICAgICAgICAgICA6Z2xvYmFsKC5oZWFkZXIsIC5wdXp6bGUsIC5jb250cm9scykge1xuICAgICAgICAgICAgICAgICAgICBmb250LXNpemU6IC44ZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQG1lZGlhIChtYXgtaGVpZ2h0OiA2MDBweCl7XG4gICAgICAgICAgICAgICAgOmdsb2JhbCguaGVhZGVyLCAucHV6emxlLCAuY29udHJvbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9udC1zaXplOiAuOGVtO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDpnbG9iYWwoYm9keSkge1xuICAgICAgICAgICAgICAgIG1hcmdpbjogMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC5yb290ZXIge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICAgICAgICAgICAgICBib3R0b206IDA7XG4gICAgICAgICAgICAgICAgZm9udC1zaXplOiAuOGVtO1xuICAgICAgICAgICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICAgICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgYH1cbiAgICAgICAgPC9zdHlsZT5cbiAgICAgICAgPHN0eWxlIGpzeCBnbG9iYWw+e1JhbmdlU3R5bGV9PC9zdHlsZT5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cbn1cbiJdfQ== */\n/*@ sourceURL=pages/index.js */'
        })
      );
    }
  }, {
    key: '__reactstandin__regenerateByEval',
    value: function __reactstandin__regenerateByEval(key, code) {
      this[key] = eval(code);
    }
  }]);

  return GenerationUI;
}(__WEBPACK_IMPORTED_MODULE_1_react__["Component"]);

GenerationUI.propTypes = {
  generateGame: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.func.isRequired
};

var NumberControl = function NumberControl(_ref3) {
  var number = _ref3.number,
      onClick = _ref3.onClick,
      completionPercentage = _ref3.completionPercentage;
  return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
    'div',
    {
      key: number,

      onClick: onClick,
      className: 'jsx-' + NumberControlStyle.__scopedHash + ' ' + 'number',
      __source: {
        fileName: _jsxFileName,
        lineNumber: 285
      }
    },
    __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
      'div',
      {
        className: 'jsx-' + NumberControlStyle.__scopedHash,
        __source: {
          fileName: _jsxFileName,
          lineNumber: 290
        }
      },
      number
    ),
    __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(CirclularProgress, { percent: completionPercentage, __source: {
        fileName: _jsxFileName,
        lineNumber: 291
      }
    }),
    __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_0_styled_jsx_style___default.a, {
      styleId: NumberControlStyle.__scopedHash,
      css: NumberControlStyle.__scoped
    })
  );
};

NumberControl.propTypes = {
  number: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.number.isRequired,
  onClick: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.func,
  completionPercentage: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.number.isRequired
};

NumberControl.defaultProps = {
  onClick: null
};

var Cell = function Cell(props) {
  var value = props.value,
      onClick = props.onClick,
      isPeer = props.isPeer,
      isSelected = props.isSelected,
      sameValue = props.sameValue,
      prefilled = props.prefilled,
      notes = props.notes,
      conflict = props.conflict;

  var backgroundColor = getBackGroundColor({
    conflict: conflict, isPeer: isPeer, sameValue: sameValue, isSelected: isSelected
  });
  var fontColor = getFontColor({ conflict: conflict, prefilled: prefilled, value: value });
  return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
    'div',
    { onClick: onClick, className: 'jsx-' + CellStyle.__scopedHash + ' ' + __WEBPACK_IMPORTED_MODULE_0_styled_jsx_style___default.a.dynamic([['1302207814', [backgroundColor || 'initial', fontColor || 'initial']]]) + ' ' + 'cell',
      __source: {
        fileName: _jsxFileName,
        lineNumber: 315
      }
    },
    notes ? Object(__WEBPACK_IMPORTED_MODULE_12__sudoku__["d" /* range */])(9).map(function (i) {
      return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
        'div',
        { key: i, className: 'jsx-' + CellStyle.__scopedHash + ' ' + __WEBPACK_IMPORTED_MODULE_0_styled_jsx_style___default.a.dynamic([['1302207814', [backgroundColor || 'initial', fontColor || 'initial']]]) + ' ' + 'note-number',
          __source: {
            fileName: _jsxFileName,
            lineNumber: 320
          }
        },
        notes.has(i + 1) && i + 1
      );
    }) : value && value,
    __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_0_styled_jsx_style___default.a, {
      styleId: CellStyle.__scopedHash,
      css: CellStyle.__scoped
    }),
    __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_0_styled_jsx_style___default.a, {
      styleId: '1302207814',
      css: '.cell.__jsx-style-dynamic-selector{background-color:' + (backgroundColor || 'initial') + ';color:' + (fontColor || 'initial') + ';}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhZ2VzL2luZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQXVVa0IsQUFHbUUsOENBQ1gsbUNBQ3ZDIiwiZmlsZSI6InBhZ2VzL2luZGV4LmpzIiwic291cmNlUm9vdCI6Ii9Vc2Vycy9saWNoZW5tYS9Qcm9qZWN0cy9TdUR1b2t1L1N1RHVva3UiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBqc3gtYTExeS9hY2Nlc3NpYmxlLWVtb2ppICovXG5pbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50LCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBTZXQsIExpc3QsIGZyb21KUyB9IGZyb20gJ2ltbXV0YWJsZSc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IE5leHRIZWFkIGZyb20gJ25leHQvaGVhZCc7XG5pbXBvcnQgQ29sb3IgZnJvbSAnY29sb3InO1xuaW1wb3J0IElucHV0UmFuZ2UgZnJvbSAncmVhY3QtaW5wdXQtcmFuZ2UnO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLWV4dHJhbmVvdXMtZGVwZW5kZW5jaWVzXG5pbXBvcnQgY3NzIGZyb20gJ3N0eWxlZC1qc3gvY3NzJztcblxuaW1wb3J0IFJhbmdlU3R5bGUgZnJvbSAnLi4vaW5wdXQtcmFuZ2Utc3R5bGUnO1xuaW1wb3J0IExvdXBlSWNvbiBmcm9tICcuLi9zdmcvbG91cGUuc3ZnJztcbmltcG9ydCBSZW1vdmVJY29uIGZyb20gJy4uL3N2Zy9yZW1vdmUuc3ZnJztcbmltcG9ydCBSZWxvYWRJY29uIGZyb20gJy4uL3N2Zy9yZWxvYWQuc3ZnJztcbmltcG9ydCBSZXR1cm5JY29uIGZyb20gJy4uL3N2Zy9yZXR1cm4uc3ZnJztcblxuaW1wb3J0IHsgbWFrZVB1enpsZSwgcGx1Y2ssIGlzUGVlciBhcyBhcmVDb29yZGluYXRlUGVlcnMsIHJhbmdlIH0gZnJvbSAnLi4vc3Vkb2t1JztcbmltcG9ydCB7IGJhY2tHcm91bmRCbHVlIH0gZnJvbSAnLi4vY29sb3JzJztcbmltcG9ydCBUaXAgZnJvbSAnLi4vY29tcG9uZW50cy90b29sLXRpcCc7XG5cbmltcG9ydCBpbyBmcm9tICdzb2NrZXQuaW8tY2xpZW50J1xuXG5jb25zdCBEZXNjcmlwdGlvbiA9ICdEaXNjb3ZlciB0aGUgbmV4dCBldm9sdXRpb24gb2YgU3Vkb2t1IHdpdGggYW1hemluZyBncmFwaGljcywgYW5pbWF0aW9ucywgYW5kIHVzZXItZnJpZW5kbHkgZmVhdHVyZXMuIEVuam95IGEgU3Vkb2t1IGV4cGVyaWVuY2UgbGlrZSB5b3UgbmV2ZXIgaGF2ZSBiZWZvcmUgd2l0aCBjdXN0b21pemFibGUgZ2FtZSBnZW5lcmF0aW9uLCBjZWxsIGhpZ2hsaWdodGluZywgaW50dWl0aXZlIGNvbnRyb2xzIGFuZCBtb3JlISc7XG5jb25zdCBjZWxsV2lkdGggPSAyLjU7XG5cbmNvbnN0IExpZ2h0Qmx1ZTEwMCA9ICcjQjNFNUZDJztcbmNvbnN0IExpZ2h0Qmx1ZTIwMCA9ICcjODFENEZBJztcbmNvbnN0IExpZ2h0Qmx1ZTMwMCA9ICcjNEZDM0Y3JztcbmNvbnN0IEluZGlnbzcwMCA9ICcjMzAzRjlGJztcbmNvbnN0IERlZXBPcmFuZ2UyMDAgPSAnI0ZGQUI5MSc7XG5jb25zdCBEZWVwT3JhbmdlNjAwID0gJyNGNDUxMUUnO1xuY29uc3QgQ29udHJvbE51bWJlckNvbG9yID0gSW5kaWdvNzAwO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbG9uZS1ibG9ja3NcbnsgLyogbGFuZ3VhZ2U9Q1NTICovIH1cbmNvbnN0IENlbGxTdHlsZSA9IGNzc2Bcbi5jZWxsIHtcbiAgICBoZWlnaHQ6ICR7Y2VsbFdpZHRofWVtO1xuICAgIHdpZHRoOiAke2NlbGxXaWR0aH1lbTtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtd3JhcDogd3JhcDtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgIGZvbnQtc2l6ZTogMS4xZW07XG4gICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgdHJhbnNpdGlvbjogYmFja2dyb3VuZC1jb2xvciAuM3MgZWFzZS1pbi1vdXQ7XG59XG4uY2VsbDpudGgtY2hpbGQoM24rMyk6bm90KDpsYXN0LWNoaWxkKSB7XG4gICAgYm9yZGVyLXJpZ2h0OiAycHggc29saWQgYmxhY2s7XG59XG4uY2VsbDpub3QoOmxhc3QtY2hpbGQpIHtcbiAgICBib3JkZXItcmlnaHQ6IDFweCBzb2xpZCBibGFjaztcbn1cbi5ub3RlLW51bWJlciB7XG4gICAgZm9udC1zaXplOiAuNmVtO1xuICAgIHdpZHRoOiAzMyU7XG4gICAgaGVpZ2h0OiAzMyU7XG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG59XG5gO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbG9uZS1ibG9ja3NcbnsgLyogbGFuZ3VhZ2U9Q1NTICovIH1cbmNvbnN0IEFjdGlvbnNTdHlsZSA9IGNzc2Bcbi5hY3Rpb25zIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIG1heC13aWR0aDogNDAwcHg7XG4gICAgbWFyZ2luLXRvcDogLjVlbTtcbiAgICBwYWRkaW5nOiAwIC42ZW07XG59XG4uYWN0aW9uIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbn1cbi5hY3Rpb24gOmdsb2JhbChzdmcpIHtcbiAgICB3aWR0aDogMi41ZW07XG4gICAgbWFyZ2luLWJvdHRvbTogLjJlbTtcbn1cbi5yZWRvIDpnbG9iYWwoc3ZnKSB7XG4gICAgdHJhbnNmb3JtOiBzY2FsZVgoLTEpO1xufVxuYDtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxvbmUtYmxvY2tzXG57IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG5jb25zdCBDb250cm9sU3R5bGUgPSBjc3NgXG4uY29udHJvbCB7XG4gICAgcGFkZGluZzogMCAyZW07XG4gICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIGRpc3BsYXk6IGlubGluZS1mbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgZmxleC13cmFwOiB3cmFwO1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgIGZvbnQtZmFtaWx5OiAnU3BlY2lhbCBFbGl0ZScsIGN1cnNpdmU7XG4gICAgdHJhbnNpdGlvbjogZmlsdGVyIC41cyBlYXNlLWluLW91dDtcbiAgICB3aWR0aDogMTAwJTtcbn1cbmA7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sb25lLWJsb2Nrc1xueyAvKiBsYW5ndWFnZT1DU1MgKi8gfVxuY29uc3QgTnVtYmVyQ29udHJvbFN0eWxlID0gY3NzYFxuLm51bWJlciB7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBmb250LXNpemU6IDJlbTtcbiAgICBtYXJnaW46IC4xZW07XG4gICAgd2lkdGg6IDEuNWVtO1xuICAgIGhlaWdodDogMS41ZW07XG4gICAgY29sb3I6ICR7Q29udHJvbE51bWJlckNvbG9yfTtcbiAgICBib3gtc2hhZG93OiAwIDFweCAycHggcmdiYSgwLDAsMCwwLjE2KSwgMCAxcHggMnB4IHJnYmEoMCwwLDAsMC4yMyk7XG4gICAgYm9yZGVyLXJhZGl1czogNTAlO1xufVxuLm51bWJlciA+IGRpdiB7XG4gICAgbWFyZ2luLXRvcDogLjNlbTtcbn1cbmA7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sb25lLWJsb2Nrc1xueyAvKiBsYW5ndWFnZT1DU1MgKi8gfVxuY29uc3QgUHV6emxlU3R5bGUgPSBjc3NgXG4ucHV6emxlIHtcbiAgICBtYXJnaW4tdG9wOiAuNWVtO1xuICAgIHdpZHRoOiAke2NlbGxXaWR0aCAqIDl9ZW07XG4gICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIGJveC1zaGFkb3c6IDAgM3B4IDZweCByZ2JhKDAsMCwwLDAuMTYpLCAwIDNweCA2cHggcmdiYSgwLDAsMCwwLjIzKTtcbn1cbi5yb3cge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBmbGV4OiAwO1xuICAgIHdpZHRoOiAke2NlbGxXaWR0aCAqIDl9ZW07XG59XG4ucm93Om5vdCg6bGFzdC1jaGlsZCkge1xuICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCBibGFjaztcbn1cbi5yb3c6bnRoLWNoaWxkKDNuKzMpOm5vdCg6bGFzdC1jaGlsZCkge1xuICAgIGJvcmRlci1ib3R0b206IDJweCBzb2xpZCBibGFjayAhaW1wb3J0YW50O1xufVxuYDtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxvbmUtYmxvY2tzXG57IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG5jb25zdCBDaXJjdWx1YXJQcm9ncmVzc1N0eWxlID0gY3NzYFxuLmNpcmN1bGFyLXByb2dyZXNzIHtcbiAgICBkaXNwbGF5OiBibG9jaztcbiAgICB3aWR0aDogMTAwJTtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgdG9wOiAwO1xuICAgIGxlZnQ6IDA7XG4gICAgdHJhbnNpdGlvbjogZmlsdGVyIC40cyBlYXNlLWluLW91dDtcbn1cblxuLmNpcmNsZS1iZyB7XG4gICAgZmlsbDogbm9uZTtcbiAgICBzdHJva2U6ICNlZWU7XG4gICAgc3Ryb2tlLXdpZHRoOiAzLjg7XG59XG5cbi5jaXJjbGUge1xuICAgIHN0cm9rZTogJHtDb250cm9sTnVtYmVyQ29sb3J9O1xuICAgIHRyYW5zaXRpb246IHN0cm9rZS1kYXNoYXJyYXkgLjRzIGVhc2UtaW4tb3V0O1xuICAgIGZpbGw6IG5vbmU7XG4gICAgc3Ryb2tlLXdpZHRoOiAyLjg7XG4gICAgc3Ryb2tlLWxpbmVjYXA6IHJvdW5kO1xufVxuYDtcblxuY29uc3QgQ2lyY3VsYXJQYXRoRCA9ICdNMTggMi4wODQ1IGEgMTUuOTE1NSAxNS45MTU1IDAgMCAxIDAgMzEuODMxIGEgMTUuOTE1NSAxNS45MTU1IDAgMCAxIDAgLTMxLjgzMSc7XG5cbmZ1bmN0aW9uIGdldEJhY2tHcm91bmRDb2xvcih7XG4gIGNvbmZsaWN0LCBpc1BlZXIsIHNhbWVWYWx1ZSwgaXNTZWxlY3RlZCxcbn0pIHtcbiAgaWYgKGNvbmZsaWN0ICYmIGlzUGVlciAmJiBzYW1lVmFsdWUpIHtcbiAgICByZXR1cm4gRGVlcE9yYW5nZTIwMDtcbiAgfSBlbHNlIGlmIChzYW1lVmFsdWUpIHtcbiAgICByZXR1cm4gTGlnaHRCbHVlMzAwO1xuICB9IGVsc2UgaWYgKGlzU2VsZWN0ZWQpIHtcbiAgICByZXR1cm4gTGlnaHRCbHVlMjAwO1xuICB9IGVsc2UgaWYgKGlzUGVlcikge1xuICAgIHJldHVybiBMaWdodEJsdWUxMDA7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRGb250Q29sb3IoeyB2YWx1ZSwgY29uZmxpY3QsIHByZWZpbGxlZCB9KSB7XG4gIGlmIChjb25mbGljdCAmJiAhcHJlZmlsbGVkKSB7XG4gICAgcmV0dXJuIERlZXBPcmFuZ2U2MDA7XG4gIH0gZWxzZSBpZiAoIXByZWZpbGxlZCAmJiB2YWx1ZSkge1xuICAgIHJldHVybiBDb250cm9sTnVtYmVyQ29sb3I7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5jbGFzcyBHZW5lcmF0aW9uVUkgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcblxuICAgIHRoaXMuc3RhdGUgPSB7IHZhbHVlOiAzMCB9O1xuICB9XG5cbiAgZ2VuZXJhdGVHYW1lID0gKCkgPT4ge1xuICAgIHRoaXMucHJvcHMuZ2VuZXJhdGVHYW1lKHRoaXMuc3RhdGUudmFsdWUpO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImdlbmVyYXRpb25cIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb3B5XCI+U3RhcnQgd2l0aCB7dGhpcy5zdGF0ZS52YWx1ZX0gY2VsbHMgcHJlZmlsbGVkPC9kaXY+XG4gICAgICAgIDxJbnB1dFJhbmdlXG4gICAgICAgICAgbWF4VmFsdWU9ezgxfVxuICAgICAgICAgIG1pblZhbHVlPXsxN31cbiAgICAgICAgICB2YWx1ZT17dGhpcy5zdGF0ZS52YWx1ZX1cbiAgICAgICAgICBvbkNoYW5nZT17dmFsdWUgPT4gdGhpcy5zZXRTdGF0ZSh7IHZhbHVlIH0pfVxuICAgICAgICAvPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImJ1dHRvblwiIG9uQ2xpY2s9e3RoaXMuZ2VuZXJhdGVHYW1lfT5QbGF5IFN1ZG9rdTwvZGl2PlxuICAgICAgICB7IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG4gICAgICAgIDxzdHlsZSBqc3g+e2BcbiAgICAgICAgICAgIC5jb3B5IHtcbiAgICAgICAgICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgICAgICAgICAgICAgZm9udC1zaXplOiAxLjNlbTtcbiAgICAgICAgICAgICAgICBtYXJnaW4tYm90dG9tOiAuNWVtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLmdlbmVyYXRpb24ge1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgICAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgICAgICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOmdsb2JhbCguaW5wdXQtcmFuZ2UpIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogODAlO1xuICAgICAgICAgICAgICAgIG1heC13aWR0aDogNTAwcHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAuYnV0dG9uIHtcbiAgICAgICAgICAgICAgbWFyZ2luLXRvcDogLjVlbTtcbiAgICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogLjI1ZW07XG4gICAgICAgICAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICAgICAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICAgICAgICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcbiAgICAgICAgICAgICAgY29sb3I6ICNmZmY7XG4gICAgICAgICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgICAgICAgICAgICB0cmFuc2l0aW9uOiBhbGwgLjI1cztcbiAgICAgICAgICAgICAgcGFkZGluZzogNXB4IDEwcHg7XG4gICAgICAgICAgICAgIGZvbnQtc2l6ZTogMS40ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAuYnV0dG9uOmFjdGl2ZSB7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKDBweCwgNXB4KTtcbiAgICAgICAgICAgICAgYm94LXNoYWRvdzogMCAxcHggMCAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAuYnV0dG9uIHtcbiAgICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogJHtiYWNrR3JvdW5kQmx1ZX07XG4gICAgICAgICAgICAgIGJveC1zaGFkb3c6IDAgMnB4IDRweCAwICR7Q29sb3IoYmFja0dyb3VuZEJsdWUpLmRhcmtlbigwLjUpLmhzbCgpLnN0cmluZygpfTtcbiAgICAgICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLmJ1dHRvbjpob3ZlciB7XG4gICAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6ICR7Q29sb3IoYmFja0dyb3VuZEJsdWUpLmxpZ2h0ZW4oMC4yKS5oc2woKS5zdHJpbmcoKX07XG4gICAgICAgICAgICB9XG4gICAgICAgIGB9XG4gICAgICAgIDwvc3R5bGU+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG59XG5cbkdlbmVyYXRpb25VSS5wcm9wVHlwZXMgPSB7XG4gIGdlbmVyYXRlR2FtZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbn07XG5cbmNvbnN0IE51bWJlckNvbnRyb2wgPSAoeyBudW1iZXIsIG9uQ2xpY2ssIGNvbXBsZXRpb25QZXJjZW50YWdlIH0pID0+IChcbiAgPGRpdlxuICAgIGtleT17bnVtYmVyfVxuICAgIGNsYXNzTmFtZT1cIm51bWJlclwiXG4gICAgb25DbGljaz17b25DbGlja31cbiAgPlxuICAgIDxkaXY+e251bWJlcn08L2Rpdj5cbiAgICA8Q2lyY2x1bGFyUHJvZ3Jlc3MgcGVyY2VudD17Y29tcGxldGlvblBlcmNlbnRhZ2V9IC8+XG4gICAgPHN0eWxlIGpzeD57TnVtYmVyQ29udHJvbFN0eWxlfTwvc3R5bGU+XG4gIDwvZGl2PlxuKTtcblxuTnVtYmVyQ29udHJvbC5wcm9wVHlwZXMgPSB7XG4gIG51bWJlcjogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICBvbkNsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgY29tcGxldGlvblBlcmNlbnRhZ2U6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbn07XG5cbk51bWJlckNvbnRyb2wuZGVmYXVsdFByb3BzID0ge1xuICBvbkNsaWNrOiBudWxsLFxufTtcblxuY29uc3QgQ2VsbCA9IChwcm9wcykgPT4ge1xuICBjb25zdCB7XG4gICAgdmFsdWUsIG9uQ2xpY2ssIGlzUGVlciwgaXNTZWxlY3RlZCwgc2FtZVZhbHVlLCBwcmVmaWxsZWQsIG5vdGVzLCBjb25mbGljdCxcbiAgfSA9IHByb3BzO1xuICBjb25zdCBiYWNrZ3JvdW5kQ29sb3IgPSBnZXRCYWNrR3JvdW5kQ29sb3Ioe1xuICAgIGNvbmZsaWN0LCBpc1BlZXIsIHNhbWVWYWx1ZSwgaXNTZWxlY3RlZCxcbiAgfSk7XG4gIGNvbnN0IGZvbnRDb2xvciA9IGdldEZvbnRDb2xvcih7IGNvbmZsaWN0LCBwcmVmaWxsZWQsIHZhbHVlIH0pO1xuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwiY2VsbFwiIG9uQ2xpY2s9e29uQ2xpY2t9PlxuICAgICAge1xuICAgICAgICBub3RlcyA/XG4gICAgICAgICAgcmFuZ2UoOSkubWFwKGkgPT5cbiAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgPGRpdiBrZXk9e2l9IGNsYXNzTmFtZT1cIm5vdGUtbnVtYmVyXCI+XG4gICAgICAgICAgICAgICAge25vdGVzLmhhcyhpICsgMSkgJiYgKGkgKyAxKX1cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICApKSA6XG4gICAgICAgICAgdmFsdWUgJiYgdmFsdWVcbiAgICAgIH1cbiAgICAgIHsvKiBsYW5ndWFnZT1DU1MgKi99XG4gICAgICA8c3R5bGUganN4PntDZWxsU3R5bGV9PC9zdHlsZT5cbiAgICAgIDxzdHlsZSBqc3g+e2BcbiAgICAgICAgICAgICAgICAuY2VsbCB7XG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6ICR7YmFja2dyb3VuZENvbG9yIHx8ICdpbml0aWFsJ307XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiAke2ZvbnRDb2xvciB8fCAnaW5pdGlhbCd9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGB9XG4gICAgICA8L3N0eWxlPlxuICAgIDwvZGl2PlxuICApO1xufTtcblxuQ2VsbC5wcm9wVHlwZXMgPSB7XG4gIC8vIGN1cnJlbnQgbnVtYmVyIHZhbHVlXG4gIHZhbHVlOiBQcm9wVHlwZXMubnVtYmVyLFxuICAvLyBjZWxsIGNsaWNrIGhhbmRsZXJcbiAgb25DbGljazogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgLy8gaWYgdGhlIGNlbGwgaXMgYSBwZWVyIG9mIHRoZSBzZWxlY3RlZCBjZWxsXG4gIGlzUGVlcjogUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZCxcbiAgLy8gaWYgdGhlIGNlbGwgaXMgc2VsZWN0ZWQgYnkgdGhlIHVzZXJcbiAgaXNTZWxlY3RlZDogUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZCxcbiAgLy8gY3VycmVudCBjZWxsIGhhcyB0aGUgc2FtZSB2YWx1ZSBpZiB0aGUgdXNlciBzZWxlY3RlZCBjZWxsXG4gIHNhbWVWYWx1ZTogUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZCxcbiAgLy8gaWYgdGhpcyB3YXMgcHJlZmlsbGVkIGFzIGEgcGFydCBvZiB0aGUgcHV6emxlXG4gIHByZWZpbGxlZDogUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZCxcbiAgLy8gY3VycmVudCBub3RlcyB0YWtlbiBvbiB0aGUgY2VsbFxuICBub3RlczogUHJvcFR5cGVzLmluc3RhbmNlT2YoU2V0KSxcbiAgLy8gaWYgdGhlIGN1cnJlbnQgY2VsbCBkb2VzIG5vdCBzYXRpc2Z5IHRoZSBnYW1lIGNvbnN0cmFpbnRcbiAgY29uZmxpY3Q6IFByb3BUeXBlcy5ib29sLmlzUmVxdWlyZWQsXG59O1xuXG5DZWxsLmRlZmF1bHRQcm9wcyA9IHtcbiAgbm90ZXM6IG51bGwsXG4gIHZhbHVlOiBudWxsLFxufTtcblxuY29uc3QgQ2lyY2x1bGFyUHJvZ3Jlc3MgPSAoeyBwZXJjZW50IH0pID0+IChcbiAgPHN2ZyB2aWV3Qm94PVwiMCAwIDM2IDM2XCIgY2xhc3NOYW1lPVwiY2lyY3VsYXItcHJvZ3Jlc3NcIj5cbiAgICA8cGF0aFxuICAgICAgY2xhc3NOYW1lPVwiY2lyY2xlLWJnXCJcbiAgICAgIGQ9e0NpcmN1bGFyUGF0aER9XG4gICAgLz5cbiAgICA8cGF0aFxuICAgICAgY2xhc3NOYW1lPVwiY2lyY2xlXCJcbiAgICAgIHN0cm9rZURhc2hhcnJheT17YCR7cGVyY2VudCAqIDEwMH0sIDEwMGB9XG4gICAgICBkPXtDaXJjdWxhclBhdGhEfVxuICAgIC8+XG4gICAgeyAvKiBsYW5ndWFnZT1DU1MgKi8gfVxuICAgIDxzdHlsZSBqc3g+e0NpcmN1bHVhclByb2dyZXNzU3R5bGV9PC9zdHlsZT5cbiAgPC9zdmc+XG4pO1xuXG5DaXJjbHVsYXJQcm9ncmVzcy5wcm9wVHlwZXMgPSB7XG4gIHBlcmNlbnQ6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbn07XG5cbmZ1bmN0aW9uIGdldENsaWNrSGFuZGxlcihvbkNsaWNrLCBvbkRvdWJsZUNsaWNrLCBkZWxheSA9IDI1MCkge1xuICBsZXQgdGltZW91dElEID0gbnVsbDtcbiAgcmV0dXJuIChldmVudCkgPT4ge1xuICAgIGlmICghdGltZW91dElEKSB7XG4gICAgICB0aW1lb3V0SUQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgb25DbGljayhldmVudCk7XG4gICAgICAgIHRpbWVvdXRJRCA9IG51bGw7XG4gICAgICB9LCBkZWxheSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpbWVvdXRJRCA9IGNsZWFyVGltZW91dCh0aW1lb3V0SUQpO1xuICAgICAgb25Eb3VibGVDbGljayhldmVudCk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIG1ha2Ugc2l6ZSA5IGFycmF5IG9mIDBzXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIG1ha2VDb3VudE9iamVjdCgpIHtcbiAgY29uc3QgY291bnRPYmogPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSArPSAxKSBjb3VudE9iai5wdXNoKDApO1xuICByZXR1cm4gY291bnRPYmo7XG59XG5cbi8qKlxuICogZ2l2ZW4gYSAyRCBhcnJheSBvZiBudW1iZXJzIGFzIHRoZSBpbml0aWFsIHB1enpsZSwgZ2VuZXJhdGUgdGhlIGluaXRpYWwgZ2FtZSBzdGF0ZVxuICogQHBhcmFtIHB1enpsZVxuICogQHJldHVybnMge2FueX1cbiAqL1xuZnVuY3Rpb24gbWFrZUJvYXJkKHsgcHV6emxlIH0pIHtcbiAgLy8gY3JlYXRlIGluaXRpYWwgY291bnQgb2JqZWN0IHRvIGtlZXAgdHJhY2sgb2YgY29uZmxpY3RzIHBlciBudW1iZXIgdmFsdWVcbiAgY29uc3Qgcm93cyA9IEFycmF5LmZyb20oQXJyYXkoOSkua2V5cygpKS5tYXAoKCkgPT4gbWFrZUNvdW50T2JqZWN0KCkpO1xuICBjb25zdCBjb2x1bW5zID0gQXJyYXkuZnJvbShBcnJheSg5KS5rZXlzKCkpLm1hcCgoKSA9PiBtYWtlQ291bnRPYmplY3QoKSk7XG4gIGNvbnN0IHNxdWFyZXMgPSBBcnJheS5mcm9tKEFycmF5KDkpLmtleXMoKSkubWFwKCgpID0+IG1ha2VDb3VudE9iamVjdCgpKTtcbiAgY29uc3QgcmVzdWx0ID0gcHV6emxlLm1hcCgocm93LCBpKSA9PiAoXG4gICAgcm93Lm1hcCgoY2VsbCwgaikgPT4ge1xuICAgICAgaWYgKGNlbGwpIHtcbiAgICAgICAgcm93c1tpXVtjZWxsXSArPSAxO1xuICAgICAgICBjb2x1bW5zW2pdW2NlbGxdICs9IDE7XG4gICAgICAgIHNxdWFyZXNbKChNYXRoLmZsb29yKGkgLyAzKSkgKiAzKSArIE1hdGguZmxvb3IoaiAvIDMpXVtjZWxsXSArPSAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHB1enpsZVtpXVtqXSA+IDAgPyBwdXp6bGVbaV1bal0gOiBudWxsLFxuICAgICAgICBwcmVmaWxsZWQ6ICEhcHV6emxlW2ldW2pdLFxuICAgICAgfTtcbiAgICB9KVxuICApKTtcbiAgcmV0dXJuIGZyb21KUyh7IHB1enpsZTogcmVzdWx0LCBzZWxlY3RlZDogZmFsc2UsIGNob2ljZXM6IHsgcm93cywgY29sdW1ucywgc3F1YXJlcyB9IH0pO1xufVxuXG4vKipcbiAqIGdpdmUgdGhlIGNvb3JkaW5hdGUgdXBkYXRlIHRoZSBjdXJyZW50IGJvYXJkIHdpdGggYSBudW1iZXIgY2hvaWNlXG4gKiBAcGFyYW0geFxuICogQHBhcmFtIHlcbiAqIEBwYXJhbSBudW1iZXJcbiAqIEBwYXJhbSBmaWxsIHdoZXRoZXIgdG8gc2V0IG9yIHVuc2V0XG4gKiBAcGFyYW0gYm9hcmQgdGhlIGltbXV0YWJsZSBib2FyZCBnaXZlbiB0byBjaGFuZ2VcbiAqL1xuZnVuY3Rpb24gdXBkYXRlQm9hcmRXaXRoTnVtYmVyKHtcbiAgeCwgeSwgbnVtYmVyLCBmaWxsID0gdHJ1ZSwgYm9hcmQsXG59KSB7XG4gIGxldCBjZWxsID0gYm9hcmQuZ2V0KCdwdXp6bGUnKS5nZXRJbihbeCwgeV0pO1xuICAvLyBkZWxldGUgaXRzIG5vdGVzXG4gIGNlbGwgPSBjZWxsLmRlbGV0ZSgnbm90ZXMnKTtcbiAgLy8gc2V0IG9yIHVuc2V0IGl0cyB2YWx1ZSBkZXBlbmRpbmcgb24gYGZpbGxgXG4gIGNlbGwgPSBmaWxsID8gY2VsbC5zZXQoJ3ZhbHVlJywgbnVtYmVyKSA6IGNlbGwuZGVsZXRlKCd2YWx1ZScpO1xuICBjb25zdCBpbmNyZW1lbnQgPSBmaWxsID8gMSA6IC0xO1xuICAvLyB1cGRhdGUgdGhlIGN1cnJlbnQgZ3JvdXAgY2hvaWNlc1xuICBjb25zdCByb3dQYXRoID0gWydjaG9pY2VzJywgJ3Jvd3MnLCB4LCBudW1iZXJdO1xuICBjb25zdCBjb2x1bW5QYXRoID0gWydjaG9pY2VzJywgJ2NvbHVtbnMnLCB5LCBudW1iZXJdO1xuICBjb25zdCBzcXVhcmVQYXRoID0gWydjaG9pY2VzJywgJ3NxdWFyZXMnLFxuICAgICgoTWF0aC5mbG9vcih4IC8gMykpICogMykgKyBNYXRoLmZsb29yKHkgLyAzKSwgbnVtYmVyXTtcbiAgcmV0dXJuIGJvYXJkLnNldEluKHJvd1BhdGgsIGJvYXJkLmdldEluKHJvd1BhdGgpICsgaW5jcmVtZW50KVxuICAgIC5zZXRJbihjb2x1bW5QYXRoLCBib2FyZC5nZXRJbihjb2x1bW5QYXRoKSArIGluY3JlbWVudClcbiAgICAuc2V0SW4oc3F1YXJlUGF0aCwgYm9hcmQuZ2V0SW4oc3F1YXJlUGF0aCkgKyBpbmNyZW1lbnQpXG4gICAgLnNldEluKFsncHV6emxlJywgeCwgeV0sIGNlbGwpO1xufVxuXG5mdW5jdGlvbiBnZXROdW1iZXJPZkdyb3Vwc0Fzc2lnbmVkRm9yTnVtYmVyKG51bWJlciwgZ3JvdXBzKSB7XG4gIHJldHVybiBncm91cHMucmVkdWNlKChhY2N1bXVsYXRvciwgcm93KSA9PlxuICAgIGFjY3VtdWxhdG9yICsgKHJvdy5nZXQobnVtYmVyKSA+IDAgPyAxIDogMCksIDApO1xufVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L25vLW11bHRpLWNvbXBcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEluZGV4IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgc3RhdGUgPSB7fTtcblxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICBpZiAoJ3NlcnZpY2VXb3JrZXInIGluIG5hdmlnYXRvcikge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICAgICBuYXZpZ2F0b3Iuc2VydmljZVdvcmtlclxuICAgICAgICAucmVnaXN0ZXIoJy9zZXJ2aWNlLXdvcmtlci5qcycpXG4gICAgICAgIC50aGVuKChyZWcpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnU2VydmljZVdvcmtlciBzY29wZTogJywgcmVnLnNjb3BlKTtcbiAgICAgICAgICBjb25zb2xlLmxvZygnc2VydmljZSB3b3JrZXIgcmVnaXN0cmF0aW9uIHN1Y2Nlc3NmdWwnKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ3NlcnZpY2Ugd29ya2VyIHJlZ2lzdHJhdGlvbiBmYWlsZWQnLCBlcnIubWVzc2FnZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgXG4gICAgZmV0Y2goJy9hcGkvc29ja2V0aW8nKS5maW5hbGx5KCgpID0+IHtcbiAgICAgIGNvbnN0IHNvY2tldCA9IGlvKClcblxuICAgICAgc29ja2V0Lm9uKCdjb25uZWN0JywgKCkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZygnY29ubmVjdCcpXG4gICAgICAgIHNvY2tldC5lbWl0KCdoZWxsbycpXG4gICAgICB9KVxuXG4gICAgICBzb2NrZXQub24oJ2hlbGxvJywgZGF0YSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdoZWxsbycsIGRhdGEpXG4gICAgICB9KVxuXG4gICAgICBzb2NrZXQub24oJ2EgdXNlciBjb25uZWN0ZWQnLCAoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdhIHVzZXIgY29ubmVjdGVkJylcbiAgICAgIH0pXG5cbiAgICAgIHNvY2tldC5vbignZGlzY29ubmVjdCcsICgpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ2Rpc2Nvbm5lY3QnKVxuICAgICAgfSlcbiAgICB9KVxuICAgXG4gIH1cbiAgZ2V0U2VsZWN0ZWRDZWxsKCkge1xuICAgIGNvbnN0IHsgYm9hcmQgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3Qgc2VsZWN0ZWQgPSBib2FyZC5nZXQoJ3NlbGVjdGVkJyk7XG4gICAgcmV0dXJuIHNlbGVjdGVkICYmIGJvYXJkLmdldCgncHV6emxlJykuZ2V0SW4oW3NlbGVjdGVkLngsIHNlbGVjdGVkLnldKTtcbiAgfVxuXG4gIC8vIGdldCB0aGUgbWluIGJldHdlZW4gaXRzIGNvbXBsZXRpb24gaW4gcm93cywgY29sdW1ucyBhbmQgc3F1YXJlcy5cbiAgZ2V0TnVtYmVyVmFsdWVDb3VudChudW1iZXIpIHtcbiAgICBjb25zdCByb3dzID0gdGhpcy5zdGF0ZS5ib2FyZC5nZXRJbihbJ2Nob2ljZXMnLCAncm93cyddKTtcbiAgICBjb25zdCBjb2x1bW5zID0gdGhpcy5zdGF0ZS5ib2FyZC5nZXRJbihbJ2Nob2ljZXMnLCAnY29sdW1ucyddKTtcbiAgICBjb25zdCBzcXVhcmVzID0gdGhpcy5zdGF0ZS5ib2FyZC5nZXRJbihbJ2Nob2ljZXMnLCAnc3F1YXJlcyddKTtcbiAgICByZXR1cm4gTWF0aC5taW4oXG4gICAgICBnZXROdW1iZXJPZkdyb3Vwc0Fzc2lnbmVkRm9yTnVtYmVyKG51bWJlciwgc3F1YXJlcyksXG4gICAgICBNYXRoLm1pbihcbiAgICAgICAgZ2V0TnVtYmVyT2ZHcm91cHNBc3NpZ25lZEZvck51bWJlcihudW1iZXIsIHJvd3MpLFxuICAgICAgICBnZXROdW1iZXJPZkdyb3Vwc0Fzc2lnbmVkRm9yTnVtYmVyKG51bWJlciwgY29sdW1ucyksXG4gICAgICApLFxuICAgICk7XG4gIH1cblxuICBnZW5lcmF0ZUdhbWUgPSAoZmluYWxDb3VudCA9IDIwKSA9PiB7XG4gICAgLy8gZ2V0IGEgZmlsbGVkIHB1enpsZSBnZW5lcmF0ZWRcbiAgICBjb25zdCBzb2x1dGlvbiA9IG1ha2VQdXp6bGUoKTtcbiAgICAvLyBwbHVjayB2YWx1ZXMgZnJvbSBjZWxscyB0byBjcmVhdGUgdGhlIGdhbWVcbiAgICBjb25zdCB7IHB1enpsZSB9ID0gcGx1Y2soc29sdXRpb24sIGZpbmFsQ291bnQpO1xuICAgIC8vIGluaXRpYWxpemUgdGhlIGJvYXJkIHdpdGggY2hvaWNlIGNvdW50c1xuICAgIGNvbnN0IGJvYXJkID0gbWFrZUJvYXJkKHsgcHV6emxlIH0pO1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgYm9hcmQsIGhpc3Rvcnk6IExpc3Qub2YoYm9hcmQpLCBoaXN0b3J5T2ZmU2V0OiAwLCBzb2x1dGlvbixcbiAgICB9KTtcbiAgfVxuXG4gIGFkZE51bWJlckFzTm90ZSA9IChudW1iZXIpID0+IHtcbiAgICBsZXQgeyBib2FyZCB9ID0gdGhpcy5zdGF0ZTtcbiAgICBsZXQgc2VsZWN0ZWRDZWxsID0gdGhpcy5nZXRTZWxlY3RlZENlbGwoKTtcbiAgICBpZiAoIXNlbGVjdGVkQ2VsbCkgcmV0dXJuO1xuICAgIGNvbnN0IHByZWZpbGxlZCA9IHNlbGVjdGVkQ2VsbC5nZXQoJ3ByZWZpbGxlZCcpO1xuICAgIGlmIChwcmVmaWxsZWQpIHJldHVybjtcbiAgICBjb25zdCB7IHgsIHkgfSA9IGJvYXJkLmdldCgnc2VsZWN0ZWQnKTtcbiAgICBjb25zdCBjdXJyZW50VmFsdWUgPSBzZWxlY3RlZENlbGwuZ2V0KCd2YWx1ZScpO1xuICAgIGlmIChjdXJyZW50VmFsdWUpIHtcbiAgICAgIGJvYXJkID0gdXBkYXRlQm9hcmRXaXRoTnVtYmVyKHtcbiAgICAgICAgeCwgeSwgbnVtYmVyOiBjdXJyZW50VmFsdWUsIGZpbGw6IGZhbHNlLCBib2FyZDogdGhpcy5zdGF0ZS5ib2FyZCxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBsZXQgbm90ZXMgPSBzZWxlY3RlZENlbGwuZ2V0KCdub3RlcycpIHx8IFNldCgpO1xuICAgIGlmIChub3Rlcy5oYXMobnVtYmVyKSkge1xuICAgICAgbm90ZXMgPSBub3Rlcy5kZWxldGUobnVtYmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm90ZXMgPSBub3Rlcy5hZGQobnVtYmVyKTtcbiAgICB9XG4gICAgc2VsZWN0ZWRDZWxsID0gc2VsZWN0ZWRDZWxsLnNldCgnbm90ZXMnLCBub3Rlcyk7XG4gICAgc2VsZWN0ZWRDZWxsID0gc2VsZWN0ZWRDZWxsLmRlbGV0ZSgndmFsdWUnKTtcbiAgICBib2FyZCA9IGJvYXJkLnNldEluKFsncHV6emxlJywgeCwgeV0sIHNlbGVjdGVkQ2VsbCk7XG4gICAgdGhpcy51cGRhdGVCb2FyZChib2FyZCk7XG4gIH07XG5cbiAgdXBkYXRlQm9hcmQgPSAobmV3Qm9hcmQpID0+IHtcbiAgICBsZXQgeyBoaXN0b3J5IH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IHsgaGlzdG9yeU9mZlNldCB9ID0gdGhpcy5zdGF0ZTtcbiAgICAvLyBhbnl0aGluZyBiZWZvcmUgY3VycmVudCBzdGVwIGlzIHN0aWxsIGluIGhpc3RvcnlcbiAgICBoaXN0b3J5ID0gaGlzdG9yeS5zbGljZSgwLCBoaXN0b3J5T2ZmU2V0ICsgMSk7XG4gICAgLy8gYWRkIGl0c2VsZiBvbnRvIHRoZSBoaXN0b3J5XG4gICAgaGlzdG9yeSA9IGhpc3RvcnkucHVzaChuZXdCb2FyZCk7XG4gICAgLy8gdXBkYXRlIHRoZSBnYW1lXG4gICAgdGhpcy5zZXRTdGF0ZSh7IGJvYXJkOiBuZXdCb2FyZCwgaGlzdG9yeSwgaGlzdG9yeU9mZlNldDogaGlzdG9yeS5zaXplIC0gMSB9KTtcbiAgfTtcblxuICBjYW5VbmRvID0gKCkgPT4gdGhpcy5zdGF0ZS5oaXN0b3J5T2ZmU2V0ID4gMFxuXG4gIHJlZG8gPSAoKSA9PiB7XG4gICAgY29uc3QgeyBoaXN0b3J5IH0gPSB0aGlzLnN0YXRlO1xuICAgIGxldCB7IGhpc3RvcnlPZmZTZXQgfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKGhpc3Rvcnkuc2l6ZSkge1xuICAgICAgaGlzdG9yeU9mZlNldCA9IE1hdGgubWluKGhpc3Rvcnkuc2l6ZSAtIDEsIGhpc3RvcnlPZmZTZXQgKyAxKTtcbiAgICAgIGNvbnN0IGJvYXJkID0gaGlzdG9yeS5nZXQoaGlzdG9yeU9mZlNldCk7XG4gICAgICB0aGlzLnNldFN0YXRlKHsgYm9hcmQsIGhpc3RvcnlPZmZTZXQgfSk7XG4gICAgfVxuICB9O1xuXG4gIHVuZG8gPSAoKSA9PiB7XG4gICAgY29uc3QgeyBoaXN0b3J5IH0gPSB0aGlzLnN0YXRlO1xuICAgIGxldCB7IGhpc3RvcnlPZmZTZXQsIGJvYXJkIH0gPSB0aGlzLnN0YXRlO1xuICAgIGlmIChoaXN0b3J5LnNpemUpIHtcbiAgICAgIGhpc3RvcnlPZmZTZXQgPSBNYXRoLm1heCgwLCBoaXN0b3J5T2ZmU2V0IC0gMSk7XG4gICAgICBib2FyZCA9IGhpc3RvcnkuZ2V0KGhpc3RvcnlPZmZTZXQpO1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IGJvYXJkLCBoaXN0b3J5T2ZmU2V0LCBoaXN0b3J5IH0pO1xuICAgIH1cbiAgfTtcblxuICBlcmFzZVNlbGVjdGVkID0gKCkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGVkQ2VsbCA9IHRoaXMuZ2V0U2VsZWN0ZWRDZWxsKCk7XG4gICAgaWYgKCFzZWxlY3RlZENlbGwpIHJldHVybjtcbiAgICB0aGlzLmZpbGxOdW1iZXIoZmFsc2UpO1xuICB9XG5cbiAgZmlsbFNlbGVjdGVkV2l0aFNvbHV0aW9uID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgYm9hcmQsIHNvbHV0aW9uIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IHNlbGVjdGVkQ2VsbCA9IHRoaXMuZ2V0U2VsZWN0ZWRDZWxsKCk7XG4gICAgaWYgKCFzZWxlY3RlZENlbGwpIHJldHVybjtcbiAgICBjb25zdCB7IHgsIHkgfSA9IGJvYXJkLmdldCgnc2VsZWN0ZWQnKTtcbiAgICB0aGlzLmZpbGxOdW1iZXIoc29sdXRpb25beF1beV0pO1xuICB9XG5cblxuICAvLyBmaWxsIGN1cnJlbnRseSBzZWxlY3RlZCBjZWxsIHdpdGggbnVtYmVyXG4gIGZpbGxOdW1iZXIgPSAobnVtYmVyKSA9PiB7XG4gICAgbGV0IHsgYm9hcmQgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3Qgc2VsZWN0ZWRDZWxsID0gdGhpcy5nZXRTZWxlY3RlZENlbGwoKTtcbiAgICAvLyBuby1vcCBpZiBub3RoaW5nIGlzIHNlbGVjdGVkXG4gICAgaWYgKCFzZWxlY3RlZENlbGwpIHJldHVybjtcbiAgICBjb25zdCBwcmVmaWxsZWQgPSBzZWxlY3RlZENlbGwuZ2V0KCdwcmVmaWxsZWQnKTtcbiAgICAvLyBuby1vcCBpZiBpdCBpcyByZWZpbGxlZFxuICAgIGlmIChwcmVmaWxsZWQpIHJldHVybjtcbiAgICBjb25zdCB7IHgsIHkgfSA9IGJvYXJkLmdldCgnc2VsZWN0ZWQnKTtcbiAgICBjb25zdCBjdXJyZW50VmFsdWUgPSBzZWxlY3RlZENlbGwuZ2V0KCd2YWx1ZScpO1xuICAgIC8vIHJlbW92ZSB0aGUgY3VycmVudCB2YWx1ZSBhbmQgdXBkYXRlIHRoZSBnYW1lIHN0YXRlXG4gICAgaWYgKGN1cnJlbnRWYWx1ZSkge1xuICAgICAgYm9hcmQgPSB1cGRhdGVCb2FyZFdpdGhOdW1iZXIoe1xuICAgICAgICB4LCB5LCBudW1iZXI6IGN1cnJlbnRWYWx1ZSwgZmlsbDogZmFsc2UsIGJvYXJkOiB0aGlzLnN0YXRlLmJvYXJkLFxuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIHVwZGF0ZSB0byBuZXcgbnVtYmVyIGlmIGFueVxuICAgIGNvbnN0IHNldE51bWJlciA9IGN1cnJlbnRWYWx1ZSAhPT0gbnVtYmVyICYmIG51bWJlcjtcbiAgICBpZiAoc2V0TnVtYmVyKSB7XG4gICAgICBib2FyZCA9IHVwZGF0ZUJvYXJkV2l0aE51bWJlcih7XG4gICAgICAgIHgsIHksIG51bWJlciwgZmlsbDogdHJ1ZSwgYm9hcmQsXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVCb2FyZChib2FyZCk7XG4gIH07XG5cbiAgc2VsZWN0Q2VsbCA9ICh4LCB5KSA9PiB7XG4gICAgbGV0IHsgYm9hcmQgfSA9IHRoaXMuc3RhdGU7XG4gICAgYm9hcmQgPSBib2FyZC5zZXQoJ3NlbGVjdGVkJywgeyB4LCB5IH0pO1xuICAgIHRoaXMuc2V0U3RhdGUoeyBib2FyZCB9KTtcbiAgfTtcblxuICBpc0NvbmZsaWN0KGksIGopIHtcbiAgICBjb25zdCB7IHZhbHVlIH0gPSB0aGlzLnN0YXRlLmJvYXJkLmdldEluKFsncHV6emxlJywgaSwgal0pLnRvSlNPTigpO1xuICAgIGlmICghdmFsdWUpIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCByb3dDb25mbGljdCA9XG4gICAgICB0aGlzLnN0YXRlLmJvYXJkLmdldEluKFsnY2hvaWNlcycsICdyb3dzJywgaSwgdmFsdWVdKSA+IDE7XG4gICAgY29uc3QgY29sdW1uQ29uZmxpY3QgPVxuICAgICAgdGhpcy5zdGF0ZS5ib2FyZC5nZXRJbihbJ2Nob2ljZXMnLCAnY29sdW1ucycsIGosIHZhbHVlXSkgPiAxO1xuICAgIGNvbnN0IHNxdWFyZUNvbmZsaWN0ID1cbiAgICAgIHRoaXMuc3RhdGUuYm9hcmQuZ2V0SW4oWydjaG9pY2VzJywgJ3NxdWFyZXMnLFxuICAgICAgICAoKE1hdGguZmxvb3IoaSAvIDMpKSAqIDMpICsgTWF0aC5mbG9vcihqIC8gMyksIHZhbHVlXSkgPiAxO1xuICAgIHJldHVybiByb3dDb25mbGljdCB8fCBjb2x1bW5Db25mbGljdCB8fCBzcXVhcmVDb25mbGljdDtcbiAgfVxuXG4gIHJlbmRlckNlbGwoY2VsbCwgeCwgeSkge1xuICAgIGNvbnN0IHsgYm9hcmQgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3Qgc2VsZWN0ZWQgPSB0aGlzLmdldFNlbGVjdGVkQ2VsbCgpO1xuICAgIGNvbnN0IHsgdmFsdWUsIHByZWZpbGxlZCwgbm90ZXMgfSA9IGNlbGwudG9KU09OKCk7XG4gICAgY29uc3QgY29uZmxpY3QgPSB0aGlzLmlzQ29uZmxpY3QoeCwgeSk7XG4gICAgY29uc3QgcGVlciA9IGFyZUNvb3JkaW5hdGVQZWVycyh7IHgsIHkgfSwgYm9hcmQuZ2V0KCdzZWxlY3RlZCcpKTtcbiAgICBjb25zdCBzYW1lVmFsdWUgPSAhIShzZWxlY3RlZCAmJiBzZWxlY3RlZC5nZXQoJ3ZhbHVlJylcbiAgICAgICYmIHZhbHVlID09PSBzZWxlY3RlZC5nZXQoJ3ZhbHVlJykpO1xuXG4gICAgY29uc3QgaXNTZWxlY3RlZCA9IGNlbGwgPT09IHNlbGVjdGVkO1xuICAgIHJldHVybiAoPENlbGxcbiAgICAgIHByZWZpbGxlZD17cHJlZmlsbGVkfVxuICAgICAgbm90ZXM9e25vdGVzfVxuICAgICAgc2FtZVZhbHVlPXtzYW1lVmFsdWV9XG4gICAgICBpc1NlbGVjdGVkPXtpc1NlbGVjdGVkfVxuICAgICAgaXNQZWVyPXtwZWVyfVxuICAgICAgdmFsdWU9e3ZhbHVlfVxuICAgICAgb25DbGljaz17KCkgPT4geyB0aGlzLnNlbGVjdENlbGwoeCwgeSk7IH19XG4gICAgICBrZXk9e3l9XG4gICAgICB4PXt4fVxuICAgICAgeT17eX1cbiAgICAgIGNvbmZsaWN0PXtjb25mbGljdH1cbiAgICAvPik7XG4gIH1cblxuICByZW5kZXJOdW1iZXJDb250cm9sKCkge1xuICAgIGNvbnN0IHNlbGVjdGVkQ2VsbCA9IHRoaXMuZ2V0U2VsZWN0ZWRDZWxsKCk7XG4gICAgY29uc3QgcHJlZmlsbGVkID0gc2VsZWN0ZWRDZWxsICYmIHNlbGVjdGVkQ2VsbC5nZXQoJ3ByZWZpbGxlZCcpO1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRyb2xcIj5cbiAgICAgICAge3JhbmdlKDkpLm1hcCgoaSkgPT4ge1xuICAgICAgICAgIGNvbnN0IG51bWJlciA9IGkgKyAxO1xuICAgICAgICAgIC8vIGhhbmRsZXMgYmluZGluZyBzaW5nbGUgY2xpY2sgYW5kIGRvdWJsZSBjbGljayBjYWxsYmFja3NcbiAgICAgICAgICBjb25zdCBjbGlja0hhbmRsZSA9IGdldENsaWNrSGFuZGxlcihcbiAgICAgICAgICAgICgpID0+IHsgdGhpcy5maWxsTnVtYmVyKG51bWJlcik7IH0sXG4gICAgICAgICAgICAoKSA9PiB7IHRoaXMuYWRkTnVtYmVyQXNOb3RlKG51bWJlcik7IH0sXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPE51bWJlckNvbnRyb2xcbiAgICAgICAgICAgICAga2V5PXtudW1iZXJ9XG4gICAgICAgICAgICAgIG51bWJlcj17bnVtYmVyfVxuICAgICAgICAgICAgICBvbkNsaWNrPXshcHJlZmlsbGVkID8gY2xpY2tIYW5kbGUgOiB1bmRlZmluZWR9XG4gICAgICAgICAgICAgIGNvbXBsZXRpb25QZXJjZW50YWdlPXt0aGlzLmdldE51bWJlclZhbHVlQ291bnQobnVtYmVyKSAvIDl9XG4gICAgICAgICAgICAvPik7XG4gICAgICAgIH0pfVxuICAgICAgICA8c3R5bGUganN4PntDb250cm9sU3R5bGV9PC9zdHlsZT5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cblxuICByZW5kZXJBY3Rpb25zKCkge1xuICAgIGNvbnN0IHsgaGlzdG9yeSB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBzZWxlY3RlZENlbGwgPSB0aGlzLmdldFNlbGVjdGVkQ2VsbCgpO1xuICAgIGNvbnN0IHByZWZpbGxlZCA9IHNlbGVjdGVkQ2VsbCAmJiBzZWxlY3RlZENlbGwuZ2V0KCdwcmVmaWxsZWQnKTtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJhY3Rpb25zXCI+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWN0aW9uXCIgb25DbGljaz17aGlzdG9yeS5zaXplID8gdGhpcy51bmRvIDogbnVsbH0+XG4gICAgICAgICAgPFJlbG9hZEljb24gLz5VbmRvXG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImFjdGlvbiByZWRvXCIgb25DbGljaz17aGlzdG9yeS5zaXplID8gdGhpcy5yZWRvIDogbnVsbH0+XG4gICAgICAgICAgPFJlbG9hZEljb24gLz5SZWRvXG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImFjdGlvblwiIG9uQ2xpY2s9eyFwcmVmaWxsZWQgPyB0aGlzLmVyYXNlU2VsZWN0ZWQgOiBudWxsfT5cbiAgICAgICAgICA8UmVtb3ZlSWNvbiAvPkVyYXNlXG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2XG4gICAgICAgICAgY2xhc3NOYW1lPVwiYWN0aW9uXCJcbiAgICAgICAgICBvbkNsaWNrPXshcHJlZmlsbGVkID9cbiAgICAgICAgICB0aGlzLmZpbGxTZWxlY3RlZFdpdGhTb2x1dGlvbiA6IG51bGx9XG4gICAgICAgID5cbiAgICAgICAgICA8TG91cGVJY29uIC8+SGludFxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPHN0eWxlIGpzeD57QWN0aW9uc1N0eWxlfTwvc3R5bGU+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG5cbiAgcmVuZGVyUHV6emxlKCkge1xuICAgIGNvbnN0IHsgYm9hcmQgfSA9IHRoaXMuc3RhdGU7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwicHV6emxlXCI+XG4gICAgICAgIHtib2FyZC5nZXQoJ3B1enpsZScpLm1hcCgocm93LCBpKSA9PiAoXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L25vLWFycmF5LWluZGV4LWtleVxuICAgICAgICAgIDxkaXYga2V5PXtpfSBjbGFzc05hbWU9XCJyb3dcIj5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcm93Lm1hcCgoY2VsbCwgaikgPT4gdGhpcy5yZW5kZXJDZWxsKGNlbGwsIGksIGopKS50b0FycmF5KClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKSkudG9BcnJheSgpfVxuICAgICAgICA8c3R5bGUganN4PntQdXp6bGVTdHlsZX08L3N0eWxlPlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxuXG4gIHJlbmRlckNvbnRyb2xzKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRyb2xzXCI+XG4gICAgICAgIHt0aGlzLnJlbmRlck51bWJlckNvbnRyb2woKX1cbiAgICAgICAge3RoaXMucmVuZGVyQWN0aW9ucygpfVxuICAgICAgICB7IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG4gICAgICAgIDxzdHlsZSBqc3g+e2BcbiAgICAgICAgICAgIC5jb250cm9scyB7XG4gICAgICAgICAgICAgICAgbWFyZ2luLXRvcDogLjNlbTtcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICAgICAgICAgIGZsZXgtd3JhcDogd3JhcDtcbiAgICAgICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiAuNWVtIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIGB9XG4gICAgICAgIDwvc3R5bGU+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG5cbiAgcmVuZGVyR2VuZXJhdGlvblVJKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8R2VuZXJhdGlvblVJIGdlbmVyYXRlR2FtZT17dGhpcy5nZW5lcmF0ZUdhbWV9IC8+XG4gICAgKTtcbiAgfVxuXG4gIHJlbmRlckhlYWRlcigpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJoZWFkZXJcIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJuZXctZ2FtZVwiIG9uQ2xpY2s9eygpID0+IHRoaXMuc2V0U3RhdGUoeyBib2FyZDogZmFsc2UgfSl9PlxuICAgICAgICAgIDxSZXR1cm5JY29uIC8+XG4gICAgICAgICAgPGRpdj5OZXcgR2FtZTwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPFRpcCAvPlxuICAgICAgICB7IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG4gICAgICAgIDxzdHlsZSBqc3g+e2BcbiAgICAgICAgICAgIC5oZWFkZXIge1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgICAgICAgICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICAgICAgICAgICAgICAgIG1heC13aWR0aDogNTAwcHg7XG4gICAgICAgICAgICAgICAgcGFkZGluZzogMCAwLjVlbTtcbiAgICAgICAgICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLm5ldy1nYW1lIHtcbiAgICAgICAgICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICAgICAgICAgICAgbWFyZ2luLXRvcDogLjJlbTtcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiBpbmxpbmUtZmxleDtcbiAgICAgICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICAgICAgICAgIHBhZGRpbmc6IC4yZW0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC5uZXctZ2FtZSA6Z2xvYmFsKHN2Zykge1xuICAgICAgICAgICAgICAgIGhlaWdodDogMWVtO1xuICAgICAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IC4zZW07XG4gICAgICAgICAgICB9XG4gICAgICAgIGB9XG4gICAgICAgIDwvc3R5bGU+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgYm9hcmQgfSA9IHRoaXMuc3RhdGU7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYm9keVwiPlxuICAgICAgICA8TmV4dEhlYWQ+XG4gICAgICAgICAgPHRpdGxlPlN1ZG9rdSBFdm9sdmVkPC90aXRsZT5cbiAgICAgICAgICA8bWV0YSBuYW1lPVwidmlld3BvcnRcIiBjb250ZW50PVwiaW5pdGlhbC1zY2FsZT0xLjAsIHdpZHRoPWRldmljZS13aWR0aFwiIC8+XG4gICAgICAgICAgPG1ldGEgbmFtZT1cImRlc2NyaXB0aW9uXCIgY29udGVudD17RGVzY3JpcHRpb259IC8+XG4gICAgICAgICAgPGxpbmsgaHJlZj1cImh0dHBzOi8vZm9udHMuZ29vZ2xlYXBpcy5jb20vY3NzP2ZhbWlseT1TcGVjaWFsK0VsaXRlXCIgcmVsPVwic3R5bGVzaGVldFwiIC8+XG4gICAgICAgICAgPG1ldGEgcHJvcGVydHk9XCJvZzp1cmxcIiBjb250ZW50PVwiaHR0cHM6Ly9zdWRva3Uuc2l0aWFubGl1LmNvbS9cIiAvPlxuICAgICAgICAgIDxtZXRhIHByb3BlcnR5PVwib2c6dGl0bGVcIiBjb250ZW50PVwiU3Vkb2t1IEV2b2x2ZWRcIiAvPlxuICAgICAgICAgIDxtZXRhIHByb3BlcnR5PVwib2c6dHlwZVwiIGNvbnRlbnQ9XCJ3ZWJzaXRlXCIgLz5cbiAgICAgICAgICA8bWV0YSBwcm9wZXJ0eT1cIm9nOmRlc2NyaXB0aW9uXCIgY29udGVudD17RGVzY3JpcHRpb259IC8+XG4gICAgICAgICAgPG1ldGEgcHJvcGVydHk9XCJvZzppbWFnZVwiIGNvbnRlbnQ9XCJodHRwczovL3N1ZG9rdS5zaXRpYW5saXUuY29tL3N0YXRpYy9vZy1pbWFnZS5wbmdcIiAvPlxuICAgICAgICA8L05leHRIZWFkPlxuICAgICAgICB7IWJvYXJkICYmIHRoaXMucmVuZGVyR2VuZXJhdGlvblVJKCl9XG4gICAgICAgIHtib2FyZCAmJiB0aGlzLnJlbmRlckhlYWRlcigpfVxuICAgICAgICB7Ym9hcmQgJiYgdGhpcy5yZW5kZXJQdXp6bGUoKX1cbiAgICAgICAge2JvYXJkICYmIHRoaXMucmVuZGVyQ29udHJvbHMoKX1cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJyb290ZXJcIj5cbiAgICAgICAgICBNYWRlIHdpdGggPHNwYW4+4p2k77iPPC9zcGFuPu+4jyBCeSA8YSBocmVmPVwiaHR0cHM6Ly93d3cuc2l0aWFubGl1LmNvbS9cIj5TaXRpYW4gTGl1PC9hPiB8IDxhIGhyZWY9XCJodHRwczovL21lZGl1bS5jb20vQHNpdGlhbmxpdV81NzY4MC9idWlsZGluZy1hLXN1ZG9rdS1nYW1lLWluLXJlYWN0LWNhNjYzOTE1NzEyXCI+QmxvZyBQb3N0PC9hPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgeyAvKiBsYW5ndWFnZT1DU1MgKi8gfVxuICAgICAgICA8c3R5bGUganN4PntgXG4gICAgICAgICAgICA6Z2xvYmFsKGJvZHkpLCAuYm9keSB7XG4gICAgICAgICAgICAgICAgZm9udC1mYW1pbHk6ICdTcGVjaWFsIEVsaXRlJywgY3Vyc2l2ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC5ib2R5IHtcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICAgICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgICAgICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDEwMHZoO1xuICAgICAgICAgICAgICAgIHdpZHRoOiAxMDB2dztcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBAbWVkaWEgKG1pbi13aWR0aDogODAwcHgpIGFuZCAobWluLWhlaWdodDogOTMwcHgpe1xuICAgICAgICAgICAgICAgIDpnbG9iYWwoLmhlYWRlciwgLnB1enpsZSwgLmNvbnRyb2xzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvbnQtc2l6ZTogMS41ZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQG1lZGlhIChtYXgtd2lkdGg6IDgwMHB4KSBhbmQgKG1pbi13aWR0aDogNjAwcHgpe1xuICAgICAgICAgICAgICAgIDpnbG9iYWwoLmhlYWRlciwgLnB1enpsZSwgLmNvbnRyb2xzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvbnQtc2l6ZTogMS4yZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQG1lZGlhIChtYXgtaGVpZ2h0OiA5MzBweCkgYW5kIChtaW4taGVpZ2h0OiA4MDBweCkgYW5kIChtaW4td2lkdGg6IDYwMHB4KXtcbiAgICAgICAgICAgICAgICA6Z2xvYmFsKC5oZWFkZXIsIC5wdXp6bGUsIC5jb250cm9scykge1xuICAgICAgICAgICAgICAgICAgICBmb250LXNpemU6IDEuMmVtO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEBtZWRpYSAobWF4LWhlaWdodDogODAwcHgpIGFuZCAobWluLWhlaWdodDogNjAwcHgpIGFuZCAobWluLXdpZHRoOiAzNzBweCl7XG4gICAgICAgICAgICAgICAgOmdsb2JhbCguaGVhZGVyLCAucHV6emxlLCAuY29udHJvbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9udC1zaXplOiAxZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQG1lZGlhIChtYXgtd2lkdGg6IDM3MHB4KXtcbiAgICAgICAgICAgICAgICA6Z2xvYmFsKC5oZWFkZXIsIC5wdXp6bGUsIC5jb250cm9scykge1xuICAgICAgICAgICAgICAgICAgICBmb250LXNpemU6IC44ZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQG1lZGlhIChtYXgtaGVpZ2h0OiA2MDBweCl7XG4gICAgICAgICAgICAgICAgOmdsb2JhbCguaGVhZGVyLCAucHV6emxlLCAuY29udHJvbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9udC1zaXplOiAuOGVtO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDpnbG9iYWwoYm9keSkge1xuICAgICAgICAgICAgICAgIG1hcmdpbjogMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC5yb290ZXIge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICAgICAgICAgICAgICBib3R0b206IDA7XG4gICAgICAgICAgICAgICAgZm9udC1zaXplOiAuOGVtO1xuICAgICAgICAgICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICAgICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgYH1cbiAgICAgICAgPC9zdHlsZT5cbiAgICAgICAgPHN0eWxlIGpzeCBnbG9iYWw+e1JhbmdlU3R5bGV9PC9zdHlsZT5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cbn1cbiJdfQ== */\n/*@ sourceURL=pages/index.js */',
      dynamic: [backgroundColor || 'initial', fontColor || 'initial']
    })
  );
};

Cell.propTypes = {
  // current number value
  value: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.number,
  // cell click handler
  onClick: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.func.isRequired,
  // if the cell is a peer of the selected cell
  isPeer: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.bool.isRequired,
  // if the cell is selected by the user
  isSelected: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.bool.isRequired,
  // current cell has the same value if the user selected cell
  sameValue: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.bool.isRequired,
  // if this was prefilled as a part of the puzzle
  prefilled: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.bool.isRequired,
  // current notes taken on the cell
  notes: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.instanceOf(__WEBPACK_IMPORTED_MODULE_2_immutable__["b" /* Set */]),
  // if the current cell does not satisfy the game constraint
  conflict: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.bool.isRequired
};

Cell.defaultProps = {
  notes: null,
  value: null
};

var CirclularProgress = function CirclularProgress(_ref4) {
  var percent = _ref4.percent;
  return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
    'svg',
    { viewBox: '0 0 36 36', className: 'jsx-' + CirculuarProgressStyle.__scopedHash + ' ' + 'circular-progress',
      __source: {
        fileName: _jsxFileName,
        lineNumber: 364
      }
    },
    __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement('path', {
      d: CircularPathD,
      className: 'jsx-' + CirculuarProgressStyle.__scopedHash + ' ' + 'circle-bg',
      __source: {
        fileName: _jsxFileName,
        lineNumber: 365
      }
    }),
    __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement('path', {
      strokeDasharray: percent * 100 + ', 100',
      d: CircularPathD,
      className: 'jsx-' + CirculuarProgressStyle.__scopedHash + ' ' + 'circle',
      __source: {
        fileName: _jsxFileName,
        lineNumber: 369
      }
    }),
    __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_0_styled_jsx_style___default.a, {
      styleId: CirculuarProgressStyle.__scopedHash,
      css: CirculuarProgressStyle.__scoped
    })
  );
};

CirclularProgress.propTypes = {
  percent: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.number.isRequired
};

function getClickHandler(onClick, onDoubleClick) {
  var delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 250;

  var timeoutID = null;
  return function (event) {
    if (!timeoutID) {
      timeoutID = setTimeout(function () {
        onClick(event);
        timeoutID = null;
      }, delay);
    } else {
      timeoutID = clearTimeout(timeoutID);
      onDoubleClick(event);
    }
  };
}

/**
 * make size 9 array of 0s
 * @returns {Array}
 */
function makeCountObject() {
  var countObj = [];
  for (var i = 0; i < 10; i += 1) {
    countObj.push(0);
  }return countObj;
}

/**
 * given a 2D array of numbers as the initial puzzle, generate the initial game state
 * @param puzzle
 * @returns {any}
 */
function makeBoard(_ref5) {
  var puzzle = _ref5.puzzle;

  // create initial count object to keep track of conflicts per number value
  var rows = Array.from(Array(9).keys()).map(function () {
    return makeCountObject();
  });
  var columns = Array.from(Array(9).keys()).map(function () {
    return makeCountObject();
  });
  var squares = Array.from(Array(9).keys()).map(function () {
    return makeCountObject();
  });
  var result = puzzle.map(function (row, i) {
    return row.map(function (cell, j) {
      if (cell) {
        rows[i][cell] += 1;
        columns[j][cell] += 1;
        squares[Math.floor(i / 3) * 3 + Math.floor(j / 3)][cell] += 1;
      }
      return {
        value: puzzle[i][j] > 0 ? puzzle[i][j] : null,
        prefilled: !!puzzle[i][j]
      };
    });
  });
  return Object(__WEBPACK_IMPORTED_MODULE_2_immutable__["c" /* fromJS */])({ puzzle: result, selected: false, choices: { rows: rows, columns: columns, squares: squares } });
}

/**
 * give the coordinate update the current board with a number choice
 * @param x
 * @param y
 * @param number
 * @param fill whether to set or unset
 * @param board the immutable board given to change
 */
function updateBoardWithNumber(_ref6) {
  var x = _ref6.x,
      y = _ref6.y,
      number = _ref6.number,
      _ref6$fill = _ref6.fill,
      fill = _ref6$fill === undefined ? true : _ref6$fill,
      board = _ref6.board;

  var cell = board.get('puzzle').getIn([x, y]);
  // delete its notes
  cell = cell.delete('notes');
  // set or unset its value depending on `fill`
  cell = fill ? cell.set('value', number) : cell.delete('value');
  var increment = fill ? 1 : -1;
  // update the current group choices
  var rowPath = ['choices', 'rows', x, number];
  var columnPath = ['choices', 'columns', y, number];
  var squarePath = ['choices', 'squares', Math.floor(x / 3) * 3 + Math.floor(y / 3), number];
  return board.setIn(rowPath, board.getIn(rowPath) + increment).setIn(columnPath, board.getIn(columnPath) + increment).setIn(squarePath, board.getIn(squarePath) + increment).setIn(['puzzle', x, y], cell);
}

function getNumberOfGroupsAssignedForNumber(number, groups) {
  return groups.reduce(function (accumulator, row) {
    return accumulator + (row.get(number) > 0 ? 1 : 0);
  }, 0);
}
// eslint-disable-next-line react/no-multi-comp

var Index = function (_Component2) {
  _inherits(Index, _Component2);

  function Index() {
    var _ref7;

    var _temp, _this3, _ret;

    _classCallCheck(this, Index);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this3 = _possibleConstructorReturn(this, (_ref7 = Index.__proto__ || Object.getPrototypeOf(Index)).call.apply(_ref7, [this].concat(args))), _this3), _this3.state = {}, _this3.generateGame = function () {
      var finalCount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 20;

      // get a filled puzzle generated
      var solution = Object(__WEBPACK_IMPORTED_MODULE_12__sudoku__["b" /* makePuzzle */])();
      // pluck values from cells to create the game

      var _pluck = Object(__WEBPACK_IMPORTED_MODULE_12__sudoku__["c" /* pluck */])(solution, finalCount),
          puzzle = _pluck.puzzle;
      // initialize the board with choice counts


      var board = makeBoard({ puzzle: puzzle });
      _this3.setState({
        board: board, history: __WEBPACK_IMPORTED_MODULE_2_immutable__["a" /* List */].of(board), historyOffSet: 0, solution: solution
      });
    }, _this3.addNumberAsNote = function (number) {
      var board = _this3.state.board;

      var selectedCell = _this3.getSelectedCell();
      if (!selectedCell) return;
      var prefilled = selectedCell.get('prefilled');
      if (prefilled) return;

      var _board$get = board.get('selected'),
          x = _board$get.x,
          y = _board$get.y;

      var currentValue = selectedCell.get('value');
      if (currentValue) {
        board = updateBoardWithNumber({
          x: x, y: y, number: currentValue, fill: false, board: _this3.state.board
        });
      }
      var notes = selectedCell.get('notes') || Object(__WEBPACK_IMPORTED_MODULE_2_immutable__["b" /* Set */])();
      if (notes.has(number)) {
        notes = notes.delete(number);
      } else {
        notes = notes.add(number);
      }
      selectedCell = selectedCell.set('notes', notes);
      selectedCell = selectedCell.delete('value');
      board = board.setIn(['puzzle', x, y], selectedCell);
      _this3.updateBoard(board);
    }, _this3.updateBoard = function (newBoard) {
      var history = _this3.state.history;
      var historyOffSet = _this3.state.historyOffSet;
      // anything before current step is still in history

      history = history.slice(0, historyOffSet + 1);
      // add itself onto the history
      history = history.push(newBoard);
      // update the game
      _this3.setState({ board: newBoard, history: history, historyOffSet: history.size - 1 });
    }, _this3.canUndo = function () {
      return _this3.state.historyOffSet > 0;
    }, _this3.redo = function () {
      var history = _this3.state.history;
      var historyOffSet = _this3.state.historyOffSet;

      if (history.size) {
        historyOffSet = Math.min(history.size - 1, historyOffSet + 1);
        var board = history.get(historyOffSet);
        _this3.setState({ board: board, historyOffSet: historyOffSet });
      }
    }, _this3.undo = function () {
      var history = _this3.state.history;
      var _this3$state = _this3.state,
          historyOffSet = _this3$state.historyOffSet,
          board = _this3$state.board;

      if (history.size) {
        historyOffSet = Math.max(0, historyOffSet - 1);
        board = history.get(historyOffSet);
        _this3.setState({ board: board, historyOffSet: historyOffSet, history: history });
      }
    }, _this3.eraseSelected = function () {
      var selectedCell = _this3.getSelectedCell();
      if (!selectedCell) return;
      _this3.fillNumber(false);
    }, _this3.fillSelectedWithSolution = function () {
      var _this3$state2 = _this3.state,
          board = _this3$state2.board,
          solution = _this3$state2.solution;

      var selectedCell = _this3.getSelectedCell();
      if (!selectedCell) return;

      var _board$get2 = board.get('selected'),
          x = _board$get2.x,
          y = _board$get2.y;

      _this3.fillNumber(solution[x][y]);
    }, _this3.fillNumber = function (number) {
      var board = _this3.state.board;

      var selectedCell = _this3.getSelectedCell();
      // no-op if nothing is selected
      if (!selectedCell) return;
      var prefilled = selectedCell.get('prefilled');
      // no-op if it is refilled
      if (prefilled) return;

      var _board$get3 = board.get('selected'),
          x = _board$get3.x,
          y = _board$get3.y;

      var currentValue = selectedCell.get('value');
      // remove the current value and update the game state
      if (currentValue) {
        board = updateBoardWithNumber({
          x: x, y: y, number: currentValue, fill: false, board: _this3.state.board
        });
      }
      // update to new number if any
      var setNumber = currentValue !== number && number;
      if (setNumber) {
        board = updateBoardWithNumber({
          x: x, y: y, number: number, fill: true, board: board
        });
      }
      _this3.updateBoard(board);
    }, _this3.selectCell = function (x, y) {
      var board = _this3.state.board;

      board = board.set('selected', { x: x, y: y });
      _this3.setState({ board: board });
    }, _temp), _possibleConstructorReturn(_this3, _ret);
  }

  _createClass(Index, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      // eslint-disable-next-line no-undef
      if ('serviceWorker' in navigator) {
        // eslint-disable-next-line no-undef
        navigator.serviceWorker.register('/service-worker.js').then(function (reg) {
          console.log('ServiceWorker scope: ', reg.scope);
          console.log('service worker registration successful');
        }).catch(function (err) {
          console.warn('service worker registration failed', err.message);
        });
      }

      fetch('/api/socketio').finally(function () {
        var socket = __WEBPACK_IMPORTED_MODULE_15_socket_io_client___default()();

        socket.on('connect', function () {
          console.log('connect');
          socket.emit('hello');
        });

        socket.on('hello', function (data) {
          console.log('hello', data);
        });

        socket.on('a user connected', function () {
          console.log('a user connected');
        });

        socket.on('disconnect', function () {
          console.log('disconnect');
        });
      });
    }
  }, {
    key: 'getSelectedCell',
    value: function getSelectedCell() {
      var board = this.state.board;

      var selected = board.get('selected');
      return selected && board.get('puzzle').getIn([selected.x, selected.y]);
    }

    // get the min between its completion in rows, columns and squares.

  }, {
    key: 'getNumberValueCount',
    value: function getNumberValueCount(number) {
      var rows = this.state.board.getIn(['choices', 'rows']);
      var columns = this.state.board.getIn(['choices', 'columns']);
      var squares = this.state.board.getIn(['choices', 'squares']);
      return Math.min(getNumberOfGroupsAssignedForNumber(number, squares), Math.min(getNumberOfGroupsAssignedForNumber(number, rows), getNumberOfGroupsAssignedForNumber(number, columns)));
    }

    // fill currently selected cell with number

  }, {
    key: 'isConflict',
    value: function isConflict(i, j) {
      var _state$board$getIn$to = this.state.board.getIn(['puzzle', i, j]).toJSON(),
          value = _state$board$getIn$to.value;

      if (!value) return false;
      var rowConflict = this.state.board.getIn(['choices', 'rows', i, value]) > 1;
      var columnConflict = this.state.board.getIn(['choices', 'columns', j, value]) > 1;
      var squareConflict = this.state.board.getIn(['choices', 'squares', Math.floor(i / 3) * 3 + Math.floor(j / 3), value]) > 1;
      return rowConflict || columnConflict || squareConflict;
    }
  }, {
    key: 'renderCell',
    value: function renderCell(cell, x, y) {
      var _this4 = this;

      var board = this.state.board;

      var selected = this.getSelectedCell();

      var _cell$toJSON = cell.toJSON(),
          value = _cell$toJSON.value,
          prefilled = _cell$toJSON.prefilled,
          notes = _cell$toJSON.notes;

      var conflict = this.isConflict(x, y);
      var peer = Object(__WEBPACK_IMPORTED_MODULE_12__sudoku__["a" /* isPeer */])({ x: x, y: y }, board.get('selected'));
      var sameValue = !!(selected && selected.get('value') && value === selected.get('value'));

      var isSelected = cell === selected;
      return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(Cell, {
        prefilled: prefilled,
        notes: notes,
        sameValue: sameValue,
        isSelected: isSelected,
        isPeer: peer,
        value: value,
        onClick: function onClick() {
          _this4.selectCell(x, y);
        },
        key: y,
        x: x,
        y: y,
        conflict: conflict,
        __source: {
          fileName: _jsxFileName,
          lineNumber: 669
        }
      });
    }
  }, {
    key: 'renderNumberControl',
    value: function renderNumberControl() {
      var _this5 = this;

      var selectedCell = this.getSelectedCell();
      var prefilled = selectedCell && selectedCell.get('prefilled');
      return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
        'div',
        {
          className: 'jsx-' + ControlStyle.__scopedHash + ' ' + 'control',
          __source: {
            fileName: _jsxFileName,
            lineNumber: 688
          }
        },
        Object(__WEBPACK_IMPORTED_MODULE_12__sudoku__["d" /* range */])(9).map(function (i) {
          var number = i + 1;
          // handles binding single click and double click callbacks
          var clickHandle = getClickHandler(function () {
            _this5.fillNumber(number);
          }, function () {
            _this5.addNumberAsNote(number);
          });
          return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(NumberControl, {
            key: number,
            number: number,
            onClick: !prefilled ? clickHandle : undefined,
            completionPercentage: _this5.getNumberValueCount(number) / 9,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 697
            }
          });
        }),
        __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_0_styled_jsx_style___default.a, {
          styleId: ControlStyle.__scopedHash,
          css: ControlStyle.__scoped
        })
      );
    }
  }, {
    key: 'renderActions',
    value: function renderActions() {
      var history = this.state.history;

      var selectedCell = this.getSelectedCell();
      var prefilled = selectedCell && selectedCell.get('prefilled');
      return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
        'div',
        {
          className: 'jsx-' + ActionsStyle.__scopedHash + ' ' + 'actions',
          __source: {
            fileName: _jsxFileName,
            lineNumber: 714
          }
        },
        __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
          'div',
          { onClick: history.size ? this.undo : null, className: 'jsx-' + ActionsStyle.__scopedHash + ' ' + 'action',
            __source: {
              fileName: _jsxFileName,
              lineNumber: 715
            }
          },
          __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_10__svg_reload_svg__["a" /* default */], {
            __source: {
              fileName: _jsxFileName,
              lineNumber: 716
            }
          }),
          'Undo'
        ),
        __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
          'div',
          { onClick: history.size ? this.redo : null, className: 'jsx-' + ActionsStyle.__scopedHash + ' ' + 'action redo',
            __source: {
              fileName: _jsxFileName,
              lineNumber: 718
            }
          },
          __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_10__svg_reload_svg__["a" /* default */], {
            __source: {
              fileName: _jsxFileName,
              lineNumber: 719
            }
          }),
          'Redo'
        ),
        __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
          'div',
          { onClick: !prefilled ? this.eraseSelected : null, className: 'jsx-' + ActionsStyle.__scopedHash + ' ' + 'action',
            __source: {
              fileName: _jsxFileName,
              lineNumber: 721
            }
          },
          __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_9__svg_remove_svg__["a" /* default */], {
            __source: {
              fileName: _jsxFileName,
              lineNumber: 722
            }
          }),
          'Erase'
        ),
        __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
          'div',
          {
            onClick: !prefilled ? this.fillSelectedWithSolution : null,
            className: 'jsx-' + ActionsStyle.__scopedHash + ' ' + 'action',
            __source: {
              fileName: _jsxFileName,
              lineNumber: 724
            }
          },
          __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_8__svg_loupe_svg__["a" /* default */], {
            __source: {
              fileName: _jsxFileName,
              lineNumber: 729
            }
          }),
          'Hint'
        ),
        __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_0_styled_jsx_style___default.a, {
          styleId: ActionsStyle.__scopedHash,
          css: ActionsStyle.__scoped
        })
      );
    }
  }, {
    key: 'renderPuzzle',
    value: function renderPuzzle() {
      var _this6 = this;

      var board = this.state.board;

      return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
        'div',
        {
          className: 'jsx-' + PuzzleStyle.__scopedHash + ' ' + 'puzzle',
          __source: {
            fileName: _jsxFileName,
            lineNumber: 739
          }
        },
        board.get('puzzle').map(function (row, i) {
          return (
            // eslint-disable-next-line react/no-array-index-key
            __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
              'div',
              { key: i, className: 'jsx-' + PuzzleStyle.__scopedHash + ' ' + 'row',
                __source: {
                  fileName: _jsxFileName,
                  lineNumber: 742
                }
              },
              row.map(function (cell, j) {
                return _this6.renderCell(cell, i, j);
              }).toArray()
            )
          );
        }).toArray(),
        __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_0_styled_jsx_style___default.a, {
          styleId: PuzzleStyle.__scopedHash,
          css: PuzzleStyle.__scoped
        })
      );
    }
  }, {
    key: 'renderControls',
    value: function renderControls() {
      return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
        'div',
        {
          className: 'jsx-3626433229' + ' ' + 'controls',
          __source: {
            fileName: _jsxFileName,
            lineNumber: 755
          }
        },
        this.renderNumberControl(),
        this.renderActions(),
        __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_0_styled_jsx_style___default.a, {
          styleId: '3626433229',
          css: '.controls.jsx-3626433229{margin-top:.3em;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;width:100%;padding:.5em 0;}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhZ2VzL2luZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQXN2Qm9CLEFBR2lDLGdCQUNILDBFQUNFLHlEQUNRLG1HQUNaLFdBQ0ksZUFDbkIiLCJmaWxlIjoicGFnZXMvaW5kZXguanMiLCJzb3VyY2VSb290IjoiL1VzZXJzL2xpY2hlbm1hL1Byb2plY3RzL1N1RHVva3UvU3VEdW9rdSIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIGpzeC1hMTF5L2FjY2Vzc2libGUtZW1vamkgKi9cbmltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFNldCwgTGlzdCwgZnJvbUpTIH0gZnJvbSAnaW1tdXRhYmxlJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgTmV4dEhlYWQgZnJvbSAnbmV4dC9oZWFkJztcbmltcG9ydCBDb2xvciBmcm9tICdjb2xvcic7XG5pbXBvcnQgSW5wdXRSYW5nZSBmcm9tICdyZWFjdC1pbnB1dC1yYW5nZSc7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tZXh0cmFuZW91cy1kZXBlbmRlbmNpZXNcbmltcG9ydCBjc3MgZnJvbSAnc3R5bGVkLWpzeC9jc3MnO1xuXG5pbXBvcnQgUmFuZ2VTdHlsZSBmcm9tICcuLi9pbnB1dC1yYW5nZS1zdHlsZSc7XG5pbXBvcnQgTG91cGVJY29uIGZyb20gJy4uL3N2Zy9sb3VwZS5zdmcnO1xuaW1wb3J0IFJlbW92ZUljb24gZnJvbSAnLi4vc3ZnL3JlbW92ZS5zdmcnO1xuaW1wb3J0IFJlbG9hZEljb24gZnJvbSAnLi4vc3ZnL3JlbG9hZC5zdmcnO1xuaW1wb3J0IFJldHVybkljb24gZnJvbSAnLi4vc3ZnL3JldHVybi5zdmcnO1xuXG5pbXBvcnQgeyBtYWtlUHV6emxlLCBwbHVjaywgaXNQZWVyIGFzIGFyZUNvb3JkaW5hdGVQZWVycywgcmFuZ2UgfSBmcm9tICcuLi9zdWRva3UnO1xuaW1wb3J0IHsgYmFja0dyb3VuZEJsdWUgfSBmcm9tICcuLi9jb2xvcnMnO1xuaW1wb3J0IFRpcCBmcm9tICcuLi9jb21wb25lbnRzL3Rvb2wtdGlwJztcblxuaW1wb3J0IGlvIGZyb20gJ3NvY2tldC5pby1jbGllbnQnXG5cbmNvbnN0IERlc2NyaXB0aW9uID0gJ0Rpc2NvdmVyIHRoZSBuZXh0IGV2b2x1dGlvbiBvZiBTdWRva3Ugd2l0aCBhbWF6aW5nIGdyYXBoaWNzLCBhbmltYXRpb25zLCBhbmQgdXNlci1mcmllbmRseSBmZWF0dXJlcy4gRW5qb3kgYSBTdWRva3UgZXhwZXJpZW5jZSBsaWtlIHlvdSBuZXZlciBoYXZlIGJlZm9yZSB3aXRoIGN1c3RvbWl6YWJsZSBnYW1lIGdlbmVyYXRpb24sIGNlbGwgaGlnaGxpZ2h0aW5nLCBpbnR1aXRpdmUgY29udHJvbHMgYW5kIG1vcmUhJztcbmNvbnN0IGNlbGxXaWR0aCA9IDIuNTtcblxuY29uc3QgTGlnaHRCbHVlMTAwID0gJyNCM0U1RkMnO1xuY29uc3QgTGlnaHRCbHVlMjAwID0gJyM4MUQ0RkEnO1xuY29uc3QgTGlnaHRCbHVlMzAwID0gJyM0RkMzRjcnO1xuY29uc3QgSW5kaWdvNzAwID0gJyMzMDNGOUYnO1xuY29uc3QgRGVlcE9yYW5nZTIwMCA9ICcjRkZBQjkxJztcbmNvbnN0IERlZXBPcmFuZ2U2MDAgPSAnI0Y0NTExRSc7XG5jb25zdCBDb250cm9sTnVtYmVyQ29sb3IgPSBJbmRpZ283MDA7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sb25lLWJsb2Nrc1xueyAvKiBsYW5ndWFnZT1DU1MgKi8gfVxuY29uc3QgQ2VsbFN0eWxlID0gY3NzYFxuLmNlbGwge1xuICAgIGhlaWdodDogJHtjZWxsV2lkdGh9ZW07XG4gICAgd2lkdGg6ICR7Y2VsbFdpZHRofWVtO1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC13cmFwOiB3cmFwO1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgZm9udC1zaXplOiAxLjFlbTtcbiAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICB0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kLWNvbG9yIC4zcyBlYXNlLWluLW91dDtcbn1cbi5jZWxsOm50aC1jaGlsZCgzbiszKTpub3QoOmxhc3QtY2hpbGQpIHtcbiAgICBib3JkZXItcmlnaHQ6IDJweCBzb2xpZCBibGFjaztcbn1cbi5jZWxsOm5vdCg6bGFzdC1jaGlsZCkge1xuICAgIGJvcmRlci1yaWdodDogMXB4IHNvbGlkIGJsYWNrO1xufVxuLm5vdGUtbnVtYmVyIHtcbiAgICBmb250LXNpemU6IC42ZW07XG4gICAgd2lkdGg6IDMzJTtcbiAgICBoZWlnaHQ6IDMzJTtcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbn1cbmA7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sb25lLWJsb2Nrc1xueyAvKiBsYW5ndWFnZT1DU1MgKi8gfVxuY29uc3QgQWN0aW9uc1N0eWxlID0gY3NzYFxuLmFjdGlvbnMge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgbWF4LXdpZHRoOiA0MDBweDtcbiAgICBtYXJnaW4tdG9wOiAuNWVtO1xuICAgIHBhZGRpbmc6IDAgLjZlbTtcbn1cbi5hY3Rpb24ge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xufVxuLmFjdGlvbiA6Z2xvYmFsKHN2Zykge1xuICAgIHdpZHRoOiAyLjVlbTtcbiAgICBtYXJnaW4tYm90dG9tOiAuMmVtO1xufVxuLnJlZG8gOmdsb2JhbChzdmcpIHtcbiAgICB0cmFuc2Zvcm06IHNjYWxlWCgtMSk7XG59XG5gO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbG9uZS1ibG9ja3NcbnsgLyogbGFuZ3VhZ2U9Q1NTICovIH1cbmNvbnN0IENvbnRyb2xTdHlsZSA9IGNzc2Bcbi5jb250cm9sIHtcbiAgICBwYWRkaW5nOiAwIDJlbTtcbiAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgZGlzcGxheTogaW5saW5lLWZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBmbGV4LXdyYXA6IHdyYXA7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgZm9udC1mYW1pbHk6ICdTcGVjaWFsIEVsaXRlJywgY3Vyc2l2ZTtcbiAgICB0cmFuc2l0aW9uOiBmaWx0ZXIgLjVzIGVhc2UtaW4tb3V0O1xuICAgIHdpZHRoOiAxMDAlO1xufVxuYDtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxvbmUtYmxvY2tzXG57IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG5jb25zdCBOdW1iZXJDb250cm9sU3R5bGUgPSBjc3NgXG4ubnVtYmVyIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGZvbnQtc2l6ZTogMmVtO1xuICAgIG1hcmdpbjogLjFlbTtcbiAgICB3aWR0aDogMS41ZW07XG4gICAgaGVpZ2h0OiAxLjVlbTtcbiAgICBjb2xvcjogJHtDb250cm9sTnVtYmVyQ29sb3J9O1xuICAgIGJveC1zaGFkb3c6IDAgMXB4IDJweCByZ2JhKDAsMCwwLDAuMTYpLCAwIDFweCAycHggcmdiYSgwLDAsMCwwLjIzKTtcbiAgICBib3JkZXItcmFkaXVzOiA1MCU7XG59XG4ubnVtYmVyID4gZGl2IHtcbiAgICBtYXJnaW4tdG9wOiAuM2VtO1xufVxuYDtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxvbmUtYmxvY2tzXG57IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG5jb25zdCBQdXp6bGVTdHlsZSA9IGNzc2Bcbi5wdXp6bGUge1xuICAgIG1hcmdpbi10b3A6IC41ZW07XG4gICAgd2lkdGg6ICR7Y2VsbFdpZHRoICogOX1lbTtcbiAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgYm94LXNoYWRvdzogMCAzcHggNnB4IHJnYmEoMCwwLDAsMC4xNiksIDAgM3B4IDZweCByZ2JhKDAsMCwwLDAuMjMpO1xufVxuLnJvdyB7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGZsZXg6IDA7XG4gICAgd2lkdGg6ICR7Y2VsbFdpZHRoICogOX1lbTtcbn1cbi5yb3c6bm90KDpsYXN0LWNoaWxkKSB7XG4gICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkIGJsYWNrO1xufVxuLnJvdzpudGgtY2hpbGQoM24rMyk6bm90KDpsYXN0LWNoaWxkKSB7XG4gICAgYm9yZGVyLWJvdHRvbTogMnB4IHNvbGlkIGJsYWNrICFpbXBvcnRhbnQ7XG59XG5gO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbG9uZS1ibG9ja3NcbnsgLyogbGFuZ3VhZ2U9Q1NTICovIH1cbmNvbnN0IENpcmN1bHVhclByb2dyZXNzU3R5bGUgPSBjc3NgXG4uY2lyY3VsYXItcHJvZ3Jlc3Mge1xuICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB0b3A6IDA7XG4gICAgbGVmdDogMDtcbiAgICB0cmFuc2l0aW9uOiBmaWx0ZXIgLjRzIGVhc2UtaW4tb3V0O1xufVxuXG4uY2lyY2xlLWJnIHtcbiAgICBmaWxsOiBub25lO1xuICAgIHN0cm9rZTogI2VlZTtcbiAgICBzdHJva2Utd2lkdGg6IDMuODtcbn1cblxuLmNpcmNsZSB7XG4gICAgc3Ryb2tlOiAke0NvbnRyb2xOdW1iZXJDb2xvcn07XG4gICAgdHJhbnNpdGlvbjogc3Ryb2tlLWRhc2hhcnJheSAuNHMgZWFzZS1pbi1vdXQ7XG4gICAgZmlsbDogbm9uZTtcbiAgICBzdHJva2Utd2lkdGg6IDIuODtcbiAgICBzdHJva2UtbGluZWNhcDogcm91bmQ7XG59XG5gO1xuXG5jb25zdCBDaXJjdWxhclBhdGhEID0gJ00xOCAyLjA4NDUgYSAxNS45MTU1IDE1LjkxNTUgMCAwIDEgMCAzMS44MzEgYSAxNS45MTU1IDE1LjkxNTUgMCAwIDEgMCAtMzEuODMxJztcblxuZnVuY3Rpb24gZ2V0QmFja0dyb3VuZENvbG9yKHtcbiAgY29uZmxpY3QsIGlzUGVlciwgc2FtZVZhbHVlLCBpc1NlbGVjdGVkLFxufSkge1xuICBpZiAoY29uZmxpY3QgJiYgaXNQZWVyICYmIHNhbWVWYWx1ZSkge1xuICAgIHJldHVybiBEZWVwT3JhbmdlMjAwO1xuICB9IGVsc2UgaWYgKHNhbWVWYWx1ZSkge1xuICAgIHJldHVybiBMaWdodEJsdWUzMDA7XG4gIH0gZWxzZSBpZiAoaXNTZWxlY3RlZCkge1xuICAgIHJldHVybiBMaWdodEJsdWUyMDA7XG4gIH0gZWxzZSBpZiAoaXNQZWVyKSB7XG4gICAgcmV0dXJuIExpZ2h0Qmx1ZTEwMDtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldEZvbnRDb2xvcih7IHZhbHVlLCBjb25mbGljdCwgcHJlZmlsbGVkIH0pIHtcbiAgaWYgKGNvbmZsaWN0ICYmICFwcmVmaWxsZWQpIHtcbiAgICByZXR1cm4gRGVlcE9yYW5nZTYwMDtcbiAgfSBlbHNlIGlmICghcHJlZmlsbGVkICYmIHZhbHVlKSB7XG4gICAgcmV0dXJuIENvbnRyb2xOdW1iZXJDb2xvcjtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmNsYXNzIEdlbmVyYXRpb25VSSBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuXG4gICAgdGhpcy5zdGF0ZSA9IHsgdmFsdWU6IDMwIH07XG4gIH1cblxuICBnZW5lcmF0ZUdhbWUgPSAoKSA9PiB7XG4gICAgdGhpcy5wcm9wcy5nZW5lcmF0ZUdhbWUodGhpcy5zdGF0ZS52YWx1ZSk7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ2VuZXJhdGlvblwiPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvcHlcIj5TdGFydCB3aXRoIHt0aGlzLnN0YXRlLnZhbHVlfSBjZWxscyBwcmVmaWxsZWQ8L2Rpdj5cbiAgICAgICAgPElucHV0UmFuZ2VcbiAgICAgICAgICBtYXhWYWx1ZT17ODF9XG4gICAgICAgICAgbWluVmFsdWU9ezE3fVxuICAgICAgICAgIHZhbHVlPXt0aGlzLnN0YXRlLnZhbHVlfVxuICAgICAgICAgIG9uQ2hhbmdlPXt2YWx1ZSA9PiB0aGlzLnNldFN0YXRlKHsgdmFsdWUgfSl9XG4gICAgICAgIC8+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYnV0dG9uXCIgb25DbGljaz17dGhpcy5nZW5lcmF0ZUdhbWV9PlBsYXkgU3Vkb2t1PC9kaXY+XG4gICAgICAgIHsgLyogbGFuZ3VhZ2U9Q1NTICovIH1cbiAgICAgICAgPHN0eWxlIGpzeD57YFxuICAgICAgICAgICAgLmNvcHkge1xuICAgICAgICAgICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICAgICAgICAgICAgICBmb250LXNpemU6IDEuM2VtO1xuICAgICAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IC41ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAuZ2VuZXJhdGlvbiB7XG4gICAgICAgICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgICAgICAgICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6Z2xvYmFsKC5pbnB1dC1yYW5nZSkge1xuICAgICAgICAgICAgICAgIHdpZHRoOiA4MCU7XG4gICAgICAgICAgICAgICAgbWF4LXdpZHRoOiA1MDBweDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC5idXR0b24ge1xuICAgICAgICAgICAgICBtYXJnaW4tdG9wOiAuNWVtO1xuICAgICAgICAgICAgICBib3JkZXItcmFkaXVzOiAuMjVlbTtcbiAgICAgICAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgICAgICAgICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICAgICAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xuICAgICAgICAgICAgICBjb2xvcjogI2ZmZjtcbiAgICAgICAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gICAgICAgICAgICAgIHRyYW5zaXRpb246IGFsbCAuMjVzO1xuICAgICAgICAgICAgICBwYWRkaW5nOiA1cHggMTBweDtcbiAgICAgICAgICAgICAgZm9udC1zaXplOiAxLjRlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC5idXR0b246YWN0aXZlIHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoMHB4LCA1cHgpO1xuICAgICAgICAgICAgICBib3gtc2hhZG93OiAwIDFweCAwIDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC5idXR0b24ge1xuICAgICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAke2JhY2tHcm91bmRCbHVlfTtcbiAgICAgICAgICAgICAgYm94LXNoYWRvdzogMCAycHggNHB4IDAgJHtDb2xvcihiYWNrR3JvdW5kQmx1ZSkuZGFya2VuKDAuNSkuaHNsKCkuc3RyaW5nKCl9O1xuICAgICAgICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAuYnV0dG9uOmhvdmVyIHtcbiAgICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogJHtDb2xvcihiYWNrR3JvdW5kQmx1ZSkubGlnaHRlbigwLjIpLmhzbCgpLnN0cmluZygpfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgYH1cbiAgICAgICAgPC9zdHlsZT5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cbn1cblxuR2VuZXJhdGlvblVJLnByb3BUeXBlcyA9IHtcbiAgZ2VuZXJhdGVHYW1lOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxufTtcblxuY29uc3QgTnVtYmVyQ29udHJvbCA9ICh7IG51bWJlciwgb25DbGljaywgY29tcGxldGlvblBlcmNlbnRhZ2UgfSkgPT4gKFxuICA8ZGl2XG4gICAga2V5PXtudW1iZXJ9XG4gICAgY2xhc3NOYW1lPVwibnVtYmVyXCJcbiAgICBvbkNsaWNrPXtvbkNsaWNrfVxuICA+XG4gICAgPGRpdj57bnVtYmVyfTwvZGl2PlxuICAgIDxDaXJjbHVsYXJQcm9ncmVzcyBwZXJjZW50PXtjb21wbGV0aW9uUGVyY2VudGFnZX0gLz5cbiAgICA8c3R5bGUganN4PntOdW1iZXJDb250cm9sU3R5bGV9PC9zdHlsZT5cbiAgPC9kaXY+XG4pO1xuXG5OdW1iZXJDb250cm9sLnByb3BUeXBlcyA9IHtcbiAgbnVtYmVyOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIG9uQ2xpY2s6IFByb3BUeXBlcy5mdW5jLFxuICBjb21wbGV0aW9uUGVyY2VudGFnZTogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxufTtcblxuTnVtYmVyQ29udHJvbC5kZWZhdWx0UHJvcHMgPSB7XG4gIG9uQ2xpY2s6IG51bGwsXG59O1xuXG5jb25zdCBDZWxsID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHtcbiAgICB2YWx1ZSwgb25DbGljaywgaXNQZWVyLCBpc1NlbGVjdGVkLCBzYW1lVmFsdWUsIHByZWZpbGxlZCwgbm90ZXMsIGNvbmZsaWN0LFxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IGJhY2tncm91bmRDb2xvciA9IGdldEJhY2tHcm91bmRDb2xvcih7XG4gICAgY29uZmxpY3QsIGlzUGVlciwgc2FtZVZhbHVlLCBpc1NlbGVjdGVkLFxuICB9KTtcbiAgY29uc3QgZm9udENvbG9yID0gZ2V0Rm9udENvbG9yKHsgY29uZmxpY3QsIHByZWZpbGxlZCwgdmFsdWUgfSk7XG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJjZWxsXCIgb25DbGljaz17b25DbGlja30+XG4gICAgICB7XG4gICAgICAgIG5vdGVzID9cbiAgICAgICAgICByYW5nZSg5KS5tYXAoaSA9PlxuICAgICAgICAgICAgKFxuICAgICAgICAgICAgICA8ZGl2IGtleT17aX0gY2xhc3NOYW1lPVwibm90ZS1udW1iZXJcIj5cbiAgICAgICAgICAgICAgICB7bm90ZXMuaGFzKGkgKyAxKSAmJiAoaSArIDEpfVxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICkpIDpcbiAgICAgICAgICB2YWx1ZSAmJiB2YWx1ZVxuICAgICAgfVxuICAgICAgey8qIGxhbmd1YWdlPUNTUyAqL31cbiAgICAgIDxzdHlsZSBqc3g+e0NlbGxTdHlsZX08L3N0eWxlPlxuICAgICAgPHN0eWxlIGpzeD57YFxuICAgICAgICAgICAgICAgIC5jZWxsIHtcbiAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogJHtiYWNrZ3JvdW5kQ29sb3IgfHwgJ2luaXRpYWwnfTtcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6ICR7Zm9udENvbG9yIHx8ICdpbml0aWFsJ307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgYH1cbiAgICAgIDwvc3R5bGU+XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5DZWxsLnByb3BUeXBlcyA9IHtcbiAgLy8gY3VycmVudCBudW1iZXIgdmFsdWVcbiAgdmFsdWU6IFByb3BUeXBlcy5udW1iZXIsXG4gIC8vIGNlbGwgY2xpY2sgaGFuZGxlclxuICBvbkNsaWNrOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAvLyBpZiB0aGUgY2VsbCBpcyBhIHBlZXIgb2YgdGhlIHNlbGVjdGVkIGNlbGxcbiAgaXNQZWVyOiBQcm9wVHlwZXMuYm9vbC5pc1JlcXVpcmVkLFxuICAvLyBpZiB0aGUgY2VsbCBpcyBzZWxlY3RlZCBieSB0aGUgdXNlclxuICBpc1NlbGVjdGVkOiBQcm9wVHlwZXMuYm9vbC5pc1JlcXVpcmVkLFxuICAvLyBjdXJyZW50IGNlbGwgaGFzIHRoZSBzYW1lIHZhbHVlIGlmIHRoZSB1c2VyIHNlbGVjdGVkIGNlbGxcbiAgc2FtZVZhbHVlOiBQcm9wVHlwZXMuYm9vbC5pc1JlcXVpcmVkLFxuICAvLyBpZiB0aGlzIHdhcyBwcmVmaWxsZWQgYXMgYSBwYXJ0IG9mIHRoZSBwdXp6bGVcbiAgcHJlZmlsbGVkOiBQcm9wVHlwZXMuYm9vbC5pc1JlcXVpcmVkLFxuICAvLyBjdXJyZW50IG5vdGVzIHRha2VuIG9uIHRoZSBjZWxsXG4gIG5vdGVzOiBQcm9wVHlwZXMuaW5zdGFuY2VPZihTZXQpLFxuICAvLyBpZiB0aGUgY3VycmVudCBjZWxsIGRvZXMgbm90IHNhdGlzZnkgdGhlIGdhbWUgY29uc3RyYWludFxuICBjb25mbGljdDogUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZCxcbn07XG5cbkNlbGwuZGVmYXVsdFByb3BzID0ge1xuICBub3RlczogbnVsbCxcbiAgdmFsdWU6IG51bGwsXG59O1xuXG5jb25zdCBDaXJjbHVsYXJQcm9ncmVzcyA9ICh7IHBlcmNlbnQgfSkgPT4gKFxuICA8c3ZnIHZpZXdCb3g9XCIwIDAgMzYgMzZcIiBjbGFzc05hbWU9XCJjaXJjdWxhci1wcm9ncmVzc1wiPlxuICAgIDxwYXRoXG4gICAgICBjbGFzc05hbWU9XCJjaXJjbGUtYmdcIlxuICAgICAgZD17Q2lyY3VsYXJQYXRoRH1cbiAgICAvPlxuICAgIDxwYXRoXG4gICAgICBjbGFzc05hbWU9XCJjaXJjbGVcIlxuICAgICAgc3Ryb2tlRGFzaGFycmF5PXtgJHtwZXJjZW50ICogMTAwfSwgMTAwYH1cbiAgICAgIGQ9e0NpcmN1bGFyUGF0aER9XG4gICAgLz5cbiAgICB7IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG4gICAgPHN0eWxlIGpzeD57Q2lyY3VsdWFyUHJvZ3Jlc3NTdHlsZX08L3N0eWxlPlxuICA8L3N2Zz5cbik7XG5cbkNpcmNsdWxhclByb2dyZXNzLnByb3BUeXBlcyA9IHtcbiAgcGVyY2VudDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxufTtcblxuZnVuY3Rpb24gZ2V0Q2xpY2tIYW5kbGVyKG9uQ2xpY2ssIG9uRG91YmxlQ2xpY2ssIGRlbGF5ID0gMjUwKSB7XG4gIGxldCB0aW1lb3V0SUQgPSBudWxsO1xuICByZXR1cm4gKGV2ZW50KSA9PiB7XG4gICAgaWYgKCF0aW1lb3V0SUQpIHtcbiAgICAgIHRpbWVvdXRJRCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBvbkNsaWNrKGV2ZW50KTtcbiAgICAgICAgdGltZW91dElEID0gbnVsbDtcbiAgICAgIH0sIGRlbGF5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGltZW91dElEID0gY2xlYXJUaW1lb3V0KHRpbWVvdXRJRCk7XG4gICAgICBvbkRvdWJsZUNsaWNrKGV2ZW50KTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogbWFrZSBzaXplIDkgYXJyYXkgb2YgMHNcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZnVuY3Rpb24gbWFrZUNvdW50T2JqZWN0KCkge1xuICBjb25zdCBjb3VudE9iaiA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpICs9IDEpIGNvdW50T2JqLnB1c2goMCk7XG4gIHJldHVybiBjb3VudE9iajtcbn1cblxuLyoqXG4gKiBnaXZlbiBhIDJEIGFycmF5IG9mIG51bWJlcnMgYXMgdGhlIGluaXRpYWwgcHV6emxlLCBnZW5lcmF0ZSB0aGUgaW5pdGlhbCBnYW1lIHN0YXRlXG4gKiBAcGFyYW0gcHV6emxlXG4gKiBAcmV0dXJucyB7YW55fVxuICovXG5mdW5jdGlvbiBtYWtlQm9hcmQoeyBwdXp6bGUgfSkge1xuICAvLyBjcmVhdGUgaW5pdGlhbCBjb3VudCBvYmplY3QgdG8ga2VlcCB0cmFjayBvZiBjb25mbGljdHMgcGVyIG51bWJlciB2YWx1ZVxuICBjb25zdCByb3dzID0gQXJyYXkuZnJvbShBcnJheSg5KS5rZXlzKCkpLm1hcCgoKSA9PiBtYWtlQ291bnRPYmplY3QoKSk7XG4gIGNvbnN0IGNvbHVtbnMgPSBBcnJheS5mcm9tKEFycmF5KDkpLmtleXMoKSkubWFwKCgpID0+IG1ha2VDb3VudE9iamVjdCgpKTtcbiAgY29uc3Qgc3F1YXJlcyA9IEFycmF5LmZyb20oQXJyYXkoOSkua2V5cygpKS5tYXAoKCkgPT4gbWFrZUNvdW50T2JqZWN0KCkpO1xuICBjb25zdCByZXN1bHQgPSBwdXp6bGUubWFwKChyb3csIGkpID0+IChcbiAgICByb3cubWFwKChjZWxsLCBqKSA9PiB7XG4gICAgICBpZiAoY2VsbCkge1xuICAgICAgICByb3dzW2ldW2NlbGxdICs9IDE7XG4gICAgICAgIGNvbHVtbnNbal1bY2VsbF0gKz0gMTtcbiAgICAgICAgc3F1YXJlc1soKE1hdGguZmxvb3IoaSAvIDMpKSAqIDMpICsgTWF0aC5mbG9vcihqIC8gMyldW2NlbGxdICs9IDE7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogcHV6emxlW2ldW2pdID4gMCA/IHB1enpsZVtpXVtqXSA6IG51bGwsXG4gICAgICAgIHByZWZpbGxlZDogISFwdXp6bGVbaV1bal0sXG4gICAgICB9O1xuICAgIH0pXG4gICkpO1xuICByZXR1cm4gZnJvbUpTKHsgcHV6emxlOiByZXN1bHQsIHNlbGVjdGVkOiBmYWxzZSwgY2hvaWNlczogeyByb3dzLCBjb2x1bW5zLCBzcXVhcmVzIH0gfSk7XG59XG5cbi8qKlxuICogZ2l2ZSB0aGUgY29vcmRpbmF0ZSB1cGRhdGUgdGhlIGN1cnJlbnQgYm9hcmQgd2l0aCBhIG51bWJlciBjaG9pY2VcbiAqIEBwYXJhbSB4XG4gKiBAcGFyYW0geVxuICogQHBhcmFtIG51bWJlclxuICogQHBhcmFtIGZpbGwgd2hldGhlciB0byBzZXQgb3IgdW5zZXRcbiAqIEBwYXJhbSBib2FyZCB0aGUgaW1tdXRhYmxlIGJvYXJkIGdpdmVuIHRvIGNoYW5nZVxuICovXG5mdW5jdGlvbiB1cGRhdGVCb2FyZFdpdGhOdW1iZXIoe1xuICB4LCB5LCBudW1iZXIsIGZpbGwgPSB0cnVlLCBib2FyZCxcbn0pIHtcbiAgbGV0IGNlbGwgPSBib2FyZC5nZXQoJ3B1enpsZScpLmdldEluKFt4LCB5XSk7XG4gIC8vIGRlbGV0ZSBpdHMgbm90ZXNcbiAgY2VsbCA9IGNlbGwuZGVsZXRlKCdub3RlcycpO1xuICAvLyBzZXQgb3IgdW5zZXQgaXRzIHZhbHVlIGRlcGVuZGluZyBvbiBgZmlsbGBcbiAgY2VsbCA9IGZpbGwgPyBjZWxsLnNldCgndmFsdWUnLCBudW1iZXIpIDogY2VsbC5kZWxldGUoJ3ZhbHVlJyk7XG4gIGNvbnN0IGluY3JlbWVudCA9IGZpbGwgPyAxIDogLTE7XG4gIC8vIHVwZGF0ZSB0aGUgY3VycmVudCBncm91cCBjaG9pY2VzXG4gIGNvbnN0IHJvd1BhdGggPSBbJ2Nob2ljZXMnLCAncm93cycsIHgsIG51bWJlcl07XG4gIGNvbnN0IGNvbHVtblBhdGggPSBbJ2Nob2ljZXMnLCAnY29sdW1ucycsIHksIG51bWJlcl07XG4gIGNvbnN0IHNxdWFyZVBhdGggPSBbJ2Nob2ljZXMnLCAnc3F1YXJlcycsXG4gICAgKChNYXRoLmZsb29yKHggLyAzKSkgKiAzKSArIE1hdGguZmxvb3IoeSAvIDMpLCBudW1iZXJdO1xuICByZXR1cm4gYm9hcmQuc2V0SW4ocm93UGF0aCwgYm9hcmQuZ2V0SW4ocm93UGF0aCkgKyBpbmNyZW1lbnQpXG4gICAgLnNldEluKGNvbHVtblBhdGgsIGJvYXJkLmdldEluKGNvbHVtblBhdGgpICsgaW5jcmVtZW50KVxuICAgIC5zZXRJbihzcXVhcmVQYXRoLCBib2FyZC5nZXRJbihzcXVhcmVQYXRoKSArIGluY3JlbWVudClcbiAgICAuc2V0SW4oWydwdXp6bGUnLCB4LCB5XSwgY2VsbCk7XG59XG5cbmZ1bmN0aW9uIGdldE51bWJlck9mR3JvdXBzQXNzaWduZWRGb3JOdW1iZXIobnVtYmVyLCBncm91cHMpIHtcbiAgcmV0dXJuIGdyb3Vwcy5yZWR1Y2UoKGFjY3VtdWxhdG9yLCByb3cpID0+XG4gICAgYWNjdW11bGF0b3IgKyAocm93LmdldChudW1iZXIpID4gMCA/IDEgOiAwKSwgMCk7XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3Qvbm8tbXVsdGktY29tcFxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW5kZXggZXh0ZW5kcyBDb21wb25lbnQge1xuICBzdGF0ZSA9IHt9O1xuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgIGlmICgnc2VydmljZVdvcmtlcicgaW4gbmF2aWdhdG9yKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICAgIG5hdmlnYXRvci5zZXJ2aWNlV29ya2VyXG4gICAgICAgIC5yZWdpc3RlcignL3NlcnZpY2Utd29ya2VyLmpzJylcbiAgICAgICAgLnRoZW4oKHJlZykgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdTZXJ2aWNlV29ya2VyIHNjb3BlOiAnLCByZWcuc2NvcGUpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdzZXJ2aWNlIHdvcmtlciByZWdpc3RyYXRpb24gc3VjY2Vzc2Z1bCcpO1xuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgIGNvbnNvbGUud2Fybignc2VydmljZSB3b3JrZXIgcmVnaXN0cmF0aW9uIGZhaWxlZCcsIGVyci5tZXNzYWdlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICBcbiAgICBmZXRjaCgnL2FwaS9zb2NrZXRpbycpLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgY29uc3Qgc29ja2V0ID0gaW8oKVxuXG4gICAgICBzb2NrZXQub24oJ2Nvbm5lY3QnLCAoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdjb25uZWN0JylcbiAgICAgICAgc29ja2V0LmVtaXQoJ2hlbGxvJylcbiAgICAgIH0pXG5cbiAgICAgIHNvY2tldC5vbignaGVsbG8nLCBkYXRhID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ2hlbGxvJywgZGF0YSlcbiAgICAgIH0pXG5cbiAgICAgIHNvY2tldC5vbignYSB1c2VyIGNvbm5lY3RlZCcsICgpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ2EgdXNlciBjb25uZWN0ZWQnKVxuICAgICAgfSlcblxuICAgICAgc29ja2V0Lm9uKCdkaXNjb25uZWN0JywgKCkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZygnZGlzY29ubmVjdCcpXG4gICAgICB9KVxuICAgIH0pXG4gICBcbiAgfVxuICBnZXRTZWxlY3RlZENlbGwoKSB7XG4gICAgY29uc3QgeyBib2FyZCB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBzZWxlY3RlZCA9IGJvYXJkLmdldCgnc2VsZWN0ZWQnKTtcbiAgICByZXR1cm4gc2VsZWN0ZWQgJiYgYm9hcmQuZ2V0KCdwdXp6bGUnKS5nZXRJbihbc2VsZWN0ZWQueCwgc2VsZWN0ZWQueV0pO1xuICB9XG5cbiAgLy8gZ2V0IHRoZSBtaW4gYmV0d2VlbiBpdHMgY29tcGxldGlvbiBpbiByb3dzLCBjb2x1bW5zIGFuZCBzcXVhcmVzLlxuICBnZXROdW1iZXJWYWx1ZUNvdW50KG51bWJlcikge1xuICAgIGNvbnN0IHJvd3MgPSB0aGlzLnN0YXRlLmJvYXJkLmdldEluKFsnY2hvaWNlcycsICdyb3dzJ10pO1xuICAgIGNvbnN0IGNvbHVtbnMgPSB0aGlzLnN0YXRlLmJvYXJkLmdldEluKFsnY2hvaWNlcycsICdjb2x1bW5zJ10pO1xuICAgIGNvbnN0IHNxdWFyZXMgPSB0aGlzLnN0YXRlLmJvYXJkLmdldEluKFsnY2hvaWNlcycsICdzcXVhcmVzJ10pO1xuICAgIHJldHVybiBNYXRoLm1pbihcbiAgICAgIGdldE51bWJlck9mR3JvdXBzQXNzaWduZWRGb3JOdW1iZXIobnVtYmVyLCBzcXVhcmVzKSxcbiAgICAgIE1hdGgubWluKFxuICAgICAgICBnZXROdW1iZXJPZkdyb3Vwc0Fzc2lnbmVkRm9yTnVtYmVyKG51bWJlciwgcm93cyksXG4gICAgICAgIGdldE51bWJlck9mR3JvdXBzQXNzaWduZWRGb3JOdW1iZXIobnVtYmVyLCBjb2x1bW5zKSxcbiAgICAgICksXG4gICAgKTtcbiAgfVxuXG4gIGdlbmVyYXRlR2FtZSA9IChmaW5hbENvdW50ID0gMjApID0+IHtcbiAgICAvLyBnZXQgYSBmaWxsZWQgcHV6emxlIGdlbmVyYXRlZFxuICAgIGNvbnN0IHNvbHV0aW9uID0gbWFrZVB1enpsZSgpO1xuICAgIC8vIHBsdWNrIHZhbHVlcyBmcm9tIGNlbGxzIHRvIGNyZWF0ZSB0aGUgZ2FtZVxuICAgIGNvbnN0IHsgcHV6emxlIH0gPSBwbHVjayhzb2x1dGlvbiwgZmluYWxDb3VudCk7XG4gICAgLy8gaW5pdGlhbGl6ZSB0aGUgYm9hcmQgd2l0aCBjaG9pY2UgY291bnRzXG4gICAgY29uc3QgYm9hcmQgPSBtYWtlQm9hcmQoeyBwdXp6bGUgfSk7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBib2FyZCwgaGlzdG9yeTogTGlzdC5vZihib2FyZCksIGhpc3RvcnlPZmZTZXQ6IDAsIHNvbHV0aW9uLFxuICAgIH0pO1xuICB9XG5cbiAgYWRkTnVtYmVyQXNOb3RlID0gKG51bWJlcikgPT4ge1xuICAgIGxldCB7IGJvYXJkIH0gPSB0aGlzLnN0YXRlO1xuICAgIGxldCBzZWxlY3RlZENlbGwgPSB0aGlzLmdldFNlbGVjdGVkQ2VsbCgpO1xuICAgIGlmICghc2VsZWN0ZWRDZWxsKSByZXR1cm47XG4gICAgY29uc3QgcHJlZmlsbGVkID0gc2VsZWN0ZWRDZWxsLmdldCgncHJlZmlsbGVkJyk7XG4gICAgaWYgKHByZWZpbGxlZCkgcmV0dXJuO1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gYm9hcmQuZ2V0KCdzZWxlY3RlZCcpO1xuICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHNlbGVjdGVkQ2VsbC5nZXQoJ3ZhbHVlJyk7XG4gICAgaWYgKGN1cnJlbnRWYWx1ZSkge1xuICAgICAgYm9hcmQgPSB1cGRhdGVCb2FyZFdpdGhOdW1iZXIoe1xuICAgICAgICB4LCB5LCBudW1iZXI6IGN1cnJlbnRWYWx1ZSwgZmlsbDogZmFsc2UsIGJvYXJkOiB0aGlzLnN0YXRlLmJvYXJkLFxuICAgICAgfSk7XG4gICAgfVxuICAgIGxldCBub3RlcyA9IHNlbGVjdGVkQ2VsbC5nZXQoJ25vdGVzJykgfHwgU2V0KCk7XG4gICAgaWYgKG5vdGVzLmhhcyhudW1iZXIpKSB7XG4gICAgICBub3RlcyA9IG5vdGVzLmRlbGV0ZShudW1iZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub3RlcyA9IG5vdGVzLmFkZChudW1iZXIpO1xuICAgIH1cbiAgICBzZWxlY3RlZENlbGwgPSBzZWxlY3RlZENlbGwuc2V0KCdub3RlcycsIG5vdGVzKTtcbiAgICBzZWxlY3RlZENlbGwgPSBzZWxlY3RlZENlbGwuZGVsZXRlKCd2YWx1ZScpO1xuICAgIGJvYXJkID0gYm9hcmQuc2V0SW4oWydwdXp6bGUnLCB4LCB5XSwgc2VsZWN0ZWRDZWxsKTtcbiAgICB0aGlzLnVwZGF0ZUJvYXJkKGJvYXJkKTtcbiAgfTtcblxuICB1cGRhdGVCb2FyZCA9IChuZXdCb2FyZCkgPT4ge1xuICAgIGxldCB7IGhpc3RvcnkgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgeyBoaXN0b3J5T2ZmU2V0IH0gPSB0aGlzLnN0YXRlO1xuICAgIC8vIGFueXRoaW5nIGJlZm9yZSBjdXJyZW50IHN0ZXAgaXMgc3RpbGwgaW4gaGlzdG9yeVxuICAgIGhpc3RvcnkgPSBoaXN0b3J5LnNsaWNlKDAsIGhpc3RvcnlPZmZTZXQgKyAxKTtcbiAgICAvLyBhZGQgaXRzZWxmIG9udG8gdGhlIGhpc3RvcnlcbiAgICBoaXN0b3J5ID0gaGlzdG9yeS5wdXNoKG5ld0JvYXJkKTtcbiAgICAvLyB1cGRhdGUgdGhlIGdhbWVcbiAgICB0aGlzLnNldFN0YXRlKHsgYm9hcmQ6IG5ld0JvYXJkLCBoaXN0b3J5LCBoaXN0b3J5T2ZmU2V0OiBoaXN0b3J5LnNpemUgLSAxIH0pO1xuICB9O1xuXG4gIGNhblVuZG8gPSAoKSA9PiB0aGlzLnN0YXRlLmhpc3RvcnlPZmZTZXQgPiAwXG5cbiAgcmVkbyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGhpc3RvcnkgfSA9IHRoaXMuc3RhdGU7XG4gICAgbGV0IHsgaGlzdG9yeU9mZlNldCB9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAoaGlzdG9yeS5zaXplKSB7XG4gICAgICBoaXN0b3J5T2ZmU2V0ID0gTWF0aC5taW4oaGlzdG9yeS5zaXplIC0gMSwgaGlzdG9yeU9mZlNldCArIDEpO1xuICAgICAgY29uc3QgYm9hcmQgPSBoaXN0b3J5LmdldChoaXN0b3J5T2ZmU2V0KTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBib2FyZCwgaGlzdG9yeU9mZlNldCB9KTtcbiAgICB9XG4gIH07XG5cbiAgdW5kbyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGhpc3RvcnkgfSA9IHRoaXMuc3RhdGU7XG4gICAgbGV0IHsgaGlzdG9yeU9mZlNldCwgYm9hcmQgfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKGhpc3Rvcnkuc2l6ZSkge1xuICAgICAgaGlzdG9yeU9mZlNldCA9IE1hdGgubWF4KDAsIGhpc3RvcnlPZmZTZXQgLSAxKTtcbiAgICAgIGJvYXJkID0gaGlzdG9yeS5nZXQoaGlzdG9yeU9mZlNldCk7XG4gICAgICB0aGlzLnNldFN0YXRlKHsgYm9hcmQsIGhpc3RvcnlPZmZTZXQsIGhpc3RvcnkgfSk7XG4gICAgfVxuICB9O1xuXG4gIGVyYXNlU2VsZWN0ZWQgPSAoKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0ZWRDZWxsID0gdGhpcy5nZXRTZWxlY3RlZENlbGwoKTtcbiAgICBpZiAoIXNlbGVjdGVkQ2VsbCkgcmV0dXJuO1xuICAgIHRoaXMuZmlsbE51bWJlcihmYWxzZSk7XG4gIH1cblxuICBmaWxsU2VsZWN0ZWRXaXRoU29sdXRpb24gPSAoKSA9PiB7XG4gICAgY29uc3QgeyBib2FyZCwgc29sdXRpb24gfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3Qgc2VsZWN0ZWRDZWxsID0gdGhpcy5nZXRTZWxlY3RlZENlbGwoKTtcbiAgICBpZiAoIXNlbGVjdGVkQ2VsbCkgcmV0dXJuO1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gYm9hcmQuZ2V0KCdzZWxlY3RlZCcpO1xuICAgIHRoaXMuZmlsbE51bWJlcihzb2x1dGlvblt4XVt5XSk7XG4gIH1cblxuXG4gIC8vIGZpbGwgY3VycmVudGx5IHNlbGVjdGVkIGNlbGwgd2l0aCBudW1iZXJcbiAgZmlsbE51bWJlciA9IChudW1iZXIpID0+IHtcbiAgICBsZXQgeyBib2FyZCB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBzZWxlY3RlZENlbGwgPSB0aGlzLmdldFNlbGVjdGVkQ2VsbCgpO1xuICAgIC8vIG5vLW9wIGlmIG5vdGhpbmcgaXMgc2VsZWN0ZWRcbiAgICBpZiAoIXNlbGVjdGVkQ2VsbCkgcmV0dXJuO1xuICAgIGNvbnN0IHByZWZpbGxlZCA9IHNlbGVjdGVkQ2VsbC5nZXQoJ3ByZWZpbGxlZCcpO1xuICAgIC8vIG5vLW9wIGlmIGl0IGlzIHJlZmlsbGVkXG4gICAgaWYgKHByZWZpbGxlZCkgcmV0dXJuO1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gYm9hcmQuZ2V0KCdzZWxlY3RlZCcpO1xuICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHNlbGVjdGVkQ2VsbC5nZXQoJ3ZhbHVlJyk7XG4gICAgLy8gcmVtb3ZlIHRoZSBjdXJyZW50IHZhbHVlIGFuZCB1cGRhdGUgdGhlIGdhbWUgc3RhdGVcbiAgICBpZiAoY3VycmVudFZhbHVlKSB7XG4gICAgICBib2FyZCA9IHVwZGF0ZUJvYXJkV2l0aE51bWJlcih7XG4gICAgICAgIHgsIHksIG51bWJlcjogY3VycmVudFZhbHVlLCBmaWxsOiBmYWxzZSwgYm9hcmQ6IHRoaXMuc3RhdGUuYm9hcmQsXG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gdXBkYXRlIHRvIG5ldyBudW1iZXIgaWYgYW55XG4gICAgY29uc3Qgc2V0TnVtYmVyID0gY3VycmVudFZhbHVlICE9PSBudW1iZXIgJiYgbnVtYmVyO1xuICAgIGlmIChzZXROdW1iZXIpIHtcbiAgICAgIGJvYXJkID0gdXBkYXRlQm9hcmRXaXRoTnVtYmVyKHtcbiAgICAgICAgeCwgeSwgbnVtYmVyLCBmaWxsOiB0cnVlLCBib2FyZCxcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZUJvYXJkKGJvYXJkKTtcbiAgfTtcblxuICBzZWxlY3RDZWxsID0gKHgsIHkpID0+IHtcbiAgICBsZXQgeyBib2FyZCB9ID0gdGhpcy5zdGF0ZTtcbiAgICBib2FyZCA9IGJvYXJkLnNldCgnc2VsZWN0ZWQnLCB7IHgsIHkgfSk7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IGJvYXJkIH0pO1xuICB9O1xuXG4gIGlzQ29uZmxpY3QoaSwgaikge1xuICAgIGNvbnN0IHsgdmFsdWUgfSA9IHRoaXMuc3RhdGUuYm9hcmQuZ2V0SW4oWydwdXp6bGUnLCBpLCBqXSkudG9KU09OKCk7XG4gICAgaWYgKCF2YWx1ZSkgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IHJvd0NvbmZsaWN0ID1cbiAgICAgIHRoaXMuc3RhdGUuYm9hcmQuZ2V0SW4oWydjaG9pY2VzJywgJ3Jvd3MnLCBpLCB2YWx1ZV0pID4gMTtcbiAgICBjb25zdCBjb2x1bW5Db25mbGljdCA9XG4gICAgICB0aGlzLnN0YXRlLmJvYXJkLmdldEluKFsnY2hvaWNlcycsICdjb2x1bW5zJywgaiwgdmFsdWVdKSA+IDE7XG4gICAgY29uc3Qgc3F1YXJlQ29uZmxpY3QgPVxuICAgICAgdGhpcy5zdGF0ZS5ib2FyZC5nZXRJbihbJ2Nob2ljZXMnLCAnc3F1YXJlcycsXG4gICAgICAgICgoTWF0aC5mbG9vcihpIC8gMykpICogMykgKyBNYXRoLmZsb29yKGogLyAzKSwgdmFsdWVdKSA+IDE7XG4gICAgcmV0dXJuIHJvd0NvbmZsaWN0IHx8IGNvbHVtbkNvbmZsaWN0IHx8IHNxdWFyZUNvbmZsaWN0O1xuICB9XG5cbiAgcmVuZGVyQ2VsbChjZWxsLCB4LCB5KSB7XG4gICAgY29uc3QgeyBib2FyZCB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBzZWxlY3RlZCA9IHRoaXMuZ2V0U2VsZWN0ZWRDZWxsKCk7XG4gICAgY29uc3QgeyB2YWx1ZSwgcHJlZmlsbGVkLCBub3RlcyB9ID0gY2VsbC50b0pTT04oKTtcbiAgICBjb25zdCBjb25mbGljdCA9IHRoaXMuaXNDb25mbGljdCh4LCB5KTtcbiAgICBjb25zdCBwZWVyID0gYXJlQ29vcmRpbmF0ZVBlZXJzKHsgeCwgeSB9LCBib2FyZC5nZXQoJ3NlbGVjdGVkJykpO1xuICAgIGNvbnN0IHNhbWVWYWx1ZSA9ICEhKHNlbGVjdGVkICYmIHNlbGVjdGVkLmdldCgndmFsdWUnKVxuICAgICAgJiYgdmFsdWUgPT09IHNlbGVjdGVkLmdldCgndmFsdWUnKSk7XG5cbiAgICBjb25zdCBpc1NlbGVjdGVkID0gY2VsbCA9PT0gc2VsZWN0ZWQ7XG4gICAgcmV0dXJuICg8Q2VsbFxuICAgICAgcHJlZmlsbGVkPXtwcmVmaWxsZWR9XG4gICAgICBub3Rlcz17bm90ZXN9XG4gICAgICBzYW1lVmFsdWU9e3NhbWVWYWx1ZX1cbiAgICAgIGlzU2VsZWN0ZWQ9e2lzU2VsZWN0ZWR9XG4gICAgICBpc1BlZXI9e3BlZXJ9XG4gICAgICB2YWx1ZT17dmFsdWV9XG4gICAgICBvbkNsaWNrPXsoKSA9PiB7IHRoaXMuc2VsZWN0Q2VsbCh4LCB5KTsgfX1cbiAgICAgIGtleT17eX1cbiAgICAgIHg9e3h9XG4gICAgICB5PXt5fVxuICAgICAgY29uZmxpY3Q9e2NvbmZsaWN0fVxuICAgIC8+KTtcbiAgfVxuXG4gIHJlbmRlck51bWJlckNvbnRyb2woKSB7XG4gICAgY29uc3Qgc2VsZWN0ZWRDZWxsID0gdGhpcy5nZXRTZWxlY3RlZENlbGwoKTtcbiAgICBjb25zdCBwcmVmaWxsZWQgPSBzZWxlY3RlZENlbGwgJiYgc2VsZWN0ZWRDZWxsLmdldCgncHJlZmlsbGVkJyk7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29udHJvbFwiPlxuICAgICAgICB7cmFuZ2UoOSkubWFwKChpKSA9PiB7XG4gICAgICAgICAgY29uc3QgbnVtYmVyID0gaSArIDE7XG4gICAgICAgICAgLy8gaGFuZGxlcyBiaW5kaW5nIHNpbmdsZSBjbGljayBhbmQgZG91YmxlIGNsaWNrIGNhbGxiYWNrc1xuICAgICAgICAgIGNvbnN0IGNsaWNrSGFuZGxlID0gZ2V0Q2xpY2tIYW5kbGVyKFxuICAgICAgICAgICAgKCkgPT4geyB0aGlzLmZpbGxOdW1iZXIobnVtYmVyKTsgfSxcbiAgICAgICAgICAgICgpID0+IHsgdGhpcy5hZGROdW1iZXJBc05vdGUobnVtYmVyKTsgfSxcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8TnVtYmVyQ29udHJvbFxuICAgICAgICAgICAgICBrZXk9e251bWJlcn1cbiAgICAgICAgICAgICAgbnVtYmVyPXtudW1iZXJ9XG4gICAgICAgICAgICAgIG9uQ2xpY2s9eyFwcmVmaWxsZWQgPyBjbGlja0hhbmRsZSA6IHVuZGVmaW5lZH1cbiAgICAgICAgICAgICAgY29tcGxldGlvblBlcmNlbnRhZ2U9e3RoaXMuZ2V0TnVtYmVyVmFsdWVDb3VudChudW1iZXIpIC8gOX1cbiAgICAgICAgICAgIC8+KTtcbiAgICAgICAgfSl9XG4gICAgICAgIDxzdHlsZSBqc3g+e0NvbnRyb2xTdHlsZX08L3N0eWxlPlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxuXG4gIHJlbmRlckFjdGlvbnMoKSB7XG4gICAgY29uc3QgeyBoaXN0b3J5IH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IHNlbGVjdGVkQ2VsbCA9IHRoaXMuZ2V0U2VsZWN0ZWRDZWxsKCk7XG4gICAgY29uc3QgcHJlZmlsbGVkID0gc2VsZWN0ZWRDZWxsICYmIHNlbGVjdGVkQ2VsbC5nZXQoJ3ByZWZpbGxlZCcpO1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImFjdGlvbnNcIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJhY3Rpb25cIiBvbkNsaWNrPXtoaXN0b3J5LnNpemUgPyB0aGlzLnVuZG8gOiBudWxsfT5cbiAgICAgICAgICA8UmVsb2FkSWNvbiAvPlVuZG9cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWN0aW9uIHJlZG9cIiBvbkNsaWNrPXtoaXN0b3J5LnNpemUgPyB0aGlzLnJlZG8gOiBudWxsfT5cbiAgICAgICAgICA8UmVsb2FkSWNvbiAvPlJlZG9cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWN0aW9uXCIgb25DbGljaz17IXByZWZpbGxlZCA/IHRoaXMuZXJhc2VTZWxlY3RlZCA6IG51bGx9PlxuICAgICAgICAgIDxSZW1vdmVJY29uIC8+RXJhc2VcbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXZcbiAgICAgICAgICBjbGFzc05hbWU9XCJhY3Rpb25cIlxuICAgICAgICAgIG9uQ2xpY2s9eyFwcmVmaWxsZWQgP1xuICAgICAgICAgIHRoaXMuZmlsbFNlbGVjdGVkV2l0aFNvbHV0aW9uIDogbnVsbH1cbiAgICAgICAgPlxuICAgICAgICAgIDxMb3VwZUljb24gLz5IaW50XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8c3R5bGUganN4PntBY3Rpb25zU3R5bGV9PC9zdHlsZT5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cblxuICByZW5kZXJQdXp6bGUoKSB7XG4gICAgY29uc3QgeyBib2FyZCB9ID0gdGhpcy5zdGF0ZTtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJwdXp6bGVcIj5cbiAgICAgICAge2JvYXJkLmdldCgncHV6emxlJykubWFwKChyb3csIGkpID0+IChcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3Qvbm8tYXJyYXktaW5kZXgta2V5XG4gICAgICAgICAgPGRpdiBrZXk9e2l9IGNsYXNzTmFtZT1cInJvd1wiPlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICByb3cubWFwKChjZWxsLCBqKSA9PiB0aGlzLnJlbmRlckNlbGwoY2VsbCwgaSwgaikpLnRvQXJyYXkoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICApKS50b0FycmF5KCl9XG4gICAgICAgIDxzdHlsZSBqc3g+e1B1enpsZVN0eWxlfTwvc3R5bGU+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG5cbiAgcmVuZGVyQ29udHJvbHMoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29udHJvbHNcIj5cbiAgICAgICAge3RoaXMucmVuZGVyTnVtYmVyQ29udHJvbCgpfVxuICAgICAgICB7dGhpcy5yZW5kZXJBY3Rpb25zKCl9XG4gICAgICAgIHsgLyogbGFuZ3VhZ2U9Q1NTICovIH1cbiAgICAgICAgPHN0eWxlIGpzeD57YFxuICAgICAgICAgICAgLmNvbnRyb2xzIHtcbiAgICAgICAgICAgICAgICBtYXJnaW4tdG9wOiAuM2VtO1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgICAgICAgZmxleC13cmFwOiB3cmFwO1xuICAgICAgICAgICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICAgICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICAgICAgICAgIHBhZGRpbmc6IC41ZW0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgYH1cbiAgICAgICAgPC9zdHlsZT5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cblxuICByZW5kZXJHZW5lcmF0aW9uVUkoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxHZW5lcmF0aW9uVUkgZ2VuZXJhdGVHYW1lPXt0aGlzLmdlbmVyYXRlR2FtZX0gLz5cbiAgICApO1xuICB9XG5cbiAgcmVuZGVySGVhZGVyKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImhlYWRlclwiPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm5ldy1nYW1lXCIgb25DbGljaz17KCkgPT4gdGhpcy5zZXRTdGF0ZSh7IGJvYXJkOiBmYWxzZSB9KX0+XG4gICAgICAgICAgPFJldHVybkljb24gLz5cbiAgICAgICAgICA8ZGl2Pk5ldyBHYW1lPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8VGlwIC8+XG4gICAgICAgIHsgLyogbGFuZ3VhZ2U9Q1NTICovIH1cbiAgICAgICAgPHN0eWxlIGpzeD57YFxuICAgICAgICAgICAgLmhlYWRlciB7XG4gICAgICAgICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gICAgICAgICAgICAgICAgbWF4LXdpZHRoOiA1MDBweDtcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiAwIDAuNWVtO1xuICAgICAgICAgICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAubmV3LWdhbWUge1xuICAgICAgICAgICAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICAgICAgICAgICAgICBtYXJnaW4tdG9wOiAuMmVtO1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6IGlubGluZS1mbGV4O1xuICAgICAgICAgICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgICAgICAgICAgcGFkZGluZzogLjJlbSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLm5ldy1nYW1lIDpnbG9iYWwoc3ZnKSB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxZW07XG4gICAgICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogLjNlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgYH1cbiAgICAgICAgPC9zdHlsZT5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBib2FyZCB9ID0gdGhpcy5zdGF0ZTtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJib2R5XCI+XG4gICAgICAgIDxOZXh0SGVhZD5cbiAgICAgICAgICA8dGl0bGU+U3Vkb2t1IEV2b2x2ZWQ8L3RpdGxlPlxuICAgICAgICAgIDxtZXRhIG5hbWU9XCJ2aWV3cG9ydFwiIGNvbnRlbnQ9XCJpbml0aWFsLXNjYWxlPTEuMCwgd2lkdGg9ZGV2aWNlLXdpZHRoXCIgLz5cbiAgICAgICAgICA8bWV0YSBuYW1lPVwiZGVzY3JpcHRpb25cIiBjb250ZW50PXtEZXNjcmlwdGlvbn0gLz5cbiAgICAgICAgICA8bGluayBocmVmPVwiaHR0cHM6Ly9mb250cy5nb29nbGVhcGlzLmNvbS9jc3M/ZmFtaWx5PVNwZWNpYWwrRWxpdGVcIiByZWw9XCJzdHlsZXNoZWV0XCIgLz5cbiAgICAgICAgICA8bWV0YSBwcm9wZXJ0eT1cIm9nOnVybFwiIGNvbnRlbnQ9XCJodHRwczovL3N1ZG9rdS5zaXRpYW5saXUuY29tL1wiIC8+XG4gICAgICAgICAgPG1ldGEgcHJvcGVydHk9XCJvZzp0aXRsZVwiIGNvbnRlbnQ9XCJTdWRva3UgRXZvbHZlZFwiIC8+XG4gICAgICAgICAgPG1ldGEgcHJvcGVydHk9XCJvZzp0eXBlXCIgY29udGVudD1cIndlYnNpdGVcIiAvPlxuICAgICAgICAgIDxtZXRhIHByb3BlcnR5PVwib2c6ZGVzY3JpcHRpb25cIiBjb250ZW50PXtEZXNjcmlwdGlvbn0gLz5cbiAgICAgICAgICA8bWV0YSBwcm9wZXJ0eT1cIm9nOmltYWdlXCIgY29udGVudD1cImh0dHBzOi8vc3Vkb2t1LnNpdGlhbmxpdS5jb20vc3RhdGljL29nLWltYWdlLnBuZ1wiIC8+XG4gICAgICAgIDwvTmV4dEhlYWQ+XG4gICAgICAgIHshYm9hcmQgJiYgdGhpcy5yZW5kZXJHZW5lcmF0aW9uVUkoKX1cbiAgICAgICAge2JvYXJkICYmIHRoaXMucmVuZGVySGVhZGVyKCl9XG4gICAgICAgIHtib2FyZCAmJiB0aGlzLnJlbmRlclB1enpsZSgpfVxuICAgICAgICB7Ym9hcmQgJiYgdGhpcy5yZW5kZXJDb250cm9scygpfVxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInJvb3RlclwiPlxuICAgICAgICAgIE1hZGUgd2l0aCA8c3Bhbj7inaTvuI88L3NwYW4+77iPIEJ5IDxhIGhyZWY9XCJodHRwczovL3d3dy5zaXRpYW5saXUuY29tL1wiPlNpdGlhbiBMaXU8L2E+IHwgPGEgaHJlZj1cImh0dHBzOi8vbWVkaXVtLmNvbS9Ac2l0aWFubGl1XzU3NjgwL2J1aWxkaW5nLWEtc3Vkb2t1LWdhbWUtaW4tcmVhY3QtY2E2NjM5MTU3MTJcIj5CbG9nIFBvc3Q8L2E+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICB7IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG4gICAgICAgIDxzdHlsZSBqc3g+e2BcbiAgICAgICAgICAgIDpnbG9iYWwoYm9keSksIC5ib2R5IHtcbiAgICAgICAgICAgICAgICBmb250LWZhbWlseTogJ1NwZWNpYWwgRWxpdGUnLCBjdXJzaXZlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLmJvZHkge1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICAgICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICAgICAgICAgIGhlaWdodDogMTAwdmg7XG4gICAgICAgICAgICAgICAgd2lkdGg6IDEwMHZ3O1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEBtZWRpYSAobWluLXdpZHRoOiA4MDBweCkgYW5kIChtaW4taGVpZ2h0OiA5MzBweCl7XG4gICAgICAgICAgICAgICAgOmdsb2JhbCguaGVhZGVyLCAucHV6emxlLCAuY29udHJvbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9udC1zaXplOiAxLjVlbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBAbWVkaWEgKG1heC13aWR0aDogODAwcHgpIGFuZCAobWluLXdpZHRoOiA2MDBweCl7XG4gICAgICAgICAgICAgICAgOmdsb2JhbCguaGVhZGVyLCAucHV6emxlLCAuY29udHJvbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9udC1zaXplOiAxLjJlbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBAbWVkaWEgKG1heC1oZWlnaHQ6IDkzMHB4KSBhbmQgKG1pbi1oZWlnaHQ6IDgwMHB4KSBhbmQgKG1pbi13aWR0aDogNjAwcHgpe1xuICAgICAgICAgICAgICAgIDpnbG9iYWwoLmhlYWRlciwgLnB1enpsZSwgLmNvbnRyb2xzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvbnQtc2l6ZTogMS4yZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQG1lZGlhIChtYXgtaGVpZ2h0OiA4MDBweCkgYW5kIChtaW4taGVpZ2h0OiA2MDBweCkgYW5kIChtaW4td2lkdGg6IDM3MHB4KXtcbiAgICAgICAgICAgICAgICA6Z2xvYmFsKC5oZWFkZXIsIC5wdXp6bGUsIC5jb250cm9scykge1xuICAgICAgICAgICAgICAgICAgICBmb250LXNpemU6IDFlbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBAbWVkaWEgKG1heC13aWR0aDogMzcwcHgpe1xuICAgICAgICAgICAgICAgIDpnbG9iYWwoLmhlYWRlciwgLnB1enpsZSwgLmNvbnRyb2xzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvbnQtc2l6ZTogLjhlbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBAbWVkaWEgKG1heC1oZWlnaHQ6IDYwMHB4KXtcbiAgICAgICAgICAgICAgICA6Z2xvYmFsKC5oZWFkZXIsIC5wdXp6bGUsIC5jb250cm9scykge1xuICAgICAgICAgICAgICAgICAgICBmb250LXNpemU6IC44ZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOmdsb2JhbChib2R5KSB7XG4gICAgICAgICAgICAgICAgbWFyZ2luOiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLnJvb3RlciB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgICAgICAgICAgIGJvdHRvbTogMDtcbiAgICAgICAgICAgICAgICBmb250LXNpemU6IC44ZW07XG4gICAgICAgICAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgICAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICBgfVxuICAgICAgICA8L3N0eWxlPlxuICAgICAgICA8c3R5bGUganN4IGdsb2JhbD57UmFuZ2VTdHlsZX08L3N0eWxlPlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufVxuIl19 */\n/*@ sourceURL=pages/index.js */'
        })
      );
    }
  }, {
    key: 'renderGenerationUI',
    value: function renderGenerationUI() {
      return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(GenerationUI, { generateGame: this.generateGame, __source: {
          fileName: _jsxFileName,
          lineNumber: 776
        }
      });
    }
  }, {
    key: 'renderHeader',
    value: function renderHeader() {
      var _this7 = this;

      return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
        'div',
        {
          className: 'jsx-2229275753' + ' ' + 'header',
          __source: {
            fileName: _jsxFileName,
            lineNumber: 782
          }
        },
        __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
          'div',
          { onClick: function onClick() {
              return _this7.setState({ board: false });
            }, className: 'jsx-2229275753' + ' ' + 'new-game',
            __source: {
              fileName: _jsxFileName,
              lineNumber: 783
            }
          },
          __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_11__svg_return_svg__["a" /* default */], {
            __source: {
              fileName: _jsxFileName,
              lineNumber: 784
            }
          }),
          __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
            'div',
            {
              className: 'jsx-2229275753',
              __source: {
                fileName: _jsxFileName,
                lineNumber: 785
              }
            },
            'New Game'
          )
        ),
        __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_14__components_tool_tip__["a" /* default */], {
          __source: {
            fileName: _jsxFileName,
            lineNumber: 787
          }
        }),
        __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_0_styled_jsx_style___default.a, {
          styleId: '2229275753',
          css: '.header.jsx-2229275753{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;width:100%;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;max-width:500px;padding:0 0.5em;box-sizing:border-box;}.new-game.jsx-2229275753{cursor:pointer;margin-top:.2em;display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;padding:.2em 0;}.new-game.jsx-2229275753 svg{height:1em;margin-bottom:.3em;}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhZ2VzL2luZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQW94Qm9CLEFBRzhCLEFBUUUsQUFRSixXQUNRLElBUkgsZUFTcEIsQ0FSd0IsMkNBVFQsV0FDbUIsZ0RBU1AsbUVBUlAsZ0JBQ0EsZ0JBQ00sQUFPSCxzQkFOdkIsdUVBT21CLGVBQ25CIiwiZmlsZSI6InBhZ2VzL2luZGV4LmpzIiwic291cmNlUm9vdCI6Ii9Vc2Vycy9saWNoZW5tYS9Qcm9qZWN0cy9TdUR1b2t1L1N1RHVva3UiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBqc3gtYTExeS9hY2Nlc3NpYmxlLWVtb2ppICovXG5pbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50LCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBTZXQsIExpc3QsIGZyb21KUyB9IGZyb20gJ2ltbXV0YWJsZSc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IE5leHRIZWFkIGZyb20gJ25leHQvaGVhZCc7XG5pbXBvcnQgQ29sb3IgZnJvbSAnY29sb3InO1xuaW1wb3J0IElucHV0UmFuZ2UgZnJvbSAncmVhY3QtaW5wdXQtcmFuZ2UnO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLWV4dHJhbmVvdXMtZGVwZW5kZW5jaWVzXG5pbXBvcnQgY3NzIGZyb20gJ3N0eWxlZC1qc3gvY3NzJztcblxuaW1wb3J0IFJhbmdlU3R5bGUgZnJvbSAnLi4vaW5wdXQtcmFuZ2Utc3R5bGUnO1xuaW1wb3J0IExvdXBlSWNvbiBmcm9tICcuLi9zdmcvbG91cGUuc3ZnJztcbmltcG9ydCBSZW1vdmVJY29uIGZyb20gJy4uL3N2Zy9yZW1vdmUuc3ZnJztcbmltcG9ydCBSZWxvYWRJY29uIGZyb20gJy4uL3N2Zy9yZWxvYWQuc3ZnJztcbmltcG9ydCBSZXR1cm5JY29uIGZyb20gJy4uL3N2Zy9yZXR1cm4uc3ZnJztcblxuaW1wb3J0IHsgbWFrZVB1enpsZSwgcGx1Y2ssIGlzUGVlciBhcyBhcmVDb29yZGluYXRlUGVlcnMsIHJhbmdlIH0gZnJvbSAnLi4vc3Vkb2t1JztcbmltcG9ydCB7IGJhY2tHcm91bmRCbHVlIH0gZnJvbSAnLi4vY29sb3JzJztcbmltcG9ydCBUaXAgZnJvbSAnLi4vY29tcG9uZW50cy90b29sLXRpcCc7XG5cbmltcG9ydCBpbyBmcm9tICdzb2NrZXQuaW8tY2xpZW50J1xuXG5jb25zdCBEZXNjcmlwdGlvbiA9ICdEaXNjb3ZlciB0aGUgbmV4dCBldm9sdXRpb24gb2YgU3Vkb2t1IHdpdGggYW1hemluZyBncmFwaGljcywgYW5pbWF0aW9ucywgYW5kIHVzZXItZnJpZW5kbHkgZmVhdHVyZXMuIEVuam95IGEgU3Vkb2t1IGV4cGVyaWVuY2UgbGlrZSB5b3UgbmV2ZXIgaGF2ZSBiZWZvcmUgd2l0aCBjdXN0b21pemFibGUgZ2FtZSBnZW5lcmF0aW9uLCBjZWxsIGhpZ2hsaWdodGluZywgaW50dWl0aXZlIGNvbnRyb2xzIGFuZCBtb3JlISc7XG5jb25zdCBjZWxsV2lkdGggPSAyLjU7XG5cbmNvbnN0IExpZ2h0Qmx1ZTEwMCA9ICcjQjNFNUZDJztcbmNvbnN0IExpZ2h0Qmx1ZTIwMCA9ICcjODFENEZBJztcbmNvbnN0IExpZ2h0Qmx1ZTMwMCA9ICcjNEZDM0Y3JztcbmNvbnN0IEluZGlnbzcwMCA9ICcjMzAzRjlGJztcbmNvbnN0IERlZXBPcmFuZ2UyMDAgPSAnI0ZGQUI5MSc7XG5jb25zdCBEZWVwT3JhbmdlNjAwID0gJyNGNDUxMUUnO1xuY29uc3QgQ29udHJvbE51bWJlckNvbG9yID0gSW5kaWdvNzAwO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbG9uZS1ibG9ja3NcbnsgLyogbGFuZ3VhZ2U9Q1NTICovIH1cbmNvbnN0IENlbGxTdHlsZSA9IGNzc2Bcbi5jZWxsIHtcbiAgICBoZWlnaHQ6ICR7Y2VsbFdpZHRofWVtO1xuICAgIHdpZHRoOiAke2NlbGxXaWR0aH1lbTtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtd3JhcDogd3JhcDtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgIGZvbnQtc2l6ZTogMS4xZW07XG4gICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgdHJhbnNpdGlvbjogYmFja2dyb3VuZC1jb2xvciAuM3MgZWFzZS1pbi1vdXQ7XG59XG4uY2VsbDpudGgtY2hpbGQoM24rMyk6bm90KDpsYXN0LWNoaWxkKSB7XG4gICAgYm9yZGVyLXJpZ2h0OiAycHggc29saWQgYmxhY2s7XG59XG4uY2VsbDpub3QoOmxhc3QtY2hpbGQpIHtcbiAgICBib3JkZXItcmlnaHQ6IDFweCBzb2xpZCBibGFjaztcbn1cbi5ub3RlLW51bWJlciB7XG4gICAgZm9udC1zaXplOiAuNmVtO1xuICAgIHdpZHRoOiAzMyU7XG4gICAgaGVpZ2h0OiAzMyU7XG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG59XG5gO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbG9uZS1ibG9ja3NcbnsgLyogbGFuZ3VhZ2U9Q1NTICovIH1cbmNvbnN0IEFjdGlvbnNTdHlsZSA9IGNzc2Bcbi5hY3Rpb25zIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIG1heC13aWR0aDogNDAwcHg7XG4gICAgbWFyZ2luLXRvcDogLjVlbTtcbiAgICBwYWRkaW5nOiAwIC42ZW07XG59XG4uYWN0aW9uIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbn1cbi5hY3Rpb24gOmdsb2JhbChzdmcpIHtcbiAgICB3aWR0aDogMi41ZW07XG4gICAgbWFyZ2luLWJvdHRvbTogLjJlbTtcbn1cbi5yZWRvIDpnbG9iYWwoc3ZnKSB7XG4gICAgdHJhbnNmb3JtOiBzY2FsZVgoLTEpO1xufVxuYDtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxvbmUtYmxvY2tzXG57IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG5jb25zdCBDb250cm9sU3R5bGUgPSBjc3NgXG4uY29udHJvbCB7XG4gICAgcGFkZGluZzogMCAyZW07XG4gICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIGRpc3BsYXk6IGlubGluZS1mbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgZmxleC13cmFwOiB3cmFwO1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgIGZvbnQtZmFtaWx5OiAnU3BlY2lhbCBFbGl0ZScsIGN1cnNpdmU7XG4gICAgdHJhbnNpdGlvbjogZmlsdGVyIC41cyBlYXNlLWluLW91dDtcbiAgICB3aWR0aDogMTAwJTtcbn1cbmA7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sb25lLWJsb2Nrc1xueyAvKiBsYW5ndWFnZT1DU1MgKi8gfVxuY29uc3QgTnVtYmVyQ29udHJvbFN0eWxlID0gY3NzYFxuLm51bWJlciB7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBmb250LXNpemU6IDJlbTtcbiAgICBtYXJnaW46IC4xZW07XG4gICAgd2lkdGg6IDEuNWVtO1xuICAgIGhlaWdodDogMS41ZW07XG4gICAgY29sb3I6ICR7Q29udHJvbE51bWJlckNvbG9yfTtcbiAgICBib3gtc2hhZG93OiAwIDFweCAycHggcmdiYSgwLDAsMCwwLjE2KSwgMCAxcHggMnB4IHJnYmEoMCwwLDAsMC4yMyk7XG4gICAgYm9yZGVyLXJhZGl1czogNTAlO1xufVxuLm51bWJlciA+IGRpdiB7XG4gICAgbWFyZ2luLXRvcDogLjNlbTtcbn1cbmA7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sb25lLWJsb2Nrc1xueyAvKiBsYW5ndWFnZT1DU1MgKi8gfVxuY29uc3QgUHV6emxlU3R5bGUgPSBjc3NgXG4ucHV6emxlIHtcbiAgICBtYXJnaW4tdG9wOiAuNWVtO1xuICAgIHdpZHRoOiAke2NlbGxXaWR0aCAqIDl9ZW07XG4gICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIGJveC1zaGFkb3c6IDAgM3B4IDZweCByZ2JhKDAsMCwwLDAuMTYpLCAwIDNweCA2cHggcmdiYSgwLDAsMCwwLjIzKTtcbn1cbi5yb3cge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBmbGV4OiAwO1xuICAgIHdpZHRoOiAke2NlbGxXaWR0aCAqIDl9ZW07XG59XG4ucm93Om5vdCg6bGFzdC1jaGlsZCkge1xuICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCBibGFjaztcbn1cbi5yb3c6bnRoLWNoaWxkKDNuKzMpOm5vdCg6bGFzdC1jaGlsZCkge1xuICAgIGJvcmRlci1ib3R0b206IDJweCBzb2xpZCBibGFjayAhaW1wb3J0YW50O1xufVxuYDtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxvbmUtYmxvY2tzXG57IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG5jb25zdCBDaXJjdWx1YXJQcm9ncmVzc1N0eWxlID0gY3NzYFxuLmNpcmN1bGFyLXByb2dyZXNzIHtcbiAgICBkaXNwbGF5OiBibG9jaztcbiAgICB3aWR0aDogMTAwJTtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgdG9wOiAwO1xuICAgIGxlZnQ6IDA7XG4gICAgdHJhbnNpdGlvbjogZmlsdGVyIC40cyBlYXNlLWluLW91dDtcbn1cblxuLmNpcmNsZS1iZyB7XG4gICAgZmlsbDogbm9uZTtcbiAgICBzdHJva2U6ICNlZWU7XG4gICAgc3Ryb2tlLXdpZHRoOiAzLjg7XG59XG5cbi5jaXJjbGUge1xuICAgIHN0cm9rZTogJHtDb250cm9sTnVtYmVyQ29sb3J9O1xuICAgIHRyYW5zaXRpb246IHN0cm9rZS1kYXNoYXJyYXkgLjRzIGVhc2UtaW4tb3V0O1xuICAgIGZpbGw6IG5vbmU7XG4gICAgc3Ryb2tlLXdpZHRoOiAyLjg7XG4gICAgc3Ryb2tlLWxpbmVjYXA6IHJvdW5kO1xufVxuYDtcblxuY29uc3QgQ2lyY3VsYXJQYXRoRCA9ICdNMTggMi4wODQ1IGEgMTUuOTE1NSAxNS45MTU1IDAgMCAxIDAgMzEuODMxIGEgMTUuOTE1NSAxNS45MTU1IDAgMCAxIDAgLTMxLjgzMSc7XG5cbmZ1bmN0aW9uIGdldEJhY2tHcm91bmRDb2xvcih7XG4gIGNvbmZsaWN0LCBpc1BlZXIsIHNhbWVWYWx1ZSwgaXNTZWxlY3RlZCxcbn0pIHtcbiAgaWYgKGNvbmZsaWN0ICYmIGlzUGVlciAmJiBzYW1lVmFsdWUpIHtcbiAgICByZXR1cm4gRGVlcE9yYW5nZTIwMDtcbiAgfSBlbHNlIGlmIChzYW1lVmFsdWUpIHtcbiAgICByZXR1cm4gTGlnaHRCbHVlMzAwO1xuICB9IGVsc2UgaWYgKGlzU2VsZWN0ZWQpIHtcbiAgICByZXR1cm4gTGlnaHRCbHVlMjAwO1xuICB9IGVsc2UgaWYgKGlzUGVlcikge1xuICAgIHJldHVybiBMaWdodEJsdWUxMDA7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRGb250Q29sb3IoeyB2YWx1ZSwgY29uZmxpY3QsIHByZWZpbGxlZCB9KSB7XG4gIGlmIChjb25mbGljdCAmJiAhcHJlZmlsbGVkKSB7XG4gICAgcmV0dXJuIERlZXBPcmFuZ2U2MDA7XG4gIH0gZWxzZSBpZiAoIXByZWZpbGxlZCAmJiB2YWx1ZSkge1xuICAgIHJldHVybiBDb250cm9sTnVtYmVyQ29sb3I7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5jbGFzcyBHZW5lcmF0aW9uVUkgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcblxuICAgIHRoaXMuc3RhdGUgPSB7IHZhbHVlOiAzMCB9O1xuICB9XG5cbiAgZ2VuZXJhdGVHYW1lID0gKCkgPT4ge1xuICAgIHRoaXMucHJvcHMuZ2VuZXJhdGVHYW1lKHRoaXMuc3RhdGUudmFsdWUpO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImdlbmVyYXRpb25cIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb3B5XCI+U3RhcnQgd2l0aCB7dGhpcy5zdGF0ZS52YWx1ZX0gY2VsbHMgcHJlZmlsbGVkPC9kaXY+XG4gICAgICAgIDxJbnB1dFJhbmdlXG4gICAgICAgICAgbWF4VmFsdWU9ezgxfVxuICAgICAgICAgIG1pblZhbHVlPXsxN31cbiAgICAgICAgICB2YWx1ZT17dGhpcy5zdGF0ZS52YWx1ZX1cbiAgICAgICAgICBvbkNoYW5nZT17dmFsdWUgPT4gdGhpcy5zZXRTdGF0ZSh7IHZhbHVlIH0pfVxuICAgICAgICAvPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImJ1dHRvblwiIG9uQ2xpY2s9e3RoaXMuZ2VuZXJhdGVHYW1lfT5QbGF5IFN1ZG9rdTwvZGl2PlxuICAgICAgICB7IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG4gICAgICAgIDxzdHlsZSBqc3g+e2BcbiAgICAgICAgICAgIC5jb3B5IHtcbiAgICAgICAgICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgICAgICAgICAgICAgZm9udC1zaXplOiAxLjNlbTtcbiAgICAgICAgICAgICAgICBtYXJnaW4tYm90dG9tOiAuNWVtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLmdlbmVyYXRpb24ge1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgICAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgICAgICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOmdsb2JhbCguaW5wdXQtcmFuZ2UpIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogODAlO1xuICAgICAgICAgICAgICAgIG1heC13aWR0aDogNTAwcHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAuYnV0dG9uIHtcbiAgICAgICAgICAgICAgbWFyZ2luLXRvcDogLjVlbTtcbiAgICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogLjI1ZW07XG4gICAgICAgICAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICAgICAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICAgICAgICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcbiAgICAgICAgICAgICAgY29sb3I6ICNmZmY7XG4gICAgICAgICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgICAgICAgICAgICB0cmFuc2l0aW9uOiBhbGwgLjI1cztcbiAgICAgICAgICAgICAgcGFkZGluZzogNXB4IDEwcHg7XG4gICAgICAgICAgICAgIGZvbnQtc2l6ZTogMS40ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAuYnV0dG9uOmFjdGl2ZSB7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKDBweCwgNXB4KTtcbiAgICAgICAgICAgICAgYm94LXNoYWRvdzogMCAxcHggMCAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAuYnV0dG9uIHtcbiAgICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogJHtiYWNrR3JvdW5kQmx1ZX07XG4gICAgICAgICAgICAgIGJveC1zaGFkb3c6IDAgMnB4IDRweCAwICR7Q29sb3IoYmFja0dyb3VuZEJsdWUpLmRhcmtlbigwLjUpLmhzbCgpLnN0cmluZygpfTtcbiAgICAgICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLmJ1dHRvbjpob3ZlciB7XG4gICAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6ICR7Q29sb3IoYmFja0dyb3VuZEJsdWUpLmxpZ2h0ZW4oMC4yKS5oc2woKS5zdHJpbmcoKX07XG4gICAgICAgICAgICB9XG4gICAgICAgIGB9XG4gICAgICAgIDwvc3R5bGU+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG59XG5cbkdlbmVyYXRpb25VSS5wcm9wVHlwZXMgPSB7XG4gIGdlbmVyYXRlR2FtZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbn07XG5cbmNvbnN0IE51bWJlckNvbnRyb2wgPSAoeyBudW1iZXIsIG9uQ2xpY2ssIGNvbXBsZXRpb25QZXJjZW50YWdlIH0pID0+IChcbiAgPGRpdlxuICAgIGtleT17bnVtYmVyfVxuICAgIGNsYXNzTmFtZT1cIm51bWJlclwiXG4gICAgb25DbGljaz17b25DbGlja31cbiAgPlxuICAgIDxkaXY+e251bWJlcn08L2Rpdj5cbiAgICA8Q2lyY2x1bGFyUHJvZ3Jlc3MgcGVyY2VudD17Y29tcGxldGlvblBlcmNlbnRhZ2V9IC8+XG4gICAgPHN0eWxlIGpzeD57TnVtYmVyQ29udHJvbFN0eWxlfTwvc3R5bGU+XG4gIDwvZGl2PlxuKTtcblxuTnVtYmVyQ29udHJvbC5wcm9wVHlwZXMgPSB7XG4gIG51bWJlcjogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICBvbkNsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgY29tcGxldGlvblBlcmNlbnRhZ2U6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbn07XG5cbk51bWJlckNvbnRyb2wuZGVmYXVsdFByb3BzID0ge1xuICBvbkNsaWNrOiBudWxsLFxufTtcblxuY29uc3QgQ2VsbCA9IChwcm9wcykgPT4ge1xuICBjb25zdCB7XG4gICAgdmFsdWUsIG9uQ2xpY2ssIGlzUGVlciwgaXNTZWxlY3RlZCwgc2FtZVZhbHVlLCBwcmVmaWxsZWQsIG5vdGVzLCBjb25mbGljdCxcbiAgfSA9IHByb3BzO1xuICBjb25zdCBiYWNrZ3JvdW5kQ29sb3IgPSBnZXRCYWNrR3JvdW5kQ29sb3Ioe1xuICAgIGNvbmZsaWN0LCBpc1BlZXIsIHNhbWVWYWx1ZSwgaXNTZWxlY3RlZCxcbiAgfSk7XG4gIGNvbnN0IGZvbnRDb2xvciA9IGdldEZvbnRDb2xvcih7IGNvbmZsaWN0LCBwcmVmaWxsZWQsIHZhbHVlIH0pO1xuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwiY2VsbFwiIG9uQ2xpY2s9e29uQ2xpY2t9PlxuICAgICAge1xuICAgICAgICBub3RlcyA/XG4gICAgICAgICAgcmFuZ2UoOSkubWFwKGkgPT5cbiAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgPGRpdiBrZXk9e2l9IGNsYXNzTmFtZT1cIm5vdGUtbnVtYmVyXCI+XG4gICAgICAgICAgICAgICAge25vdGVzLmhhcyhpICsgMSkgJiYgKGkgKyAxKX1cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICApKSA6XG4gICAgICAgICAgdmFsdWUgJiYgdmFsdWVcbiAgICAgIH1cbiAgICAgIHsvKiBsYW5ndWFnZT1DU1MgKi99XG4gICAgICA8c3R5bGUganN4PntDZWxsU3R5bGV9PC9zdHlsZT5cbiAgICAgIDxzdHlsZSBqc3g+e2BcbiAgICAgICAgICAgICAgICAuY2VsbCB7XG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6ICR7YmFja2dyb3VuZENvbG9yIHx8ICdpbml0aWFsJ307XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiAke2ZvbnRDb2xvciB8fCAnaW5pdGlhbCd9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGB9XG4gICAgICA8L3N0eWxlPlxuICAgIDwvZGl2PlxuICApO1xufTtcblxuQ2VsbC5wcm9wVHlwZXMgPSB7XG4gIC8vIGN1cnJlbnQgbnVtYmVyIHZhbHVlXG4gIHZhbHVlOiBQcm9wVHlwZXMubnVtYmVyLFxuICAvLyBjZWxsIGNsaWNrIGhhbmRsZXJcbiAgb25DbGljazogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgLy8gaWYgdGhlIGNlbGwgaXMgYSBwZWVyIG9mIHRoZSBzZWxlY3RlZCBjZWxsXG4gIGlzUGVlcjogUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZCxcbiAgLy8gaWYgdGhlIGNlbGwgaXMgc2VsZWN0ZWQgYnkgdGhlIHVzZXJcbiAgaXNTZWxlY3RlZDogUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZCxcbiAgLy8gY3VycmVudCBjZWxsIGhhcyB0aGUgc2FtZSB2YWx1ZSBpZiB0aGUgdXNlciBzZWxlY3RlZCBjZWxsXG4gIHNhbWVWYWx1ZTogUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZCxcbiAgLy8gaWYgdGhpcyB3YXMgcHJlZmlsbGVkIGFzIGEgcGFydCBvZiB0aGUgcHV6emxlXG4gIHByZWZpbGxlZDogUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZCxcbiAgLy8gY3VycmVudCBub3RlcyB0YWtlbiBvbiB0aGUgY2VsbFxuICBub3RlczogUHJvcFR5cGVzLmluc3RhbmNlT2YoU2V0KSxcbiAgLy8gaWYgdGhlIGN1cnJlbnQgY2VsbCBkb2VzIG5vdCBzYXRpc2Z5IHRoZSBnYW1lIGNvbnN0cmFpbnRcbiAgY29uZmxpY3Q6IFByb3BUeXBlcy5ib29sLmlzUmVxdWlyZWQsXG59O1xuXG5DZWxsLmRlZmF1bHRQcm9wcyA9IHtcbiAgbm90ZXM6IG51bGwsXG4gIHZhbHVlOiBudWxsLFxufTtcblxuY29uc3QgQ2lyY2x1bGFyUHJvZ3Jlc3MgPSAoeyBwZXJjZW50IH0pID0+IChcbiAgPHN2ZyB2aWV3Qm94PVwiMCAwIDM2IDM2XCIgY2xhc3NOYW1lPVwiY2lyY3VsYXItcHJvZ3Jlc3NcIj5cbiAgICA8cGF0aFxuICAgICAgY2xhc3NOYW1lPVwiY2lyY2xlLWJnXCJcbiAgICAgIGQ9e0NpcmN1bGFyUGF0aER9XG4gICAgLz5cbiAgICA8cGF0aFxuICAgICAgY2xhc3NOYW1lPVwiY2lyY2xlXCJcbiAgICAgIHN0cm9rZURhc2hhcnJheT17YCR7cGVyY2VudCAqIDEwMH0sIDEwMGB9XG4gICAgICBkPXtDaXJjdWxhclBhdGhEfVxuICAgIC8+XG4gICAgeyAvKiBsYW5ndWFnZT1DU1MgKi8gfVxuICAgIDxzdHlsZSBqc3g+e0NpcmN1bHVhclByb2dyZXNzU3R5bGV9PC9zdHlsZT5cbiAgPC9zdmc+XG4pO1xuXG5DaXJjbHVsYXJQcm9ncmVzcy5wcm9wVHlwZXMgPSB7XG4gIHBlcmNlbnQ6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbn07XG5cbmZ1bmN0aW9uIGdldENsaWNrSGFuZGxlcihvbkNsaWNrLCBvbkRvdWJsZUNsaWNrLCBkZWxheSA9IDI1MCkge1xuICBsZXQgdGltZW91dElEID0gbnVsbDtcbiAgcmV0dXJuIChldmVudCkgPT4ge1xuICAgIGlmICghdGltZW91dElEKSB7XG4gICAgICB0aW1lb3V0SUQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgb25DbGljayhldmVudCk7XG4gICAgICAgIHRpbWVvdXRJRCA9IG51bGw7XG4gICAgICB9LCBkZWxheSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpbWVvdXRJRCA9IGNsZWFyVGltZW91dCh0aW1lb3V0SUQpO1xuICAgICAgb25Eb3VibGVDbGljayhldmVudCk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIG1ha2Ugc2l6ZSA5IGFycmF5IG9mIDBzXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIG1ha2VDb3VudE9iamVjdCgpIHtcbiAgY29uc3QgY291bnRPYmogPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSArPSAxKSBjb3VudE9iai5wdXNoKDApO1xuICByZXR1cm4gY291bnRPYmo7XG59XG5cbi8qKlxuICogZ2l2ZW4gYSAyRCBhcnJheSBvZiBudW1iZXJzIGFzIHRoZSBpbml0aWFsIHB1enpsZSwgZ2VuZXJhdGUgdGhlIGluaXRpYWwgZ2FtZSBzdGF0ZVxuICogQHBhcmFtIHB1enpsZVxuICogQHJldHVybnMge2FueX1cbiAqL1xuZnVuY3Rpb24gbWFrZUJvYXJkKHsgcHV6emxlIH0pIHtcbiAgLy8gY3JlYXRlIGluaXRpYWwgY291bnQgb2JqZWN0IHRvIGtlZXAgdHJhY2sgb2YgY29uZmxpY3RzIHBlciBudW1iZXIgdmFsdWVcbiAgY29uc3Qgcm93cyA9IEFycmF5LmZyb20oQXJyYXkoOSkua2V5cygpKS5tYXAoKCkgPT4gbWFrZUNvdW50T2JqZWN0KCkpO1xuICBjb25zdCBjb2x1bW5zID0gQXJyYXkuZnJvbShBcnJheSg5KS5rZXlzKCkpLm1hcCgoKSA9PiBtYWtlQ291bnRPYmplY3QoKSk7XG4gIGNvbnN0IHNxdWFyZXMgPSBBcnJheS5mcm9tKEFycmF5KDkpLmtleXMoKSkubWFwKCgpID0+IG1ha2VDb3VudE9iamVjdCgpKTtcbiAgY29uc3QgcmVzdWx0ID0gcHV6emxlLm1hcCgocm93LCBpKSA9PiAoXG4gICAgcm93Lm1hcCgoY2VsbCwgaikgPT4ge1xuICAgICAgaWYgKGNlbGwpIHtcbiAgICAgICAgcm93c1tpXVtjZWxsXSArPSAxO1xuICAgICAgICBjb2x1bW5zW2pdW2NlbGxdICs9IDE7XG4gICAgICAgIHNxdWFyZXNbKChNYXRoLmZsb29yKGkgLyAzKSkgKiAzKSArIE1hdGguZmxvb3IoaiAvIDMpXVtjZWxsXSArPSAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHB1enpsZVtpXVtqXSA+IDAgPyBwdXp6bGVbaV1bal0gOiBudWxsLFxuICAgICAgICBwcmVmaWxsZWQ6ICEhcHV6emxlW2ldW2pdLFxuICAgICAgfTtcbiAgICB9KVxuICApKTtcbiAgcmV0dXJuIGZyb21KUyh7IHB1enpsZTogcmVzdWx0LCBzZWxlY3RlZDogZmFsc2UsIGNob2ljZXM6IHsgcm93cywgY29sdW1ucywgc3F1YXJlcyB9IH0pO1xufVxuXG4vKipcbiAqIGdpdmUgdGhlIGNvb3JkaW5hdGUgdXBkYXRlIHRoZSBjdXJyZW50IGJvYXJkIHdpdGggYSBudW1iZXIgY2hvaWNlXG4gKiBAcGFyYW0geFxuICogQHBhcmFtIHlcbiAqIEBwYXJhbSBudW1iZXJcbiAqIEBwYXJhbSBmaWxsIHdoZXRoZXIgdG8gc2V0IG9yIHVuc2V0XG4gKiBAcGFyYW0gYm9hcmQgdGhlIGltbXV0YWJsZSBib2FyZCBnaXZlbiB0byBjaGFuZ2VcbiAqL1xuZnVuY3Rpb24gdXBkYXRlQm9hcmRXaXRoTnVtYmVyKHtcbiAgeCwgeSwgbnVtYmVyLCBmaWxsID0gdHJ1ZSwgYm9hcmQsXG59KSB7XG4gIGxldCBjZWxsID0gYm9hcmQuZ2V0KCdwdXp6bGUnKS5nZXRJbihbeCwgeV0pO1xuICAvLyBkZWxldGUgaXRzIG5vdGVzXG4gIGNlbGwgPSBjZWxsLmRlbGV0ZSgnbm90ZXMnKTtcbiAgLy8gc2V0IG9yIHVuc2V0IGl0cyB2YWx1ZSBkZXBlbmRpbmcgb24gYGZpbGxgXG4gIGNlbGwgPSBmaWxsID8gY2VsbC5zZXQoJ3ZhbHVlJywgbnVtYmVyKSA6IGNlbGwuZGVsZXRlKCd2YWx1ZScpO1xuICBjb25zdCBpbmNyZW1lbnQgPSBmaWxsID8gMSA6IC0xO1xuICAvLyB1cGRhdGUgdGhlIGN1cnJlbnQgZ3JvdXAgY2hvaWNlc1xuICBjb25zdCByb3dQYXRoID0gWydjaG9pY2VzJywgJ3Jvd3MnLCB4LCBudW1iZXJdO1xuICBjb25zdCBjb2x1bW5QYXRoID0gWydjaG9pY2VzJywgJ2NvbHVtbnMnLCB5LCBudW1iZXJdO1xuICBjb25zdCBzcXVhcmVQYXRoID0gWydjaG9pY2VzJywgJ3NxdWFyZXMnLFxuICAgICgoTWF0aC5mbG9vcih4IC8gMykpICogMykgKyBNYXRoLmZsb29yKHkgLyAzKSwgbnVtYmVyXTtcbiAgcmV0dXJuIGJvYXJkLnNldEluKHJvd1BhdGgsIGJvYXJkLmdldEluKHJvd1BhdGgpICsgaW5jcmVtZW50KVxuICAgIC5zZXRJbihjb2x1bW5QYXRoLCBib2FyZC5nZXRJbihjb2x1bW5QYXRoKSArIGluY3JlbWVudClcbiAgICAuc2V0SW4oc3F1YXJlUGF0aCwgYm9hcmQuZ2V0SW4oc3F1YXJlUGF0aCkgKyBpbmNyZW1lbnQpXG4gICAgLnNldEluKFsncHV6emxlJywgeCwgeV0sIGNlbGwpO1xufVxuXG5mdW5jdGlvbiBnZXROdW1iZXJPZkdyb3Vwc0Fzc2lnbmVkRm9yTnVtYmVyKG51bWJlciwgZ3JvdXBzKSB7XG4gIHJldHVybiBncm91cHMucmVkdWNlKChhY2N1bXVsYXRvciwgcm93KSA9PlxuICAgIGFjY3VtdWxhdG9yICsgKHJvdy5nZXQobnVtYmVyKSA+IDAgPyAxIDogMCksIDApO1xufVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L25vLW11bHRpLWNvbXBcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEluZGV4IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgc3RhdGUgPSB7fTtcblxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICBpZiAoJ3NlcnZpY2VXb3JrZXInIGluIG5hdmlnYXRvcikge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICAgICBuYXZpZ2F0b3Iuc2VydmljZVdvcmtlclxuICAgICAgICAucmVnaXN0ZXIoJy9zZXJ2aWNlLXdvcmtlci5qcycpXG4gICAgICAgIC50aGVuKChyZWcpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnU2VydmljZVdvcmtlciBzY29wZTogJywgcmVnLnNjb3BlKTtcbiAgICAgICAgICBjb25zb2xlLmxvZygnc2VydmljZSB3b3JrZXIgcmVnaXN0cmF0aW9uIHN1Y2Nlc3NmdWwnKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ3NlcnZpY2Ugd29ya2VyIHJlZ2lzdHJhdGlvbiBmYWlsZWQnLCBlcnIubWVzc2FnZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgXG4gICAgZmV0Y2goJy9hcGkvc29ja2V0aW8nKS5maW5hbGx5KCgpID0+IHtcbiAgICAgIGNvbnN0IHNvY2tldCA9IGlvKClcblxuICAgICAgc29ja2V0Lm9uKCdjb25uZWN0JywgKCkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZygnY29ubmVjdCcpXG4gICAgICAgIHNvY2tldC5lbWl0KCdoZWxsbycpXG4gICAgICB9KVxuXG4gICAgICBzb2NrZXQub24oJ2hlbGxvJywgZGF0YSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdoZWxsbycsIGRhdGEpXG4gICAgICB9KVxuXG4gICAgICBzb2NrZXQub24oJ2EgdXNlciBjb25uZWN0ZWQnLCAoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdhIHVzZXIgY29ubmVjdGVkJylcbiAgICAgIH0pXG5cbiAgICAgIHNvY2tldC5vbignZGlzY29ubmVjdCcsICgpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ2Rpc2Nvbm5lY3QnKVxuICAgICAgfSlcbiAgICB9KVxuICAgXG4gIH1cbiAgZ2V0U2VsZWN0ZWRDZWxsKCkge1xuICAgIGNvbnN0IHsgYm9hcmQgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3Qgc2VsZWN0ZWQgPSBib2FyZC5nZXQoJ3NlbGVjdGVkJyk7XG4gICAgcmV0dXJuIHNlbGVjdGVkICYmIGJvYXJkLmdldCgncHV6emxlJykuZ2V0SW4oW3NlbGVjdGVkLngsIHNlbGVjdGVkLnldKTtcbiAgfVxuXG4gIC8vIGdldCB0aGUgbWluIGJldHdlZW4gaXRzIGNvbXBsZXRpb24gaW4gcm93cywgY29sdW1ucyBhbmQgc3F1YXJlcy5cbiAgZ2V0TnVtYmVyVmFsdWVDb3VudChudW1iZXIpIHtcbiAgICBjb25zdCByb3dzID0gdGhpcy5zdGF0ZS5ib2FyZC5nZXRJbihbJ2Nob2ljZXMnLCAncm93cyddKTtcbiAgICBjb25zdCBjb2x1bW5zID0gdGhpcy5zdGF0ZS5ib2FyZC5nZXRJbihbJ2Nob2ljZXMnLCAnY29sdW1ucyddKTtcbiAgICBjb25zdCBzcXVhcmVzID0gdGhpcy5zdGF0ZS5ib2FyZC5nZXRJbihbJ2Nob2ljZXMnLCAnc3F1YXJlcyddKTtcbiAgICByZXR1cm4gTWF0aC5taW4oXG4gICAgICBnZXROdW1iZXJPZkdyb3Vwc0Fzc2lnbmVkRm9yTnVtYmVyKG51bWJlciwgc3F1YXJlcyksXG4gICAgICBNYXRoLm1pbihcbiAgICAgICAgZ2V0TnVtYmVyT2ZHcm91cHNBc3NpZ25lZEZvck51bWJlcihudW1iZXIsIHJvd3MpLFxuICAgICAgICBnZXROdW1iZXJPZkdyb3Vwc0Fzc2lnbmVkRm9yTnVtYmVyKG51bWJlciwgY29sdW1ucyksXG4gICAgICApLFxuICAgICk7XG4gIH1cblxuICBnZW5lcmF0ZUdhbWUgPSAoZmluYWxDb3VudCA9IDIwKSA9PiB7XG4gICAgLy8gZ2V0IGEgZmlsbGVkIHB1enpsZSBnZW5lcmF0ZWRcbiAgICBjb25zdCBzb2x1dGlvbiA9IG1ha2VQdXp6bGUoKTtcbiAgICAvLyBwbHVjayB2YWx1ZXMgZnJvbSBjZWxscyB0byBjcmVhdGUgdGhlIGdhbWVcbiAgICBjb25zdCB7IHB1enpsZSB9ID0gcGx1Y2soc29sdXRpb24sIGZpbmFsQ291bnQpO1xuICAgIC8vIGluaXRpYWxpemUgdGhlIGJvYXJkIHdpdGggY2hvaWNlIGNvdW50c1xuICAgIGNvbnN0IGJvYXJkID0gbWFrZUJvYXJkKHsgcHV6emxlIH0pO1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgYm9hcmQsIGhpc3Rvcnk6IExpc3Qub2YoYm9hcmQpLCBoaXN0b3J5T2ZmU2V0OiAwLCBzb2x1dGlvbixcbiAgICB9KTtcbiAgfVxuXG4gIGFkZE51bWJlckFzTm90ZSA9IChudW1iZXIpID0+IHtcbiAgICBsZXQgeyBib2FyZCB9ID0gdGhpcy5zdGF0ZTtcbiAgICBsZXQgc2VsZWN0ZWRDZWxsID0gdGhpcy5nZXRTZWxlY3RlZENlbGwoKTtcbiAgICBpZiAoIXNlbGVjdGVkQ2VsbCkgcmV0dXJuO1xuICAgIGNvbnN0IHByZWZpbGxlZCA9IHNlbGVjdGVkQ2VsbC5nZXQoJ3ByZWZpbGxlZCcpO1xuICAgIGlmIChwcmVmaWxsZWQpIHJldHVybjtcbiAgICBjb25zdCB7IHgsIHkgfSA9IGJvYXJkLmdldCgnc2VsZWN0ZWQnKTtcbiAgICBjb25zdCBjdXJyZW50VmFsdWUgPSBzZWxlY3RlZENlbGwuZ2V0KCd2YWx1ZScpO1xuICAgIGlmIChjdXJyZW50VmFsdWUpIHtcbiAgICAgIGJvYXJkID0gdXBkYXRlQm9hcmRXaXRoTnVtYmVyKHtcbiAgICAgICAgeCwgeSwgbnVtYmVyOiBjdXJyZW50VmFsdWUsIGZpbGw6IGZhbHNlLCBib2FyZDogdGhpcy5zdGF0ZS5ib2FyZCxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBsZXQgbm90ZXMgPSBzZWxlY3RlZENlbGwuZ2V0KCdub3RlcycpIHx8IFNldCgpO1xuICAgIGlmIChub3Rlcy5oYXMobnVtYmVyKSkge1xuICAgICAgbm90ZXMgPSBub3Rlcy5kZWxldGUobnVtYmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm90ZXMgPSBub3Rlcy5hZGQobnVtYmVyKTtcbiAgICB9XG4gICAgc2VsZWN0ZWRDZWxsID0gc2VsZWN0ZWRDZWxsLnNldCgnbm90ZXMnLCBub3Rlcyk7XG4gICAgc2VsZWN0ZWRDZWxsID0gc2VsZWN0ZWRDZWxsLmRlbGV0ZSgndmFsdWUnKTtcbiAgICBib2FyZCA9IGJvYXJkLnNldEluKFsncHV6emxlJywgeCwgeV0sIHNlbGVjdGVkQ2VsbCk7XG4gICAgdGhpcy51cGRhdGVCb2FyZChib2FyZCk7XG4gIH07XG5cbiAgdXBkYXRlQm9hcmQgPSAobmV3Qm9hcmQpID0+IHtcbiAgICBsZXQgeyBoaXN0b3J5IH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IHsgaGlzdG9yeU9mZlNldCB9ID0gdGhpcy5zdGF0ZTtcbiAgICAvLyBhbnl0aGluZyBiZWZvcmUgY3VycmVudCBzdGVwIGlzIHN0aWxsIGluIGhpc3RvcnlcbiAgICBoaXN0b3J5ID0gaGlzdG9yeS5zbGljZSgwLCBoaXN0b3J5T2ZmU2V0ICsgMSk7XG4gICAgLy8gYWRkIGl0c2VsZiBvbnRvIHRoZSBoaXN0b3J5XG4gICAgaGlzdG9yeSA9IGhpc3RvcnkucHVzaChuZXdCb2FyZCk7XG4gICAgLy8gdXBkYXRlIHRoZSBnYW1lXG4gICAgdGhpcy5zZXRTdGF0ZSh7IGJvYXJkOiBuZXdCb2FyZCwgaGlzdG9yeSwgaGlzdG9yeU9mZlNldDogaGlzdG9yeS5zaXplIC0gMSB9KTtcbiAgfTtcblxuICBjYW5VbmRvID0gKCkgPT4gdGhpcy5zdGF0ZS5oaXN0b3J5T2ZmU2V0ID4gMFxuXG4gIHJlZG8gPSAoKSA9PiB7XG4gICAgY29uc3QgeyBoaXN0b3J5IH0gPSB0aGlzLnN0YXRlO1xuICAgIGxldCB7IGhpc3RvcnlPZmZTZXQgfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKGhpc3Rvcnkuc2l6ZSkge1xuICAgICAgaGlzdG9yeU9mZlNldCA9IE1hdGgubWluKGhpc3Rvcnkuc2l6ZSAtIDEsIGhpc3RvcnlPZmZTZXQgKyAxKTtcbiAgICAgIGNvbnN0IGJvYXJkID0gaGlzdG9yeS5nZXQoaGlzdG9yeU9mZlNldCk7XG4gICAgICB0aGlzLnNldFN0YXRlKHsgYm9hcmQsIGhpc3RvcnlPZmZTZXQgfSk7XG4gICAgfVxuICB9O1xuXG4gIHVuZG8gPSAoKSA9PiB7XG4gICAgY29uc3QgeyBoaXN0b3J5IH0gPSB0aGlzLnN0YXRlO1xuICAgIGxldCB7IGhpc3RvcnlPZmZTZXQsIGJvYXJkIH0gPSB0aGlzLnN0YXRlO1xuICAgIGlmIChoaXN0b3J5LnNpemUpIHtcbiAgICAgIGhpc3RvcnlPZmZTZXQgPSBNYXRoLm1heCgwLCBoaXN0b3J5T2ZmU2V0IC0gMSk7XG4gICAgICBib2FyZCA9IGhpc3RvcnkuZ2V0KGhpc3RvcnlPZmZTZXQpO1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IGJvYXJkLCBoaXN0b3J5T2ZmU2V0LCBoaXN0b3J5IH0pO1xuICAgIH1cbiAgfTtcblxuICBlcmFzZVNlbGVjdGVkID0gKCkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGVkQ2VsbCA9IHRoaXMuZ2V0U2VsZWN0ZWRDZWxsKCk7XG4gICAgaWYgKCFzZWxlY3RlZENlbGwpIHJldHVybjtcbiAgICB0aGlzLmZpbGxOdW1iZXIoZmFsc2UpO1xuICB9XG5cbiAgZmlsbFNlbGVjdGVkV2l0aFNvbHV0aW9uID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgYm9hcmQsIHNvbHV0aW9uIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IHNlbGVjdGVkQ2VsbCA9IHRoaXMuZ2V0U2VsZWN0ZWRDZWxsKCk7XG4gICAgaWYgKCFzZWxlY3RlZENlbGwpIHJldHVybjtcbiAgICBjb25zdCB7IHgsIHkgfSA9IGJvYXJkLmdldCgnc2VsZWN0ZWQnKTtcbiAgICB0aGlzLmZpbGxOdW1iZXIoc29sdXRpb25beF1beV0pO1xuICB9XG5cblxuICAvLyBmaWxsIGN1cnJlbnRseSBzZWxlY3RlZCBjZWxsIHdpdGggbnVtYmVyXG4gIGZpbGxOdW1iZXIgPSAobnVtYmVyKSA9PiB7XG4gICAgbGV0IHsgYm9hcmQgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3Qgc2VsZWN0ZWRDZWxsID0gdGhpcy5nZXRTZWxlY3RlZENlbGwoKTtcbiAgICAvLyBuby1vcCBpZiBub3RoaW5nIGlzIHNlbGVjdGVkXG4gICAgaWYgKCFzZWxlY3RlZENlbGwpIHJldHVybjtcbiAgICBjb25zdCBwcmVmaWxsZWQgPSBzZWxlY3RlZENlbGwuZ2V0KCdwcmVmaWxsZWQnKTtcbiAgICAvLyBuby1vcCBpZiBpdCBpcyByZWZpbGxlZFxuICAgIGlmIChwcmVmaWxsZWQpIHJldHVybjtcbiAgICBjb25zdCB7IHgsIHkgfSA9IGJvYXJkLmdldCgnc2VsZWN0ZWQnKTtcbiAgICBjb25zdCBjdXJyZW50VmFsdWUgPSBzZWxlY3RlZENlbGwuZ2V0KCd2YWx1ZScpO1xuICAgIC8vIHJlbW92ZSB0aGUgY3VycmVudCB2YWx1ZSBhbmQgdXBkYXRlIHRoZSBnYW1lIHN0YXRlXG4gICAgaWYgKGN1cnJlbnRWYWx1ZSkge1xuICAgICAgYm9hcmQgPSB1cGRhdGVCb2FyZFdpdGhOdW1iZXIoe1xuICAgICAgICB4LCB5LCBudW1iZXI6IGN1cnJlbnRWYWx1ZSwgZmlsbDogZmFsc2UsIGJvYXJkOiB0aGlzLnN0YXRlLmJvYXJkLFxuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIHVwZGF0ZSB0byBuZXcgbnVtYmVyIGlmIGFueVxuICAgIGNvbnN0IHNldE51bWJlciA9IGN1cnJlbnRWYWx1ZSAhPT0gbnVtYmVyICYmIG51bWJlcjtcbiAgICBpZiAoc2V0TnVtYmVyKSB7XG4gICAgICBib2FyZCA9IHVwZGF0ZUJvYXJkV2l0aE51bWJlcih7XG4gICAgICAgIHgsIHksIG51bWJlciwgZmlsbDogdHJ1ZSwgYm9hcmQsXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVCb2FyZChib2FyZCk7XG4gIH07XG5cbiAgc2VsZWN0Q2VsbCA9ICh4LCB5KSA9PiB7XG4gICAgbGV0IHsgYm9hcmQgfSA9IHRoaXMuc3RhdGU7XG4gICAgYm9hcmQgPSBib2FyZC5zZXQoJ3NlbGVjdGVkJywgeyB4LCB5IH0pO1xuICAgIHRoaXMuc2V0U3RhdGUoeyBib2FyZCB9KTtcbiAgfTtcblxuICBpc0NvbmZsaWN0KGksIGopIHtcbiAgICBjb25zdCB7IHZhbHVlIH0gPSB0aGlzLnN0YXRlLmJvYXJkLmdldEluKFsncHV6emxlJywgaSwgal0pLnRvSlNPTigpO1xuICAgIGlmICghdmFsdWUpIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCByb3dDb25mbGljdCA9XG4gICAgICB0aGlzLnN0YXRlLmJvYXJkLmdldEluKFsnY2hvaWNlcycsICdyb3dzJywgaSwgdmFsdWVdKSA+IDE7XG4gICAgY29uc3QgY29sdW1uQ29uZmxpY3QgPVxuICAgICAgdGhpcy5zdGF0ZS5ib2FyZC5nZXRJbihbJ2Nob2ljZXMnLCAnY29sdW1ucycsIGosIHZhbHVlXSkgPiAxO1xuICAgIGNvbnN0IHNxdWFyZUNvbmZsaWN0ID1cbiAgICAgIHRoaXMuc3RhdGUuYm9hcmQuZ2V0SW4oWydjaG9pY2VzJywgJ3NxdWFyZXMnLFxuICAgICAgICAoKE1hdGguZmxvb3IoaSAvIDMpKSAqIDMpICsgTWF0aC5mbG9vcihqIC8gMyksIHZhbHVlXSkgPiAxO1xuICAgIHJldHVybiByb3dDb25mbGljdCB8fCBjb2x1bW5Db25mbGljdCB8fCBzcXVhcmVDb25mbGljdDtcbiAgfVxuXG4gIHJlbmRlckNlbGwoY2VsbCwgeCwgeSkge1xuICAgIGNvbnN0IHsgYm9hcmQgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3Qgc2VsZWN0ZWQgPSB0aGlzLmdldFNlbGVjdGVkQ2VsbCgpO1xuICAgIGNvbnN0IHsgdmFsdWUsIHByZWZpbGxlZCwgbm90ZXMgfSA9IGNlbGwudG9KU09OKCk7XG4gICAgY29uc3QgY29uZmxpY3QgPSB0aGlzLmlzQ29uZmxpY3QoeCwgeSk7XG4gICAgY29uc3QgcGVlciA9IGFyZUNvb3JkaW5hdGVQZWVycyh7IHgsIHkgfSwgYm9hcmQuZ2V0KCdzZWxlY3RlZCcpKTtcbiAgICBjb25zdCBzYW1lVmFsdWUgPSAhIShzZWxlY3RlZCAmJiBzZWxlY3RlZC5nZXQoJ3ZhbHVlJylcbiAgICAgICYmIHZhbHVlID09PSBzZWxlY3RlZC5nZXQoJ3ZhbHVlJykpO1xuXG4gICAgY29uc3QgaXNTZWxlY3RlZCA9IGNlbGwgPT09IHNlbGVjdGVkO1xuICAgIHJldHVybiAoPENlbGxcbiAgICAgIHByZWZpbGxlZD17cHJlZmlsbGVkfVxuICAgICAgbm90ZXM9e25vdGVzfVxuICAgICAgc2FtZVZhbHVlPXtzYW1lVmFsdWV9XG4gICAgICBpc1NlbGVjdGVkPXtpc1NlbGVjdGVkfVxuICAgICAgaXNQZWVyPXtwZWVyfVxuICAgICAgdmFsdWU9e3ZhbHVlfVxuICAgICAgb25DbGljaz17KCkgPT4geyB0aGlzLnNlbGVjdENlbGwoeCwgeSk7IH19XG4gICAgICBrZXk9e3l9XG4gICAgICB4PXt4fVxuICAgICAgeT17eX1cbiAgICAgIGNvbmZsaWN0PXtjb25mbGljdH1cbiAgICAvPik7XG4gIH1cblxuICByZW5kZXJOdW1iZXJDb250cm9sKCkge1xuICAgIGNvbnN0IHNlbGVjdGVkQ2VsbCA9IHRoaXMuZ2V0U2VsZWN0ZWRDZWxsKCk7XG4gICAgY29uc3QgcHJlZmlsbGVkID0gc2VsZWN0ZWRDZWxsICYmIHNlbGVjdGVkQ2VsbC5nZXQoJ3ByZWZpbGxlZCcpO1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRyb2xcIj5cbiAgICAgICAge3JhbmdlKDkpLm1hcCgoaSkgPT4ge1xuICAgICAgICAgIGNvbnN0IG51bWJlciA9IGkgKyAxO1xuICAgICAgICAgIC8vIGhhbmRsZXMgYmluZGluZyBzaW5nbGUgY2xpY2sgYW5kIGRvdWJsZSBjbGljayBjYWxsYmFja3NcbiAgICAgICAgICBjb25zdCBjbGlja0hhbmRsZSA9IGdldENsaWNrSGFuZGxlcihcbiAgICAgICAgICAgICgpID0+IHsgdGhpcy5maWxsTnVtYmVyKG51bWJlcik7IH0sXG4gICAgICAgICAgICAoKSA9PiB7IHRoaXMuYWRkTnVtYmVyQXNOb3RlKG51bWJlcik7IH0sXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPE51bWJlckNvbnRyb2xcbiAgICAgICAgICAgICAga2V5PXtudW1iZXJ9XG4gICAgICAgICAgICAgIG51bWJlcj17bnVtYmVyfVxuICAgICAgICAgICAgICBvbkNsaWNrPXshcHJlZmlsbGVkID8gY2xpY2tIYW5kbGUgOiB1bmRlZmluZWR9XG4gICAgICAgICAgICAgIGNvbXBsZXRpb25QZXJjZW50YWdlPXt0aGlzLmdldE51bWJlclZhbHVlQ291bnQobnVtYmVyKSAvIDl9XG4gICAgICAgICAgICAvPik7XG4gICAgICAgIH0pfVxuICAgICAgICA8c3R5bGUganN4PntDb250cm9sU3R5bGV9PC9zdHlsZT5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cblxuICByZW5kZXJBY3Rpb25zKCkge1xuICAgIGNvbnN0IHsgaGlzdG9yeSB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBzZWxlY3RlZENlbGwgPSB0aGlzLmdldFNlbGVjdGVkQ2VsbCgpO1xuICAgIGNvbnN0IHByZWZpbGxlZCA9IHNlbGVjdGVkQ2VsbCAmJiBzZWxlY3RlZENlbGwuZ2V0KCdwcmVmaWxsZWQnKTtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJhY3Rpb25zXCI+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWN0aW9uXCIgb25DbGljaz17aGlzdG9yeS5zaXplID8gdGhpcy51bmRvIDogbnVsbH0+XG4gICAgICAgICAgPFJlbG9hZEljb24gLz5VbmRvXG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImFjdGlvbiByZWRvXCIgb25DbGljaz17aGlzdG9yeS5zaXplID8gdGhpcy5yZWRvIDogbnVsbH0+XG4gICAgICAgICAgPFJlbG9hZEljb24gLz5SZWRvXG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImFjdGlvblwiIG9uQ2xpY2s9eyFwcmVmaWxsZWQgPyB0aGlzLmVyYXNlU2VsZWN0ZWQgOiBudWxsfT5cbiAgICAgICAgICA8UmVtb3ZlSWNvbiAvPkVyYXNlXG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2XG4gICAgICAgICAgY2xhc3NOYW1lPVwiYWN0aW9uXCJcbiAgICAgICAgICBvbkNsaWNrPXshcHJlZmlsbGVkID9cbiAgICAgICAgICB0aGlzLmZpbGxTZWxlY3RlZFdpdGhTb2x1dGlvbiA6IG51bGx9XG4gICAgICAgID5cbiAgICAgICAgICA8TG91cGVJY29uIC8+SGludFxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPHN0eWxlIGpzeD57QWN0aW9uc1N0eWxlfTwvc3R5bGU+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG5cbiAgcmVuZGVyUHV6emxlKCkge1xuICAgIGNvbnN0IHsgYm9hcmQgfSA9IHRoaXMuc3RhdGU7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwicHV6emxlXCI+XG4gICAgICAgIHtib2FyZC5nZXQoJ3B1enpsZScpLm1hcCgocm93LCBpKSA9PiAoXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L25vLWFycmF5LWluZGV4LWtleVxuICAgICAgICAgIDxkaXYga2V5PXtpfSBjbGFzc05hbWU9XCJyb3dcIj5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcm93Lm1hcCgoY2VsbCwgaikgPT4gdGhpcy5yZW5kZXJDZWxsKGNlbGwsIGksIGopKS50b0FycmF5KClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKSkudG9BcnJheSgpfVxuICAgICAgICA8c3R5bGUganN4PntQdXp6bGVTdHlsZX08L3N0eWxlPlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxuXG4gIHJlbmRlckNvbnRyb2xzKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRyb2xzXCI+XG4gICAgICAgIHt0aGlzLnJlbmRlck51bWJlckNvbnRyb2woKX1cbiAgICAgICAge3RoaXMucmVuZGVyQWN0aW9ucygpfVxuICAgICAgICB7IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG4gICAgICAgIDxzdHlsZSBqc3g+e2BcbiAgICAgICAgICAgIC5jb250cm9scyB7XG4gICAgICAgICAgICAgICAgbWFyZ2luLXRvcDogLjNlbTtcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICAgICAgICAgIGZsZXgtd3JhcDogd3JhcDtcbiAgICAgICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiAuNWVtIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIGB9XG4gICAgICAgIDwvc3R5bGU+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG5cbiAgcmVuZGVyR2VuZXJhdGlvblVJKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8R2VuZXJhdGlvblVJIGdlbmVyYXRlR2FtZT17dGhpcy5nZW5lcmF0ZUdhbWV9IC8+XG4gICAgKTtcbiAgfVxuXG4gIHJlbmRlckhlYWRlcigpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJoZWFkZXJcIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJuZXctZ2FtZVwiIG9uQ2xpY2s9eygpID0+IHRoaXMuc2V0U3RhdGUoeyBib2FyZDogZmFsc2UgfSl9PlxuICAgICAgICAgIDxSZXR1cm5JY29uIC8+XG4gICAgICAgICAgPGRpdj5OZXcgR2FtZTwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPFRpcCAvPlxuICAgICAgICB7IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG4gICAgICAgIDxzdHlsZSBqc3g+e2BcbiAgICAgICAgICAgIC5oZWFkZXIge1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgICAgICAgICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICAgICAgICAgICAgICAgIG1heC13aWR0aDogNTAwcHg7XG4gICAgICAgICAgICAgICAgcGFkZGluZzogMCAwLjVlbTtcbiAgICAgICAgICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLm5ldy1nYW1lIHtcbiAgICAgICAgICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICAgICAgICAgICAgbWFyZ2luLXRvcDogLjJlbTtcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiBpbmxpbmUtZmxleDtcbiAgICAgICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICAgICAgICAgIHBhZGRpbmc6IC4yZW0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC5uZXctZ2FtZSA6Z2xvYmFsKHN2Zykge1xuICAgICAgICAgICAgICAgIGhlaWdodDogMWVtO1xuICAgICAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IC4zZW07XG4gICAgICAgICAgICB9XG4gICAgICAgIGB9XG4gICAgICAgIDwvc3R5bGU+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgYm9hcmQgfSA9IHRoaXMuc3RhdGU7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYm9keVwiPlxuICAgICAgICA8TmV4dEhlYWQ+XG4gICAgICAgICAgPHRpdGxlPlN1ZG9rdSBFdm9sdmVkPC90aXRsZT5cbiAgICAgICAgICA8bWV0YSBuYW1lPVwidmlld3BvcnRcIiBjb250ZW50PVwiaW5pdGlhbC1zY2FsZT0xLjAsIHdpZHRoPWRldmljZS13aWR0aFwiIC8+XG4gICAgICAgICAgPG1ldGEgbmFtZT1cImRlc2NyaXB0aW9uXCIgY29udGVudD17RGVzY3JpcHRpb259IC8+XG4gICAgICAgICAgPGxpbmsgaHJlZj1cImh0dHBzOi8vZm9udHMuZ29vZ2xlYXBpcy5jb20vY3NzP2ZhbWlseT1TcGVjaWFsK0VsaXRlXCIgcmVsPVwic3R5bGVzaGVldFwiIC8+XG4gICAgICAgICAgPG1ldGEgcHJvcGVydHk9XCJvZzp1cmxcIiBjb250ZW50PVwiaHR0cHM6Ly9zdWRva3Uuc2l0aWFubGl1LmNvbS9cIiAvPlxuICAgICAgICAgIDxtZXRhIHByb3BlcnR5PVwib2c6dGl0bGVcIiBjb250ZW50PVwiU3Vkb2t1IEV2b2x2ZWRcIiAvPlxuICAgICAgICAgIDxtZXRhIHByb3BlcnR5PVwib2c6dHlwZVwiIGNvbnRlbnQ9XCJ3ZWJzaXRlXCIgLz5cbiAgICAgICAgICA8bWV0YSBwcm9wZXJ0eT1cIm9nOmRlc2NyaXB0aW9uXCIgY29udGVudD17RGVzY3JpcHRpb259IC8+XG4gICAgICAgICAgPG1ldGEgcHJvcGVydHk9XCJvZzppbWFnZVwiIGNvbnRlbnQ9XCJodHRwczovL3N1ZG9rdS5zaXRpYW5saXUuY29tL3N0YXRpYy9vZy1pbWFnZS5wbmdcIiAvPlxuICAgICAgICA8L05leHRIZWFkPlxuICAgICAgICB7IWJvYXJkICYmIHRoaXMucmVuZGVyR2VuZXJhdGlvblVJKCl9XG4gICAgICAgIHtib2FyZCAmJiB0aGlzLnJlbmRlckhlYWRlcigpfVxuICAgICAgICB7Ym9hcmQgJiYgdGhpcy5yZW5kZXJQdXp6bGUoKX1cbiAgICAgICAge2JvYXJkICYmIHRoaXMucmVuZGVyQ29udHJvbHMoKX1cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJyb290ZXJcIj5cbiAgICAgICAgICBNYWRlIHdpdGggPHNwYW4+4p2k77iPPC9zcGFuPu+4jyBCeSA8YSBocmVmPVwiaHR0cHM6Ly93d3cuc2l0aWFubGl1LmNvbS9cIj5TaXRpYW4gTGl1PC9hPiB8IDxhIGhyZWY9XCJodHRwczovL21lZGl1bS5jb20vQHNpdGlhbmxpdV81NzY4MC9idWlsZGluZy1hLXN1ZG9rdS1nYW1lLWluLXJlYWN0LWNhNjYzOTE1NzEyXCI+QmxvZyBQb3N0PC9hPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgeyAvKiBsYW5ndWFnZT1DU1MgKi8gfVxuICAgICAgICA8c3R5bGUganN4PntgXG4gICAgICAgICAgICA6Z2xvYmFsKGJvZHkpLCAuYm9keSB7XG4gICAgICAgICAgICAgICAgZm9udC1mYW1pbHk6ICdTcGVjaWFsIEVsaXRlJywgY3Vyc2l2ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC5ib2R5IHtcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICAgICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgICAgICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDEwMHZoO1xuICAgICAgICAgICAgICAgIHdpZHRoOiAxMDB2dztcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBAbWVkaWEgKG1pbi13aWR0aDogODAwcHgpIGFuZCAobWluLWhlaWdodDogOTMwcHgpe1xuICAgICAgICAgICAgICAgIDpnbG9iYWwoLmhlYWRlciwgLnB1enpsZSwgLmNvbnRyb2xzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvbnQtc2l6ZTogMS41ZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQG1lZGlhIChtYXgtd2lkdGg6IDgwMHB4KSBhbmQgKG1pbi13aWR0aDogNjAwcHgpe1xuICAgICAgICAgICAgICAgIDpnbG9iYWwoLmhlYWRlciwgLnB1enpsZSwgLmNvbnRyb2xzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvbnQtc2l6ZTogMS4yZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQG1lZGlhIChtYXgtaGVpZ2h0OiA5MzBweCkgYW5kIChtaW4taGVpZ2h0OiA4MDBweCkgYW5kIChtaW4td2lkdGg6IDYwMHB4KXtcbiAgICAgICAgICAgICAgICA6Z2xvYmFsKC5oZWFkZXIsIC5wdXp6bGUsIC5jb250cm9scykge1xuICAgICAgICAgICAgICAgICAgICBmb250LXNpemU6IDEuMmVtO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEBtZWRpYSAobWF4LWhlaWdodDogODAwcHgpIGFuZCAobWluLWhlaWdodDogNjAwcHgpIGFuZCAobWluLXdpZHRoOiAzNzBweCl7XG4gICAgICAgICAgICAgICAgOmdsb2JhbCguaGVhZGVyLCAucHV6emxlLCAuY29udHJvbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9udC1zaXplOiAxZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQG1lZGlhIChtYXgtd2lkdGg6IDM3MHB4KXtcbiAgICAgICAgICAgICAgICA6Z2xvYmFsKC5oZWFkZXIsIC5wdXp6bGUsIC5jb250cm9scykge1xuICAgICAgICAgICAgICAgICAgICBmb250LXNpemU6IC44ZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQG1lZGlhIChtYXgtaGVpZ2h0OiA2MDBweCl7XG4gICAgICAgICAgICAgICAgOmdsb2JhbCguaGVhZGVyLCAucHV6emxlLCAuY29udHJvbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9udC1zaXplOiAuOGVtO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDpnbG9iYWwoYm9keSkge1xuICAgICAgICAgICAgICAgIG1hcmdpbjogMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC5yb290ZXIge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICAgICAgICAgICAgICBib3R0b206IDA7XG4gICAgICAgICAgICAgICAgZm9udC1zaXplOiAuOGVtO1xuICAgICAgICAgICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICAgICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgYH1cbiAgICAgICAgPC9zdHlsZT5cbiAgICAgICAgPHN0eWxlIGpzeCBnbG9iYWw+e1JhbmdlU3R5bGV9PC9zdHlsZT5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cbn1cbiJdfQ== */\n/*@ sourceURL=pages/index.js */'
        })
      );
    }
  }, {
    key: 'render',
    value: function render() {
      var board = this.state.board;

      return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
        'div',
        {
          className: 'jsx-389099333' + ' ' + 'body',
          __source: {
            fileName: _jsxFileName,
            lineNumber: 819
          }
        },
        __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
          __WEBPACK_IMPORTED_MODULE_4_next_head___default.a,
          {
            __source: {
              fileName: _jsxFileName,
              lineNumber: 820
            }
          },
          __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
            'title',
            {
              className: 'jsx-389099333',
              __source: {
                fileName: _jsxFileName,
                lineNumber: 821
              }
            },
            'Sudoku Evolved'
          ),
          __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement('meta', { name: 'viewport', content: 'initial-scale=1.0, width=device-width', className: 'jsx-389099333',
            __source: {
              fileName: _jsxFileName,
              lineNumber: 822
            }
          }),
          __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement('meta', { name: 'description', content: Description, className: 'jsx-389099333',
            __source: {
              fileName: _jsxFileName,
              lineNumber: 823
            }
          }),
          __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement('link', { href: 'https://fonts.googleapis.com/css?family=Special+Elite', rel: 'stylesheet', className: 'jsx-389099333',
            __source: {
              fileName: _jsxFileName,
              lineNumber: 824
            }
          }),
          __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement('meta', { property: 'og:url', content: 'https://sudoku.sitianliu.com/', className: 'jsx-389099333',
            __source: {
              fileName: _jsxFileName,
              lineNumber: 825
            }
          }),
          __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement('meta', { property: 'og:title', content: 'Sudoku Evolved', className: 'jsx-389099333',
            __source: {
              fileName: _jsxFileName,
              lineNumber: 826
            }
          }),
          __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement('meta', { property: 'og:type', content: 'website', className: 'jsx-389099333',
            __source: {
              fileName: _jsxFileName,
              lineNumber: 827
            }
          }),
          __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement('meta', { property: 'og:description', content: Description, className: 'jsx-389099333',
            __source: {
              fileName: _jsxFileName,
              lineNumber: 828
            }
          }),
          __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement('meta', { property: 'og:image', content: 'https://sudoku.sitianliu.com/static/og-image.png', className: 'jsx-389099333',
            __source: {
              fileName: _jsxFileName,
              lineNumber: 829
            }
          })
        ),
        !board && this.renderGenerationUI(),
        board && this.renderHeader(),
        board && this.renderPuzzle(),
        board && this.renderControls(),
        __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
          'div',
          {
            className: 'jsx-389099333' + ' ' + 'rooter',
            __source: {
              fileName: _jsxFileName,
              lineNumber: 835
            }
          },
          'Made with ',
          __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
            'span',
            {
              className: 'jsx-389099333',
              __source: {
                fileName: _jsxFileName,
                lineNumber: 836
              }
            },
            '\u2764\uFE0F'
          ),
          '\uFE0F By ',
          __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
            'a',
            { href: 'https://www.sitianliu.com/', className: 'jsx-389099333',
              __source: {
                fileName: _jsxFileName,
                lineNumber: 836
              }
            },
            'Sitian Liu'
          ),
          ' | ',
          __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(
            'a',
            { href: 'https://medium.com/@sitianliu_57680/building-a-sudoku-game-in-react-ca663915712', className: 'jsx-389099333',
              __source: {
                fileName: _jsxFileName,
                lineNumber: 836
              }
            },
            'Blog Post'
          )
        ),
        __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_0_styled_jsx_style___default.a, {
          styleId: '389099333',
          css: 'body,.body.jsx-389099333{font-family:\'Special Elite\',cursive;}.body.jsx-389099333{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;height:100vh;width:100vw;position:relative;}@media (min-width:800px) and (min-height:930px){.header,.puzzle,.controls{font-size:1.5em;}}@media (max-width:800px) and (min-width:600px){.header,.puzzle,.controls{font-size:1.2em;}}@media (max-height:930px) and (min-height:800px) and (min-width:600px){.header,.puzzle,.controls{font-size:1.2em;}}@media (max-height:800px) and (min-height:600px) and (min-width:370px){.header,.puzzle,.controls{font-size:1em;}}@media (max-width:370px){.header,.puzzle,.controls{font-size:.8em;}}@media (max-height:600px){.header,.puzzle,.controls{font-size:.8em;}}body{margin:0;}.rooter.jsx-389099333{position:fixed;bottom:0;font-size:.8em;width:100%;text-align:center;}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhZ2VzL2luZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQXMwQm9CLEFBR3NELEFBR3hCLEFBVU8sQUFLQSxBQUtBLEFBS0YsQUFLQyxBQUtBLEFBSVYsQUFHTSxTQUZuQixLQWRJLENBS0EsQUFLQSxBQU9TLENBaENULEFBS0EsQUFLQSxRQXVCZSxZQTlDbkIsR0ErQ2UsV0FDTyxrQkFDdEIsTUE5QzBCLDhFQUNILDZGQUNJLG1HQUNWLGFBQ0QsWUFDTSxrQkFDdEIiLCJmaWxlIjoicGFnZXMvaW5kZXguanMiLCJzb3VyY2VSb290IjoiL1VzZXJzL2xpY2hlbm1hL1Byb2plY3RzL1N1RHVva3UvU3VEdW9rdSIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIGpzeC1hMTF5L2FjY2Vzc2libGUtZW1vamkgKi9cbmltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFNldCwgTGlzdCwgZnJvbUpTIH0gZnJvbSAnaW1tdXRhYmxlJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgTmV4dEhlYWQgZnJvbSAnbmV4dC9oZWFkJztcbmltcG9ydCBDb2xvciBmcm9tICdjb2xvcic7XG5pbXBvcnQgSW5wdXRSYW5nZSBmcm9tICdyZWFjdC1pbnB1dC1yYW5nZSc7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tZXh0cmFuZW91cy1kZXBlbmRlbmNpZXNcbmltcG9ydCBjc3MgZnJvbSAnc3R5bGVkLWpzeC9jc3MnO1xuXG5pbXBvcnQgUmFuZ2VTdHlsZSBmcm9tICcuLi9pbnB1dC1yYW5nZS1zdHlsZSc7XG5pbXBvcnQgTG91cGVJY29uIGZyb20gJy4uL3N2Zy9sb3VwZS5zdmcnO1xuaW1wb3J0IFJlbW92ZUljb24gZnJvbSAnLi4vc3ZnL3JlbW92ZS5zdmcnO1xuaW1wb3J0IFJlbG9hZEljb24gZnJvbSAnLi4vc3ZnL3JlbG9hZC5zdmcnO1xuaW1wb3J0IFJldHVybkljb24gZnJvbSAnLi4vc3ZnL3JldHVybi5zdmcnO1xuXG5pbXBvcnQgeyBtYWtlUHV6emxlLCBwbHVjaywgaXNQZWVyIGFzIGFyZUNvb3JkaW5hdGVQZWVycywgcmFuZ2UgfSBmcm9tICcuLi9zdWRva3UnO1xuaW1wb3J0IHsgYmFja0dyb3VuZEJsdWUgfSBmcm9tICcuLi9jb2xvcnMnO1xuaW1wb3J0IFRpcCBmcm9tICcuLi9jb21wb25lbnRzL3Rvb2wtdGlwJztcblxuaW1wb3J0IGlvIGZyb20gJ3NvY2tldC5pby1jbGllbnQnXG5cbmNvbnN0IERlc2NyaXB0aW9uID0gJ0Rpc2NvdmVyIHRoZSBuZXh0IGV2b2x1dGlvbiBvZiBTdWRva3Ugd2l0aCBhbWF6aW5nIGdyYXBoaWNzLCBhbmltYXRpb25zLCBhbmQgdXNlci1mcmllbmRseSBmZWF0dXJlcy4gRW5qb3kgYSBTdWRva3UgZXhwZXJpZW5jZSBsaWtlIHlvdSBuZXZlciBoYXZlIGJlZm9yZSB3aXRoIGN1c3RvbWl6YWJsZSBnYW1lIGdlbmVyYXRpb24sIGNlbGwgaGlnaGxpZ2h0aW5nLCBpbnR1aXRpdmUgY29udHJvbHMgYW5kIG1vcmUhJztcbmNvbnN0IGNlbGxXaWR0aCA9IDIuNTtcblxuY29uc3QgTGlnaHRCbHVlMTAwID0gJyNCM0U1RkMnO1xuY29uc3QgTGlnaHRCbHVlMjAwID0gJyM4MUQ0RkEnO1xuY29uc3QgTGlnaHRCbHVlMzAwID0gJyM0RkMzRjcnO1xuY29uc3QgSW5kaWdvNzAwID0gJyMzMDNGOUYnO1xuY29uc3QgRGVlcE9yYW5nZTIwMCA9ICcjRkZBQjkxJztcbmNvbnN0IERlZXBPcmFuZ2U2MDAgPSAnI0Y0NTExRSc7XG5jb25zdCBDb250cm9sTnVtYmVyQ29sb3IgPSBJbmRpZ283MDA7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sb25lLWJsb2Nrc1xueyAvKiBsYW5ndWFnZT1DU1MgKi8gfVxuY29uc3QgQ2VsbFN0eWxlID0gY3NzYFxuLmNlbGwge1xuICAgIGhlaWdodDogJHtjZWxsV2lkdGh9ZW07XG4gICAgd2lkdGg6ICR7Y2VsbFdpZHRofWVtO1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC13cmFwOiB3cmFwO1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgZm9udC1zaXplOiAxLjFlbTtcbiAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICB0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kLWNvbG9yIC4zcyBlYXNlLWluLW91dDtcbn1cbi5jZWxsOm50aC1jaGlsZCgzbiszKTpub3QoOmxhc3QtY2hpbGQpIHtcbiAgICBib3JkZXItcmlnaHQ6IDJweCBzb2xpZCBibGFjaztcbn1cbi5jZWxsOm5vdCg6bGFzdC1jaGlsZCkge1xuICAgIGJvcmRlci1yaWdodDogMXB4IHNvbGlkIGJsYWNrO1xufVxuLm5vdGUtbnVtYmVyIHtcbiAgICBmb250LXNpemU6IC42ZW07XG4gICAgd2lkdGg6IDMzJTtcbiAgICBoZWlnaHQ6IDMzJTtcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbn1cbmA7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sb25lLWJsb2Nrc1xueyAvKiBsYW5ndWFnZT1DU1MgKi8gfVxuY29uc3QgQWN0aW9uc1N0eWxlID0gY3NzYFxuLmFjdGlvbnMge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgbWF4LXdpZHRoOiA0MDBweDtcbiAgICBtYXJnaW4tdG9wOiAuNWVtO1xuICAgIHBhZGRpbmc6IDAgLjZlbTtcbn1cbi5hY3Rpb24ge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xufVxuLmFjdGlvbiA6Z2xvYmFsKHN2Zykge1xuICAgIHdpZHRoOiAyLjVlbTtcbiAgICBtYXJnaW4tYm90dG9tOiAuMmVtO1xufVxuLnJlZG8gOmdsb2JhbChzdmcpIHtcbiAgICB0cmFuc2Zvcm06IHNjYWxlWCgtMSk7XG59XG5gO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbG9uZS1ibG9ja3NcbnsgLyogbGFuZ3VhZ2U9Q1NTICovIH1cbmNvbnN0IENvbnRyb2xTdHlsZSA9IGNzc2Bcbi5jb250cm9sIHtcbiAgICBwYWRkaW5nOiAwIDJlbTtcbiAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgZGlzcGxheTogaW5saW5lLWZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBmbGV4LXdyYXA6IHdyYXA7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgZm9udC1mYW1pbHk6ICdTcGVjaWFsIEVsaXRlJywgY3Vyc2l2ZTtcbiAgICB0cmFuc2l0aW9uOiBmaWx0ZXIgLjVzIGVhc2UtaW4tb3V0O1xuICAgIHdpZHRoOiAxMDAlO1xufVxuYDtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxvbmUtYmxvY2tzXG57IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG5jb25zdCBOdW1iZXJDb250cm9sU3R5bGUgPSBjc3NgXG4ubnVtYmVyIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGZvbnQtc2l6ZTogMmVtO1xuICAgIG1hcmdpbjogLjFlbTtcbiAgICB3aWR0aDogMS41ZW07XG4gICAgaGVpZ2h0OiAxLjVlbTtcbiAgICBjb2xvcjogJHtDb250cm9sTnVtYmVyQ29sb3J9O1xuICAgIGJveC1zaGFkb3c6IDAgMXB4IDJweCByZ2JhKDAsMCwwLDAuMTYpLCAwIDFweCAycHggcmdiYSgwLDAsMCwwLjIzKTtcbiAgICBib3JkZXItcmFkaXVzOiA1MCU7XG59XG4ubnVtYmVyID4gZGl2IHtcbiAgICBtYXJnaW4tdG9wOiAuM2VtO1xufVxuYDtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxvbmUtYmxvY2tzXG57IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG5jb25zdCBQdXp6bGVTdHlsZSA9IGNzc2Bcbi5wdXp6bGUge1xuICAgIG1hcmdpbi10b3A6IC41ZW07XG4gICAgd2lkdGg6ICR7Y2VsbFdpZHRoICogOX1lbTtcbiAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgYm94LXNoYWRvdzogMCAzcHggNnB4IHJnYmEoMCwwLDAsMC4xNiksIDAgM3B4IDZweCByZ2JhKDAsMCwwLDAuMjMpO1xufVxuLnJvdyB7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGZsZXg6IDA7XG4gICAgd2lkdGg6ICR7Y2VsbFdpZHRoICogOX1lbTtcbn1cbi5yb3c6bm90KDpsYXN0LWNoaWxkKSB7XG4gICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkIGJsYWNrO1xufVxuLnJvdzpudGgtY2hpbGQoM24rMyk6bm90KDpsYXN0LWNoaWxkKSB7XG4gICAgYm9yZGVyLWJvdHRvbTogMnB4IHNvbGlkIGJsYWNrICFpbXBvcnRhbnQ7XG59XG5gO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbG9uZS1ibG9ja3NcbnsgLyogbGFuZ3VhZ2U9Q1NTICovIH1cbmNvbnN0IENpcmN1bHVhclByb2dyZXNzU3R5bGUgPSBjc3NgXG4uY2lyY3VsYXItcHJvZ3Jlc3Mge1xuICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB0b3A6IDA7XG4gICAgbGVmdDogMDtcbiAgICB0cmFuc2l0aW9uOiBmaWx0ZXIgLjRzIGVhc2UtaW4tb3V0O1xufVxuXG4uY2lyY2xlLWJnIHtcbiAgICBmaWxsOiBub25lO1xuICAgIHN0cm9rZTogI2VlZTtcbiAgICBzdHJva2Utd2lkdGg6IDMuODtcbn1cblxuLmNpcmNsZSB7XG4gICAgc3Ryb2tlOiAke0NvbnRyb2xOdW1iZXJDb2xvcn07XG4gICAgdHJhbnNpdGlvbjogc3Ryb2tlLWRhc2hhcnJheSAuNHMgZWFzZS1pbi1vdXQ7XG4gICAgZmlsbDogbm9uZTtcbiAgICBzdHJva2Utd2lkdGg6IDIuODtcbiAgICBzdHJva2UtbGluZWNhcDogcm91bmQ7XG59XG5gO1xuXG5jb25zdCBDaXJjdWxhclBhdGhEID0gJ00xOCAyLjA4NDUgYSAxNS45MTU1IDE1LjkxNTUgMCAwIDEgMCAzMS44MzEgYSAxNS45MTU1IDE1LjkxNTUgMCAwIDEgMCAtMzEuODMxJztcblxuZnVuY3Rpb24gZ2V0QmFja0dyb3VuZENvbG9yKHtcbiAgY29uZmxpY3QsIGlzUGVlciwgc2FtZVZhbHVlLCBpc1NlbGVjdGVkLFxufSkge1xuICBpZiAoY29uZmxpY3QgJiYgaXNQZWVyICYmIHNhbWVWYWx1ZSkge1xuICAgIHJldHVybiBEZWVwT3JhbmdlMjAwO1xuICB9IGVsc2UgaWYgKHNhbWVWYWx1ZSkge1xuICAgIHJldHVybiBMaWdodEJsdWUzMDA7XG4gIH0gZWxzZSBpZiAoaXNTZWxlY3RlZCkge1xuICAgIHJldHVybiBMaWdodEJsdWUyMDA7XG4gIH0gZWxzZSBpZiAoaXNQZWVyKSB7XG4gICAgcmV0dXJuIExpZ2h0Qmx1ZTEwMDtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldEZvbnRDb2xvcih7IHZhbHVlLCBjb25mbGljdCwgcHJlZmlsbGVkIH0pIHtcbiAgaWYgKGNvbmZsaWN0ICYmICFwcmVmaWxsZWQpIHtcbiAgICByZXR1cm4gRGVlcE9yYW5nZTYwMDtcbiAgfSBlbHNlIGlmICghcHJlZmlsbGVkICYmIHZhbHVlKSB7XG4gICAgcmV0dXJuIENvbnRyb2xOdW1iZXJDb2xvcjtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmNsYXNzIEdlbmVyYXRpb25VSSBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuXG4gICAgdGhpcy5zdGF0ZSA9IHsgdmFsdWU6IDMwIH07XG4gIH1cblxuICBnZW5lcmF0ZUdhbWUgPSAoKSA9PiB7XG4gICAgdGhpcy5wcm9wcy5nZW5lcmF0ZUdhbWUodGhpcy5zdGF0ZS52YWx1ZSk7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ2VuZXJhdGlvblwiPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvcHlcIj5TdGFydCB3aXRoIHt0aGlzLnN0YXRlLnZhbHVlfSBjZWxscyBwcmVmaWxsZWQ8L2Rpdj5cbiAgICAgICAgPElucHV0UmFuZ2VcbiAgICAgICAgICBtYXhWYWx1ZT17ODF9XG4gICAgICAgICAgbWluVmFsdWU9ezE3fVxuICAgICAgICAgIHZhbHVlPXt0aGlzLnN0YXRlLnZhbHVlfVxuICAgICAgICAgIG9uQ2hhbmdlPXt2YWx1ZSA9PiB0aGlzLnNldFN0YXRlKHsgdmFsdWUgfSl9XG4gICAgICAgIC8+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYnV0dG9uXCIgb25DbGljaz17dGhpcy5nZW5lcmF0ZUdhbWV9PlBsYXkgU3Vkb2t1PC9kaXY+XG4gICAgICAgIHsgLyogbGFuZ3VhZ2U9Q1NTICovIH1cbiAgICAgICAgPHN0eWxlIGpzeD57YFxuICAgICAgICAgICAgLmNvcHkge1xuICAgICAgICAgICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICAgICAgICAgICAgICBmb250LXNpemU6IDEuM2VtO1xuICAgICAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IC41ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAuZ2VuZXJhdGlvbiB7XG4gICAgICAgICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgICAgICAgICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6Z2xvYmFsKC5pbnB1dC1yYW5nZSkge1xuICAgICAgICAgICAgICAgIHdpZHRoOiA4MCU7XG4gICAgICAgICAgICAgICAgbWF4LXdpZHRoOiA1MDBweDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC5idXR0b24ge1xuICAgICAgICAgICAgICBtYXJnaW4tdG9wOiAuNWVtO1xuICAgICAgICAgICAgICBib3JkZXItcmFkaXVzOiAuMjVlbTtcbiAgICAgICAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgICAgICAgICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICAgICAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xuICAgICAgICAgICAgICBjb2xvcjogI2ZmZjtcbiAgICAgICAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gICAgICAgICAgICAgIHRyYW5zaXRpb246IGFsbCAuMjVzO1xuICAgICAgICAgICAgICBwYWRkaW5nOiA1cHggMTBweDtcbiAgICAgICAgICAgICAgZm9udC1zaXplOiAxLjRlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC5idXR0b246YWN0aXZlIHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoMHB4LCA1cHgpO1xuICAgICAgICAgICAgICBib3gtc2hhZG93OiAwIDFweCAwIDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC5idXR0b24ge1xuICAgICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAke2JhY2tHcm91bmRCbHVlfTtcbiAgICAgICAgICAgICAgYm94LXNoYWRvdzogMCAycHggNHB4IDAgJHtDb2xvcihiYWNrR3JvdW5kQmx1ZSkuZGFya2VuKDAuNSkuaHNsKCkuc3RyaW5nKCl9O1xuICAgICAgICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAuYnV0dG9uOmhvdmVyIHtcbiAgICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogJHtDb2xvcihiYWNrR3JvdW5kQmx1ZSkubGlnaHRlbigwLjIpLmhzbCgpLnN0cmluZygpfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgYH1cbiAgICAgICAgPC9zdHlsZT5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cbn1cblxuR2VuZXJhdGlvblVJLnByb3BUeXBlcyA9IHtcbiAgZ2VuZXJhdGVHYW1lOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxufTtcblxuY29uc3QgTnVtYmVyQ29udHJvbCA9ICh7IG51bWJlciwgb25DbGljaywgY29tcGxldGlvblBlcmNlbnRhZ2UgfSkgPT4gKFxuICA8ZGl2XG4gICAga2V5PXtudW1iZXJ9XG4gICAgY2xhc3NOYW1lPVwibnVtYmVyXCJcbiAgICBvbkNsaWNrPXtvbkNsaWNrfVxuICA+XG4gICAgPGRpdj57bnVtYmVyfTwvZGl2PlxuICAgIDxDaXJjbHVsYXJQcm9ncmVzcyBwZXJjZW50PXtjb21wbGV0aW9uUGVyY2VudGFnZX0gLz5cbiAgICA8c3R5bGUganN4PntOdW1iZXJDb250cm9sU3R5bGV9PC9zdHlsZT5cbiAgPC9kaXY+XG4pO1xuXG5OdW1iZXJDb250cm9sLnByb3BUeXBlcyA9IHtcbiAgbnVtYmVyOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIG9uQ2xpY2s6IFByb3BUeXBlcy5mdW5jLFxuICBjb21wbGV0aW9uUGVyY2VudGFnZTogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxufTtcblxuTnVtYmVyQ29udHJvbC5kZWZhdWx0UHJvcHMgPSB7XG4gIG9uQ2xpY2s6IG51bGwsXG59O1xuXG5jb25zdCBDZWxsID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHtcbiAgICB2YWx1ZSwgb25DbGljaywgaXNQZWVyLCBpc1NlbGVjdGVkLCBzYW1lVmFsdWUsIHByZWZpbGxlZCwgbm90ZXMsIGNvbmZsaWN0LFxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IGJhY2tncm91bmRDb2xvciA9IGdldEJhY2tHcm91bmRDb2xvcih7XG4gICAgY29uZmxpY3QsIGlzUGVlciwgc2FtZVZhbHVlLCBpc1NlbGVjdGVkLFxuICB9KTtcbiAgY29uc3QgZm9udENvbG9yID0gZ2V0Rm9udENvbG9yKHsgY29uZmxpY3QsIHByZWZpbGxlZCwgdmFsdWUgfSk7XG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJjZWxsXCIgb25DbGljaz17b25DbGlja30+XG4gICAgICB7XG4gICAgICAgIG5vdGVzID9cbiAgICAgICAgICByYW5nZSg5KS5tYXAoaSA9PlxuICAgICAgICAgICAgKFxuICAgICAgICAgICAgICA8ZGl2IGtleT17aX0gY2xhc3NOYW1lPVwibm90ZS1udW1iZXJcIj5cbiAgICAgICAgICAgICAgICB7bm90ZXMuaGFzKGkgKyAxKSAmJiAoaSArIDEpfVxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICkpIDpcbiAgICAgICAgICB2YWx1ZSAmJiB2YWx1ZVxuICAgICAgfVxuICAgICAgey8qIGxhbmd1YWdlPUNTUyAqL31cbiAgICAgIDxzdHlsZSBqc3g+e0NlbGxTdHlsZX08L3N0eWxlPlxuICAgICAgPHN0eWxlIGpzeD57YFxuICAgICAgICAgICAgICAgIC5jZWxsIHtcbiAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogJHtiYWNrZ3JvdW5kQ29sb3IgfHwgJ2luaXRpYWwnfTtcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6ICR7Zm9udENvbG9yIHx8ICdpbml0aWFsJ307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgYH1cbiAgICAgIDwvc3R5bGU+XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5DZWxsLnByb3BUeXBlcyA9IHtcbiAgLy8gY3VycmVudCBudW1iZXIgdmFsdWVcbiAgdmFsdWU6IFByb3BUeXBlcy5udW1iZXIsXG4gIC8vIGNlbGwgY2xpY2sgaGFuZGxlclxuICBvbkNsaWNrOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAvLyBpZiB0aGUgY2VsbCBpcyBhIHBlZXIgb2YgdGhlIHNlbGVjdGVkIGNlbGxcbiAgaXNQZWVyOiBQcm9wVHlwZXMuYm9vbC5pc1JlcXVpcmVkLFxuICAvLyBpZiB0aGUgY2VsbCBpcyBzZWxlY3RlZCBieSB0aGUgdXNlclxuICBpc1NlbGVjdGVkOiBQcm9wVHlwZXMuYm9vbC5pc1JlcXVpcmVkLFxuICAvLyBjdXJyZW50IGNlbGwgaGFzIHRoZSBzYW1lIHZhbHVlIGlmIHRoZSB1c2VyIHNlbGVjdGVkIGNlbGxcbiAgc2FtZVZhbHVlOiBQcm9wVHlwZXMuYm9vbC5pc1JlcXVpcmVkLFxuICAvLyBpZiB0aGlzIHdhcyBwcmVmaWxsZWQgYXMgYSBwYXJ0IG9mIHRoZSBwdXp6bGVcbiAgcHJlZmlsbGVkOiBQcm9wVHlwZXMuYm9vbC5pc1JlcXVpcmVkLFxuICAvLyBjdXJyZW50IG5vdGVzIHRha2VuIG9uIHRoZSBjZWxsXG4gIG5vdGVzOiBQcm9wVHlwZXMuaW5zdGFuY2VPZihTZXQpLFxuICAvLyBpZiB0aGUgY3VycmVudCBjZWxsIGRvZXMgbm90IHNhdGlzZnkgdGhlIGdhbWUgY29uc3RyYWludFxuICBjb25mbGljdDogUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZCxcbn07XG5cbkNlbGwuZGVmYXVsdFByb3BzID0ge1xuICBub3RlczogbnVsbCxcbiAgdmFsdWU6IG51bGwsXG59O1xuXG5jb25zdCBDaXJjbHVsYXJQcm9ncmVzcyA9ICh7IHBlcmNlbnQgfSkgPT4gKFxuICA8c3ZnIHZpZXdCb3g9XCIwIDAgMzYgMzZcIiBjbGFzc05hbWU9XCJjaXJjdWxhci1wcm9ncmVzc1wiPlxuICAgIDxwYXRoXG4gICAgICBjbGFzc05hbWU9XCJjaXJjbGUtYmdcIlxuICAgICAgZD17Q2lyY3VsYXJQYXRoRH1cbiAgICAvPlxuICAgIDxwYXRoXG4gICAgICBjbGFzc05hbWU9XCJjaXJjbGVcIlxuICAgICAgc3Ryb2tlRGFzaGFycmF5PXtgJHtwZXJjZW50ICogMTAwfSwgMTAwYH1cbiAgICAgIGQ9e0NpcmN1bGFyUGF0aER9XG4gICAgLz5cbiAgICB7IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG4gICAgPHN0eWxlIGpzeD57Q2lyY3VsdWFyUHJvZ3Jlc3NTdHlsZX08L3N0eWxlPlxuICA8L3N2Zz5cbik7XG5cbkNpcmNsdWxhclByb2dyZXNzLnByb3BUeXBlcyA9IHtcbiAgcGVyY2VudDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxufTtcblxuZnVuY3Rpb24gZ2V0Q2xpY2tIYW5kbGVyKG9uQ2xpY2ssIG9uRG91YmxlQ2xpY2ssIGRlbGF5ID0gMjUwKSB7XG4gIGxldCB0aW1lb3V0SUQgPSBudWxsO1xuICByZXR1cm4gKGV2ZW50KSA9PiB7XG4gICAgaWYgKCF0aW1lb3V0SUQpIHtcbiAgICAgIHRpbWVvdXRJRCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBvbkNsaWNrKGV2ZW50KTtcbiAgICAgICAgdGltZW91dElEID0gbnVsbDtcbiAgICAgIH0sIGRlbGF5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGltZW91dElEID0gY2xlYXJUaW1lb3V0KHRpbWVvdXRJRCk7XG4gICAgICBvbkRvdWJsZUNsaWNrKGV2ZW50KTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogbWFrZSBzaXplIDkgYXJyYXkgb2YgMHNcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZnVuY3Rpb24gbWFrZUNvdW50T2JqZWN0KCkge1xuICBjb25zdCBjb3VudE9iaiA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpICs9IDEpIGNvdW50T2JqLnB1c2goMCk7XG4gIHJldHVybiBjb3VudE9iajtcbn1cblxuLyoqXG4gKiBnaXZlbiBhIDJEIGFycmF5IG9mIG51bWJlcnMgYXMgdGhlIGluaXRpYWwgcHV6emxlLCBnZW5lcmF0ZSB0aGUgaW5pdGlhbCBnYW1lIHN0YXRlXG4gKiBAcGFyYW0gcHV6emxlXG4gKiBAcmV0dXJucyB7YW55fVxuICovXG5mdW5jdGlvbiBtYWtlQm9hcmQoeyBwdXp6bGUgfSkge1xuICAvLyBjcmVhdGUgaW5pdGlhbCBjb3VudCBvYmplY3QgdG8ga2VlcCB0cmFjayBvZiBjb25mbGljdHMgcGVyIG51bWJlciB2YWx1ZVxuICBjb25zdCByb3dzID0gQXJyYXkuZnJvbShBcnJheSg5KS5rZXlzKCkpLm1hcCgoKSA9PiBtYWtlQ291bnRPYmplY3QoKSk7XG4gIGNvbnN0IGNvbHVtbnMgPSBBcnJheS5mcm9tKEFycmF5KDkpLmtleXMoKSkubWFwKCgpID0+IG1ha2VDb3VudE9iamVjdCgpKTtcbiAgY29uc3Qgc3F1YXJlcyA9IEFycmF5LmZyb20oQXJyYXkoOSkua2V5cygpKS5tYXAoKCkgPT4gbWFrZUNvdW50T2JqZWN0KCkpO1xuICBjb25zdCByZXN1bHQgPSBwdXp6bGUubWFwKChyb3csIGkpID0+IChcbiAgICByb3cubWFwKChjZWxsLCBqKSA9PiB7XG4gICAgICBpZiAoY2VsbCkge1xuICAgICAgICByb3dzW2ldW2NlbGxdICs9IDE7XG4gICAgICAgIGNvbHVtbnNbal1bY2VsbF0gKz0gMTtcbiAgICAgICAgc3F1YXJlc1soKE1hdGguZmxvb3IoaSAvIDMpKSAqIDMpICsgTWF0aC5mbG9vcihqIC8gMyldW2NlbGxdICs9IDE7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogcHV6emxlW2ldW2pdID4gMCA/IHB1enpsZVtpXVtqXSA6IG51bGwsXG4gICAgICAgIHByZWZpbGxlZDogISFwdXp6bGVbaV1bal0sXG4gICAgICB9O1xuICAgIH0pXG4gICkpO1xuICByZXR1cm4gZnJvbUpTKHsgcHV6emxlOiByZXN1bHQsIHNlbGVjdGVkOiBmYWxzZSwgY2hvaWNlczogeyByb3dzLCBjb2x1bW5zLCBzcXVhcmVzIH0gfSk7XG59XG5cbi8qKlxuICogZ2l2ZSB0aGUgY29vcmRpbmF0ZSB1cGRhdGUgdGhlIGN1cnJlbnQgYm9hcmQgd2l0aCBhIG51bWJlciBjaG9pY2VcbiAqIEBwYXJhbSB4XG4gKiBAcGFyYW0geVxuICogQHBhcmFtIG51bWJlclxuICogQHBhcmFtIGZpbGwgd2hldGhlciB0byBzZXQgb3IgdW5zZXRcbiAqIEBwYXJhbSBib2FyZCB0aGUgaW1tdXRhYmxlIGJvYXJkIGdpdmVuIHRvIGNoYW5nZVxuICovXG5mdW5jdGlvbiB1cGRhdGVCb2FyZFdpdGhOdW1iZXIoe1xuICB4LCB5LCBudW1iZXIsIGZpbGwgPSB0cnVlLCBib2FyZCxcbn0pIHtcbiAgbGV0IGNlbGwgPSBib2FyZC5nZXQoJ3B1enpsZScpLmdldEluKFt4LCB5XSk7XG4gIC8vIGRlbGV0ZSBpdHMgbm90ZXNcbiAgY2VsbCA9IGNlbGwuZGVsZXRlKCdub3RlcycpO1xuICAvLyBzZXQgb3IgdW5zZXQgaXRzIHZhbHVlIGRlcGVuZGluZyBvbiBgZmlsbGBcbiAgY2VsbCA9IGZpbGwgPyBjZWxsLnNldCgndmFsdWUnLCBudW1iZXIpIDogY2VsbC5kZWxldGUoJ3ZhbHVlJyk7XG4gIGNvbnN0IGluY3JlbWVudCA9IGZpbGwgPyAxIDogLTE7XG4gIC8vIHVwZGF0ZSB0aGUgY3VycmVudCBncm91cCBjaG9pY2VzXG4gIGNvbnN0IHJvd1BhdGggPSBbJ2Nob2ljZXMnLCAncm93cycsIHgsIG51bWJlcl07XG4gIGNvbnN0IGNvbHVtblBhdGggPSBbJ2Nob2ljZXMnLCAnY29sdW1ucycsIHksIG51bWJlcl07XG4gIGNvbnN0IHNxdWFyZVBhdGggPSBbJ2Nob2ljZXMnLCAnc3F1YXJlcycsXG4gICAgKChNYXRoLmZsb29yKHggLyAzKSkgKiAzKSArIE1hdGguZmxvb3IoeSAvIDMpLCBudW1iZXJdO1xuICByZXR1cm4gYm9hcmQuc2V0SW4ocm93UGF0aCwgYm9hcmQuZ2V0SW4ocm93UGF0aCkgKyBpbmNyZW1lbnQpXG4gICAgLnNldEluKGNvbHVtblBhdGgsIGJvYXJkLmdldEluKGNvbHVtblBhdGgpICsgaW5jcmVtZW50KVxuICAgIC5zZXRJbihzcXVhcmVQYXRoLCBib2FyZC5nZXRJbihzcXVhcmVQYXRoKSArIGluY3JlbWVudClcbiAgICAuc2V0SW4oWydwdXp6bGUnLCB4LCB5XSwgY2VsbCk7XG59XG5cbmZ1bmN0aW9uIGdldE51bWJlck9mR3JvdXBzQXNzaWduZWRGb3JOdW1iZXIobnVtYmVyLCBncm91cHMpIHtcbiAgcmV0dXJuIGdyb3Vwcy5yZWR1Y2UoKGFjY3VtdWxhdG9yLCByb3cpID0+XG4gICAgYWNjdW11bGF0b3IgKyAocm93LmdldChudW1iZXIpID4gMCA/IDEgOiAwKSwgMCk7XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3Qvbm8tbXVsdGktY29tcFxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW5kZXggZXh0ZW5kcyBDb21wb25lbnQge1xuICBzdGF0ZSA9IHt9O1xuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgIGlmICgnc2VydmljZVdvcmtlcicgaW4gbmF2aWdhdG9yKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICAgIG5hdmlnYXRvci5zZXJ2aWNlV29ya2VyXG4gICAgICAgIC5yZWdpc3RlcignL3NlcnZpY2Utd29ya2VyLmpzJylcbiAgICAgICAgLnRoZW4oKHJlZykgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdTZXJ2aWNlV29ya2VyIHNjb3BlOiAnLCByZWcuc2NvcGUpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdzZXJ2aWNlIHdvcmtlciByZWdpc3RyYXRpb24gc3VjY2Vzc2Z1bCcpO1xuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgIGNvbnNvbGUud2Fybignc2VydmljZSB3b3JrZXIgcmVnaXN0cmF0aW9uIGZhaWxlZCcsIGVyci5tZXNzYWdlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICBcbiAgICBmZXRjaCgnL2FwaS9zb2NrZXRpbycpLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgY29uc3Qgc29ja2V0ID0gaW8oKVxuXG4gICAgICBzb2NrZXQub24oJ2Nvbm5lY3QnLCAoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdjb25uZWN0JylcbiAgICAgICAgc29ja2V0LmVtaXQoJ2hlbGxvJylcbiAgICAgIH0pXG5cbiAgICAgIHNvY2tldC5vbignaGVsbG8nLCBkYXRhID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ2hlbGxvJywgZGF0YSlcbiAgICAgIH0pXG5cbiAgICAgIHNvY2tldC5vbignYSB1c2VyIGNvbm5lY3RlZCcsICgpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ2EgdXNlciBjb25uZWN0ZWQnKVxuICAgICAgfSlcblxuICAgICAgc29ja2V0Lm9uKCdkaXNjb25uZWN0JywgKCkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZygnZGlzY29ubmVjdCcpXG4gICAgICB9KVxuICAgIH0pXG4gICBcbiAgfVxuICBnZXRTZWxlY3RlZENlbGwoKSB7XG4gICAgY29uc3QgeyBib2FyZCB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBzZWxlY3RlZCA9IGJvYXJkLmdldCgnc2VsZWN0ZWQnKTtcbiAgICByZXR1cm4gc2VsZWN0ZWQgJiYgYm9hcmQuZ2V0KCdwdXp6bGUnKS5nZXRJbihbc2VsZWN0ZWQueCwgc2VsZWN0ZWQueV0pO1xuICB9XG5cbiAgLy8gZ2V0IHRoZSBtaW4gYmV0d2VlbiBpdHMgY29tcGxldGlvbiBpbiByb3dzLCBjb2x1bW5zIGFuZCBzcXVhcmVzLlxuICBnZXROdW1iZXJWYWx1ZUNvdW50KG51bWJlcikge1xuICAgIGNvbnN0IHJvd3MgPSB0aGlzLnN0YXRlLmJvYXJkLmdldEluKFsnY2hvaWNlcycsICdyb3dzJ10pO1xuICAgIGNvbnN0IGNvbHVtbnMgPSB0aGlzLnN0YXRlLmJvYXJkLmdldEluKFsnY2hvaWNlcycsICdjb2x1bW5zJ10pO1xuICAgIGNvbnN0IHNxdWFyZXMgPSB0aGlzLnN0YXRlLmJvYXJkLmdldEluKFsnY2hvaWNlcycsICdzcXVhcmVzJ10pO1xuICAgIHJldHVybiBNYXRoLm1pbihcbiAgICAgIGdldE51bWJlck9mR3JvdXBzQXNzaWduZWRGb3JOdW1iZXIobnVtYmVyLCBzcXVhcmVzKSxcbiAgICAgIE1hdGgubWluKFxuICAgICAgICBnZXROdW1iZXJPZkdyb3Vwc0Fzc2lnbmVkRm9yTnVtYmVyKG51bWJlciwgcm93cyksXG4gICAgICAgIGdldE51bWJlck9mR3JvdXBzQXNzaWduZWRGb3JOdW1iZXIobnVtYmVyLCBjb2x1bW5zKSxcbiAgICAgICksXG4gICAgKTtcbiAgfVxuXG4gIGdlbmVyYXRlR2FtZSA9IChmaW5hbENvdW50ID0gMjApID0+IHtcbiAgICAvLyBnZXQgYSBmaWxsZWQgcHV6emxlIGdlbmVyYXRlZFxuICAgIGNvbnN0IHNvbHV0aW9uID0gbWFrZVB1enpsZSgpO1xuICAgIC8vIHBsdWNrIHZhbHVlcyBmcm9tIGNlbGxzIHRvIGNyZWF0ZSB0aGUgZ2FtZVxuICAgIGNvbnN0IHsgcHV6emxlIH0gPSBwbHVjayhzb2x1dGlvbiwgZmluYWxDb3VudCk7XG4gICAgLy8gaW5pdGlhbGl6ZSB0aGUgYm9hcmQgd2l0aCBjaG9pY2UgY291bnRzXG4gICAgY29uc3QgYm9hcmQgPSBtYWtlQm9hcmQoeyBwdXp6bGUgfSk7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBib2FyZCwgaGlzdG9yeTogTGlzdC5vZihib2FyZCksIGhpc3RvcnlPZmZTZXQ6IDAsIHNvbHV0aW9uLFxuICAgIH0pO1xuICB9XG5cbiAgYWRkTnVtYmVyQXNOb3RlID0gKG51bWJlcikgPT4ge1xuICAgIGxldCB7IGJvYXJkIH0gPSB0aGlzLnN0YXRlO1xuICAgIGxldCBzZWxlY3RlZENlbGwgPSB0aGlzLmdldFNlbGVjdGVkQ2VsbCgpO1xuICAgIGlmICghc2VsZWN0ZWRDZWxsKSByZXR1cm47XG4gICAgY29uc3QgcHJlZmlsbGVkID0gc2VsZWN0ZWRDZWxsLmdldCgncHJlZmlsbGVkJyk7XG4gICAgaWYgKHByZWZpbGxlZCkgcmV0dXJuO1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gYm9hcmQuZ2V0KCdzZWxlY3RlZCcpO1xuICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHNlbGVjdGVkQ2VsbC5nZXQoJ3ZhbHVlJyk7XG4gICAgaWYgKGN1cnJlbnRWYWx1ZSkge1xuICAgICAgYm9hcmQgPSB1cGRhdGVCb2FyZFdpdGhOdW1iZXIoe1xuICAgICAgICB4LCB5LCBudW1iZXI6IGN1cnJlbnRWYWx1ZSwgZmlsbDogZmFsc2UsIGJvYXJkOiB0aGlzLnN0YXRlLmJvYXJkLFxuICAgICAgfSk7XG4gICAgfVxuICAgIGxldCBub3RlcyA9IHNlbGVjdGVkQ2VsbC5nZXQoJ25vdGVzJykgfHwgU2V0KCk7XG4gICAgaWYgKG5vdGVzLmhhcyhudW1iZXIpKSB7XG4gICAgICBub3RlcyA9IG5vdGVzLmRlbGV0ZShudW1iZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub3RlcyA9IG5vdGVzLmFkZChudW1iZXIpO1xuICAgIH1cbiAgICBzZWxlY3RlZENlbGwgPSBzZWxlY3RlZENlbGwuc2V0KCdub3RlcycsIG5vdGVzKTtcbiAgICBzZWxlY3RlZENlbGwgPSBzZWxlY3RlZENlbGwuZGVsZXRlKCd2YWx1ZScpO1xuICAgIGJvYXJkID0gYm9hcmQuc2V0SW4oWydwdXp6bGUnLCB4LCB5XSwgc2VsZWN0ZWRDZWxsKTtcbiAgICB0aGlzLnVwZGF0ZUJvYXJkKGJvYXJkKTtcbiAgfTtcblxuICB1cGRhdGVCb2FyZCA9IChuZXdCb2FyZCkgPT4ge1xuICAgIGxldCB7IGhpc3RvcnkgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgeyBoaXN0b3J5T2ZmU2V0IH0gPSB0aGlzLnN0YXRlO1xuICAgIC8vIGFueXRoaW5nIGJlZm9yZSBjdXJyZW50IHN0ZXAgaXMgc3RpbGwgaW4gaGlzdG9yeVxuICAgIGhpc3RvcnkgPSBoaXN0b3J5LnNsaWNlKDAsIGhpc3RvcnlPZmZTZXQgKyAxKTtcbiAgICAvLyBhZGQgaXRzZWxmIG9udG8gdGhlIGhpc3RvcnlcbiAgICBoaXN0b3J5ID0gaGlzdG9yeS5wdXNoKG5ld0JvYXJkKTtcbiAgICAvLyB1cGRhdGUgdGhlIGdhbWVcbiAgICB0aGlzLnNldFN0YXRlKHsgYm9hcmQ6IG5ld0JvYXJkLCBoaXN0b3J5LCBoaXN0b3J5T2ZmU2V0OiBoaXN0b3J5LnNpemUgLSAxIH0pO1xuICB9O1xuXG4gIGNhblVuZG8gPSAoKSA9PiB0aGlzLnN0YXRlLmhpc3RvcnlPZmZTZXQgPiAwXG5cbiAgcmVkbyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGhpc3RvcnkgfSA9IHRoaXMuc3RhdGU7XG4gICAgbGV0IHsgaGlzdG9yeU9mZlNldCB9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAoaGlzdG9yeS5zaXplKSB7XG4gICAgICBoaXN0b3J5T2ZmU2V0ID0gTWF0aC5taW4oaGlzdG9yeS5zaXplIC0gMSwgaGlzdG9yeU9mZlNldCArIDEpO1xuICAgICAgY29uc3QgYm9hcmQgPSBoaXN0b3J5LmdldChoaXN0b3J5T2ZmU2V0KTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBib2FyZCwgaGlzdG9yeU9mZlNldCB9KTtcbiAgICB9XG4gIH07XG5cbiAgdW5kbyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGhpc3RvcnkgfSA9IHRoaXMuc3RhdGU7XG4gICAgbGV0IHsgaGlzdG9yeU9mZlNldCwgYm9hcmQgfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKGhpc3Rvcnkuc2l6ZSkge1xuICAgICAgaGlzdG9yeU9mZlNldCA9IE1hdGgubWF4KDAsIGhpc3RvcnlPZmZTZXQgLSAxKTtcbiAgICAgIGJvYXJkID0gaGlzdG9yeS5nZXQoaGlzdG9yeU9mZlNldCk7XG4gICAgICB0aGlzLnNldFN0YXRlKHsgYm9hcmQsIGhpc3RvcnlPZmZTZXQsIGhpc3RvcnkgfSk7XG4gICAgfVxuICB9O1xuXG4gIGVyYXNlU2VsZWN0ZWQgPSAoKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0ZWRDZWxsID0gdGhpcy5nZXRTZWxlY3RlZENlbGwoKTtcbiAgICBpZiAoIXNlbGVjdGVkQ2VsbCkgcmV0dXJuO1xuICAgIHRoaXMuZmlsbE51bWJlcihmYWxzZSk7XG4gIH1cblxuICBmaWxsU2VsZWN0ZWRXaXRoU29sdXRpb24gPSAoKSA9PiB7XG4gICAgY29uc3QgeyBib2FyZCwgc29sdXRpb24gfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3Qgc2VsZWN0ZWRDZWxsID0gdGhpcy5nZXRTZWxlY3RlZENlbGwoKTtcbiAgICBpZiAoIXNlbGVjdGVkQ2VsbCkgcmV0dXJuO1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gYm9hcmQuZ2V0KCdzZWxlY3RlZCcpO1xuICAgIHRoaXMuZmlsbE51bWJlcihzb2x1dGlvblt4XVt5XSk7XG4gIH1cblxuXG4gIC8vIGZpbGwgY3VycmVudGx5IHNlbGVjdGVkIGNlbGwgd2l0aCBudW1iZXJcbiAgZmlsbE51bWJlciA9IChudW1iZXIpID0+IHtcbiAgICBsZXQgeyBib2FyZCB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBzZWxlY3RlZENlbGwgPSB0aGlzLmdldFNlbGVjdGVkQ2VsbCgpO1xuICAgIC8vIG5vLW9wIGlmIG5vdGhpbmcgaXMgc2VsZWN0ZWRcbiAgICBpZiAoIXNlbGVjdGVkQ2VsbCkgcmV0dXJuO1xuICAgIGNvbnN0IHByZWZpbGxlZCA9IHNlbGVjdGVkQ2VsbC5nZXQoJ3ByZWZpbGxlZCcpO1xuICAgIC8vIG5vLW9wIGlmIGl0IGlzIHJlZmlsbGVkXG4gICAgaWYgKHByZWZpbGxlZCkgcmV0dXJuO1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gYm9hcmQuZ2V0KCdzZWxlY3RlZCcpO1xuICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHNlbGVjdGVkQ2VsbC5nZXQoJ3ZhbHVlJyk7XG4gICAgLy8gcmVtb3ZlIHRoZSBjdXJyZW50IHZhbHVlIGFuZCB1cGRhdGUgdGhlIGdhbWUgc3RhdGVcbiAgICBpZiAoY3VycmVudFZhbHVlKSB7XG4gICAgICBib2FyZCA9IHVwZGF0ZUJvYXJkV2l0aE51bWJlcih7XG4gICAgICAgIHgsIHksIG51bWJlcjogY3VycmVudFZhbHVlLCBmaWxsOiBmYWxzZSwgYm9hcmQ6IHRoaXMuc3RhdGUuYm9hcmQsXG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gdXBkYXRlIHRvIG5ldyBudW1iZXIgaWYgYW55XG4gICAgY29uc3Qgc2V0TnVtYmVyID0gY3VycmVudFZhbHVlICE9PSBudW1iZXIgJiYgbnVtYmVyO1xuICAgIGlmIChzZXROdW1iZXIpIHtcbiAgICAgIGJvYXJkID0gdXBkYXRlQm9hcmRXaXRoTnVtYmVyKHtcbiAgICAgICAgeCwgeSwgbnVtYmVyLCBmaWxsOiB0cnVlLCBib2FyZCxcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZUJvYXJkKGJvYXJkKTtcbiAgfTtcblxuICBzZWxlY3RDZWxsID0gKHgsIHkpID0+IHtcbiAgICBsZXQgeyBib2FyZCB9ID0gdGhpcy5zdGF0ZTtcbiAgICBib2FyZCA9IGJvYXJkLnNldCgnc2VsZWN0ZWQnLCB7IHgsIHkgfSk7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IGJvYXJkIH0pO1xuICB9O1xuXG4gIGlzQ29uZmxpY3QoaSwgaikge1xuICAgIGNvbnN0IHsgdmFsdWUgfSA9IHRoaXMuc3RhdGUuYm9hcmQuZ2V0SW4oWydwdXp6bGUnLCBpLCBqXSkudG9KU09OKCk7XG4gICAgaWYgKCF2YWx1ZSkgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IHJvd0NvbmZsaWN0ID1cbiAgICAgIHRoaXMuc3RhdGUuYm9hcmQuZ2V0SW4oWydjaG9pY2VzJywgJ3Jvd3MnLCBpLCB2YWx1ZV0pID4gMTtcbiAgICBjb25zdCBjb2x1bW5Db25mbGljdCA9XG4gICAgICB0aGlzLnN0YXRlLmJvYXJkLmdldEluKFsnY2hvaWNlcycsICdjb2x1bW5zJywgaiwgdmFsdWVdKSA+IDE7XG4gICAgY29uc3Qgc3F1YXJlQ29uZmxpY3QgPVxuICAgICAgdGhpcy5zdGF0ZS5ib2FyZC5nZXRJbihbJ2Nob2ljZXMnLCAnc3F1YXJlcycsXG4gICAgICAgICgoTWF0aC5mbG9vcihpIC8gMykpICogMykgKyBNYXRoLmZsb29yKGogLyAzKSwgdmFsdWVdKSA+IDE7XG4gICAgcmV0dXJuIHJvd0NvbmZsaWN0IHx8IGNvbHVtbkNvbmZsaWN0IHx8IHNxdWFyZUNvbmZsaWN0O1xuICB9XG5cbiAgcmVuZGVyQ2VsbChjZWxsLCB4LCB5KSB7XG4gICAgY29uc3QgeyBib2FyZCB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBzZWxlY3RlZCA9IHRoaXMuZ2V0U2VsZWN0ZWRDZWxsKCk7XG4gICAgY29uc3QgeyB2YWx1ZSwgcHJlZmlsbGVkLCBub3RlcyB9ID0gY2VsbC50b0pTT04oKTtcbiAgICBjb25zdCBjb25mbGljdCA9IHRoaXMuaXNDb25mbGljdCh4LCB5KTtcbiAgICBjb25zdCBwZWVyID0gYXJlQ29vcmRpbmF0ZVBlZXJzKHsgeCwgeSB9LCBib2FyZC5nZXQoJ3NlbGVjdGVkJykpO1xuICAgIGNvbnN0IHNhbWVWYWx1ZSA9ICEhKHNlbGVjdGVkICYmIHNlbGVjdGVkLmdldCgndmFsdWUnKVxuICAgICAgJiYgdmFsdWUgPT09IHNlbGVjdGVkLmdldCgndmFsdWUnKSk7XG5cbiAgICBjb25zdCBpc1NlbGVjdGVkID0gY2VsbCA9PT0gc2VsZWN0ZWQ7XG4gICAgcmV0dXJuICg8Q2VsbFxuICAgICAgcHJlZmlsbGVkPXtwcmVmaWxsZWR9XG4gICAgICBub3Rlcz17bm90ZXN9XG4gICAgICBzYW1lVmFsdWU9e3NhbWVWYWx1ZX1cbiAgICAgIGlzU2VsZWN0ZWQ9e2lzU2VsZWN0ZWR9XG4gICAgICBpc1BlZXI9e3BlZXJ9XG4gICAgICB2YWx1ZT17dmFsdWV9XG4gICAgICBvbkNsaWNrPXsoKSA9PiB7IHRoaXMuc2VsZWN0Q2VsbCh4LCB5KTsgfX1cbiAgICAgIGtleT17eX1cbiAgICAgIHg9e3h9XG4gICAgICB5PXt5fVxuICAgICAgY29uZmxpY3Q9e2NvbmZsaWN0fVxuICAgIC8+KTtcbiAgfVxuXG4gIHJlbmRlck51bWJlckNvbnRyb2woKSB7XG4gICAgY29uc3Qgc2VsZWN0ZWRDZWxsID0gdGhpcy5nZXRTZWxlY3RlZENlbGwoKTtcbiAgICBjb25zdCBwcmVmaWxsZWQgPSBzZWxlY3RlZENlbGwgJiYgc2VsZWN0ZWRDZWxsLmdldCgncHJlZmlsbGVkJyk7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29udHJvbFwiPlxuICAgICAgICB7cmFuZ2UoOSkubWFwKChpKSA9PiB7XG4gICAgICAgICAgY29uc3QgbnVtYmVyID0gaSArIDE7XG4gICAgICAgICAgLy8gaGFuZGxlcyBiaW5kaW5nIHNpbmdsZSBjbGljayBhbmQgZG91YmxlIGNsaWNrIGNhbGxiYWNrc1xuICAgICAgICAgIGNvbnN0IGNsaWNrSGFuZGxlID0gZ2V0Q2xpY2tIYW5kbGVyKFxuICAgICAgICAgICAgKCkgPT4geyB0aGlzLmZpbGxOdW1iZXIobnVtYmVyKTsgfSxcbiAgICAgICAgICAgICgpID0+IHsgdGhpcy5hZGROdW1iZXJBc05vdGUobnVtYmVyKTsgfSxcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8TnVtYmVyQ29udHJvbFxuICAgICAgICAgICAgICBrZXk9e251bWJlcn1cbiAgICAgICAgICAgICAgbnVtYmVyPXtudW1iZXJ9XG4gICAgICAgICAgICAgIG9uQ2xpY2s9eyFwcmVmaWxsZWQgPyBjbGlja0hhbmRsZSA6IHVuZGVmaW5lZH1cbiAgICAgICAgICAgICAgY29tcGxldGlvblBlcmNlbnRhZ2U9e3RoaXMuZ2V0TnVtYmVyVmFsdWVDb3VudChudW1iZXIpIC8gOX1cbiAgICAgICAgICAgIC8+KTtcbiAgICAgICAgfSl9XG4gICAgICAgIDxzdHlsZSBqc3g+e0NvbnRyb2xTdHlsZX08L3N0eWxlPlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxuXG4gIHJlbmRlckFjdGlvbnMoKSB7XG4gICAgY29uc3QgeyBoaXN0b3J5IH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IHNlbGVjdGVkQ2VsbCA9IHRoaXMuZ2V0U2VsZWN0ZWRDZWxsKCk7XG4gICAgY29uc3QgcHJlZmlsbGVkID0gc2VsZWN0ZWRDZWxsICYmIHNlbGVjdGVkQ2VsbC5nZXQoJ3ByZWZpbGxlZCcpO1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImFjdGlvbnNcIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJhY3Rpb25cIiBvbkNsaWNrPXtoaXN0b3J5LnNpemUgPyB0aGlzLnVuZG8gOiBudWxsfT5cbiAgICAgICAgICA8UmVsb2FkSWNvbiAvPlVuZG9cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWN0aW9uIHJlZG9cIiBvbkNsaWNrPXtoaXN0b3J5LnNpemUgPyB0aGlzLnJlZG8gOiBudWxsfT5cbiAgICAgICAgICA8UmVsb2FkSWNvbiAvPlJlZG9cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWN0aW9uXCIgb25DbGljaz17IXByZWZpbGxlZCA/IHRoaXMuZXJhc2VTZWxlY3RlZCA6IG51bGx9PlxuICAgICAgICAgIDxSZW1vdmVJY29uIC8+RXJhc2VcbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXZcbiAgICAgICAgICBjbGFzc05hbWU9XCJhY3Rpb25cIlxuICAgICAgICAgIG9uQ2xpY2s9eyFwcmVmaWxsZWQgP1xuICAgICAgICAgIHRoaXMuZmlsbFNlbGVjdGVkV2l0aFNvbHV0aW9uIDogbnVsbH1cbiAgICAgICAgPlxuICAgICAgICAgIDxMb3VwZUljb24gLz5IaW50XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8c3R5bGUganN4PntBY3Rpb25zU3R5bGV9PC9zdHlsZT5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cblxuICByZW5kZXJQdXp6bGUoKSB7XG4gICAgY29uc3QgeyBib2FyZCB9ID0gdGhpcy5zdGF0ZTtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJwdXp6bGVcIj5cbiAgICAgICAge2JvYXJkLmdldCgncHV6emxlJykubWFwKChyb3csIGkpID0+IChcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3Qvbm8tYXJyYXktaW5kZXgta2V5XG4gICAgICAgICAgPGRpdiBrZXk9e2l9IGNsYXNzTmFtZT1cInJvd1wiPlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICByb3cubWFwKChjZWxsLCBqKSA9PiB0aGlzLnJlbmRlckNlbGwoY2VsbCwgaSwgaikpLnRvQXJyYXkoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICApKS50b0FycmF5KCl9XG4gICAgICAgIDxzdHlsZSBqc3g+e1B1enpsZVN0eWxlfTwvc3R5bGU+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG5cbiAgcmVuZGVyQ29udHJvbHMoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29udHJvbHNcIj5cbiAgICAgICAge3RoaXMucmVuZGVyTnVtYmVyQ29udHJvbCgpfVxuICAgICAgICB7dGhpcy5yZW5kZXJBY3Rpb25zKCl9XG4gICAgICAgIHsgLyogbGFuZ3VhZ2U9Q1NTICovIH1cbiAgICAgICAgPHN0eWxlIGpzeD57YFxuICAgICAgICAgICAgLmNvbnRyb2xzIHtcbiAgICAgICAgICAgICAgICBtYXJnaW4tdG9wOiAuM2VtO1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgICAgICAgZmxleC13cmFwOiB3cmFwO1xuICAgICAgICAgICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICAgICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICAgICAgICAgIHBhZGRpbmc6IC41ZW0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgYH1cbiAgICAgICAgPC9zdHlsZT5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cblxuICByZW5kZXJHZW5lcmF0aW9uVUkoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxHZW5lcmF0aW9uVUkgZ2VuZXJhdGVHYW1lPXt0aGlzLmdlbmVyYXRlR2FtZX0gLz5cbiAgICApO1xuICB9XG5cbiAgcmVuZGVySGVhZGVyKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImhlYWRlclwiPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm5ldy1nYW1lXCIgb25DbGljaz17KCkgPT4gdGhpcy5zZXRTdGF0ZSh7IGJvYXJkOiBmYWxzZSB9KX0+XG4gICAgICAgICAgPFJldHVybkljb24gLz5cbiAgICAgICAgICA8ZGl2Pk5ldyBHYW1lPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8VGlwIC8+XG4gICAgICAgIHsgLyogbGFuZ3VhZ2U9Q1NTICovIH1cbiAgICAgICAgPHN0eWxlIGpzeD57YFxuICAgICAgICAgICAgLmhlYWRlciB7XG4gICAgICAgICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gICAgICAgICAgICAgICAgbWF4LXdpZHRoOiA1MDBweDtcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiAwIDAuNWVtO1xuICAgICAgICAgICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAubmV3LWdhbWUge1xuICAgICAgICAgICAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICAgICAgICAgICAgICBtYXJnaW4tdG9wOiAuMmVtO1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6IGlubGluZS1mbGV4O1xuICAgICAgICAgICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgICAgICAgICAgcGFkZGluZzogLjJlbSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLm5ldy1nYW1lIDpnbG9iYWwoc3ZnKSB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxZW07XG4gICAgICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogLjNlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgYH1cbiAgICAgICAgPC9zdHlsZT5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBib2FyZCB9ID0gdGhpcy5zdGF0ZTtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJib2R5XCI+XG4gICAgICAgIDxOZXh0SGVhZD5cbiAgICAgICAgICA8dGl0bGU+U3Vkb2t1IEV2b2x2ZWQ8L3RpdGxlPlxuICAgICAgICAgIDxtZXRhIG5hbWU9XCJ2aWV3cG9ydFwiIGNvbnRlbnQ9XCJpbml0aWFsLXNjYWxlPTEuMCwgd2lkdGg9ZGV2aWNlLXdpZHRoXCIgLz5cbiAgICAgICAgICA8bWV0YSBuYW1lPVwiZGVzY3JpcHRpb25cIiBjb250ZW50PXtEZXNjcmlwdGlvbn0gLz5cbiAgICAgICAgICA8bGluayBocmVmPVwiaHR0cHM6Ly9mb250cy5nb29nbGVhcGlzLmNvbS9jc3M/ZmFtaWx5PVNwZWNpYWwrRWxpdGVcIiByZWw9XCJzdHlsZXNoZWV0XCIgLz5cbiAgICAgICAgICA8bWV0YSBwcm9wZXJ0eT1cIm9nOnVybFwiIGNvbnRlbnQ9XCJodHRwczovL3N1ZG9rdS5zaXRpYW5saXUuY29tL1wiIC8+XG4gICAgICAgICAgPG1ldGEgcHJvcGVydHk9XCJvZzp0aXRsZVwiIGNvbnRlbnQ9XCJTdWRva3UgRXZvbHZlZFwiIC8+XG4gICAgICAgICAgPG1ldGEgcHJvcGVydHk9XCJvZzp0eXBlXCIgY29udGVudD1cIndlYnNpdGVcIiAvPlxuICAgICAgICAgIDxtZXRhIHByb3BlcnR5PVwib2c6ZGVzY3JpcHRpb25cIiBjb250ZW50PXtEZXNjcmlwdGlvbn0gLz5cbiAgICAgICAgICA8bWV0YSBwcm9wZXJ0eT1cIm9nOmltYWdlXCIgY29udGVudD1cImh0dHBzOi8vc3Vkb2t1LnNpdGlhbmxpdS5jb20vc3RhdGljL29nLWltYWdlLnBuZ1wiIC8+XG4gICAgICAgIDwvTmV4dEhlYWQ+XG4gICAgICAgIHshYm9hcmQgJiYgdGhpcy5yZW5kZXJHZW5lcmF0aW9uVUkoKX1cbiAgICAgICAge2JvYXJkICYmIHRoaXMucmVuZGVySGVhZGVyKCl9XG4gICAgICAgIHtib2FyZCAmJiB0aGlzLnJlbmRlclB1enpsZSgpfVxuICAgICAgICB7Ym9hcmQgJiYgdGhpcy5yZW5kZXJDb250cm9scygpfVxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInJvb3RlclwiPlxuICAgICAgICAgIE1hZGUgd2l0aCA8c3Bhbj7inaTvuI88L3NwYW4+77iPIEJ5IDxhIGhyZWY9XCJodHRwczovL3d3dy5zaXRpYW5saXUuY29tL1wiPlNpdGlhbiBMaXU8L2E+IHwgPGEgaHJlZj1cImh0dHBzOi8vbWVkaXVtLmNvbS9Ac2l0aWFubGl1XzU3NjgwL2J1aWxkaW5nLWEtc3Vkb2t1LWdhbWUtaW4tcmVhY3QtY2E2NjM5MTU3MTJcIj5CbG9nIFBvc3Q8L2E+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICB7IC8qIGxhbmd1YWdlPUNTUyAqLyB9XG4gICAgICAgIDxzdHlsZSBqc3g+e2BcbiAgICAgICAgICAgIDpnbG9iYWwoYm9keSksIC5ib2R5IHtcbiAgICAgICAgICAgICAgICBmb250LWZhbWlseTogJ1NwZWNpYWwgRWxpdGUnLCBjdXJzaXZlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLmJvZHkge1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICAgICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICAgICAgICAgIGhlaWdodDogMTAwdmg7XG4gICAgICAgICAgICAgICAgd2lkdGg6IDEwMHZ3O1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEBtZWRpYSAobWluLXdpZHRoOiA4MDBweCkgYW5kIChtaW4taGVpZ2h0OiA5MzBweCl7XG4gICAgICAgICAgICAgICAgOmdsb2JhbCguaGVhZGVyLCAucHV6emxlLCAuY29udHJvbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9udC1zaXplOiAxLjVlbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBAbWVkaWEgKG1heC13aWR0aDogODAwcHgpIGFuZCAobWluLXdpZHRoOiA2MDBweCl7XG4gICAgICAgICAgICAgICAgOmdsb2JhbCguaGVhZGVyLCAucHV6emxlLCAuY29udHJvbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9udC1zaXplOiAxLjJlbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBAbWVkaWEgKG1heC1oZWlnaHQ6IDkzMHB4KSBhbmQgKG1pbi1oZWlnaHQ6IDgwMHB4KSBhbmQgKG1pbi13aWR0aDogNjAwcHgpe1xuICAgICAgICAgICAgICAgIDpnbG9iYWwoLmhlYWRlciwgLnB1enpsZSwgLmNvbnRyb2xzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvbnQtc2l6ZTogMS4yZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQG1lZGlhIChtYXgtaGVpZ2h0OiA4MDBweCkgYW5kIChtaW4taGVpZ2h0OiA2MDBweCkgYW5kIChtaW4td2lkdGg6IDM3MHB4KXtcbiAgICAgICAgICAgICAgICA6Z2xvYmFsKC5oZWFkZXIsIC5wdXp6bGUsIC5jb250cm9scykge1xuICAgICAgICAgICAgICAgICAgICBmb250LXNpemU6IDFlbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBAbWVkaWEgKG1heC13aWR0aDogMzcwcHgpe1xuICAgICAgICAgICAgICAgIDpnbG9iYWwoLmhlYWRlciwgLnB1enpsZSwgLmNvbnRyb2xzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvbnQtc2l6ZTogLjhlbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBAbWVkaWEgKG1heC1oZWlnaHQ6IDYwMHB4KXtcbiAgICAgICAgICAgICAgICA6Z2xvYmFsKC5oZWFkZXIsIC5wdXp6bGUsIC5jb250cm9scykge1xuICAgICAgICAgICAgICAgICAgICBmb250LXNpemU6IC44ZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOmdsb2JhbChib2R5KSB7XG4gICAgICAgICAgICAgICAgbWFyZ2luOiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLnJvb3RlciB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgICAgICAgICAgIGJvdHRvbTogMDtcbiAgICAgICAgICAgICAgICBmb250LXNpemU6IC44ZW07XG4gICAgICAgICAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgICAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICBgfVxuICAgICAgICA8L3N0eWxlPlxuICAgICAgICA8c3R5bGUganN4IGdsb2JhbD57UmFuZ2VTdHlsZX08L3N0eWxlPlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufVxuIl19 */\n/*@ sourceURL=pages/index.js */'
        }),
        __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_0_styled_jsx_style___default.a, {
          styleId: __WEBPACK_IMPORTED_MODULE_7__input_range_style__["a" /* default */].__hash,
          css: __WEBPACK_IMPORTED_MODULE_7__input_range_style__["a" /* default */]
        })
      );
    }
  }, {
    key: '__reactstandin__regenerateByEval',
    value: function __reactstandin__regenerateByEval(key, code) {
      this[key] = eval(code);
    }
  }]);

  return Index;
}(__WEBPACK_IMPORTED_MODULE_1_react__["Component"]);

var _default = Index;
/* harmony default export */ __webpack_exports__["default"] = (_default);
;

(function () {
  var reactHotLoader = __webpack_require__("./node_modules/react-hot-loader/patch.js").default;

  var leaveModule = __webpack_require__("./node_modules/react-hot-loader/patch.js").leaveModule;

  if (!reactHotLoader) {
    return;
  }

  reactHotLoader.register(Description, 'Description', '/Users/lichenma/Projects/SuDuoku/SuDuoku/pages/index.js');
  reactHotLoader.register(cellWidth, 'cellWidth', '/Users/lichenma/Projects/SuDuoku/SuDuoku/pages/index.js');
  reactHotLoader.register(LightBlue100, 'LightBlue100', '/Users/lichenma/Projects/SuDuoku/SuDuoku/pages/index.js');
  reactHotLoader.register(LightBlue200, 'LightBlue200', '/Users/lichenma/Projects/SuDuoku/SuDuoku/pages/index.js');
  reactHotLoader.register(LightBlue300, 'LightBlue300', '/Users/lichenma/Projects/SuDuoku/SuDuoku/pages/index.js');
  reactHotLoader.register(Indigo700, 'Indigo700', '/Users/lichenma/Projects/SuDuoku/SuDuoku/pages/index.js');
  reactHotLoader.register(DeepOrange200, 'DeepOrange200', '/Users/lichenma/Projects/SuDuoku/SuDuoku/pages/index.js');
  reactHotLoader.register(DeepOrange600, 'DeepOrange600', '/Users/lichenma/Projects/SuDuoku/SuDuoku/pages/index.js');
  reactHotLoader.register(ControlNumberColor, 'ControlNumberColor', '/Users/lichenma/Projects/SuDuoku/SuDuoku/pages/index.js');
  reactHotLoader.register(CellStyle, 'CellStyle', '/Users/lichenma/Projects/SuDuoku/SuDuoku/pages/index.js');
  reactHotLoader.register(ActionsStyle, 'ActionsStyle', '/Users/lichenma/Projects/SuDuoku/SuDuoku/pages/index.js');
  reactHotLoader.register(ControlStyle, 'ControlStyle', '/Users/lichenma/Projects/SuDuoku/SuDuoku/pages/index.js');
  reactHotLoader.register(NumberControlStyle, 'NumberControlStyle', '/Users/lichenma/Projects/SuDuoku/SuDuoku/pages/index.js');
  reactHotLoader.register(PuzzleStyle, 'PuzzleStyle', '/Users/lichenma/Projects/SuDuoku/SuDuoku/pages/index.js');
  reactHotLoader.register(CirculuarProgressStyle, 'CirculuarProgressStyle', '/Users/lichenma/Projects/SuDuoku/SuDuoku/pages/index.js');
  reactHotLoader.register(CircularPathD, 'CircularPathD', '/Users/lichenma/Projects/SuDuoku/SuDuoku/pages/index.js');
  reactHotLoader.register(getBackGroundColor, 'getBackGroundColor', '/Users/lichenma/Projects/SuDuoku/SuDuoku/pages/index.js');
  reactHotLoader.register(getFontColor, 'getFontColor', '/Users/lichenma/Projects/SuDuoku/SuDuoku/pages/index.js');
  reactHotLoader.register(GenerationUI, 'GenerationUI', '/Users/lichenma/Projects/SuDuoku/SuDuoku/pages/index.js');
  reactHotLoader.register(NumberControl, 'NumberControl', '/Users/lichenma/Projects/SuDuoku/SuDuoku/pages/index.js');
  reactHotLoader.register(Cell, 'Cell', '/Users/lichenma/Projects/SuDuoku/SuDuoku/pages/index.js');
  reactHotLoader.register(CirclularProgress, 'CirclularProgress', '/Users/lichenma/Projects/SuDuoku/SuDuoku/pages/index.js');
  reactHotLoader.register(getClickHandler, 'getClickHandler', '/Users/lichenma/Projects/SuDuoku/SuDuoku/pages/index.js');
  reactHotLoader.register(makeCountObject, 'makeCountObject', '/Users/lichenma/Projects/SuDuoku/SuDuoku/pages/index.js');
  reactHotLoader.register(makeBoard, 'makeBoard', '/Users/lichenma/Projects/SuDuoku/SuDuoku/pages/index.js');
  reactHotLoader.register(updateBoardWithNumber, 'updateBoardWithNumber', '/Users/lichenma/Projects/SuDuoku/SuDuoku/pages/index.js');
  reactHotLoader.register(getNumberOfGroupsAssignedForNumber, 'getNumberOfGroupsAssignedForNumber', '/Users/lichenma/Projects/SuDuoku/SuDuoku/pages/index.js');
  reactHotLoader.register(Index, 'Index', '/Users/lichenma/Projects/SuDuoku/SuDuoku/pages/index.js');
  reactHotLoader.register(_default, 'default', '/Users/lichenma/Projects/SuDuoku/SuDuoku/pages/index.js');
  leaveModule(module);
})();

;
    (function (Component, route) {
      if(!Component) return
      if (false) return
      module.hot.accept()
      Component.__route = route

      if (module.hot.status() === 'idle') return

      var components = next.router.components
      for (var r in components) {
        if (!components.hasOwnProperty(r)) continue

        if (components[r].Component.__route === route) {
          next.router.update(r, Component)
        }
      }
    })(typeof __webpack_exports__ !== 'undefined' ? __webpack_exports__.default : (module.exports.default || module.exports), "/")
  
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__("./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./sudoku.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (immutable) */ __webpack_exports__["d"] = range;
/* harmony export (immutable) */ __webpack_exports__["b"] = makePuzzle;
/* harmony export (immutable) */ __webpack_exports__["a"] = isPeer;
/* harmony export (immutable) */ __webpack_exports__["c"] = pluck;
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

(function () {
  var enterModule = __webpack_require__("./node_modules/react-hot-loader/patch.js").enterModule;

  enterModule && enterModule(module);
})();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function randomChoice(choices) {
  return choices[Math.floor(Math.random() * choices.length)];
}

function range(n) {
  return Array.from(Array(n).keys());
}

// TODO use immutable when this is all working
function makePuzzle() {
  while (true) {
    try {
      var _ret = function () {
        var puzzle = Array.from(Array(9).keys()).map(function () {
          return Array.from(Array(9).keys());
        });
        var rows = Array.from(Array(9).keys()).map(function () {
          return new Set([1, 2, 3, 4, 5, 6, 7, 8, 9]);
        });
        var columns = Array.from(Array(9).keys()).map(function () {
          return new Set([1, 2, 3, 4, 5, 6, 7, 8, 9]);
        });
        var squares = Array.from(Array(9).keys()).map(function () {
          return new Set([1, 2, 3, 4, 5, 6, 7, 8, 9]);
        });
        Array.from(Array(9).keys()).forEach(function (i) {
          Array.from(Array(9).keys()).forEach(function (j) {
            var row = rows[i];
            var column = columns[j];
            var square = squares[Math.floor(i / 3) * 3 + Math.floor(j / 3)];
            var choices = [].concat(_toConsumableArray(row)).filter(function (x) {
              return column.has(x);
            }).filter(function (x) {
              return square.has(x);
            });
            var choice = randomChoice(choices);
            if (!choice) {
              // eslint-disable-next-line no-throw-literal
              throw 'dead end';
            }
            puzzle[i][j] = choice;
            column.delete(choice);
            row.delete(choice);
            square.delete(choice);
          });
        });
        return {
          v: puzzle
        };
      }();

      if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
    } catch (e) {
      // eslint-disable-next-line no-continue
      continue;
    }
  }
}

/**
 * Answers the question: can the cell (i,j) in the puzzle contain the number
 in cell "c"
 * @param puzzle
 * @param i
 * @param j
 * @param c
 */
function canBeA(puzzle, i, j, c) {
  var x = Math.floor(c / 9);
  var y = c % 9;
  var value = puzzle[x][y];
  if (puzzle[i][j] === value) return true;
  if (puzzle[i][j] > 0) return false;
  // if not the cell itself, and the mth cell of the group contains the value v, then "no"
  // eslint-disable-next-line guard-for-in,no-restricted-syntax
  for (var m in Array.from(Array(9).keys())) {
    var rowPeer = { x: m, y: j };
    var columnPeer = { x: i, y: m };
    var SquarePeer = {
      x: Math.floor(i / 3) * 3 + Math.floor(m / 3),
      y: Math.floor(j / 3) * 3 + m % 3
    };
    if (!(rowPeer.x === x && rowPeer.y === y) && puzzle[(rowPeer.x, rowPeer.y)] === value) return false;
    if (!(columnPeer.x === x && columnPeer.y === y) && puzzle[(columnPeer.x, columnPeer.y)] === value) return false;
    if (!(SquarePeer.x === x && SquarePeer.y === y) && puzzle[(SquarePeer.x, SquarePeer.y)] === value) return false;
  }
  return true;
}

/**
 *
 * @param a
 * @param b
 * @returns {boolean}
 */
function isPeer(a, b) {
  if (!a || !b) return false;
  var squareA = Math.floor(a.x / 3) * 3 + Math.floor(a.y / 3);
  var squareB = Math.floor(b.x / 3) * 3 + Math.floor(b.y / 3);
  return a.x === b.x || a.y === b.y || squareA === squareB;
}

function pluck(allCells) {
  var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

  var puzzle = JSON.parse(JSON.stringify(allCells));
  /**
     * starts with a set of all 81 cells, and tries to remove one (randomly) at a time,
     * but not before checking that the cell can still be deduced from the remaining cells.
     * @type {Set}
     */
  var cells = new Set(Array.from(Array(81).keys()));
  var cellsLeft = new Set(cells);

  var _loop = function _loop() {
    var cell = randomChoice([].concat(_toConsumableArray(cells)));
    var x = Math.floor(cell / 9);
    var y = cell % 9;
    cellsLeft.delete(cell);
    /**
         * row, column and square record whether another cell in those groups could also take
         * on the value we are trying to pluck. (If another cell can, then we can't use the
         * group to deduce this value.) If all three groups are True, then we cannot pluck
         * this cell and must try another one.
         */
    var row = false;
    var column = false;
    var square = false;
    range(9).forEach(function (i) {
      var rowPeer = { x: i, y: y };
      var columnPeer = { x: x, y: i };
      var squarePeer = {
        x: Math.floor(Math.floor(cell / 9) / 3) * 3 + Math.floor(i / 3),
        y: Math.floor(cell / 9) % 3 * 3 + i % 3
      };
      if (rowPeer.x !== x) {
        row = canBeA(puzzle, rowPeer.x, rowPeer.y, cell);
      }
      if (columnPeer.y !== y) {
        column = canBeA(puzzle, columnPeer.x, columnPeer.y, cell);
      }
      if (squarePeer.x !== x && squarePeer.y !== y) {
        square = canBeA(puzzle, squarePeer.x, squarePeer.y, cell);
      }
    });
    if (row && column && square) {
      // eslint-disable-next-line no-continue
      return 'continue';
    } else {
      // this is a pluckable cell!
      // eslint-disable-next-line no-param-reassign
      puzzle[x][y] = 0; // 0 denotes a blank cell
      /**
             * remove from the set of visible cells (pluck it)
             * we don't need to reset "cellsleft" because if a cell was not pluckable
             * earlier, then it will still not be pluckable now (with less information
             * on the board).
             */
      cells.delete(cell);
    }
  };

  while (cellsLeft.size && cells.size > n) {
    var _ret2 = _loop();

    if (_ret2 === 'continue') continue;
  }
  return { puzzle: puzzle, size: cells.size };
}
;

(function () {
  var reactHotLoader = __webpack_require__("./node_modules/react-hot-loader/patch.js").default;

  var leaveModule = __webpack_require__("./node_modules/react-hot-loader/patch.js").leaveModule;

  if (!reactHotLoader) {
    return;
  }

  reactHotLoader.register(randomChoice, 'randomChoice', '/Users/lichenma/Projects/SuDuoku/SuDuoku/sudoku.js');
  reactHotLoader.register(range, 'range', '/Users/lichenma/Projects/SuDuoku/SuDuoku/sudoku.js');
  reactHotLoader.register(makePuzzle, 'makePuzzle', '/Users/lichenma/Projects/SuDuoku/SuDuoku/sudoku.js');
  reactHotLoader.register(canBeA, 'canBeA', '/Users/lichenma/Projects/SuDuoku/SuDuoku/sudoku.js');
  reactHotLoader.register(isPeer, 'isPeer', '/Users/lichenma/Projects/SuDuoku/SuDuoku/sudoku.js');
  reactHotLoader.register(pluck, 'pluck', '/Users/lichenma/Projects/SuDuoku/SuDuoku/sudoku.js');
  leaveModule(module);
})();

;
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__("./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./svg/help.svg":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__("./node_modules/react/cjs/react.development.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }



var _ref = /*#__PURE__*/__WEBPACK_IMPORTED_MODULE_0_react__["createElement"]("path", {
  d: "M231.2 336.033c-9.35 0-17 7.65-17 17v11.333c0 9.35 7.65 17 17 17s17-7.65 17-17v-11.333c0-9.35-7.65-17-17-17z"
});

var _ref2 = /*#__PURE__*/__WEBPACK_IMPORTED_MODULE_0_react__["createElement"]("path", {
  d: "M236.867 473.733c130.617 0 236.867-106.25 236.867-236.867S367.483 0 236.867 0 0 106.25 0 236.867s106.25 236.866 236.867 236.866zm0-439.733c111.917 0 202.867 90.95 202.867 202.867s-90.95 202.867-202.867 202.867S34 348.783 34 236.867 124.95 34 236.867 34z"
});

var _ref3 = /*#__PURE__*/__WEBPACK_IMPORTED_MODULE_0_react__["createElement"]("path", {
  d: "M163.2 194.367c.283 0 .283 0 0 0 9.35 0 17-7.083 17-16.433 0 0 .283-13.6 7.083-26.917 8.5-17 23.517-25.5 45.617-25.5 20.683 0 35.983 5.667 44.483 16.717 7.083 9.067 9.067 21.533 5.667 35.133-4.25 16.717-18.7 31.167-32.583 45.333-17 17.567-34.85 35.417-34.85 59.5 0 9.35 7.65 17 17 17s17-7.65 17-17c0-10.2 12.183-22.667 25.217-35.7 16.15-16.433 34.567-35.133 41.083-60.633 6.233-23.517 1.983-47.033-11.617-64.317-10.483-13.6-31.45-30.033-71.117-30.033-44.483 0-65.733 23.8-75.933 44.2-10.2 20.4-10.767 39.95-10.767 42.217 0 9.066 7.367 16.433 16.717 16.433z"
});

function SvgHelp(props) {
  return /*#__PURE__*/__WEBPACK_IMPORTED_MODULE_0_react__["createElement"]("svg", _extends({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 473.733 473.733"
  }, props), _ref, _ref2, _ref3);
}

/* harmony default export */ __webpack_exports__["a"] = (SvgHelp);

/***/ }),

/***/ "./svg/loupe.svg":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__("./node_modules/react/cjs/react.development.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }



var _ref = /*#__PURE__*/__WEBPACK_IMPORTED_MODULE_0_react__["createElement"]("path", {
  d: "M457.602 54.355c-72.417-72.416-190.245-72.416-262.661 0-35.081 35.079-54.399 81.721-54.399 131.331 0 45.193 16.039 87.917 45.413 121.688l-22.119 22.119-22.542-22.542a13.173 13.173 0 00-18.628 0L17.055 412.563C6.057 423.559 0 438.18 0 453.733c0 15.552 6.057 30.174 17.053 41.17 10.998 10.998 25.619 17.054 41.17 17.054 15.551 0 30.174-6.057 41.17-17.053l105.612-105.61a13.173 13.173 0 000-18.628l-22.542-22.542 22.126-22.126c34.793 30.215 78.234 45.331 121.682 45.331 47.561 0 95.123-18.104 131.331-54.311C492.68 281.938 512 235.298 512 185.688c0-49.613-19.318-96.254-54.398-131.333zM80.765 476.275c-6.021 6.021-14.026 9.337-22.542 9.337-8.515 0-16.521-3.317-22.542-9.338-6.02-6.02-9.337-14.026-9.337-22.54s3.317-16.521 9.338-22.542l58.934-58.934L139.7 417.34l-58.935 58.935zm77.565-77.564l-45.084-45.084 18.734-18.734 45.084 45.085-18.734 18.733zm280.643-100.323c-62.144 62.146-163.259 62.146-225.403 0-30.104-30.104-46.683-70.128-46.683-112.702s16.579-82.598 46.683-112.701c31.072-31.072 71.887-46.609 112.702-46.609 40.814 0 81.63 15.535 112.702 46.609 30.104 30.103 46.683 70.128 46.683 112.701s-16.58 82.598-46.684 112.702z"
});

var _ref2 = /*#__PURE__*/__WEBPACK_IMPORTED_MODULE_0_react__["createElement"]("path", {
  d: "M417.234 94.721c-50.158-50.156-131.769-50.158-181.927 0-50.156 50.158-50.156 131.769.001 181.927 25.079 25.077 58.02 37.617 90.963 37.617s65.885-12.54 90.964-37.617v-.001c50.156-50.156 50.156-131.768-.001-181.926zM398.605 258.02c-39.886 39.886-104.783 39.886-144.669.001-39.886-39.886-39.886-104.784-.001-144.67 19.945-19.946 46.136-29.914 72.336-29.914 26.193 0 52.394 9.974 72.334 29.914 39.886 39.885 39.886 104.783 0 144.669z"
});

var _ref3 = /*#__PURE__*/__WEBPACK_IMPORTED_MODULE_0_react__["createElement"]("path", {
  d: "M375.321 136.636c-27.048-27.045-71.053-27.045-98.1 0-5.144 5.144-5.144 13.484 0 18.63 5.144 5.144 13.484 5.144 18.63 0 16.772-16.774 44.068-16.774 60.842 0a13.128 13.128 0 009.314 3.858 13.13 13.13 0 009.314-3.858c5.144-5.144 5.144-13.485 0-18.63z"
});

function SvgLoupe(props) {
  return /*#__PURE__*/__WEBPACK_IMPORTED_MODULE_0_react__["createElement"]("svg", _extends({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 512 512"
  }, props), _ref, _ref2, _ref3);
}

/* harmony default export */ __webpack_exports__["a"] = (SvgLoupe);

/***/ }),

/***/ "./svg/reload.svg":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__("./node_modules/react/cjs/react.development.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }



var _ref = /*#__PURE__*/__WEBPACK_IMPORTED_MODULE_0_react__["createElement"]("path", {
  d: "M482.195 226.196C482.195 101.471 380.725 0 256.001 0S29.805 101.471 29.805 226.196c0 7.409 6.007 13.416 13.416 13.416s13.416-6.008 13.416-13.416c0-109.93 89.434-199.363 199.363-199.363s199.363 89.434 199.363 199.363c0 109.928-89.434 199.362-199.363 199.362h-23.276l33.282-37.255c4.937-5.525 4.458-14.007-1.067-18.944-5.525-4.937-14.008-4.457-18.944 1.068l-47.576 53.255c-7.788 8.718-7.788 21.866 0 30.584l47.576 53.255a13.379 13.379 0 0010.01 4.478c3.181 0 6.375-1.126 8.934-3.41 5.526-4.937 6.004-13.419 1.067-18.944l-33.282-37.255H256c124.725 0 226.195-101.471 226.195-226.194z"
});

function SvgReload(props) {
  return /*#__PURE__*/__WEBPACK_IMPORTED_MODULE_0_react__["createElement"]("svg", _extends({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 512 512"
  }, props), _ref);
}

/* harmony default export */ __webpack_exports__["a"] = (SvgReload);

/***/ }),

/***/ "./svg/remove.svg":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__("./node_modules/react/cjs/react.development.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }



var _ref = /*#__PURE__*/__WEBPACK_IMPORTED_MODULE_0_react__["createElement"]("path", {
  d: "M60.197 418.646H27.571c-6.978 0-12.634 5.657-12.634 12.634s5.656 12.634 12.634 12.634h32.627c6.978 0 12.634-5.657 12.634-12.634-.001-6.976-5.658-12.634-12.635-12.634zM114.205 467.363c-4.934-4.932-12.933-4.934-17.867 0l-23.07 23.07c-4.934 4.934-4.935 12.933 0 17.868a12.598 12.598 0 008.933 3.701c3.233 0 6.467-1.234 8.933-3.701l23.07-23.07c4.935-4.934 4.936-12.933.001-17.868zM484.431 424.963H262.965l226.699-226.688c9.851-9.852 9.852-25.881.001-35.733L334.522 7.388c-9.853-9.851-25.882-9.851-35.735 0l-247.99 247.99c-14.318 14.318-22.203 33.354-22.203 53.602 0 20.247 7.885 39.284 22.203 53.602l74.701 74.699c8.351 8.351 19.455 12.951 31.266 12.951H484.43c6.978 0 12.634-5.657 12.634-12.634.001-6.977-5.655-12.635-12.633-12.635zm-327.666 0c-5.062 0-9.82-1.972-13.401-5.551l-74.699-74.699c-19.704-19.704-19.704-51.765 0-71.468l40.557-40.557 133.335 133.336c2.467 2.466 5.7 3.7 8.933 3.7s6.467-1.234 8.933-3.7c4.934-4.934 4.935-12.933.001-17.868L127.09 214.821 316.655 25.254l155.142 155.155L227.23 424.963h-70.465z"
});

function SvgRemove(props) {
  return /*#__PURE__*/__WEBPACK_IMPORTED_MODULE_0_react__["createElement"]("svg", _extends({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 512.001 512.001"
  }, props), _ref);
}

/* harmony default export */ __webpack_exports__["a"] = (SvgRemove);

/***/ }),

/***/ "./svg/return.svg":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__("./node_modules/react/cjs/react.development.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }



var _ref = /*#__PURE__*/__WEBPACK_IMPORTED_MODULE_0_react__["createElement"]("path", {
  d: "M384.834 180.699H36.101l73.326-82.187c4.755-5.33 4.289-13.505-1.041-18.26-5.328-4.754-13.505-4.29-18.26 1.041l-82.582 92.56c-10.059 11.278-10.058 28.282.001 39.557l82.582 92.561a12.897 12.897 0 009.654 4.323c3.064 0 6.139-1.083 8.606-3.282 5.33-4.755 5.795-12.93 1.041-18.26l-73.326-82.188h348.733c55.858 0 101.3 45.444 101.3 101.3s-45.443 101.3-101.3 101.3h-61.58c-7.143 0-12.933 5.791-12.933 12.933 0 7.142 5.79 12.933 12.933 12.933h61.58c70.12 0 127.166-57.046 127.166-127.166-.001-70.119-57.047-127.165-127.167-127.165z"
});

function SvgReturn(props) {
  return /*#__PURE__*/__WEBPACK_IMPORTED_MODULE_0_react__["createElement"]("svg", _extends({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 512.001 512.001"
  }, props), _ref);
}

/* harmony default export */ __webpack_exports__["a"] = (SvgReturn);

/***/ }),

/***/ 2:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__("./pages/index.js");


/***/ })

},[2])
          return { page: comp.default }
        })
      ;
//# sourceMappingURL=index.js.map